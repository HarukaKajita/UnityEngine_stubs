import typing, clr
from UnityEngine import TextureFormat, Color32, Object
from Unity.Collections import NativeArray_1
from System import Attribute, IDisposable, Array_1
from Unity.Profiling.LowLevel import MarkerFlags, ProfilerMarkerDataType
from Unity.Profiling.LowLevel.Unsafe import ProfilerRecorderHandle
from System.Collections.Generic import List_1

class DebugScreenCapture:
    @property
    def Height(self) -> int: ...
    @Height.setter
    def Height(self, value: int) -> int: ...
    @property
    def ImageFormat(self) -> TextureFormat: ...
    @ImageFormat.setter
    def ImageFormat(self, value: TextureFormat) -> TextureFormat: ...
    @property
    def RawImageDataReference(self) -> NativeArray_1[int]: ...
    @RawImageDataReference.setter
    def RawImageDataReference(self, value: NativeArray_1[int]) -> NativeArray_1[int]: ...
    @property
    def Width(self) -> int: ...
    @Width.setter
    def Width(self, value: int) -> int: ...


class IgnoredByDeepProfilerAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class ProfilerCategory:
    @typing.overload
    def __init__(self, categoryName: str) -> None: ...
    @typing.overload
    def __init__(self, categoryName: str, color: ProfilerCategoryColor) -> None: ...
    @classmethod
    @property
    def Ai(cls) -> ProfilerCategory: ...
    @classmethod
    @property
    def Animation(cls) -> ProfilerCategory: ...
    @classmethod
    @property
    def Audio(cls) -> ProfilerCategory: ...
    @property
    def Color(self) -> Color32: ...
    @classmethod
    @property
    def FileIO(cls) -> ProfilerCategory: ...
    @classmethod
    @property
    def Gui(cls) -> ProfilerCategory: ...
    @classmethod
    @property
    def Input(cls) -> ProfilerCategory: ...
    @classmethod
    @property
    def Internal(cls) -> ProfilerCategory: ...
    @classmethod
    @property
    def Lighting(cls) -> ProfilerCategory: ...
    @classmethod
    @property
    def Loading(cls) -> ProfilerCategory: ...
    @classmethod
    @property
    def Memory(cls) -> ProfilerCategory: ...
    @property
    def Name(self) -> str: ...
    @classmethod
    @property
    def Network(cls) -> ProfilerCategory: ...
    @classmethod
    @property
    def Particles(cls) -> ProfilerCategory: ...
    @classmethod
    @property
    def Physics(cls) -> ProfilerCategory: ...
    @classmethod
    @property
    def Physics2D(cls) -> ProfilerCategory: ...
    @classmethod
    @property
    def Render(cls) -> ProfilerCategory: ...
    @classmethod
    @property
    def Scripts(cls) -> ProfilerCategory: ...
    @classmethod
    @property
    def Video(cls) -> ProfilerCategory: ...
    @classmethod
    @property
    def VirtualTexturing(cls) -> ProfilerCategory: ...
    @classmethod
    @property
    def Vr(cls) -> ProfilerCategory: ...
    # Operator not supported op_Implicit(category: ProfilerCategory)
    def ToString(self) -> str: ...


class ProfilerCategoryColor(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Render : ProfilerCategoryColor # 0
    Scripts : ProfilerCategoryColor # 1
    BurstJobs : ProfilerCategoryColor # 2
    Other : ProfilerCategoryColor # 3
    Physics : ProfilerCategoryColor # 4
    Animation : ProfilerCategoryColor # 5
    Audio : ProfilerCategoryColor # 6
    AudioJob : ProfilerCategoryColor # 7
    AudioUpdateJob : ProfilerCategoryColor # 8
    Lighting : ProfilerCategoryColor # 9
    GC : ProfilerCategoryColor # 10
    VSync : ProfilerCategoryColor # 11
    Memory : ProfilerCategoryColor # 12
    Internal : ProfilerCategoryColor # 13
    UI : ProfilerCategoryColor # 14
    Build : ProfilerCategoryColor # 15
    Input : ProfilerCategoryColor # 16


class ProfilerCategoryFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : ProfilerCategoryFlags # 0
    Builtin : ProfilerCategoryFlags # 1


class ProfilerCounterOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : ProfilerCounterOptions # 0
    FlushOnEndOfFrame : ProfilerCounterOptions # 2
    ResetToZeroOnFlush : ProfilerCounterOptions # 4


class ProfilerFlowEventType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Begin : ProfilerFlowEventType # 0
    ParallelNext : ProfilerFlowEventType # 1
    End : ProfilerFlowEventType # 2
    Next : ProfilerFlowEventType # 3


class ProfilerMarker:
    @typing.overload
    def __init__(self, category: ProfilerCategory, name: str) -> None: ...
    @typing.overload
    def __init__(self, category: ProfilerCategory, name: str, flags: MarkerFlags) -> None: ...
    @typing.overload
    def __init__(self, category: ProfilerCategory, name: clr.Reference[str], nameLen: int) -> None: ...
    @typing.overload
    def __init__(self, category: ProfilerCategory, name: clr.Reference[str], nameLen: int, flags: MarkerFlags) -> None: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: clr.Reference[str], nameLen: int) -> None: ...
    @property
    def Handle(self) -> int: ...
    def Auto(self) -> ProfilerMarker.AutoScope: ...
    def End(self) -> None: ...
    # Skipped Begin due to it being static, abstract and generic.

    Begin : Begin_MethodGroup
    class Begin_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, contextUnityObject: Object) -> None:...


    class AutoScope(IDisposable):
        def Dispose(self) -> None: ...



class ProfilerMarkerDataUnit(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Undefined : ProfilerMarkerDataUnit # 0
    TimeNanoseconds : ProfilerMarkerDataUnit # 1
    Bytes : ProfilerMarkerDataUnit # 2
    Count : ProfilerMarkerDataUnit # 3
    Percent : ProfilerMarkerDataUnit # 4
    FrequencyHz : ProfilerMarkerDataUnit # 5


class ProfilerRecorder(IDisposable):
    @typing.overload
    def __init__(self, category: ProfilerCategory, statName: str, capacity: int = ..., options: ProfilerRecorderOptions = ...) -> None: ...
    @typing.overload
    def __init__(self, category: ProfilerCategory, statName: clr.Reference[str], statNameLen: int, capacity: int = ..., options: ProfilerRecorderOptions = ...) -> None: ...
    @typing.overload
    def __init__(self, categoryName: str, statName: str, capacity: int = ..., options: ProfilerRecorderOptions = ...) -> None: ...
    @typing.overload
    def __init__(self, marker: ProfilerMarker, capacity: int = ..., options: ProfilerRecorderOptions = ...) -> None: ...
    @typing.overload
    def __init__(self, statHandle: ProfilerRecorderHandle, capacity: int = ..., options: ProfilerRecorderOptions = ...) -> None: ...
    @typing.overload
    def __init__(self, statName: str, capacity: int = ..., options: ProfilerRecorderOptions = ...) -> None: ...
    @property
    def Capacity(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def CurrentValue(self) -> int: ...
    @property
    def CurrentValueAsDouble(self) -> float: ...
    @property
    def DataType(self) -> ProfilerMarkerDataType: ...
    @property
    def IsRunning(self) -> bool: ...
    @property
    def LastValue(self) -> int: ...
    @property
    def LastValueAsDouble(self) -> float: ...
    @property
    def UnitType(self) -> ProfilerMarkerDataUnit: ...
    @property
    def Valid(self) -> bool: ...
    @property
    def WrappedAround(self) -> bool: ...
    def Dispose(self) -> None: ...
    def GetSample(self, index: int) -> ProfilerRecorderSample: ...
    def Reset(self) -> None: ...
    def Start(self) -> None: ...
    def Stop(self) -> None: ...
    def ToArray(self) -> Array_1[ProfilerRecorderSample]: ...
    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo : CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, outSamples: List_1[ProfilerRecorderSample], reset: bool = ...) -> None:...
        @typing.overload
        def __call__(self, dest: clr.Reference[ProfilerRecorderSample], destSize: int, reset: bool = ...) -> int:...

    # Skipped StartNew due to it being static, abstract and generic.

    StartNew : StartNew_MethodGroup
    class StartNew_MethodGroup:
        @typing.overload
        def __call__(self, marker: ProfilerMarker, capacity: int = ..., options: ProfilerRecorderOptions = ...) -> ProfilerRecorder:...
        @typing.overload
        def __call__(self, category: ProfilerCategory, statName: str, capacity: int = ..., options: ProfilerRecorderOptions = ...) -> ProfilerRecorder:...



class ProfilerRecorderOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : ProfilerRecorderOptions # 0
    StartImmediately : ProfilerRecorderOptions # 1
    KeepAliveDuringDomainReload : ProfilerRecorderOptions # 2
    CollectOnlyOnCurrentThread : ProfilerRecorderOptions # 4
    WrapAroundWhenCapacityReached : ProfilerRecorderOptions # 8
    SumAllSamplesInFrame : ProfilerRecorderOptions # 16
    Default : ProfilerRecorderOptions # 24
    GpuRecorder : ProfilerRecorderOptions # 64


class ProfilerRecorderSample:
    @property
    def Count(self) -> int: ...
    @property
    def Value(self) -> int: ...

