import typing, clr, abc
from System import MulticastDelegate, IAsyncResult, AsyncCallback, Attribute, Exception, IDisposable, Array, Array_1, Span_1, IEquatable_1, IFormattable, IFormatProvider, DateTime, ReadOnlySpan_1, IComparable_1, IComparable, SystemException, Action_2, Action, Action_1, Func_1
from System.Reflection import MethodInfo, MethodBase, Assembly
from System.Collections import IDictionary, IEnumerable, IEnumerator, Hashtable
from Unity.Collections import NativeArray_1, Allocator, NativeSlice_1
from UnityEngine.Playables import PlayableGraph
from System.Collections.Generic import List_1, IList_1, KeyValuePair_2, IEnumerable_1, IEnumerator_1, HashSet_1, IDictionary_2, Dictionary_2
from System.Threading import CancellationToken
from System.IO import Stream
from UnityEngine.Audio import AudioMixerGroup
from UnityEngine.Rendering import LightProbeUsage, ReflectionProbeUsage, ShadowCastingMode, OpaqueSortMode, CameraEvent, CommandBuffer, ComputeQueueType, ScriptableCullingParameters, LocalKeyword, LocalKeywordSpace, RenderTextureSubElement, TextureDimension, GraphicsTier, OpenGLESVersion, GraphicsFence, GraphicsFenceType, SynchronisationStageFlags, SynchronisationStage, GPUFence, LightShadowResolution, LightEvent, ShadowMapPass, SphericalHarmonicsL2, IndexFormat, SubMeshDescriptor, VertexAttributeDescriptor, VertexAttribute, VertexAttributeFormat, MeshUpdateFlags, BlendShapeBufferLayout, UVChannelFlags, RenderPipelineAsset, ReflectionProbeClearFlags, ReflectionProbeMode, ReflectionProbeRefreshMode, ReflectionProbeTimeSlicingMode, ReflectionProbeType, ReflectionProbeBlendInfo, AmbientMode, DefaultReflectionMode, RenderBufferLoadAction, RenderBufferStoreAction, ShadowSamplingMode, GlobalKeyword, ShaderHardwareTier, ShaderTagId, ShaderPropertyFlags, ShaderPropertyType, PassType, CopyTextureSupport, FoveatedRenderingCaps, GraphicsDeviceType, RenderingThreadingMode
from UnityEngine.Experimental.Rendering import RayTracingMode, DefaultFormat, TextureCreationFlags, GraphicsFormat, FormatUsage
from Unity.Jobs import JobHandle
from UnityEngine.SceneManagement import Scene
from UnityEngine.iOS import ActivityIndicatorStyle
from UnityEngine.Scripting import PreserveAttribute
from UnityEngine.SocialPlatforms import ISocialPlatform, ILocalUser, IAchievement, ILeaderboard, IAchievementDescription, IScore, IUserProfile
from UnityEngine.Events import UnityAction_1
from UnityEngine.Animations import AnimatorControllerPlayable
from System.Text import Encoding

class AccelerationEvent:
    @property
    def acceleration(self) -> Vector3: ...
    @property
    def deltaTime(self) -> float: ...


class ADBannerView:
    def __init__(self, type: ADBannerView.Type, layout: ADBannerView.Layout) -> None: ...
    @property
    def layout(self) -> ADBannerView.Layout: ...
    @layout.setter
    def layout(self, value: ADBannerView.Layout) -> ADBannerView.Layout: ...
    @property
    def loaded(self) -> bool: ...
    @property
    def position(self) -> Vector2: ...
    @position.setter
    def position(self, value: Vector2) -> Vector2: ...
    @property
    def size(self) -> Vector2: ...
    @property
    def visible(self) -> bool: ...
    @visible.setter
    def visible(self, value: bool) -> bool: ...
    @staticmethod
    def IsAvailable(type: ADBannerView.Type) -> bool: ...

    class BannerWasClickedDelegate(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self) -> None: ...


    class BannerWasLoadedDelegate(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self) -> None: ...


    class Layout(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Top : ADBannerView.Layout # 0
        TopLeft : ADBannerView.Layout # 0
        BottomLeft : ADBannerView.Layout # 1
        Bottom : ADBannerView.Layout # 1
        CenterLeft : ADBannerView.Layout # 2
        TopRight : ADBannerView.Layout # 4
        BottomRight : ADBannerView.Layout # 5
        CenterRight : ADBannerView.Layout # 6
        TopCenter : ADBannerView.Layout # 8
        BottomCenter : ADBannerView.Layout # 9
        Center : ADBannerView.Layout # 10
        Manual : ADBannerView.Layout # -1


    class Type(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Banner : ADBannerView.Type # 0
        MediumRect : ADBannerView.Type # 1



class AddComponentMenu(Attribute):
    @typing.overload
    def __init__(self, menuName: str) -> None: ...
    @typing.overload
    def __init__(self, menuName: str, order: int) -> None: ...
    @property
    def componentMenu(self) -> str: ...
    @property
    def componentOrder(self) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class AdditionalCanvasShaderChannels(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : AdditionalCanvasShaderChannels # 0
    TexCoord1 : AdditionalCanvasShaderChannels # 1
    TexCoord2 : AdditionalCanvasShaderChannels # 2
    TexCoord3 : AdditionalCanvasShaderChannels # 4
    Normal : AdditionalCanvasShaderChannels # 8
    Tangent : AdditionalCanvasShaderChannels # 16


class ADInterstitialAd:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, autoReload: bool) -> None: ...
    @classmethod
    @property
    def isAvailable(cls) -> bool: ...
    @property
    def loaded(self) -> bool: ...
    def ReloadAd(self) -> None: ...
    def Show(self) -> None: ...

    class InterstitialWasLoadedDelegate(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self) -> None: ...



class AnchoredJoint2D(Joint2D):
    def __init__(self) -> None: ...
    @property
    def anchor(self) -> Vector2: ...
    @anchor.setter
    def anchor(self, value: Vector2) -> Vector2: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoConfigureConnectedAnchor(self) -> bool: ...
    @autoConfigureConnectedAnchor.setter
    def autoConfigureConnectedAnchor(self, value: bool) -> bool: ...
    @property
    def breakAction(self) -> JointBreakAction2D: ...
    @breakAction.setter
    def breakAction(self, value: JointBreakAction2D) -> JointBreakAction2D: ...
    @property
    def breakForce(self) -> float: ...
    @breakForce.setter
    def breakForce(self, value: float) -> float: ...
    @property
    def breakTorque(self) -> float: ...
    @breakTorque.setter
    def breakTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collideConnected(self) -> bool: ...
    @collideConnected.setter
    def collideConnected(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def connectedAnchor(self) -> Vector2: ...
    @connectedAnchor.setter
    def connectedAnchor(self, value: Vector2) -> Vector2: ...
    @property
    def connectedBody(self) -> Rigidbody2D: ...
    @connectedBody.setter
    def connectedBody(self, value: Rigidbody2D) -> Rigidbody2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enableCollision(self) -> bool: ...
    @enableCollision.setter
    def enableCollision(self, value: bool) -> bool: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def reactionForce(self) -> Vector2: ...
    @property
    def reactionTorque(self) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class AndroidActivityIndicatorStyle(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Large : AndroidActivityIndicatorStyle # 0
    InversedLarge : AndroidActivityIndicatorStyle # 1
    Small : AndroidActivityIndicatorStyle # 2
    InversedSmall : AndroidActivityIndicatorStyle # 3
    DontShow : AndroidActivityIndicatorStyle # -1


class AndroidInput:
    @classmethod
    @property
    def secondaryTouchEnabled(cls) -> bool: ...
    @classmethod
    @property
    def secondaryTouchHeight(cls) -> int: ...
    @classmethod
    @property
    def secondaryTouchWidth(cls) -> int: ...
    @classmethod
    @property
    def touchCountSecondary(cls) -> int: ...
    @staticmethod
    def GetSecondaryTouch(index: int) -> Touch: ...


class AndroidJavaClass(AndroidJavaObject):
    def __init__(self, className: str) -> None: ...


class AndroidJavaException(Exception):
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class AndroidJavaObject(IDisposable):
    @typing.overload
    def __init__(self, className: str, args: Array_1[str]) -> None: ...
    @typing.overload
    def __init__(self, className: str, args: Array_1[AndroidJavaObject]) -> None: ...
    @typing.overload
    def __init__(self, className: str, args: Array_1[AndroidJavaClass]) -> None: ...
    @typing.overload
    def __init__(self, className: str, args: Array_1[AndroidJavaProxy]) -> None: ...
    @typing.overload
    def __init__(self, className: str, args: Array_1[AndroidJavaRunnable]) -> None: ...
    @typing.overload
    def __init__(self, className: str, args: Array_1[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, clazz: int, constructorID: int, args: Array_1[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, jobject: int) -> None: ...
    def CloneReference(self) -> AndroidJavaObject: ...
    def Dispose(self) -> None: ...
    def GetRawClass(self) -> int: ...
    def GetRawObject(self) -> int: ...
    # Skipped Call due to it being static, abstract and generic.

    Call : Call_MethodGroup
    class Call_MethodGroup:
        @typing.overload
        def __getitem__(self, t:typing.Type[Call_1_T1]) -> Call_1[Call_1_T1]: ...

        Call_1_T1 = typing.TypeVar('Call_1_T1')
        class Call_1(typing.Generic[Call_1_T1]):
            Call_1_T = AndroidJavaObject.Call_MethodGroup.Call_1_T1
            Call_1_ReturnType = AndroidJavaObject.Call_MethodGroup.Call_1_T1
            @typing.overload
            def __call__(self, methodID: int, args: Array_1[Call_1_T]) -> None:...
            @typing.overload
            def __call__(self, methodID: int, args: Array_1[typing.Any]) -> Call_1_ReturnType:...
            @typing.overload
            def __call__(self, methodName: str, args: Array_1[Call_1_T]) -> None:...
            @typing.overload
            def __call__(self, methodName: str, args: Array_1[typing.Any]) -> Call_1_ReturnType:...

        @typing.overload
        def __getitem__(self, t:typing.Tuple[typing.Type[Call_2_T1], typing.Type[Call_2_T2]]) -> Call_2[Call_2_T1, Call_2_T2]: ...

        Call_2_T1 = typing.TypeVar('Call_2_T1')
        Call_2_T2 = typing.TypeVar('Call_2_T2')
        class Call_2(typing.Generic[Call_2_T1, Call_2_T2]):
            Call_2_ReturnType = AndroidJavaObject.Call_MethodGroup.Call_2_T1
            Call_2_T = AndroidJavaObject.Call_MethodGroup.Call_2_T2
            @typing.overload
            def __call__(self, methodID: int, args: Array_1[Call_2_T]) -> Call_2_ReturnType:...
            @typing.overload
            def __call__(self, methodName: str, args: Array_1[Call_2_T]) -> Call_2_ReturnType:...

        @typing.overload
        def __call__(self, methodID: int, args: Array_1[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, methodName: str, args: Array_1[typing.Any]) -> None:...

    # Skipped CallStatic due to it being static, abstract and generic.

    CallStatic : CallStatic_MethodGroup
    class CallStatic_MethodGroup:
        @typing.overload
        def __getitem__(self, t:typing.Type[CallStatic_1_T1]) -> CallStatic_1[CallStatic_1_T1]: ...

        CallStatic_1_T1 = typing.TypeVar('CallStatic_1_T1')
        class CallStatic_1(typing.Generic[CallStatic_1_T1]):
            CallStatic_1_T = AndroidJavaObject.CallStatic_MethodGroup.CallStatic_1_T1
            CallStatic_1_ReturnType = AndroidJavaObject.CallStatic_MethodGroup.CallStatic_1_T1
            @typing.overload
            def __call__(self, methodID: int, args: Array_1[CallStatic_1_T]) -> None:...
            @typing.overload
            def __call__(self, methodID: int, args: Array_1[typing.Any]) -> CallStatic_1_ReturnType:...
            @typing.overload
            def __call__(self, methodName: str, args: Array_1[CallStatic_1_T]) -> None:...
            @typing.overload
            def __call__(self, methodName: str, args: Array_1[typing.Any]) -> CallStatic_1_ReturnType:...

        @typing.overload
        def __getitem__(self, t:typing.Tuple[typing.Type[CallStatic_2_T1], typing.Type[CallStatic_2_T2]]) -> CallStatic_2[CallStatic_2_T1, CallStatic_2_T2]: ...

        CallStatic_2_T1 = typing.TypeVar('CallStatic_2_T1')
        CallStatic_2_T2 = typing.TypeVar('CallStatic_2_T2')
        class CallStatic_2(typing.Generic[CallStatic_2_T1, CallStatic_2_T2]):
            CallStatic_2_ReturnType = AndroidJavaObject.CallStatic_MethodGroup.CallStatic_2_T1
            CallStatic_2_T = AndroidJavaObject.CallStatic_MethodGroup.CallStatic_2_T2
            @typing.overload
            def __call__(self, methodID: int, args: Array_1[CallStatic_2_T]) -> CallStatic_2_ReturnType:...
            @typing.overload
            def __call__(self, methodName: str, args: Array_1[CallStatic_2_T]) -> CallStatic_2_ReturnType:...

        @typing.overload
        def __call__(self, methodID: int, args: Array_1[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, methodName: str, args: Array_1[typing.Any]) -> None:...

    # Skipped Get due to it being static, abstract and generic.

    Get : Get_MethodGroup
    class Get_MethodGroup:
        def __getitem__(self, t:typing.Type[Get_1_T1]) -> Get_1[Get_1_T1]: ...

        Get_1_T1 = typing.TypeVar('Get_1_T1')
        class Get_1(typing.Generic[Get_1_T1]):
            Get_1_FieldType = AndroidJavaObject.Get_MethodGroup.Get_1_T1
            @typing.overload
            def __call__(self, fieldID: int) -> Get_1_FieldType:...
            @typing.overload
            def __call__(self, fieldName: str) -> Get_1_FieldType:...


    # Skipped GetStatic due to it being static, abstract and generic.

    GetStatic : GetStatic_MethodGroup
    class GetStatic_MethodGroup:
        def __getitem__(self, t:typing.Type[GetStatic_1_T1]) -> GetStatic_1[GetStatic_1_T1]: ...

        GetStatic_1_T1 = typing.TypeVar('GetStatic_1_T1')
        class GetStatic_1(typing.Generic[GetStatic_1_T1]):
            GetStatic_1_FieldType = AndroidJavaObject.GetStatic_MethodGroup.GetStatic_1_T1
            @typing.overload
            def __call__(self, fieldID: int) -> GetStatic_1_FieldType:...
            @typing.overload
            def __call__(self, fieldName: str) -> GetStatic_1_FieldType:...


    # Skipped Set due to it being static, abstract and generic.

    Set : Set_MethodGroup
    class Set_MethodGroup:
        def __getitem__(self, t:typing.Type[Set_1_T1]) -> Set_1[Set_1_T1]: ...

        Set_1_T1 = typing.TypeVar('Set_1_T1')
        class Set_1(typing.Generic[Set_1_T1]):
            Set_1_FieldType = AndroidJavaObject.Set_MethodGroup.Set_1_T1
            @typing.overload
            def __call__(self, fieldID: int, val: Set_1_FieldType) -> None:...
            @typing.overload
            def __call__(self, fieldName: str, val: Set_1_FieldType) -> None:...


    # Skipped SetStatic due to it being static, abstract and generic.

    SetStatic : SetStatic_MethodGroup
    class SetStatic_MethodGroup:
        def __getitem__(self, t:typing.Type[SetStatic_1_T1]) -> SetStatic_1[SetStatic_1_T1]: ...

        SetStatic_1_T1 = typing.TypeVar('SetStatic_1_T1')
        class SetStatic_1(typing.Generic[SetStatic_1_T1]):
            SetStatic_1_FieldType = AndroidJavaObject.SetStatic_MethodGroup.SetStatic_1_T1
            @typing.overload
            def __call__(self, fieldID: int, val: SetStatic_1_FieldType) -> None:...
            @typing.overload
            def __call__(self, fieldName: str, val: SetStatic_1_FieldType) -> None:...




class AndroidJavaProxy:
    @typing.overload
    def __init__(self, javaInterface: str) -> None: ...
    @typing.overload
    def __init__(self, javaInterface: AndroidJavaClass) -> None: ...
    javaInterface : AndroidJavaClass
    def equals(self, obj: AndroidJavaObject) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...
    # Skipped Invoke due to it being static, abstract and generic.

    Invoke : Invoke_MethodGroup
    class Invoke_MethodGroup:
        @typing.overload
        def __call__(self, methodName: str, javaArgs: int) -> int:...
        @typing.overload
        def __call__(self, methodName: str, javaArgs: Array_1[AndroidJavaObject]) -> AndroidJavaObject:...
        @typing.overload
        def __call__(self, methodName: str, args: Array_1[typing.Any]) -> AndroidJavaObject:...



class AndroidJavaRunnable(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self) -> None: ...


class AndroidJNI(abc.ABC):
    @staticmethod
    def AllocObject(clazz: int) -> int: ...
    @staticmethod
    def AttachCurrentThread() -> int: ...
    @staticmethod
    def CallBooleanMethodUnsafe(obj: int, methodID: int, args: clr.Reference[jvalue]) -> bool: ...
    @staticmethod
    def CallByteMethod(obj: int, methodID: int, args: Array_1[jvalue]) -> int: ...
    @staticmethod
    def CallCharMethodUnsafe(obj: int, methodID: int, args: clr.Reference[jvalue]) -> str: ...
    @staticmethod
    def CallDoubleMethodUnsafe(obj: int, methodID: int, args: clr.Reference[jvalue]) -> float: ...
    @staticmethod
    def CallFloatMethodUnsafe(obj: int, methodID: int, args: clr.Reference[jvalue]) -> float: ...
    @staticmethod
    def CallIntMethodUnsafe(obj: int, methodID: int, args: clr.Reference[jvalue]) -> int: ...
    @staticmethod
    def CallLongMethodUnsafe(obj: int, methodID: int, args: clr.Reference[jvalue]) -> int: ...
    @staticmethod
    def CallObjectMethodUnsafe(obj: int, methodID: int, args: clr.Reference[jvalue]) -> int: ...
    @staticmethod
    def CallSByteMethodUnsafe(obj: int, methodID: int, args: clr.Reference[jvalue]) -> int: ...
    @staticmethod
    def CallShortMethodUnsafe(obj: int, methodID: int, args: clr.Reference[jvalue]) -> int: ...
    @staticmethod
    def CallStaticBooleanMethodUnsafe(clazz: int, methodID: int, args: clr.Reference[jvalue]) -> bool: ...
    @staticmethod
    def CallStaticByteMethod(clazz: int, methodID: int, args: Array_1[jvalue]) -> int: ...
    @staticmethod
    def CallStaticCharMethodUnsafe(clazz: int, methodID: int, args: clr.Reference[jvalue]) -> str: ...
    @staticmethod
    def CallStaticDoubleMethodUnsafe(clazz: int, methodID: int, args: clr.Reference[jvalue]) -> float: ...
    @staticmethod
    def CallStaticFloatMethodUnsafe(clazz: int, methodID: int, args: clr.Reference[jvalue]) -> float: ...
    @staticmethod
    def CallStaticIntMethodUnsafe(clazz: int, methodID: int, args: clr.Reference[jvalue]) -> int: ...
    @staticmethod
    def CallStaticLongMethodUnsafe(clazz: int, methodID: int, args: clr.Reference[jvalue]) -> int: ...
    @staticmethod
    def CallStaticObjectMethodUnsafe(clazz: int, methodID: int, args: clr.Reference[jvalue]) -> int: ...
    @staticmethod
    def CallStaticSByteMethodUnsafe(clazz: int, methodID: int, args: clr.Reference[jvalue]) -> int: ...
    @staticmethod
    def CallStaticShortMethodUnsafe(clazz: int, methodID: int, args: clr.Reference[jvalue]) -> int: ...
    @staticmethod
    def CallStaticStringMethodUnsafe(clazz: int, methodID: int, args: clr.Reference[jvalue]) -> str: ...
    @staticmethod
    def CallStaticVoidMethodUnsafe(clazz: int, methodID: int, args: clr.Reference[jvalue]) -> None: ...
    @staticmethod
    def CallStringMethodUnsafe(obj: int, methodID: int, args: clr.Reference[jvalue]) -> str: ...
    @staticmethod
    def CallVoidMethodUnsafe(obj: int, methodID: int, args: clr.Reference[jvalue]) -> None: ...
    @staticmethod
    def DeleteGlobalRef(obj: int) -> None: ...
    @staticmethod
    def DeleteLocalRef(obj: int) -> None: ...
    @staticmethod
    def DeleteWeakGlobalRef(obj: int) -> None: ...
    @staticmethod
    def DetachCurrentThread() -> int: ...
    @staticmethod
    def EnsureLocalCapacity(capacity: int) -> int: ...
    @staticmethod
    def ExceptionClear() -> None: ...
    @staticmethod
    def ExceptionDescribe() -> None: ...
    @staticmethod
    def ExceptionOccurred() -> int: ...
    @staticmethod
    def FatalError(message: str) -> None: ...
    @staticmethod
    def FindClass(name: str) -> int: ...
    @staticmethod
    def FromBooleanArray(array: int) -> Array_1[bool]: ...
    @staticmethod
    def FromByteArray(array: int) -> Array_1[int]: ...
    @staticmethod
    def FromCharArray(array: int) -> Array_1[str]: ...
    @staticmethod
    def FromDoubleArray(array: int) -> Array_1[float]: ...
    @staticmethod
    def FromFloatArray(array: int) -> Array_1[float]: ...
    @staticmethod
    def FromIntArray(array: int) -> Array_1[int]: ...
    @staticmethod
    def FromLongArray(array: int) -> Array_1[int]: ...
    @staticmethod
    def FromObjectArray(array: int) -> Array_1[int]: ...
    @staticmethod
    def FromReflectedField(refField: int) -> int: ...
    @staticmethod
    def FromReflectedMethod(refMethod: int) -> int: ...
    @staticmethod
    def FromSByteArray(array: int) -> Array_1[int]: ...
    @staticmethod
    def FromShortArray(array: int) -> Array_1[int]: ...
    @staticmethod
    def GetArrayLength(array: int) -> int: ...
    @staticmethod
    def GetBooleanArrayElement(array: int, index: int) -> bool: ...
    @staticmethod
    def GetBooleanField(obj: int, fieldID: int) -> bool: ...
    @staticmethod
    def GetByteArrayElement(array: int, index: int) -> int: ...
    @staticmethod
    def GetByteField(obj: int, fieldID: int) -> int: ...
    @staticmethod
    def GetCharArrayElement(array: int, index: int) -> str: ...
    @staticmethod
    def GetCharField(obj: int, fieldID: int) -> str: ...
    @staticmethod
    def GetDirectBufferAddress(buffer: int) -> clr.Reference[int]: ...
    @staticmethod
    def GetDirectBufferCapacity(buffer: int) -> int: ...
    @staticmethod
    def GetDirectByteBuffer(buffer: int) -> NativeArray_1[int]: ...
    @staticmethod
    def GetDirectSByteBuffer(buffer: int) -> NativeArray_1[int]: ...
    @staticmethod
    def GetDoubleArrayElement(array: int, index: int) -> float: ...
    @staticmethod
    def GetDoubleField(obj: int, fieldID: int) -> float: ...
    @staticmethod
    def GetFieldID(clazz: int, name: str, sig: str) -> int: ...
    @staticmethod
    def GetFloatArrayElement(array: int, index: int) -> float: ...
    @staticmethod
    def GetFloatField(obj: int, fieldID: int) -> float: ...
    @staticmethod
    def GetIntArrayElement(array: int, index: int) -> int: ...
    @staticmethod
    def GetIntField(obj: int, fieldID: int) -> int: ...
    @staticmethod
    def GetJavaVM() -> int: ...
    @staticmethod
    def GetLongArrayElement(array: int, index: int) -> int: ...
    @staticmethod
    def GetLongField(obj: int, fieldID: int) -> int: ...
    @staticmethod
    def GetMethodID(clazz: int, name: str, sig: str) -> int: ...
    @staticmethod
    def GetObjectArrayElement(array: int, index: int) -> int: ...
    @staticmethod
    def GetObjectClass(obj: int) -> int: ...
    @staticmethod
    def GetObjectField(obj: int, fieldID: int) -> int: ...
    @staticmethod
    def GetSByteArrayElement(array: int, index: int) -> int: ...
    @staticmethod
    def GetSByteField(obj: int, fieldID: int) -> int: ...
    @staticmethod
    def GetShortArrayElement(array: int, index: int) -> int: ...
    @staticmethod
    def GetShortField(obj: int, fieldID: int) -> int: ...
    @staticmethod
    def GetStaticBooleanField(clazz: int, fieldID: int) -> bool: ...
    @staticmethod
    def GetStaticByteField(clazz: int, fieldID: int) -> int: ...
    @staticmethod
    def GetStaticCharField(clazz: int, fieldID: int) -> str: ...
    @staticmethod
    def GetStaticDoubleField(clazz: int, fieldID: int) -> float: ...
    @staticmethod
    def GetStaticFieldID(clazz: int, name: str, sig: str) -> int: ...
    @staticmethod
    def GetStaticFloatField(clazz: int, fieldID: int) -> float: ...
    @staticmethod
    def GetStaticIntField(clazz: int, fieldID: int) -> int: ...
    @staticmethod
    def GetStaticLongField(clazz: int, fieldID: int) -> int: ...
    @staticmethod
    def GetStaticMethodID(clazz: int, name: str, sig: str) -> int: ...
    @staticmethod
    def GetStaticObjectField(clazz: int, fieldID: int) -> int: ...
    @staticmethod
    def GetStaticSByteField(clazz: int, fieldID: int) -> int: ...
    @staticmethod
    def GetStaticShortField(clazz: int, fieldID: int) -> int: ...
    @staticmethod
    def GetStaticStringField(clazz: int, fieldID: int) -> str: ...
    @staticmethod
    def GetStringChars(str: int) -> str: ...
    @staticmethod
    def GetStringField(obj: int, fieldID: int) -> str: ...
    @staticmethod
    def GetStringLength(str: int) -> int: ...
    @staticmethod
    def GetStringUTFChars(str: int) -> str: ...
    @staticmethod
    def GetStringUTFLength(str: int) -> int: ...
    @staticmethod
    def GetSuperclass(clazz: int) -> int: ...
    @staticmethod
    def GetVersion() -> int: ...
    @staticmethod
    def IsAssignableFrom(clazz1: int, clazz2: int) -> bool: ...
    @staticmethod
    def IsInstanceOf(obj: int, clazz: int) -> bool: ...
    @staticmethod
    def IsSameObject(obj1: int, obj2: int) -> bool: ...
    @staticmethod
    def NewBooleanArray(size: int) -> int: ...
    @staticmethod
    def NewByteArray(size: int) -> int: ...
    @staticmethod
    def NewCharArray(size: int) -> int: ...
    @staticmethod
    def NewDoubleArray(size: int) -> int: ...
    @staticmethod
    def NewFloatArray(size: int) -> int: ...
    @staticmethod
    def NewGlobalRef(obj: int) -> int: ...
    @staticmethod
    def NewIntArray(size: int) -> int: ...
    @staticmethod
    def NewLocalRef(obj: int) -> int: ...
    @staticmethod
    def NewLongArray(size: int) -> int: ...
    @staticmethod
    def NewObjectA(clazz: int, methodID: int, args: clr.Reference[jvalue]) -> int: ...
    @staticmethod
    def NewObjectArray(size: int, clazz: int, obj: int) -> int: ...
    @staticmethod
    def NewSByteArray(size: int) -> int: ...
    @staticmethod
    def NewShortArray(size: int) -> int: ...
    @staticmethod
    def NewStringUTF(bytes: str) -> int: ...
    @staticmethod
    def NewWeakGlobalRef(obj: int) -> int: ...
    @staticmethod
    def PopLocalFrame(ptr: int) -> int: ...
    @staticmethod
    def PushLocalFrame(capacity: int) -> int: ...
    @staticmethod
    def RegisterNatives(clazz: int, methods: Array_1[JNINativeMethod]) -> int: ...
    @staticmethod
    def SetBooleanField(obj: int, fieldID: int, val: bool) -> None: ...
    @staticmethod
    def SetByteArrayElement(array: int, index: int, val: int) -> None: ...
    @staticmethod
    def SetByteField(obj: int, fieldID: int, val: int) -> None: ...
    @staticmethod
    def SetCharArrayElement(array: int, index: int, val: str) -> None: ...
    @staticmethod
    def SetCharField(obj: int, fieldID: int, val: str) -> None: ...
    @staticmethod
    def SetDoubleArrayElement(array: int, index: int, val: float) -> None: ...
    @staticmethod
    def SetDoubleField(obj: int, fieldID: int, val: float) -> None: ...
    @staticmethod
    def SetFloatArrayElement(array: int, index: int, val: float) -> None: ...
    @staticmethod
    def SetFloatField(obj: int, fieldID: int, val: float) -> None: ...
    @staticmethod
    def SetIntArrayElement(array: int, index: int, val: int) -> None: ...
    @staticmethod
    def SetIntField(obj: int, fieldID: int, val: int) -> None: ...
    @staticmethod
    def SetLongArrayElement(array: int, index: int, val: int) -> None: ...
    @staticmethod
    def SetLongField(obj: int, fieldID: int, val: int) -> None: ...
    @staticmethod
    def SetObjectArrayElement(array: int, index: int, obj: int) -> None: ...
    @staticmethod
    def SetObjectField(obj: int, fieldID: int, val: int) -> None: ...
    @staticmethod
    def SetSByteArrayElement(array: int, index: int, val: int) -> None: ...
    @staticmethod
    def SetSByteField(obj: int, fieldID: int, val: int) -> None: ...
    @staticmethod
    def SetShortArrayElement(array: int, index: int, val: int) -> None: ...
    @staticmethod
    def SetShortField(obj: int, fieldID: int, val: int) -> None: ...
    @staticmethod
    def SetStaticBooleanField(clazz: int, fieldID: int, val: bool) -> None: ...
    @staticmethod
    def SetStaticByteField(clazz: int, fieldID: int, val: int) -> None: ...
    @staticmethod
    def SetStaticCharField(clazz: int, fieldID: int, val: str) -> None: ...
    @staticmethod
    def SetStaticDoubleField(clazz: int, fieldID: int, val: float) -> None: ...
    @staticmethod
    def SetStaticFloatField(clazz: int, fieldID: int, val: float) -> None: ...
    @staticmethod
    def SetStaticIntField(clazz: int, fieldID: int, val: int) -> None: ...
    @staticmethod
    def SetStaticLongField(clazz: int, fieldID: int, val: int) -> None: ...
    @staticmethod
    def SetStaticObjectField(clazz: int, fieldID: int, val: int) -> None: ...
    @staticmethod
    def SetStaticSByteField(clazz: int, fieldID: int, val: int) -> None: ...
    @staticmethod
    def SetStaticShortField(clazz: int, fieldID: int, val: int) -> None: ...
    @staticmethod
    def SetStaticStringField(clazz: int, fieldID: int, val: str) -> None: ...
    @staticmethod
    def SetStringField(obj: int, fieldID: int, val: str) -> None: ...
    @staticmethod
    def Throw(obj: int) -> int: ...
    @staticmethod
    def ThrowNew(clazz: int, message: str) -> int: ...
    @staticmethod
    def ToBooleanArray(array: Array_1[bool]) -> int: ...
    @staticmethod
    def ToByteArray(array: Array_1[int]) -> int: ...
    @staticmethod
    def ToReflectedField(clazz: int, fieldID: int, isStatic: bool) -> int: ...
    @staticmethod
    def ToReflectedMethod(clazz: int, methodID: int, isStatic: bool) -> int: ...
    @staticmethod
    def UnregisterNatives(clazz: int) -> int: ...
    # Skipped CallBooleanMethod due to it being static, abstract and generic.

    CallBooleanMethod : CallBooleanMethod_MethodGroup
    class CallBooleanMethod_MethodGroup:
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Array_1[jvalue]) -> bool:...
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Span_1[jvalue]) -> bool:...

    # Skipped CallCharMethod due to it being static, abstract and generic.

    CallCharMethod : CallCharMethod_MethodGroup
    class CallCharMethod_MethodGroup:
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Array_1[jvalue]) -> str:...
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Span_1[jvalue]) -> str:...

    # Skipped CallDoubleMethod due to it being static, abstract and generic.

    CallDoubleMethod : CallDoubleMethod_MethodGroup
    class CallDoubleMethod_MethodGroup:
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Array_1[jvalue]) -> float:...
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Span_1[jvalue]) -> float:...

    # Skipped CallFloatMethod due to it being static, abstract and generic.

    CallFloatMethod : CallFloatMethod_MethodGroup
    class CallFloatMethod_MethodGroup:
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Array_1[jvalue]) -> float:...
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Span_1[jvalue]) -> float:...

    # Skipped CallIntMethod due to it being static, abstract and generic.

    CallIntMethod : CallIntMethod_MethodGroup
    class CallIntMethod_MethodGroup:
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Array_1[jvalue]) -> int:...
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Span_1[jvalue]) -> int:...

    # Skipped CallLongMethod due to it being static, abstract and generic.

    CallLongMethod : CallLongMethod_MethodGroup
    class CallLongMethod_MethodGroup:
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Array_1[jvalue]) -> int:...
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Span_1[jvalue]) -> int:...

    # Skipped CallObjectMethod due to it being static, abstract and generic.

    CallObjectMethod : CallObjectMethod_MethodGroup
    class CallObjectMethod_MethodGroup:
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Array_1[jvalue]) -> int:...
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Span_1[jvalue]) -> int:...

    # Skipped CallSByteMethod due to it being static, abstract and generic.

    CallSByteMethod : CallSByteMethod_MethodGroup
    class CallSByteMethod_MethodGroup:
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Array_1[jvalue]) -> int:...
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Span_1[jvalue]) -> int:...

    # Skipped CallShortMethod due to it being static, abstract and generic.

    CallShortMethod : CallShortMethod_MethodGroup
    class CallShortMethod_MethodGroup:
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Array_1[jvalue]) -> int:...
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Span_1[jvalue]) -> int:...

    # Skipped CallStaticBooleanMethod due to it being static, abstract and generic.

    CallStaticBooleanMethod : CallStaticBooleanMethod_MethodGroup
    class CallStaticBooleanMethod_MethodGroup:
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Array_1[jvalue]) -> bool:...
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Span_1[jvalue]) -> bool:...

    # Skipped CallStaticCharMethod due to it being static, abstract and generic.

    CallStaticCharMethod : CallStaticCharMethod_MethodGroup
    class CallStaticCharMethod_MethodGroup:
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Array_1[jvalue]) -> str:...
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Span_1[jvalue]) -> str:...

    # Skipped CallStaticDoubleMethod due to it being static, abstract and generic.

    CallStaticDoubleMethod : CallStaticDoubleMethod_MethodGroup
    class CallStaticDoubleMethod_MethodGroup:
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Array_1[jvalue]) -> float:...
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Span_1[jvalue]) -> float:...

    # Skipped CallStaticFloatMethod due to it being static, abstract and generic.

    CallStaticFloatMethod : CallStaticFloatMethod_MethodGroup
    class CallStaticFloatMethod_MethodGroup:
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Array_1[jvalue]) -> float:...
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Span_1[jvalue]) -> float:...

    # Skipped CallStaticIntMethod due to it being static, abstract and generic.

    CallStaticIntMethod : CallStaticIntMethod_MethodGroup
    class CallStaticIntMethod_MethodGroup:
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Array_1[jvalue]) -> int:...
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Span_1[jvalue]) -> int:...

    # Skipped CallStaticLongMethod due to it being static, abstract and generic.

    CallStaticLongMethod : CallStaticLongMethod_MethodGroup
    class CallStaticLongMethod_MethodGroup:
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Array_1[jvalue]) -> int:...
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Span_1[jvalue]) -> int:...

    # Skipped CallStaticObjectMethod due to it being static, abstract and generic.

    CallStaticObjectMethod : CallStaticObjectMethod_MethodGroup
    class CallStaticObjectMethod_MethodGroup:
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Array_1[jvalue]) -> int:...
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Span_1[jvalue]) -> int:...

    # Skipped CallStaticSByteMethod due to it being static, abstract and generic.

    CallStaticSByteMethod : CallStaticSByteMethod_MethodGroup
    class CallStaticSByteMethod_MethodGroup:
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Array_1[jvalue]) -> int:...
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Span_1[jvalue]) -> int:...

    # Skipped CallStaticShortMethod due to it being static, abstract and generic.

    CallStaticShortMethod : CallStaticShortMethod_MethodGroup
    class CallStaticShortMethod_MethodGroup:
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Array_1[jvalue]) -> int:...
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Span_1[jvalue]) -> int:...

    # Skipped CallStaticStringMethod due to it being static, abstract and generic.

    CallStaticStringMethod : CallStaticStringMethod_MethodGroup
    class CallStaticStringMethod_MethodGroup:
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Array_1[jvalue]) -> str:...
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Span_1[jvalue]) -> str:...

    # Skipped CallStaticVoidMethod due to it being static, abstract and generic.

    CallStaticVoidMethod : CallStaticVoidMethod_MethodGroup
    class CallStaticVoidMethod_MethodGroup:
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Array_1[jvalue]) -> None:...
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Span_1[jvalue]) -> None:...

    # Skipped CallStringMethod due to it being static, abstract and generic.

    CallStringMethod : CallStringMethod_MethodGroup
    class CallStringMethod_MethodGroup:
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Array_1[jvalue]) -> str:...
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Span_1[jvalue]) -> str:...

    # Skipped CallVoidMethod due to it being static, abstract and generic.

    CallVoidMethod : CallVoidMethod_MethodGroup
    class CallVoidMethod_MethodGroup:
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Array_1[jvalue]) -> None:...
        @typing.overload
        def __call__(self, obj: int, methodID: int, args: Span_1[jvalue]) -> None:...

    # Skipped NewDirectByteBuffer due to it being static, abstract and generic.

    NewDirectByteBuffer : NewDirectByteBuffer_MethodGroup
    class NewDirectByteBuffer_MethodGroup:
        @typing.overload
        def __call__(self, buffer: NativeArray_1[int]) -> int:...
        # Method NewDirectByteBuffer(buffer : NativeArray`1) was skipped since it collides with above method
        @typing.overload
        def __call__(self, buffer: clr.Reference[int], capacity: int) -> int:...

    # Skipped NewObject due to it being static, abstract and generic.

    NewObject : NewObject_MethodGroup
    class NewObject_MethodGroup:
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Array_1[jvalue]) -> int:...
        @typing.overload
        def __call__(self, clazz: int, methodID: int, args: Span_1[jvalue]) -> int:...

    # Skipped NewString due to it being static, abstract and generic.

    NewString : NewString_MethodGroup
    class NewString_MethodGroup:
        @typing.overload
        def __call__(self, chars: Array_1[str]) -> int:...
        @typing.overload
        def __call__(self, chars: str) -> int:...

    # Skipped SetBooleanArrayElement due to it being static, abstract and generic.

    SetBooleanArrayElement : SetBooleanArrayElement_MethodGroup
    class SetBooleanArrayElement_MethodGroup:
        def __call__(self, array: int, index: int, val: int) -> None:...
        # Method SetBooleanArrayElement(array : IntPtr, index : Int32, val : Boolean) was skipped since it collides with above method

    # Skipped ToCharArray due to it being static, abstract and generic.

    ToCharArray : ToCharArray_MethodGroup
    class ToCharArray_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[str]) -> int:...
        @typing.overload
        def __call__(self, array: clr.Reference[str], length: int) -> int:...

    # Skipped ToDoubleArray due to it being static, abstract and generic.

    ToDoubleArray : ToDoubleArray_MethodGroup
    class ToDoubleArray_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[float]) -> int:...
        @typing.overload
        def __call__(self, array: clr.Reference[float], length: int) -> int:...

    # Skipped ToFloatArray due to it being static, abstract and generic.

    ToFloatArray : ToFloatArray_MethodGroup
    class ToFloatArray_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[float]) -> int:...
        @typing.overload
        def __call__(self, array: clr.Reference[float], length: int) -> int:...

    # Skipped ToIntArray due to it being static, abstract and generic.

    ToIntArray : ToIntArray_MethodGroup
    class ToIntArray_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[int]) -> int:...
        @typing.overload
        def __call__(self, array: clr.Reference[int], length: int) -> int:...

    # Skipped ToLongArray due to it being static, abstract and generic.

    ToLongArray : ToLongArray_MethodGroup
    class ToLongArray_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[int]) -> int:...
        @typing.overload
        def __call__(self, array: clr.Reference[int], length: int) -> int:...

    # Skipped ToObjectArray due to it being static, abstract and generic.

    ToObjectArray : ToObjectArray_MethodGroup
    class ToObjectArray_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[int]) -> int:...
        @typing.overload
        def __call__(self, array: Array_1[int], arrayClass: int) -> int:...
        @typing.overload
        def __call__(self, array: clr.Reference[int], length: int, arrayClass: int) -> int:...

    # Skipped ToSByteArray due to it being static, abstract and generic.

    ToSByteArray : ToSByteArray_MethodGroup
    class ToSByteArray_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[int]) -> int:...
        @typing.overload
        def __call__(self, array: clr.Reference[int], length: int) -> int:...

    # Skipped ToShortArray due to it being static, abstract and generic.

    ToShortArray : ToShortArray_MethodGroup
    class ToShortArray_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[int]) -> int:...
        @typing.overload
        def __call__(self, array: clr.Reference[int], length: int) -> int:...



class AndroidJNIHelper(abc.ABC):
    @classmethod
    @property
    def debug(cls) -> bool: ...
    @classmethod
    @debug.setter
    def debug(cls, value: bool) -> bool: ...
    @staticmethod
    def ConvertToJNIArray(array: Array) -> int: ...
    @staticmethod
    def CreateJavaProxy(proxy: AndroidJavaProxy) -> int: ...
    @staticmethod
    def CreateJavaRunnable(jrunnable: AndroidJavaRunnable) -> int: ...
    # Skipped Box due to it being static, abstract and generic.

    Box : Box_MethodGroup
    class Box_MethodGroup:
        @typing.overload
        def __call__(self, value: float) -> int:...
        # Method Box(value : Double) was skipped since it collides with above method
        # Method Box(value : SByte) was skipped since it collides with above method
        # Method Box(value : Int16) was skipped since it collides with above method
        # Method Box(value : Int32) was skipped since it collides with above method
        # Method Box(value : Int64) was skipped since it collides with above method
        @typing.overload
        def __call__(self, value: str) -> int:...
        # Method Box(value : Boolean) was skipped since it collides with above method

    # Skipped ConvertFromJNIArray due to it being static, abstract and generic.

    ConvertFromJNIArray : ConvertFromJNIArray_MethodGroup
    class ConvertFromJNIArray_MethodGroup:
        def __getitem__(self, t:typing.Type[ConvertFromJNIArray_1_T1]) -> ConvertFromJNIArray_1[ConvertFromJNIArray_1_T1]: ...

        ConvertFromJNIArray_1_T1 = typing.TypeVar('ConvertFromJNIArray_1_T1')
        class ConvertFromJNIArray_1(typing.Generic[ConvertFromJNIArray_1_T1]):
            ConvertFromJNIArray_1_ArrayType = AndroidJNIHelper.ConvertFromJNIArray_MethodGroup.ConvertFromJNIArray_1_T1
            def __call__(self, array: int) -> ConvertFromJNIArray_1_ArrayType:...


    # Skipped CreateJNIArgArray due to it being static, abstract and generic.

    CreateJNIArgArray : CreateJNIArgArray_MethodGroup
    class CreateJNIArgArray_MethodGroup:
        @typing.overload
        def __call__(self, args: Array_1[typing.Any]) -> Array_1[jvalue]:...
        @typing.overload
        def __call__(self, args: Array_1[typing.Any], jniArgs: Span_1[jvalue]) -> None:...

    # Skipped DeleteJNIArgArray due to it being static, abstract and generic.

    DeleteJNIArgArray : DeleteJNIArgArray_MethodGroup
    class DeleteJNIArgArray_MethodGroup:
        @typing.overload
        def __call__(self, args: Array_1[typing.Any], jniArgs: Array_1[jvalue]) -> None:...
        @typing.overload
        def __call__(self, args: Array_1[typing.Any], jniArgs: Span_1[jvalue]) -> None:...

    # Skipped GetConstructorID due to it being static, abstract and generic.

    GetConstructorID : GetConstructorID_MethodGroup
    class GetConstructorID_MethodGroup:
        @typing.overload
        def __call__(self, javaClass: int) -> int:...
        @typing.overload
        def __call__(self, jclass: int, args: Array_1[typing.Any]) -> int:...
        @typing.overload
        def __call__(self, javaClass: int, signature: str) -> int:...

    # Skipped GetFieldID due to it being static, abstract and generic.

    GetFieldID : GetFieldID_MethodGroup
    class GetFieldID_MethodGroup:
        def __getitem__(self, t:typing.Type[GetFieldID_1_T1]) -> GetFieldID_1[GetFieldID_1_T1]: ...

        GetFieldID_1_T1 = typing.TypeVar('GetFieldID_1_T1')
        class GetFieldID_1(typing.Generic[GetFieldID_1_T1]):
            GetFieldID_1_FieldType = AndroidJNIHelper.GetFieldID_MethodGroup.GetFieldID_1_T1
            def __call__(self, jclass: int, fieldName: str, isStatic: bool) -> int:...

        @typing.overload
        def __call__(self, javaClass: int, fieldName: str) -> int:...
        @typing.overload
        def __call__(self, javaClass: int, fieldName: str, signature: str) -> int:...
        @typing.overload
        def __call__(self, javaClass: int, fieldName: str, signature: str, isStatic: bool) -> int:...

    # Skipped GetMethodID due to it being static, abstract and generic.

    GetMethodID : GetMethodID_MethodGroup
    class GetMethodID_MethodGroup:
        def __getitem__(self, t:typing.Type[GetMethodID_1_T1]) -> GetMethodID_1[GetMethodID_1_T1]: ...

        GetMethodID_1_T1 = typing.TypeVar('GetMethodID_1_T1')
        class GetMethodID_1(typing.Generic[GetMethodID_1_T1]):
            GetMethodID_1_ReturnType = AndroidJNIHelper.GetMethodID_MethodGroup.GetMethodID_1_T1
            def __call__(self, jclass: int, methodName: str, args: Array_1[typing.Any], isStatic: bool) -> int:...

        @typing.overload
        def __call__(self, javaClass: int, methodName: str) -> int:...
        @typing.overload
        def __call__(self, javaClass: int, methodName: str, signature: str) -> int:...
        @typing.overload
        def __call__(self, jclass: int, methodName: str, args: Array_1[typing.Any], isStatic: bool) -> int:...
        @typing.overload
        def __call__(self, javaClass: int, methodName: str, signature: str, isStatic: bool) -> int:...

    # Skipped GetSignature due to it being static, abstract and generic.

    GetSignature : GetSignature_MethodGroup
    class GetSignature_MethodGroup:
        def __getitem__(self, t:typing.Type[GetSignature_1_T1]) -> GetSignature_1[GetSignature_1_T1]: ...

        GetSignature_1_T1 = typing.TypeVar('GetSignature_1_T1')
        class GetSignature_1(typing.Generic[GetSignature_1_T1]):
            GetSignature_1_ReturnType = AndroidJNIHelper.GetSignature_MethodGroup.GetSignature_1_T1
            def __call__(self, args: Array_1[typing.Any]) -> str:...

        @typing.overload
        def __call__(self, args: Array_1[typing.Any]) -> str:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> str:...

    # Skipped Unbox due to it being static, abstract and generic.

    Unbox : Unbox_MethodGroup
    class Unbox_MethodGroup:
        @typing.overload
        def __call__(self, obj: int, value: clr.Reference[float]) -> None:...
        # Method Unbox(obj : IntPtr, value : Double&) was skipped since it collides with above method
        # Method Unbox(obj : IntPtr, value : SByte&) was skipped since it collides with above method
        # Method Unbox(obj : IntPtr, value : Int16&) was skipped since it collides with above method
        # Method Unbox(obj : IntPtr, value : Int32&) was skipped since it collides with above method
        # Method Unbox(obj : IntPtr, value : Int64&) was skipped since it collides with above method
        @typing.overload
        def __call__(self, obj: int, value: clr.Reference[str]) -> None:...
        # Method Unbox(obj : IntPtr, value : Boolean&) was skipped since it collides with above method



class Animation(Behaviour, IEnumerable):
    def __init__(self) -> None: ...
    @property
    def animateOnlyIfVisible(self) -> bool: ...
    @animateOnlyIfVisible.setter
    def animateOnlyIfVisible(self, value: bool) -> bool: ...
    @property
    def animatePhysics(self) -> bool: ...
    @animatePhysics.setter
    def animatePhysics(self, value: bool) -> bool: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def clip(self) -> AnimationClip: ...
    @clip.setter
    def clip(self, value: AnimationClip) -> AnimationClip: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def cullingType(self) -> AnimationCullingType: ...
    @cullingType.setter
    def cullingType(self, value: AnimationCullingType) -> AnimationCullingType: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def isPlaying(self) -> bool: ...
    @property
    def Item(self) -> AnimationState: ...
    @property
    def light(self) -> Component: ...
    @property
    def localBounds(self) -> Bounds: ...
    @localBounds.setter
    def localBounds(self, value: Bounds) -> Bounds: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def playAutomatically(self) -> bool: ...
    @playAutomatically.setter
    def playAutomatically(self, value: bool) -> bool: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def wrapMode(self) -> WrapMode: ...
    @wrapMode.setter
    def wrapMode(self, value: WrapMode) -> WrapMode: ...
    def GetClip(self, name: str) -> AnimationClip: ...
    def GetClipCount(self) -> int: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def IsPlaying(self, name: str) -> bool: ...
    def Sample(self) -> None: ...
    def SyncLayer(self, layer: int) -> None: ...
    # Skipped AddClip due to it being static, abstract and generic.

    AddClip : AddClip_MethodGroup
    class AddClip_MethodGroup:
        @typing.overload
        def __call__(self, clip: AnimationClip, newName: str) -> None:...
        @typing.overload
        def __call__(self, clip: AnimationClip, newName: str, firstFrame: int, lastFrame: int) -> None:...
        @typing.overload
        def __call__(self, clip: AnimationClip, newName: str, firstFrame: int, lastFrame: int, addLoopFrame: bool) -> None:...

    # Skipped Blend due to it being static, abstract and generic.

    Blend : Blend_MethodGroup
    class Blend_MethodGroup:
        @typing.overload
        def __call__(self, animation: str) -> None:...
        @typing.overload
        def __call__(self, animation: str, targetWeight: float) -> None:...
        @typing.overload
        def __call__(self, animation: str, targetWeight: float, fadeLength: float) -> None:...

    # Skipped CrossFade due to it being static, abstract and generic.

    CrossFade : CrossFade_MethodGroup
    class CrossFade_MethodGroup:
        @typing.overload
        def __call__(self, animation: str) -> None:...
        @typing.overload
        def __call__(self, animation: str, fadeLength: float) -> None:...
        @typing.overload
        def __call__(self, animation: str, fadeLength: float, mode: PlayMode) -> None:...

    # Skipped CrossFadeQueued due to it being static, abstract and generic.

    CrossFadeQueued : CrossFadeQueued_MethodGroup
    class CrossFadeQueued_MethodGroup:
        @typing.overload
        def __call__(self, animation: str) -> AnimationState:...
        @typing.overload
        def __call__(self, animation: str, fadeLength: float) -> AnimationState:...
        @typing.overload
        def __call__(self, animation: str, fadeLength: float, queue: QueueMode) -> AnimationState:...
        @typing.overload
        def __call__(self, animation: str, fadeLength: float, queue: QueueMode, mode: PlayMode) -> AnimationState:...

    # Skipped Play due to it being static, abstract and generic.

    Play : Play_MethodGroup
    class Play_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, mode: PlayMode) -> bool:...
        @typing.overload
        def __call__(self, mode: AnimationPlayMode) -> bool:...
        @typing.overload
        def __call__(self, animation: str) -> bool:...
        @typing.overload
        def __call__(self, animation: str, mode: PlayMode) -> bool:...
        @typing.overload
        def __call__(self, animation: str, mode: AnimationPlayMode) -> bool:...

    # Skipped PlayQueued due to it being static, abstract and generic.

    PlayQueued : PlayQueued_MethodGroup
    class PlayQueued_MethodGroup:
        @typing.overload
        def __call__(self, animation: str) -> AnimationState:...
        @typing.overload
        def __call__(self, animation: str, queue: QueueMode) -> AnimationState:...
        @typing.overload
        def __call__(self, animation: str, queue: QueueMode, mode: PlayMode) -> AnimationState:...

    # Skipped RemoveClip due to it being static, abstract and generic.

    RemoveClip : RemoveClip_MethodGroup
    class RemoveClip_MethodGroup:
        @typing.overload
        def __call__(self, clip: AnimationClip) -> None:...
        @typing.overload
        def __call__(self, clipName: str) -> None:...

    # Skipped Rewind due to it being static, abstract and generic.

    Rewind : Rewind_MethodGroup
    class Rewind_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, name: str) -> None:...

    # Skipped Stop due to it being static, abstract and generic.

    Stop : Stop_MethodGroup
    class Stop_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, name: str) -> None:...



class AnimationBlendMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Blend : AnimationBlendMode # 0
    Additive : AnimationBlendMode # 1


class AnimationClip(Motion):
    def __init__(self) -> None: ...
    @property
    def apparentSpeed(self) -> float: ...
    @property
    def averageAngularSpeed(self) -> float: ...
    @property
    def averageDuration(self) -> float: ...
    @property
    def averageSpeed(self) -> Vector3: ...
    @property
    def empty(self) -> bool: ...
    @property
    def events(self) -> Array_1[AnimationEvent]: ...
    @events.setter
    def events(self, value: Array_1[AnimationEvent]) -> Array_1[AnimationEvent]: ...
    @property
    def frameRate(self) -> float: ...
    @frameRate.setter
    def frameRate(self, value: float) -> float: ...
    @property
    def hasGenericRootTransform(self) -> bool: ...
    @property
    def hasMotionCurves(self) -> bool: ...
    @property
    def hasMotionFloatCurves(self) -> bool: ...
    @property
    def hasRootCurves(self) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def humanMotion(self) -> bool: ...
    @property
    def isAnimatorMotion(self) -> bool: ...
    @property
    def isHumanMotion(self) -> bool: ...
    @property
    def isLooping(self) -> bool: ...
    @property
    def legacy(self) -> bool: ...
    @legacy.setter
    def legacy(self, value: bool) -> bool: ...
    @property
    def length(self) -> float: ...
    @property
    def localBounds(self) -> Bounds: ...
    @localBounds.setter
    def localBounds(self, value: Bounds) -> Bounds: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def wrapMode(self) -> WrapMode: ...
    @wrapMode.setter
    def wrapMode(self, value: WrapMode) -> WrapMode: ...
    def AddEvent(self, evt: AnimationEvent) -> None: ...
    def ClearCurves(self) -> None: ...
    def EnsureQuaternionContinuity(self) -> None: ...
    def SampleAnimation(self, go: GameObject, time: float) -> None: ...
    def SetCurve(self, relativePath: str, type: typing.Type[typing.Any], propertyName: str, curve: AnimationCurve) -> None: ...


class AnimationClipPair:
    def __init__(self) -> None: ...
    originalClip : AnimationClip
    overrideClip : AnimationClip


class AnimationCullingType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    AlwaysAnimate : AnimationCullingType # 0
    BasedOnRenderers : AnimationCullingType # 1
    BasedOnClipBounds : AnimationCullingType # 2
    BasedOnUserBounds : AnimationCullingType # 3


class AnimationCurve(IEquatable_1[AnimationCurve]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, keys: Array_1[Keyframe]) -> None: ...
    @property
    def Item(self) -> Keyframe: ...
    @property
    def keys(self) -> Array_1[Keyframe]: ...
    @keys.setter
    def keys(self, value: Array_1[Keyframe]) -> Array_1[Keyframe]: ...
    @property
    def length(self) -> int: ...
    @property
    def postWrapMode(self) -> WrapMode: ...
    @postWrapMode.setter
    def postWrapMode(self, value: WrapMode) -> WrapMode: ...
    @property
    def preWrapMode(self) -> WrapMode: ...
    @preWrapMode.setter
    def preWrapMode(self, value: WrapMode) -> WrapMode: ...
    def ClearKeys(self) -> None: ...
    @staticmethod
    def Constant(timeStart: float, timeEnd: float, value: float) -> AnimationCurve: ...
    def CopyFrom(self, other: AnimationCurve) -> None: ...
    @staticmethod
    def EaseInOut(timeStart: float, valueStart: float, timeEnd: float, valueEnd: float) -> AnimationCurve: ...
    def Evaluate(self, time: float) -> float: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Linear(timeStart: float, valueStart: float, timeEnd: float, valueEnd: float) -> AnimationCurve: ...
    def MoveKey(self, index: int, key: Keyframe) -> int: ...
    def RemoveKey(self, index: int) -> None: ...
    def SmoothTangents(self, index: int, weight: float) -> None: ...
    # Skipped AddKey due to it being static, abstract and generic.

    AddKey : AddKey_MethodGroup
    class AddKey_MethodGroup:
        @typing.overload
        def __call__(self, key: Keyframe) -> int:...
        @typing.overload
        def __call__(self, time: float, value: float) -> int:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: AnimationCurve) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...



class AnimationEvent:
    def __init__(self) -> None: ...
    @property
    def animationState(self) -> AnimationState: ...
    @property
    def animatorClipInfo(self) -> AnimatorClipInfo: ...
    @property
    def animatorStateInfo(self) -> AnimatorStateInfo: ...
    @property
    def data(self) -> str: ...
    @data.setter
    def data(self, value: str) -> str: ...
    @property
    def floatParameter(self) -> float: ...
    @floatParameter.setter
    def floatParameter(self, value: float) -> float: ...
    @property
    def functionName(self) -> str: ...
    @functionName.setter
    def functionName(self, value: str) -> str: ...
    @property
    def intParameter(self) -> int: ...
    @intParameter.setter
    def intParameter(self, value: int) -> int: ...
    @property
    def isFiredByAnimator(self) -> bool: ...
    @property
    def isFiredByLegacy(self) -> bool: ...
    @property
    def messageOptions(self) -> SendMessageOptions: ...
    @messageOptions.setter
    def messageOptions(self, value: SendMessageOptions) -> SendMessageOptions: ...
    @property
    def objectReferenceParameter(self) -> Object: ...
    @objectReferenceParameter.setter
    def objectReferenceParameter(self, value: Object) -> Object: ...
    @property
    def stringParameter(self) -> str: ...
    @stringParameter.setter
    def stringParameter(self, value: str) -> str: ...
    @property
    def time(self) -> float: ...
    @time.setter
    def time(self, value: float) -> float: ...


class AnimationInfo:
    @property
    def clip(self) -> AnimationClip: ...
    @property
    def weight(self) -> float: ...


class AnimationPlayMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Stop : AnimationPlayMode # 0
    Queue : AnimationPlayMode # 1
    Mix : AnimationPlayMode # 2


class AnimationState(TrackedReference):
    def __init__(self) -> None: ...
    @property
    def blendMode(self) -> AnimationBlendMode: ...
    @blendMode.setter
    def blendMode(self, value: AnimationBlendMode) -> AnimationBlendMode: ...
    @property
    def clip(self) -> AnimationClip: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def layer(self) -> int: ...
    @layer.setter
    def layer(self, value: int) -> int: ...
    @property
    def length(self) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def normalizedSpeed(self) -> float: ...
    @normalizedSpeed.setter
    def normalizedSpeed(self, value: float) -> float: ...
    @property
    def normalizedTime(self) -> float: ...
    @normalizedTime.setter
    def normalizedTime(self, value: float) -> float: ...
    @property
    def speed(self) -> float: ...
    @speed.setter
    def speed(self, value: float) -> float: ...
    @property
    def time(self) -> float: ...
    @time.setter
    def time(self, value: float) -> float: ...
    @property
    def weight(self) -> float: ...
    @weight.setter
    def weight(self, value: float) -> float: ...
    @property
    def wrapMode(self) -> WrapMode: ...
    @wrapMode.setter
    def wrapMode(self, value: WrapMode) -> WrapMode: ...
    def RemoveMixingTransform(self, mix: Transform) -> None: ...
    # Skipped AddMixingTransform due to it being static, abstract and generic.

    AddMixingTransform : AddMixingTransform_MethodGroup
    class AddMixingTransform_MethodGroup:
        @typing.overload
        def __call__(self, mix: Transform) -> None:...
        @typing.overload
        def __call__(self, mix: Transform, recursive: bool) -> None:...



class Animator(Behaviour):
    def __init__(self) -> None: ...
    @property
    def angularVelocity(self) -> Vector3: ...
    @property
    def animatePhysics(self) -> bool: ...
    @animatePhysics.setter
    def animatePhysics(self, value: bool) -> bool: ...
    @property
    def animation(self) -> Component: ...
    @property
    def applyRootMotion(self) -> bool: ...
    @applyRootMotion.setter
    def applyRootMotion(self, value: bool) -> bool: ...
    @property
    def audio(self) -> Component: ...
    @property
    def avatar(self) -> Avatar: ...
    @avatar.setter
    def avatar(self, value: Avatar) -> Avatar: ...
    @property
    def avatarRoot(self) -> Transform: ...
    @property
    def bodyPosition(self) -> Vector3: ...
    @bodyPosition.setter
    def bodyPosition(self, value: Vector3) -> Vector3: ...
    @property
    def bodyRotation(self) -> Quaternion: ...
    @bodyRotation.setter
    def bodyRotation(self, value: Quaternion) -> Quaternion: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def cullingMode(self) -> AnimatorCullingMode: ...
    @cullingMode.setter
    def cullingMode(self, value: AnimatorCullingMode) -> AnimatorCullingMode: ...
    @property
    def deltaPosition(self) -> Vector3: ...
    @property
    def deltaRotation(self) -> Quaternion: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def feetPivotActive(self) -> float: ...
    @feetPivotActive.setter
    def feetPivotActive(self, value: float) -> float: ...
    @property
    def fireEvents(self) -> bool: ...
    @fireEvents.setter
    def fireEvents(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def gravityWeight(self) -> float: ...
    @property
    def hasBoundPlayables(self) -> bool: ...
    @property
    def hasRootMotion(self) -> bool: ...
    @property
    def hasTransformHierarchy(self) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def humanScale(self) -> float: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def isHuman(self) -> bool: ...
    @property
    def isInitialized(self) -> bool: ...
    @property
    def isMatchingTarget(self) -> bool: ...
    @property
    def isOptimizable(self) -> bool: ...
    @property
    def keepAnimatorControllerStateOnDisable(self) -> bool: ...
    @keepAnimatorControllerStateOnDisable.setter
    def keepAnimatorControllerStateOnDisable(self, value: bool) -> bool: ...
    @property
    def keepAnimatorStateOnDisable(self) -> bool: ...
    @keepAnimatorStateOnDisable.setter
    def keepAnimatorStateOnDisable(self, value: bool) -> bool: ...
    @property
    def layerCount(self) -> int: ...
    @property
    def layersAffectMassCenter(self) -> bool: ...
    @layersAffectMassCenter.setter
    def layersAffectMassCenter(self, value: bool) -> bool: ...
    @property
    def leftFeetBottomHeight(self) -> float: ...
    @property
    def light(self) -> Component: ...
    @property
    def linearVelocityBlending(self) -> bool: ...
    @linearVelocityBlending.setter
    def linearVelocityBlending(self, value: bool) -> bool: ...
    @property
    def logWarnings(self) -> bool: ...
    @logWarnings.setter
    def logWarnings(self, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def parameterCount(self) -> int: ...
    @property
    def parameters(self) -> Array_1[AnimatorControllerParameter]: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def pivotPosition(self) -> Vector3: ...
    @property
    def pivotWeight(self) -> float: ...
    @property
    def playableGraph(self) -> PlayableGraph: ...
    @property
    def playbackTime(self) -> float: ...
    @playbackTime.setter
    def playbackTime(self, value: float) -> float: ...
    @property
    def recorderMode(self) -> AnimatorRecorderMode: ...
    @property
    def recorderStartTime(self) -> float: ...
    @recorderStartTime.setter
    def recorderStartTime(self, value: float) -> float: ...
    @property
    def recorderStopTime(self) -> float: ...
    @recorderStopTime.setter
    def recorderStopTime(self, value: float) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rightFeetBottomHeight(self) -> float: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def rootPosition(self) -> Vector3: ...
    @rootPosition.setter
    def rootPosition(self, value: Vector3) -> Vector3: ...
    @property
    def rootRotation(self) -> Quaternion: ...
    @rootRotation.setter
    def rootRotation(self, value: Quaternion) -> Quaternion: ...
    @property
    def runtimeAnimatorController(self) -> RuntimeAnimatorController: ...
    @runtimeAnimatorController.setter
    def runtimeAnimatorController(self, value: RuntimeAnimatorController) -> RuntimeAnimatorController: ...
    @property
    def speed(self) -> float: ...
    @speed.setter
    def speed(self, value: float) -> float: ...
    @property
    def stabilizeFeet(self) -> bool: ...
    @stabilizeFeet.setter
    def stabilizeFeet(self, value: bool) -> bool: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def targetPosition(self) -> Vector3: ...
    @property
    def targetRotation(self) -> Quaternion: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def updateMode(self) -> AnimatorUpdateMode: ...
    @updateMode.setter
    def updateMode(self, value: AnimatorUpdateMode) -> AnimatorUpdateMode: ...
    @property
    def velocity(self) -> Vector3: ...
    @property
    def writeDefaultValuesOnDisable(self) -> bool: ...
    @writeDefaultValuesOnDisable.setter
    def writeDefaultValuesOnDisable(self, value: bool) -> bool: ...
    def ApplyBuiltinRootMotion(self) -> None: ...
    def ForceStateNormalizedTime(self, normalizedTime: float) -> None: ...
    def GetAnimatorTransitionInfo(self, layerIndex: int) -> AnimatorTransitionInfo: ...
    def GetBoneTransform(self, humanBoneId: HumanBodyBones) -> Transform: ...
    def GetCurrentAnimationClipState(self, layerIndex: int) -> Array_1[AnimationInfo]: ...
    def GetCurrentAnimatorClipInfoCount(self, layerIndex: int) -> int: ...
    def GetCurrentAnimatorStateInfo(self, layerIndex: int) -> AnimatorStateInfo: ...
    def GetIKHintPosition(self, hint: AvatarIKHint) -> Vector3: ...
    def GetIKHintPositionWeight(self, hint: AvatarIKHint) -> float: ...
    def GetIKPosition(self, goal: AvatarIKGoal) -> Vector3: ...
    def GetIKPositionWeight(self, goal: AvatarIKGoal) -> float: ...
    def GetIKRotation(self, goal: AvatarIKGoal) -> Quaternion: ...
    def GetIKRotationWeight(self, goal: AvatarIKGoal) -> float: ...
    def GetLayerIndex(self, layerName: str) -> int: ...
    def GetLayerName(self, layerIndex: int) -> str: ...
    def GetLayerWeight(self, layerIndex: int) -> float: ...
    def GetNextAnimationClipState(self, layerIndex: int) -> Array_1[AnimationInfo]: ...
    def GetNextAnimatorClipInfoCount(self, layerIndex: int) -> int: ...
    def GetNextAnimatorStateInfo(self, layerIndex: int) -> AnimatorStateInfo: ...
    def GetParameter(self, index: int) -> AnimatorControllerParameter: ...
    def HasState(self, layerIndex: int, stateID: int) -> bool: ...
    def IsControlled(self, transform: Transform) -> bool: ...
    def IsInTransition(self, layerIndex: int) -> bool: ...
    def Rebind(self) -> None: ...
    def SetBoneLocalRotation(self, humanBoneId: HumanBodyBones, rotation: Quaternion) -> None: ...
    def SetIKHintPosition(self, hint: AvatarIKHint, hintPosition: Vector3) -> None: ...
    def SetIKHintPositionWeight(self, hint: AvatarIKHint, value: float) -> None: ...
    def SetIKPosition(self, goal: AvatarIKGoal, goalPosition: Vector3) -> None: ...
    def SetIKPositionWeight(self, goal: AvatarIKGoal, value: float) -> None: ...
    def SetIKRotation(self, goal: AvatarIKGoal, goalRotation: Quaternion) -> None: ...
    def SetIKRotationWeight(self, goal: AvatarIKGoal, value: float) -> None: ...
    def SetLayerWeight(self, layerIndex: int, weight: float) -> None: ...
    def SetLookAtPosition(self, lookAtPosition: Vector3) -> None: ...
    def SetTarget(self, targetIndex: AvatarTarget, targetNormalizedTime: float) -> None: ...
    def StartPlayback(self) -> None: ...
    def StartRecording(self, frameCount: int) -> None: ...
    def Stop(self) -> None: ...
    def StopPlayback(self) -> None: ...
    def StopRecording(self) -> None: ...
    @staticmethod
    def StringToHash(name: str) -> int: ...
    def Update(self, deltaTime: float) -> None: ...
    def WriteDefaultValues(self) -> None: ...
    # Skipped CrossFade due to it being static, abstract and generic.

    CrossFade : CrossFade_MethodGroup
    class CrossFade_MethodGroup:
        @typing.overload
        def __call__(self, stateHashName: int, normalizedTransitionDuration: float) -> None:...
        @typing.overload
        def __call__(self, stateName: str, normalizedTransitionDuration: float) -> None:...
        @typing.overload
        def __call__(self, stateHashName: int, normalizedTransitionDuration: float, layer: int) -> None:...
        @typing.overload
        def __call__(self, stateName: str, normalizedTransitionDuration: float, layer: int) -> None:...
        @typing.overload
        def __call__(self, stateHashName: int, normalizedTransitionDuration: float, layer: int, normalizedTimeOffset: float) -> None:...
        @typing.overload
        def __call__(self, stateName: str, normalizedTransitionDuration: float, layer: int, normalizedTimeOffset: float) -> None:...
        @typing.overload
        def __call__(self, stateHashName: int, normalizedTransitionDuration: float, layer: int, normalizedTimeOffset: float, normalizedTransitionTime: float) -> None:...
        @typing.overload
        def __call__(self, stateName: str, normalizedTransitionDuration: float, layer: int, normalizedTimeOffset: float, normalizedTransitionTime: float) -> None:...

    # Skipped CrossFadeInFixedTime due to it being static, abstract and generic.

    CrossFadeInFixedTime : CrossFadeInFixedTime_MethodGroup
    class CrossFadeInFixedTime_MethodGroup:
        @typing.overload
        def __call__(self, stateHashName: int, fixedTransitionDuration: float) -> None:...
        @typing.overload
        def __call__(self, stateName: str, fixedTransitionDuration: float) -> None:...
        @typing.overload
        def __call__(self, stateHashName: int, fixedTransitionDuration: float, layer: int) -> None:...
        @typing.overload
        def __call__(self, stateName: str, fixedTransitionDuration: float, layer: int) -> None:...
        @typing.overload
        def __call__(self, stateHashName: int, fixedTransitionDuration: float, layer: int, fixedTimeOffset: float) -> None:...
        @typing.overload
        def __call__(self, stateName: str, fixedTransitionDuration: float, layer: int, fixedTimeOffset: float) -> None:...
        @typing.overload
        def __call__(self, stateHashName: int, fixedTransitionDuration: float, layer: int, fixedTimeOffset: float, normalizedTransitionTime: float) -> None:...
        @typing.overload
        def __call__(self, stateName: str, fixedTransitionDuration: float, layer: int, fixedTimeOffset: float, normalizedTransitionTime: float) -> None:...

    # Skipped GetBehaviour due to it being static, abstract and generic.

    GetBehaviour : GetBehaviour_MethodGroup
    class GetBehaviour_MethodGroup:
        def __getitem__(self, t:typing.Type[GetBehaviour_1_T1]) -> GetBehaviour_1[GetBehaviour_1_T1]: ...

        GetBehaviour_1_T1 = typing.TypeVar('GetBehaviour_1_T1')
        class GetBehaviour_1(typing.Generic[GetBehaviour_1_T1]):
            GetBehaviour_1_T = Animator.GetBehaviour_MethodGroup.GetBehaviour_1_T1
            def __call__(self) -> GetBehaviour_1_T:...


    # Skipped GetBehaviours due to it being static, abstract and generic.

    GetBehaviours : GetBehaviours_MethodGroup
    class GetBehaviours_MethodGroup:
        def __getitem__(self, t:typing.Type[GetBehaviours_1_T1]) -> GetBehaviours_1[GetBehaviours_1_T1]: ...

        GetBehaviours_1_T1 = typing.TypeVar('GetBehaviours_1_T1')
        class GetBehaviours_1(typing.Generic[GetBehaviours_1_T1]):
            GetBehaviours_1_T = Animator.GetBehaviours_MethodGroup.GetBehaviours_1_T1
            def __call__(self) -> Array_1[GetBehaviours_1_T]:...

        def __call__(self, fullPathHash: int, layerIndex: int) -> Array_1[StateMachineBehaviour]:...

    # Skipped GetBool due to it being static, abstract and generic.

    GetBool : GetBool_MethodGroup
    class GetBool_MethodGroup:
        @typing.overload
        def __call__(self, id: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped GetCurrentAnimatorClipInfo due to it being static, abstract and generic.

    GetCurrentAnimatorClipInfo : GetCurrentAnimatorClipInfo_MethodGroup
    class GetCurrentAnimatorClipInfo_MethodGroup:
        @typing.overload
        def __call__(self, layerIndex: int) -> Array_1[AnimatorClipInfo]:...
        @typing.overload
        def __call__(self, layerIndex: int, clips: List_1[AnimatorClipInfo]) -> None:...

    # Skipped GetFloat due to it being static, abstract and generic.

    GetFloat : GetFloat_MethodGroup
    class GetFloat_MethodGroup:
        @typing.overload
        def __call__(self, id: int) -> float:...
        @typing.overload
        def __call__(self, name: str) -> float:...

    # Skipped GetInteger due to it being static, abstract and generic.

    GetInteger : GetInteger_MethodGroup
    class GetInteger_MethodGroup:
        @typing.overload
        def __call__(self, id: int) -> int:...
        @typing.overload
        def __call__(self, name: str) -> int:...

    # Skipped GetNextAnimatorClipInfo due to it being static, abstract and generic.

    GetNextAnimatorClipInfo : GetNextAnimatorClipInfo_MethodGroup
    class GetNextAnimatorClipInfo_MethodGroup:
        @typing.overload
        def __call__(self, layerIndex: int) -> Array_1[AnimatorClipInfo]:...
        @typing.overload
        def __call__(self, layerIndex: int, clips: List_1[AnimatorClipInfo]) -> None:...

    # Skipped GetQuaternion due to it being static, abstract and generic.

    GetQuaternion : GetQuaternion_MethodGroup
    class GetQuaternion_MethodGroup:
        @typing.overload
        def __call__(self, id: int) -> Quaternion:...
        @typing.overload
        def __call__(self, name: str) -> Quaternion:...

    # Skipped GetVector due to it being static, abstract and generic.

    GetVector : GetVector_MethodGroup
    class GetVector_MethodGroup:
        @typing.overload
        def __call__(self, id: int) -> Vector3:...
        @typing.overload
        def __call__(self, name: str) -> Vector3:...

    # Skipped InterruptMatchTarget due to it being static, abstract and generic.

    InterruptMatchTarget : InterruptMatchTarget_MethodGroup
    class InterruptMatchTarget_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, completeMatch: bool) -> None:...

    # Skipped IsParameterControlledByCurve due to it being static, abstract and generic.

    IsParameterControlledByCurve : IsParameterControlledByCurve_MethodGroup
    class IsParameterControlledByCurve_MethodGroup:
        @typing.overload
        def __call__(self, id: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped MatchTarget due to it being static, abstract and generic.

    MatchTarget : MatchTarget_MethodGroup
    class MatchTarget_MethodGroup:
        @typing.overload
        def __call__(self, matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: AvatarTarget, weightMask: MatchTargetWeightMask, startNormalizedTime: float) -> None:...
        @typing.overload
        def __call__(self, matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: AvatarTarget, weightMask: MatchTargetWeightMask, startNormalizedTime: float, targetNormalizedTime: float) -> None:...
        @typing.overload
        def __call__(self, matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: AvatarTarget, weightMask: MatchTargetWeightMask, startNormalizedTime: float, targetNormalizedTime: float, completeMatch: bool) -> None:...

    # Skipped Play due to it being static, abstract and generic.

    Play : Play_MethodGroup
    class Play_MethodGroup:
        @typing.overload
        def __call__(self, stateNameHash: int) -> None:...
        @typing.overload
        def __call__(self, stateName: str) -> None:...
        @typing.overload
        def __call__(self, stateNameHash: int, layer: int) -> None:...
        @typing.overload
        def __call__(self, stateName: str, layer: int) -> None:...
        @typing.overload
        def __call__(self, stateNameHash: int, layer: int, normalizedTime: float) -> None:...
        @typing.overload
        def __call__(self, stateName: str, layer: int, normalizedTime: float) -> None:...

    # Skipped PlayInFixedTime due to it being static, abstract and generic.

    PlayInFixedTime : PlayInFixedTime_MethodGroup
    class PlayInFixedTime_MethodGroup:
        @typing.overload
        def __call__(self, stateNameHash: int) -> None:...
        @typing.overload
        def __call__(self, stateName: str) -> None:...
        @typing.overload
        def __call__(self, stateNameHash: int, layer: int) -> None:...
        @typing.overload
        def __call__(self, stateName: str, layer: int) -> None:...
        @typing.overload
        def __call__(self, stateNameHash: int, layer: int, fixedTime: float) -> None:...
        @typing.overload
        def __call__(self, stateName: str, layer: int, fixedTime: float) -> None:...

    # Skipped ResetTrigger due to it being static, abstract and generic.

    ResetTrigger : ResetTrigger_MethodGroup
    class ResetTrigger_MethodGroup:
        @typing.overload
        def __call__(self, id: int) -> None:...
        @typing.overload
        def __call__(self, name: str) -> None:...

    # Skipped SetBool due to it being static, abstract and generic.

    SetBool : SetBool_MethodGroup
    class SetBool_MethodGroup:
        @typing.overload
        def __call__(self, id: int, value: bool) -> None:...
        @typing.overload
        def __call__(self, name: str, value: bool) -> None:...

    # Skipped SetFloat due to it being static, abstract and generic.

    SetFloat : SetFloat_MethodGroup
    class SetFloat_MethodGroup:
        @typing.overload
        def __call__(self, id: int, value: float) -> None:...
        @typing.overload
        def __call__(self, name: str, value: float) -> None:...
        @typing.overload
        def __call__(self, id: int, value: float, dampTime: float, deltaTime: float) -> None:...
        @typing.overload
        def __call__(self, name: str, value: float, dampTime: float, deltaTime: float) -> None:...

    # Skipped SetInteger due to it being static, abstract and generic.

    SetInteger : SetInteger_MethodGroup
    class SetInteger_MethodGroup:
        @typing.overload
        def __call__(self, id: int, value: int) -> None:...
        @typing.overload
        def __call__(self, name: str, value: int) -> None:...

    # Skipped SetLookAtWeight due to it being static, abstract and generic.

    SetLookAtWeight : SetLookAtWeight_MethodGroup
    class SetLookAtWeight_MethodGroup:
        @typing.overload
        def __call__(self, weight: float) -> None:...
        @typing.overload
        def __call__(self, weight: float, bodyWeight: float) -> None:...
        @typing.overload
        def __call__(self, weight: float, bodyWeight: float, headWeight: float) -> None:...
        @typing.overload
        def __call__(self, weight: float, bodyWeight: float, headWeight: float, eyesWeight: float) -> None:...
        @typing.overload
        def __call__(self, weight: float, bodyWeight: float, headWeight: float, eyesWeight: float, clampWeight: float) -> None:...

    # Skipped SetQuaternion due to it being static, abstract and generic.

    SetQuaternion : SetQuaternion_MethodGroup
    class SetQuaternion_MethodGroup:
        @typing.overload
        def __call__(self, id: int, value: Quaternion) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Quaternion) -> None:...

    # Skipped SetTrigger due to it being static, abstract and generic.

    SetTrigger : SetTrigger_MethodGroup
    class SetTrigger_MethodGroup:
        @typing.overload
        def __call__(self, id: int) -> None:...
        @typing.overload
        def __call__(self, name: str) -> None:...

    # Skipped SetVector due to it being static, abstract and generic.

    SetVector : SetVector_MethodGroup
    class SetVector_MethodGroup:
        @typing.overload
        def __call__(self, id: int, value: Vector3) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Vector3) -> None:...



class AnimatorClipInfo:
    @property
    def clip(self) -> AnimationClip: ...
    @property
    def weight(self) -> float: ...


class AnimatorControllerParameter:
    def __init__(self) -> None: ...
    @property
    def defaultBool(self) -> bool: ...
    @defaultBool.setter
    def defaultBool(self, value: bool) -> bool: ...
    @property
    def defaultFloat(self) -> float: ...
    @defaultFloat.setter
    def defaultFloat(self, value: float) -> float: ...
    @property
    def defaultInt(self) -> int: ...
    @defaultInt.setter
    def defaultInt(self, value: int) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def nameHash(self) -> int: ...
    @property
    def type(self) -> AnimatorControllerParameterType: ...
    @type.setter
    def type(self, value: AnimatorControllerParameterType) -> AnimatorControllerParameterType: ...
    def Equals(self, o: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class AnimatorControllerParameterType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Float : AnimatorControllerParameterType # 1
    Int : AnimatorControllerParameterType # 3
    Bool : AnimatorControllerParameterType # 4
    Trigger : AnimatorControllerParameterType # 9


class AnimatorCullingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    AlwaysAnimate : AnimatorCullingMode # 0
    CullUpdateTransforms : AnimatorCullingMode # 1
    BasedOnRenderers : AnimatorCullingMode # 1
    CullCompletely : AnimatorCullingMode # 2


class AnimatorOverrideController(RuntimeAnimatorController):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, controller: RuntimeAnimatorController) -> None: ...
    @property
    def animationClips(self) -> Array_1[AnimationClip]: ...
    @property
    def clips(self) -> Array_1[AnimationClipPair]: ...
    @clips.setter
    def clips(self, value: Array_1[AnimationClipPair]) -> Array_1[AnimationClipPair]: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def Item(self) -> AnimationClip: ...
    @Item.setter
    def Item(self, value: AnimationClip) -> AnimationClip: ...
    @property
    def Item(self) -> AnimationClip: ...
    @Item.setter
    def Item(self, value: AnimationClip) -> AnimationClip: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def overridesCount(self) -> int: ...
    @property
    def runtimeAnimatorController(self) -> RuntimeAnimatorController: ...
    @runtimeAnimatorController.setter
    def runtimeAnimatorController(self, value: RuntimeAnimatorController) -> RuntimeAnimatorController: ...
    def ApplyOverrides(self, overrides: IList_1[KeyValuePair_2[AnimationClip, AnimationClip]]) -> None: ...
    def GetOverrides(self, overrides: List_1[KeyValuePair_2[AnimationClip, AnimationClip]]) -> None: ...


class AnimatorRecorderMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Offline : AnimatorRecorderMode # 0
    Playback : AnimatorRecorderMode # 1
    Record : AnimatorRecorderMode # 2


class AnimatorStateInfo:
    @property
    def fullPathHash(self) -> int: ...
    @property
    def length(self) -> float: ...
    @property
    def loop(self) -> bool: ...
    @property
    def nameHash(self) -> int: ...
    @property
    def normalizedTime(self) -> float: ...
    @property
    def shortNameHash(self) -> int: ...
    @property
    def speed(self) -> float: ...
    @property
    def speedMultiplier(self) -> float: ...
    @property
    def tagHash(self) -> int: ...
    def IsName(self, name: str) -> bool: ...
    def IsTag(self, tag: str) -> bool: ...


class AnimatorTransitionInfo:
    @property
    def anyState(self) -> bool: ...
    @property
    def duration(self) -> float: ...
    @property
    def durationUnit(self) -> DurationUnit: ...
    @property
    def fullPathHash(self) -> int: ...
    @property
    def nameHash(self) -> int: ...
    @property
    def normalizedTime(self) -> float: ...
    @property
    def userNameHash(self) -> int: ...
    def IsName(self, name: str) -> bool: ...
    def IsUserName(self, name: str) -> bool: ...


class AnimatorUpdateMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Normal : AnimatorUpdateMode # 0
    AnimatePhysics : AnimatorUpdateMode # 1
    UnscaledTime : AnimatorUpdateMode # 2


class AnimatorUtility:
    def __init__(self) -> None: ...
    @staticmethod
    def DeoptimizeTransformHierarchy(go: GameObject) -> None: ...
    @staticmethod
    def OptimizeTransformHierarchy(go: GameObject, exposedTransforms: Array_1[str]) -> None: ...


class AnisotropicFiltering(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Disable : AnisotropicFiltering # 0
    Enable : AnisotropicFiltering # 1
    ForceEnable : AnisotropicFiltering # 2


class Application:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def absoluteURL(cls) -> str: ...
    @classmethod
    @property
    def backgroundLoadingPriority(cls) -> ThreadPriority: ...
    @classmethod
    @backgroundLoadingPriority.setter
    def backgroundLoadingPriority(cls, value: ThreadPriority) -> ThreadPriority: ...
    @classmethod
    @property
    def buildGUID(cls) -> str: ...
    @classmethod
    @property
    def cloudProjectId(cls) -> str: ...
    @classmethod
    @property
    def companyName(cls) -> str: ...
    @classmethod
    @property
    def consoleLogPath(cls) -> str: ...
    @classmethod
    @property
    def dataPath(cls) -> str: ...
    @classmethod
    @property
    def exitCancellationToken(cls) -> CancellationToken: ...
    @classmethod
    @property
    def genuine(cls) -> bool: ...
    @classmethod
    @property
    def genuineCheckAvailable(cls) -> bool: ...
    @classmethod
    @property
    def identifier(cls) -> str: ...
    @classmethod
    @property
    def installerName(cls) -> str: ...
    @classmethod
    @property
    def installMode(cls) -> ApplicationInstallMode: ...
    @classmethod
    @property
    def internetReachability(cls) -> NetworkReachability: ...
    @classmethod
    @property
    def isBatchMode(cls) -> bool: ...
    @classmethod
    @property
    def isConsolePlatform(cls) -> bool: ...
    @classmethod
    @property
    def isEditor(cls) -> bool: ...
    @classmethod
    @property
    def isFocused(cls) -> bool: ...
    @classmethod
    @property
    def isLoadingLevel(cls) -> bool: ...
    @classmethod
    @property
    def isMobilePlatform(cls) -> bool: ...
    @classmethod
    @property
    def isPlayer(cls) -> bool: ...
    @classmethod
    @property
    def isPlaying(cls) -> bool: ...
    @classmethod
    @property
    def isShowingSplashScreen(cls) -> bool: ...
    @classmethod
    @property
    def levelCount(cls) -> int: ...
    @classmethod
    @property
    def loadedLevel(cls) -> int: ...
    @classmethod
    @property
    def loadedLevelName(cls) -> str: ...
    @classmethod
    @property
    def persistentDataPath(cls) -> str: ...
    @classmethod
    @property
    def platform(cls) -> RuntimePlatform: ...
    @classmethod
    @property
    def productName(cls) -> str: ...
    @classmethod
    @property
    def runInBackground(cls) -> bool: ...
    @classmethod
    @runInBackground.setter
    def runInBackground(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def sandboxType(cls) -> ApplicationSandboxType: ...
    @classmethod
    @property
    def stackTraceLogType(cls) -> StackTraceLogType: ...
    @classmethod
    @stackTraceLogType.setter
    def stackTraceLogType(cls, value: StackTraceLogType) -> StackTraceLogType: ...
    @classmethod
    @property
    def streamedBytes(cls) -> int: ...
    @classmethod
    @property
    def streamingAssetsPath(cls) -> str: ...
    @classmethod
    @property
    def systemLanguage(cls) -> SystemLanguage: ...
    @classmethod
    @property
    def targetFrameRate(cls) -> int: ...
    @classmethod
    @targetFrameRate.setter
    def targetFrameRate(cls, value: int) -> int: ...
    @classmethod
    @property
    def temporaryCachePath(cls) -> str: ...
    @classmethod
    @property
    def unityVersion(cls) -> str: ...
    @classmethod
    @property
    def version(cls) -> str: ...
    @classmethod
    @property
    def webSecurityEnabled(cls) -> bool: ...
    @staticmethod
    def CancelQuit() -> None: ...
    @staticmethod
    def DontDestroyOnLoad(o: Object) -> None: ...
    @staticmethod
    def ExternalCall(functionName: str, args: Array_1[typing.Any]) -> None: ...
    @staticmethod
    def ExternalEval(script: str) -> None: ...
    @staticmethod
    def ForceCrash(mode: int) -> None: ...
    @staticmethod
    def GetBuildTags() -> Array_1[str]: ...
    @staticmethod
    def GetStackTraceLogType(logType: LogType) -> StackTraceLogType: ...
    @staticmethod
    def HasProLicense() -> bool: ...
    @staticmethod
    def HasUserAuthorization(mode: UserAuthorization) -> bool: ...
    @staticmethod
    def IsPlaying(obj: Object) -> bool: ...
    @staticmethod
    def OpenURL(url: str) -> None: ...
    @staticmethod
    def RegisterLogCallback(handler: Application.LogCallback) -> None: ...
    @staticmethod
    def RegisterLogCallbackThreaded(handler: Application.LogCallback) -> None: ...
    @staticmethod
    def RequestAdvertisingIdentifierAsync(delegateMethod: Application.AdvertisingIdentifierCallback) -> bool: ...
    @staticmethod
    def RequestUserAuthorization(mode: UserAuthorization) -> AsyncOperation: ...
    @staticmethod
    def SetBuildTags(buildTags: Array_1[str]) -> None: ...
    @staticmethod
    def SetStackTraceLogType(logType: LogType, stackTraceType: StackTraceLogType) -> None: ...
    @staticmethod
    def Unload() -> None: ...
    # Skipped CanStreamedLevelBeLoaded due to it being static, abstract and generic.

    CanStreamedLevelBeLoaded : CanStreamedLevelBeLoaded_MethodGroup
    class CanStreamedLevelBeLoaded_MethodGroup:
        @typing.overload
        def __call__(self, levelIndex: int) -> bool:...
        @typing.overload
        def __call__(self, levelName: str) -> bool:...

    # Skipped CaptureScreenshot due to it being static, abstract and generic.

    CaptureScreenshot : CaptureScreenshot_MethodGroup
    class CaptureScreenshot_MethodGroup:
        @typing.overload
        def __call__(self, filename: str) -> None:...
        @typing.overload
        def __call__(self, filename: str, superSize: int) -> None:...

    # Skipped GetStreamProgressForLevel due to it being static, abstract and generic.

    GetStreamProgressForLevel : GetStreamProgressForLevel_MethodGroup
    class GetStreamProgressForLevel_MethodGroup:
        @typing.overload
        def __call__(self, levelIndex: int) -> float:...
        @typing.overload
        def __call__(self, levelName: str) -> float:...

    # Skipped LoadLevel due to it being static, abstract and generic.

    LoadLevel : LoadLevel_MethodGroup
    class LoadLevel_MethodGroup:
        @typing.overload
        def __call__(self, index: int) -> None:...
        @typing.overload
        def __call__(self, name: str) -> None:...

    # Skipped LoadLevelAdditive due to it being static, abstract and generic.

    LoadLevelAdditive : LoadLevelAdditive_MethodGroup
    class LoadLevelAdditive_MethodGroup:
        @typing.overload
        def __call__(self, index: int) -> None:...
        @typing.overload
        def __call__(self, name: str) -> None:...

    # Skipped LoadLevelAdditiveAsync due to it being static, abstract and generic.

    LoadLevelAdditiveAsync : LoadLevelAdditiveAsync_MethodGroup
    class LoadLevelAdditiveAsync_MethodGroup:
        @typing.overload
        def __call__(self, index: int) -> AsyncOperation:...
        @typing.overload
        def __call__(self, levelName: str) -> AsyncOperation:...

    # Skipped LoadLevelAsync due to it being static, abstract and generic.

    LoadLevelAsync : LoadLevelAsync_MethodGroup
    class LoadLevelAsync_MethodGroup:
        @typing.overload
        def __call__(self, index: int) -> AsyncOperation:...
        @typing.overload
        def __call__(self, levelName: str) -> AsyncOperation:...

    # Skipped Quit due to it being static, abstract and generic.

    Quit : Quit_MethodGroup
    class Quit_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, exitCode: int) -> None:...

    # Skipped UnloadLevel due to it being static, abstract and generic.

    UnloadLevel : UnloadLevel_MethodGroup
    class UnloadLevel_MethodGroup:
        @typing.overload
        def __call__(self, index: int) -> bool:...
        @typing.overload
        def __call__(self, scenePath: str) -> bool:...


    class AdvertisingIdentifierCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, advertisingId: str, trackingEnabled: bool, errorMsg: str, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, advertisingId: str, trackingEnabled: bool, errorMsg: str) -> None: ...


    class LogCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, condition: str, stackTrace: str, type: LogType, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, condition: str, stackTrace: str, type: LogType) -> None: ...


    class LowMemoryCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self) -> None: ...


    class MemoryUsageChangedCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, usage: clr.Reference[ApplicationMemoryUsageChange], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, usage: clr.Reference[ApplicationMemoryUsageChange], result: IAsyncResult) -> None: ...
        def Invoke(self, usage: clr.Reference[ApplicationMemoryUsageChange]) -> None: ...



class ApplicationInstallMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : ApplicationInstallMode # 0
    Store : ApplicationInstallMode # 1
    DeveloperBuild : ApplicationInstallMode # 2
    Adhoc : ApplicationInstallMode # 3
    Enterprise : ApplicationInstallMode # 4
    Editor : ApplicationInstallMode # 5


class ApplicationMemoryUsage(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : ApplicationMemoryUsage # 0
    Low : ApplicationMemoryUsage # 1
    Medium : ApplicationMemoryUsage # 2
    High : ApplicationMemoryUsage # 3
    Critical : ApplicationMemoryUsage # 4


class ApplicationMemoryUsageChange:
    def __init__(self, usage: ApplicationMemoryUsage) -> None: ...
    @property
    def memoryUsage(self) -> ApplicationMemoryUsage: ...
    @memoryUsage.setter
    def memoryUsage(self, value: ApplicationMemoryUsage) -> ApplicationMemoryUsage: ...


class ApplicationSandboxType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : ApplicationSandboxType # 0
    NotSandboxed : ApplicationSandboxType # 1
    Sandboxed : ApplicationSandboxType # 2
    SandboxBroken : ApplicationSandboxType # 3


class AreaEffector2D(Effector2D):
    def __init__(self) -> None: ...
    @property
    def angularDrag(self) -> float: ...
    @angularDrag.setter
    def angularDrag(self, value: float) -> float: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def colliderMask(self) -> int: ...
    @colliderMask.setter
    def colliderMask(self, value: int) -> int: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def drag(self) -> float: ...
    @drag.setter
    def drag(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def forceAngle(self) -> float: ...
    @forceAngle.setter
    def forceAngle(self, value: float) -> float: ...
    @property
    def forceDirection(self) -> float: ...
    @forceDirection.setter
    def forceDirection(self, value: float) -> float: ...
    @property
    def forceMagnitude(self) -> float: ...
    @forceMagnitude.setter
    def forceMagnitude(self, value: float) -> float: ...
    @property
    def forceTarget(self) -> EffectorSelection2D: ...
    @forceTarget.setter
    def forceTarget(self, value: EffectorSelection2D) -> EffectorSelection2D: ...
    @property
    def forceVariation(self) -> float: ...
    @forceVariation.setter
    def forceVariation(self, value: float) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useColliderMask(self) -> bool: ...
    @useColliderMask.setter
    def useColliderMask(self, value: bool) -> bool: ...
    @property
    def useGlobalAngle(self) -> bool: ...
    @useGlobalAngle.setter
    def useGlobalAngle(self, value: bool) -> bool: ...


class ArmDof(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    ShoulderDownUp : ArmDof # 0
    ShoulderFrontBack : ArmDof # 1
    ArmDownUp : ArmDof # 2
    ArmFrontBack : ArmDof # 3
    ArmRollInOut : ArmDof # 4
    ForeArmCloseOpen : ArmDof # 5
    ForeArmRollInOut : ArmDof # 6
    HandDownUp : ArmDof # 7
    HandInOut : ArmDof # 8
    LastArmDof : ArmDof # 9


class ArticulationBody(Behaviour):
    def __init__(self) -> None: ...
    @property
    def anchorPosition(self) -> Vector3: ...
    @anchorPosition.setter
    def anchorPosition(self, value: Vector3) -> Vector3: ...
    @property
    def anchorRotation(self) -> Quaternion: ...
    @anchorRotation.setter
    def anchorRotation(self, value: Quaternion) -> Quaternion: ...
    @property
    def angularDamping(self) -> float: ...
    @angularDamping.setter
    def angularDamping(self, value: float) -> float: ...
    @property
    def angularVelocity(self) -> Vector3: ...
    @angularVelocity.setter
    def angularVelocity(self, value: Vector3) -> Vector3: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def automaticCenterOfMass(self) -> bool: ...
    @automaticCenterOfMass.setter
    def automaticCenterOfMass(self, value: bool) -> bool: ...
    @property
    def automaticInertiaTensor(self) -> bool: ...
    @automaticInertiaTensor.setter
    def automaticInertiaTensor(self, value: bool) -> bool: ...
    @property
    def camera(self) -> Component: ...
    @property
    def centerOfMass(self) -> Vector3: ...
    @centerOfMass.setter
    def centerOfMass(self, value: Vector3) -> Vector3: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def collisionDetectionMode(self) -> CollisionDetectionMode: ...
    @collisionDetectionMode.setter
    def collisionDetectionMode(self, value: CollisionDetectionMode) -> CollisionDetectionMode: ...
    @property
    def computeParentAnchor(self) -> bool: ...
    @computeParentAnchor.setter
    def computeParentAnchor(self, value: bool) -> bool: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def dofCount(self) -> int: ...
    @property
    def driveForce(self) -> ArticulationReducedSpace: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def immovable(self) -> bool: ...
    @immovable.setter
    def immovable(self, value: bool) -> bool: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def index(self) -> int: ...
    @property
    def inertiaTensor(self) -> Vector3: ...
    @inertiaTensor.setter
    def inertiaTensor(self, value: Vector3) -> Vector3: ...
    @property
    def inertiaTensorRotation(self) -> Quaternion: ...
    @inertiaTensorRotation.setter
    def inertiaTensorRotation(self, value: Quaternion) -> Quaternion: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def isRoot(self) -> bool: ...
    @property
    def jointAcceleration(self) -> ArticulationReducedSpace: ...
    @jointAcceleration.setter
    def jointAcceleration(self, value: ArticulationReducedSpace) -> ArticulationReducedSpace: ...
    @property
    def jointForce(self) -> ArticulationReducedSpace: ...
    @jointForce.setter
    def jointForce(self, value: ArticulationReducedSpace) -> ArticulationReducedSpace: ...
    @property
    def jointFriction(self) -> float: ...
    @jointFriction.setter
    def jointFriction(self, value: float) -> float: ...
    @property
    def jointPosition(self) -> ArticulationReducedSpace: ...
    @jointPosition.setter
    def jointPosition(self, value: ArticulationReducedSpace) -> ArticulationReducedSpace: ...
    @property
    def jointType(self) -> ArticulationJointType: ...
    @jointType.setter
    def jointType(self, value: ArticulationJointType) -> ArticulationJointType: ...
    @property
    def jointVelocity(self) -> ArticulationReducedSpace: ...
    @jointVelocity.setter
    def jointVelocity(self, value: ArticulationReducedSpace) -> ArticulationReducedSpace: ...
    @property
    def light(self) -> Component: ...
    @property
    def linearDamping(self) -> float: ...
    @linearDamping.setter
    def linearDamping(self, value: float) -> float: ...
    @property
    def linearLockX(self) -> ArticulationDofLock: ...
    @linearLockX.setter
    def linearLockX(self, value: ArticulationDofLock) -> ArticulationDofLock: ...
    @property
    def linearLockY(self) -> ArticulationDofLock: ...
    @linearLockY.setter
    def linearLockY(self, value: ArticulationDofLock) -> ArticulationDofLock: ...
    @property
    def linearLockZ(self) -> ArticulationDofLock: ...
    @linearLockZ.setter
    def linearLockZ(self, value: ArticulationDofLock) -> ArticulationDofLock: ...
    @property
    def mass(self) -> float: ...
    @mass.setter
    def mass(self, value: float) -> float: ...
    @property
    def matchAnchors(self) -> bool: ...
    @matchAnchors.setter
    def matchAnchors(self, value: bool) -> bool: ...
    @property
    def maxAngularVelocity(self) -> float: ...
    @maxAngularVelocity.setter
    def maxAngularVelocity(self, value: float) -> float: ...
    @property
    def maxDepenetrationVelocity(self) -> float: ...
    @maxDepenetrationVelocity.setter
    def maxDepenetrationVelocity(self, value: float) -> float: ...
    @property
    def maxJointVelocity(self) -> float: ...
    @maxJointVelocity.setter
    def maxJointVelocity(self, value: float) -> float: ...
    @property
    def maxLinearVelocity(self) -> float: ...
    @maxLinearVelocity.setter
    def maxLinearVelocity(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def parentAnchorPosition(self) -> Vector3: ...
    @parentAnchorPosition.setter
    def parentAnchorPosition(self, value: Vector3) -> Vector3: ...
    @property
    def parentAnchorRotation(self) -> Quaternion: ...
    @parentAnchorRotation.setter
    def parentAnchorRotation(self, value: Quaternion) -> Quaternion: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def sleepThreshold(self) -> float: ...
    @sleepThreshold.setter
    def sleepThreshold(self, value: float) -> float: ...
    @property
    def solverIterations(self) -> int: ...
    @solverIterations.setter
    def solverIterations(self, value: int) -> int: ...
    @property
    def solverVelocityIterations(self) -> int: ...
    @solverVelocityIterations.setter
    def solverVelocityIterations(self, value: int) -> int: ...
    @property
    def swingYLock(self) -> ArticulationDofLock: ...
    @swingYLock.setter
    def swingYLock(self, value: ArticulationDofLock) -> ArticulationDofLock: ...
    @property
    def swingZLock(self) -> ArticulationDofLock: ...
    @swingZLock.setter
    def swingZLock(self, value: ArticulationDofLock) -> ArticulationDofLock: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def twistLock(self) -> ArticulationDofLock: ...
    @twistLock.setter
    def twistLock(self, value: ArticulationDofLock) -> ArticulationDofLock: ...
    @property
    def useGravity(self) -> bool: ...
    @useGravity.setter
    def useGravity(self, value: bool) -> bool: ...
    @property
    def velocity(self) -> Vector3: ...
    @velocity.setter
    def velocity(self, value: Vector3) -> Vector3: ...
    @property
    def worldCenterOfMass(self) -> Vector3: ...
    @property
    def xDrive(self) -> ArticulationDrive: ...
    @xDrive.setter
    def xDrive(self, value: ArticulationDrive) -> ArticulationDrive: ...
    @property
    def yDrive(self) -> ArticulationDrive: ...
    @yDrive.setter
    def yDrive(self, value: ArticulationDrive) -> ArticulationDrive: ...
    @property
    def zDrive(self) -> ArticulationDrive: ...
    @zDrive.setter
    def zDrive(self, value: ArticulationDrive) -> ArticulationDrive: ...
    def GetClosestPoint(self, point: Vector3) -> Vector3: ...
    def GetDenseJacobian(self, jacobian: clr.Reference[ArticulationJacobian]) -> int: ...
    def GetDofStartIndices(self, dofStartIndices: List_1[int]) -> int: ...
    def GetDriveForces(self, forces: List_1[float]) -> int: ...
    def GetDriveTargets(self, targets: List_1[float]) -> int: ...
    def GetDriveTargetVelocities(self, targetVelocities: List_1[float]) -> int: ...
    def GetJointAccelerations(self, accelerations: List_1[float]) -> int: ...
    def GetJointCoriolisCentrifugalForces(self, forces: List_1[float]) -> int: ...
    def GetJointExternalForces(self, forces: List_1[float], step: float) -> int: ...
    def GetJointForces(self, forces: List_1[float]) -> int: ...
    def GetJointForcesForAcceleration(self, acceleration: ArticulationReducedSpace) -> ArticulationReducedSpace: ...
    def GetJointGravityForces(self, forces: List_1[float]) -> int: ...
    def GetJointPositions(self, positions: List_1[float]) -> int: ...
    def GetJointVelocities(self, velocities: List_1[float]) -> int: ...
    def GetPointVelocity(self, worldPoint: Vector3) -> Vector3: ...
    def GetRelativePointVelocity(self, relativePoint: Vector3) -> Vector3: ...
    def IsSleeping(self) -> bool: ...
    def ResetCenterOfMass(self) -> None: ...
    def ResetInertiaTensor(self) -> None: ...
    def SetDriveDamping(self, axis: ArticulationDriveAxis, value: float) -> None: ...
    def SetDriveForceLimit(self, axis: ArticulationDriveAxis, value: float) -> None: ...
    def SetDriveLimits(self, axis: ArticulationDriveAxis, lower: float, upper: float) -> None: ...
    def SetDriveStiffness(self, axis: ArticulationDriveAxis, value: float) -> None: ...
    def SetDriveTarget(self, axis: ArticulationDriveAxis, value: float) -> None: ...
    def SetDriveTargets(self, targets: List_1[float]) -> None: ...
    def SetDriveTargetVelocities(self, targetVelocities: List_1[float]) -> None: ...
    def SetDriveTargetVelocity(self, axis: ArticulationDriveAxis, value: float) -> None: ...
    def SetJointAccelerations(self, accelerations: List_1[float]) -> None: ...
    def SetJointForces(self, forces: List_1[float]) -> None: ...
    def SetJointPositions(self, positions: List_1[float]) -> None: ...
    def SetJointVelocities(self, velocities: List_1[float]) -> None: ...
    def Sleep(self) -> None: ...
    def SnapAnchorToClosestContact(self) -> None: ...
    def TeleportRoot(self, position: Vector3, rotation: Quaternion) -> None: ...
    def WakeUp(self) -> None: ...
    # Skipped AddForce due to it being static, abstract and generic.

    AddForce : AddForce_MethodGroup
    class AddForce_MethodGroup:
        @typing.overload
        def __call__(self, force: Vector3) -> None:...
        @typing.overload
        def __call__(self, force: Vector3, mode: ForceMode) -> None:...

    # Skipped AddForceAtPosition due to it being static, abstract and generic.

    AddForceAtPosition : AddForceAtPosition_MethodGroup
    class AddForceAtPosition_MethodGroup:
        @typing.overload
        def __call__(self, force: Vector3, position: Vector3) -> None:...
        @typing.overload
        def __call__(self, force: Vector3, position: Vector3, mode: ForceMode) -> None:...

    # Skipped AddRelativeForce due to it being static, abstract and generic.

    AddRelativeForce : AddRelativeForce_MethodGroup
    class AddRelativeForce_MethodGroup:
        @typing.overload
        def __call__(self, force: Vector3) -> None:...
        @typing.overload
        def __call__(self, force: Vector3, mode: ForceMode) -> None:...

    # Skipped AddRelativeTorque due to it being static, abstract and generic.

    AddRelativeTorque : AddRelativeTorque_MethodGroup
    class AddRelativeTorque_MethodGroup:
        @typing.overload
        def __call__(self, torque: Vector3) -> None:...
        @typing.overload
        def __call__(self, torque: Vector3, mode: ForceMode) -> None:...

    # Skipped AddTorque due to it being static, abstract and generic.

    AddTorque : AddTorque_MethodGroup
    class AddTorque_MethodGroup:
        @typing.overload
        def __call__(self, torque: Vector3) -> None:...
        @typing.overload
        def __call__(self, torque: Vector3, mode: ForceMode) -> None:...

    # Skipped GetAccumulatedForce due to it being static, abstract and generic.

    GetAccumulatedForce : GetAccumulatedForce_MethodGroup
    class GetAccumulatedForce_MethodGroup:
        @typing.overload
        def __call__(self) -> Vector3:...
        @typing.overload
        def __call__(self, step: float) -> Vector3:...

    # Skipped GetAccumulatedTorque due to it being static, abstract and generic.

    GetAccumulatedTorque : GetAccumulatedTorque_MethodGroup
    class GetAccumulatedTorque_MethodGroup:
        @typing.overload
        def __call__(self) -> Vector3:...
        @typing.overload
        def __call__(self, step: float) -> Vector3:...



class ArticulationDofLock(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    LockedMotion : ArticulationDofLock # 0
    LimitedMotion : ArticulationDofLock # 1
    FreeMotion : ArticulationDofLock # 2


class ArticulationDrive:
    damping : float
    driveType : ArticulationDriveType
    forceLimit : float
    lowerLimit : float
    stiffness : float
    target : float
    targetVelocity : float
    upperLimit : float


class ArticulationDriveAxis(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    X : ArticulationDriveAxis # 0
    Y : ArticulationDriveAxis # 1
    Z : ArticulationDriveAxis # 2


class ArticulationDriveType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Force : ArticulationDriveType # 0
    Acceleration : ArticulationDriveType # 1
    Target : ArticulationDriveType # 2
    Velocity : ArticulationDriveType # 3


class ArticulationJacobian:
    def __init__(self, rows: int, cols: int) -> None: ...
    @property
    def columns(self) -> int: ...
    @columns.setter
    def columns(self, value: int) -> int: ...
    @property
    def elements(self) -> List_1[float]: ...
    @elements.setter
    def elements(self, value: List_1[float]) -> List_1[float]: ...
    @property
    def Item(self) -> float: ...
    @Item.setter
    def Item(self, value: float) -> float: ...
    @property
    def rows(self) -> int: ...
    @rows.setter
    def rows(self, value: int) -> int: ...


class ArticulationJointType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    FixedJoint : ArticulationJointType # 0
    PrismaticJoint : ArticulationJointType # 1
    RevoluteJoint : ArticulationJointType # 2
    SphericalJoint : ArticulationJointType # 3


class ArticulationReducedSpace:
    @typing.overload
    def __init__(self, a: float) -> None: ...
    @typing.overload
    def __init__(self, a: float, b: float) -> None: ...
    @typing.overload
    def __init__(self, a: float, b: float, c: float) -> None: ...
    dofCount : int
    @property
    def Item(self) -> float: ...
    @Item.setter
    def Item(self, value: float) -> float: ...

    class <x>e__FixedBuffer:
        FixedElementField : float



class AssemblyIsEditorAssembly(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class AssetBundle(Object):
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def isStreamedSceneAssetBundle(self) -> bool: ...
    @property
    def mainAsset(self) -> Object: ...
    @classmethod
    @property
    def memoryBudgetKB(cls) -> int: ...
    @classmethod
    @memoryBudgetKB.setter
    def memoryBudgetKB(cls, value: int) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    def AllAssetNames(self) -> Array_1[str]: ...
    def Contains(self, name: str) -> bool: ...
    @staticmethod
    def CreateFromFile(path: str) -> AssetBundle: ...
    @staticmethod
    def CreateFromMemory(binary: Array_1[int]) -> AssetBundleCreateRequest: ...
    @staticmethod
    def CreateFromMemoryImmediate(binary: Array_1[int]) -> AssetBundle: ...
    def GetAllAssetNames(self) -> Array_1[str]: ...
    @staticmethod
    def GetAllLoadedAssetBundles() -> IEnumerable_1[AssetBundle]: ...
    def GetAllScenePaths(self) -> Array_1[str]: ...
    @staticmethod
    def RecompressAssetBundleAsync(inputPath: str, outputPath: str, method: BuildCompression, expectedCRC: int = ..., priority: ThreadPriority = ...) -> AssetBundleRecompressOperation: ...
    def Unload(self, unloadAllLoadedObjects: bool) -> None: ...
    @staticmethod
    def UnloadAllAssetBundles(unloadAllObjects: bool) -> None: ...
    def UnloadAsync(self, unloadAllLoadedObjects: bool) -> AssetBundleUnloadOperation: ...
    # Skipped Load due to it being static, abstract and generic.

    Load : Load_MethodGroup
    class Load_MethodGroup:
        def __getitem__(self, t:typing.Type[Load_1_T1]) -> Load_1[Load_1_T1]: ...

        Load_1_T1 = typing.TypeVar('Load_1_T1')
        class Load_1(typing.Generic[Load_1_T1]):
            Load_1_T = AssetBundle.Load_MethodGroup.Load_1_T1
            def __call__(self, name: str) -> Object:...

        def __call__(self, name: str) -> Object:...

    # Skipped LoadAll due to it being static, abstract and generic.

    LoadAll : LoadAll_MethodGroup
    class LoadAll_MethodGroup:
        def __getitem__(self, t:typing.Type[LoadAll_1_T1]) -> LoadAll_1[LoadAll_1_T1]: ...

        LoadAll_1_T1 = typing.TypeVar('LoadAll_1_T1')
        class LoadAll_1(typing.Generic[LoadAll_1_T1]):
            LoadAll_1_T = AssetBundle.LoadAll_MethodGroup.LoadAll_1_T1
            def __call__(self) -> Array_1[LoadAll_1_T]:...

        def __call__(self) -> Array_1[Object]:...

    # Skipped LoadAllAssets due to it being static, abstract and generic.

    LoadAllAssets : LoadAllAssets_MethodGroup
    class LoadAllAssets_MethodGroup:
        def __getitem__(self, t:typing.Type[LoadAllAssets_1_T1]) -> LoadAllAssets_1[LoadAllAssets_1_T1]: ...

        LoadAllAssets_1_T1 = typing.TypeVar('LoadAllAssets_1_T1')
        class LoadAllAssets_1(typing.Generic[LoadAllAssets_1_T1]):
            LoadAllAssets_1_T = AssetBundle.LoadAllAssets_MethodGroup.LoadAllAssets_1_T1
            def __call__(self) -> Array_1[LoadAllAssets_1_T]:...

        @typing.overload
        def __call__(self) -> Array_1[Object]:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> Array_1[Object]:...

    # Skipped LoadAllAssetsAsync due to it being static, abstract and generic.

    LoadAllAssetsAsync : LoadAllAssetsAsync_MethodGroup
    class LoadAllAssetsAsync_MethodGroup:
        def __getitem__(self, t:typing.Type[LoadAllAssetsAsync_1_T1]) -> LoadAllAssetsAsync_1[LoadAllAssetsAsync_1_T1]: ...

        LoadAllAssetsAsync_1_T1 = typing.TypeVar('LoadAllAssetsAsync_1_T1')
        class LoadAllAssetsAsync_1(typing.Generic[LoadAllAssetsAsync_1_T1]):
            LoadAllAssetsAsync_1_T = AssetBundle.LoadAllAssetsAsync_MethodGroup.LoadAllAssetsAsync_1_T1
            def __call__(self) -> AssetBundleRequest:...

        @typing.overload
        def __call__(self) -> AssetBundleRequest:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> AssetBundleRequest:...

    # Skipped LoadAsset due to it being static, abstract and generic.

    LoadAsset : LoadAsset_MethodGroup
    class LoadAsset_MethodGroup:
        def __getitem__(self, t:typing.Type[LoadAsset_1_T1]) -> LoadAsset_1[LoadAsset_1_T1]: ...

        LoadAsset_1_T1 = typing.TypeVar('LoadAsset_1_T1')
        class LoadAsset_1(typing.Generic[LoadAsset_1_T1]):
            LoadAsset_1_T = AssetBundle.LoadAsset_MethodGroup.LoadAsset_1_T1
            def __call__(self, name: str) -> LoadAsset_1_T:...

        @typing.overload
        def __call__(self, name: str) -> Object:...
        @typing.overload
        def __call__(self, name: str, type: typing.Type[typing.Any]) -> Object:...

    # Skipped LoadAssetAsync due to it being static, abstract and generic.

    LoadAssetAsync : LoadAssetAsync_MethodGroup
    class LoadAssetAsync_MethodGroup:
        def __getitem__(self, t:typing.Type[LoadAssetAsync_1_T1]) -> LoadAssetAsync_1[LoadAssetAsync_1_T1]: ...

        LoadAssetAsync_1_T1 = typing.TypeVar('LoadAssetAsync_1_T1')
        class LoadAssetAsync_1(typing.Generic[LoadAssetAsync_1_T1]):
            LoadAssetAsync_1_T = AssetBundle.LoadAssetAsync_MethodGroup.LoadAssetAsync_1_T1
            def __call__(self, name: str) -> AssetBundleRequest:...

        @typing.overload
        def __call__(self, name: str) -> AssetBundleRequest:...
        @typing.overload
        def __call__(self, name: str, type: typing.Type[typing.Any]) -> AssetBundleRequest:...

    # Skipped LoadAssetWithSubAssets due to it being static, abstract and generic.

    LoadAssetWithSubAssets : LoadAssetWithSubAssets_MethodGroup
    class LoadAssetWithSubAssets_MethodGroup:
        def __getitem__(self, t:typing.Type[LoadAssetWithSubAssets_1_T1]) -> LoadAssetWithSubAssets_1[LoadAssetWithSubAssets_1_T1]: ...

        LoadAssetWithSubAssets_1_T1 = typing.TypeVar('LoadAssetWithSubAssets_1_T1')
        class LoadAssetWithSubAssets_1(typing.Generic[LoadAssetWithSubAssets_1_T1]):
            LoadAssetWithSubAssets_1_T = AssetBundle.LoadAssetWithSubAssets_MethodGroup.LoadAssetWithSubAssets_1_T1
            def __call__(self, name: str) -> Array_1[LoadAssetWithSubAssets_1_T]:...

        @typing.overload
        def __call__(self, name: str) -> Array_1[Object]:...
        @typing.overload
        def __call__(self, name: str, type: typing.Type[typing.Any]) -> Array_1[Object]:...

    # Skipped LoadAssetWithSubAssetsAsync due to it being static, abstract and generic.

    LoadAssetWithSubAssetsAsync : LoadAssetWithSubAssetsAsync_MethodGroup
    class LoadAssetWithSubAssetsAsync_MethodGroup:
        def __getitem__(self, t:typing.Type[LoadAssetWithSubAssetsAsync_1_T1]) -> LoadAssetWithSubAssetsAsync_1[LoadAssetWithSubAssetsAsync_1_T1]: ...

        LoadAssetWithSubAssetsAsync_1_T1 = typing.TypeVar('LoadAssetWithSubAssetsAsync_1_T1')
        class LoadAssetWithSubAssetsAsync_1(typing.Generic[LoadAssetWithSubAssetsAsync_1_T1]):
            LoadAssetWithSubAssetsAsync_1_T = AssetBundle.LoadAssetWithSubAssetsAsync_MethodGroup.LoadAssetWithSubAssetsAsync_1_T1
            def __call__(self, name: str) -> AssetBundleRequest:...

        @typing.overload
        def __call__(self, name: str) -> AssetBundleRequest:...
        @typing.overload
        def __call__(self, name: str, type: typing.Type[typing.Any]) -> AssetBundleRequest:...

    # Skipped LoadFromFile due to it being static, abstract and generic.

    LoadFromFile : LoadFromFile_MethodGroup
    class LoadFromFile_MethodGroup:
        @typing.overload
        def __call__(self, path: str) -> AssetBundle:...
        @typing.overload
        def __call__(self, path: str, crc: int) -> AssetBundle:...
        @typing.overload
        def __call__(self, path: str, crc: int, offset: int) -> AssetBundle:...

    # Skipped LoadFromFileAsync due to it being static, abstract and generic.

    LoadFromFileAsync : LoadFromFileAsync_MethodGroup
    class LoadFromFileAsync_MethodGroup:
        @typing.overload
        def __call__(self, path: str) -> AssetBundleCreateRequest:...
        @typing.overload
        def __call__(self, path: str, crc: int) -> AssetBundleCreateRequest:...
        @typing.overload
        def __call__(self, path: str, crc: int, offset: int) -> AssetBundleCreateRequest:...

    # Skipped LoadFromMemory due to it being static, abstract and generic.

    LoadFromMemory : LoadFromMemory_MethodGroup
    class LoadFromMemory_MethodGroup:
        @typing.overload
        def __call__(self, binary: Array_1[int]) -> AssetBundle:...
        @typing.overload
        def __call__(self, binary: Array_1[int], crc: int) -> AssetBundle:...

    # Skipped LoadFromMemoryAsync due to it being static, abstract and generic.

    LoadFromMemoryAsync : LoadFromMemoryAsync_MethodGroup
    class LoadFromMemoryAsync_MethodGroup:
        @typing.overload
        def __call__(self, binary: Array_1[int]) -> AssetBundleCreateRequest:...
        @typing.overload
        def __call__(self, binary: Array_1[int], crc: int) -> AssetBundleCreateRequest:...

    # Skipped LoadFromStream due to it being static, abstract and generic.

    LoadFromStream : LoadFromStream_MethodGroup
    class LoadFromStream_MethodGroup:
        @typing.overload
        def __call__(self, stream: Stream) -> AssetBundle:...
        @typing.overload
        def __call__(self, stream: Stream, crc: int) -> AssetBundle:...
        @typing.overload
        def __call__(self, stream: Stream, crc: int, managedReadBufferSize: int) -> AssetBundle:...

    # Skipped LoadFromStreamAsync due to it being static, abstract and generic.

    LoadFromStreamAsync : LoadFromStreamAsync_MethodGroup
    class LoadFromStreamAsync_MethodGroup:
        @typing.overload
        def __call__(self, stream: Stream) -> AssetBundleCreateRequest:...
        @typing.overload
        def __call__(self, stream: Stream, crc: int) -> AssetBundleCreateRequest:...
        @typing.overload
        def __call__(self, stream: Stream, crc: int, managedReadBufferSize: int) -> AssetBundleCreateRequest:...



class AssetBundleCreateRequest(AsyncOperation):
    def __init__(self) -> None: ...
    @property
    def allowSceneActivation(self) -> bool: ...
    @allowSceneActivation.setter
    def allowSceneActivation(self, value: bool) -> bool: ...
    @property
    def assetBundle(self) -> AssetBundle: ...
    @property
    def isDone(self) -> bool: ...
    @property
    def priority(self) -> int: ...
    @priority.setter
    def priority(self, value: int) -> int: ...
    @property
    def progress(self) -> float: ...


class AssetBundleLoadResult(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Success : AssetBundleLoadResult # 0
    Cancelled : AssetBundleLoadResult # 1
    NotMatchingCrc : AssetBundleLoadResult # 2
    FailedCache : AssetBundleLoadResult # 3
    NotValidAssetBundle : AssetBundleLoadResult # 4
    NoSerializedData : AssetBundleLoadResult # 5
    NotCompatible : AssetBundleLoadResult # 6
    AlreadyLoaded : AssetBundleLoadResult # 7
    FailedRead : AssetBundleLoadResult # 8
    FailedDecompression : AssetBundleLoadResult # 9
    FailedWrite : AssetBundleLoadResult # 10
    FailedDeleteRecompressionTarget : AssetBundleLoadResult # 11
    RecompressionTargetIsLoaded : AssetBundleLoadResult # 12
    RecompressionTargetExistsButNotArchive : AssetBundleLoadResult # 13


class AssetBundleManifest(Object):
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    def GetAllAssetBundles(self) -> Array_1[str]: ...
    def GetAllAssetBundlesWithVariant(self) -> Array_1[str]: ...
    def GetAllDependencies(self, assetBundleName: str) -> Array_1[str]: ...
    def GetAssetBundleHash(self, assetBundleName: str) -> Hash128: ...
    def GetDirectDependencies(self, assetBundleName: str) -> Array_1[str]: ...


class AssetBundleRecompressOperation(AsyncOperation):
    def __init__(self) -> None: ...
    @property
    def allowSceneActivation(self) -> bool: ...
    @allowSceneActivation.setter
    def allowSceneActivation(self, value: bool) -> bool: ...
    @property
    def humanReadableResult(self) -> str: ...
    @property
    def inputPath(self) -> str: ...
    @property
    def isDone(self) -> bool: ...
    @property
    def outputPath(self) -> str: ...
    @property
    def priority(self) -> int: ...
    @priority.setter
    def priority(self, value: int) -> int: ...
    @property
    def progress(self) -> float: ...
    @property
    def result(self) -> AssetBundleLoadResult: ...
    @property
    def success(self) -> bool: ...


class AssetBundleRequest(ResourceRequest):
    def __init__(self) -> None: ...
    @property
    def allAssets(self) -> Array_1[Object]: ...
    @property
    def allowSceneActivation(self) -> bool: ...
    @allowSceneActivation.setter
    def allowSceneActivation(self, value: bool) -> bool: ...
    @property
    def asset(self) -> Object: ...
    @property
    def isDone(self) -> bool: ...
    @property
    def priority(self) -> int: ...
    @priority.setter
    def priority(self, value: int) -> int: ...
    @property
    def progress(self) -> float: ...


class AssetBundleUnloadOperation(AsyncOperation):
    def __init__(self) -> None: ...
    @property
    def allowSceneActivation(self) -> bool: ...
    @allowSceneActivation.setter
    def allowSceneActivation(self, value: bool) -> bool: ...
    @property
    def isDone(self) -> bool: ...
    @property
    def priority(self) -> int: ...
    @priority.setter
    def priority(self, value: int) -> int: ...
    @property
    def progress(self) -> float: ...
    def WaitForCompletion(self) -> None: ...


class AsyncInstantiateOperation_GenericClasses(abc.ABCMeta):
    Generic_AsyncInstantiateOperation_GenericClasses_AsyncInstantiateOperation_1_T = typing.TypeVar('Generic_AsyncInstantiateOperation_GenericClasses_AsyncInstantiateOperation_1_T')
    def __getitem__(self, types : typing.Type[Generic_AsyncInstantiateOperation_GenericClasses_AsyncInstantiateOperation_1_T]) -> typing.Type[AsyncInstantiateOperation_1[Generic_AsyncInstantiateOperation_GenericClasses_AsyncInstantiateOperation_1_T]]: ...

class AsyncInstantiateOperation(AsyncInstantiateOperation_0, metaclass =AsyncInstantiateOperation_GenericClasses): ...

class AsyncInstantiateOperation_0(AsyncOperation):
    def __init__(self) -> None: ...
    @property
    def allowSceneActivation(self) -> bool: ...
    @allowSceneActivation.setter
    def allowSceneActivation(self, value: bool) -> bool: ...
    @property
    def isDone(self) -> bool: ...
    @property
    def priority(self) -> int: ...
    @priority.setter
    def priority(self, value: int) -> int: ...
    @property
    def progress(self) -> float: ...
    @property
    def Result(self) -> Array_1[Object]: ...
    def Cancel(self) -> None: ...
    @staticmethod
    def GetIntegrationTimeMS() -> float: ...
    def IsWaitingForSceneActivation(self) -> bool: ...
    @staticmethod
    def SetIntegrationTimeMS(integrationTimeMS: float) -> None: ...
    def WaitForCompletion(self) -> None: ...


AsyncInstantiateOperation_1_T = typing.TypeVar('AsyncInstantiateOperation_1_T')
class AsyncInstantiateOperation_1(typing.Generic[AsyncInstantiateOperation_1_T], CustomYieldInstruction):
    @property
    def allowSceneActivation(self) -> bool: ...
    @allowSceneActivation.setter
    def allowSceneActivation(self, value: bool) -> bool: ...
    @property
    def Current(self) -> typing.Any: ...
    @property
    def isDone(self) -> bool: ...
    @property
    def keepWaiting(self) -> bool: ...
    @property
    def progress(self) -> float: ...
    @property
    def Result(self) -> Array_1[AsyncInstantiateOperation_1_T]: ...
    def Cancel(self) -> None: ...
    def GetOperation(self) -> AsyncInstantiateOperation: ...
    def IsWaitingForSceneActivation(self) -> bool: ...
    # Operator not supported op_Implicit(generic: AsyncInstantiateOperation`1)
    def WaitForCompletion(self) -> None: ...


class AsyncOperation(YieldInstruction):
    def __init__(self) -> None: ...
    @property
    def allowSceneActivation(self) -> bool: ...
    @allowSceneActivation.setter
    def allowSceneActivation(self, value: bool) -> bool: ...
    @property
    def isDone(self) -> bool: ...
    @property
    def priority(self) -> int: ...
    @priority.setter
    def priority(self, value: int) -> int: ...
    @property
    def progress(self) -> float: ...


class AudioBehaviour(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class AudioChorusFilter(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def delay(self) -> float: ...
    @delay.setter
    def delay(self, value: float) -> float: ...
    @property
    def depth(self) -> float: ...
    @depth.setter
    def depth(self, value: float) -> float: ...
    @property
    def dryMix(self) -> float: ...
    @dryMix.setter
    def dryMix(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def feedback(self) -> float: ...
    @feedback.setter
    def feedback(self, value: float) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def rate(self) -> float: ...
    @rate.setter
    def rate(self, value: float) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def wetMix1(self) -> float: ...
    @wetMix1.setter
    def wetMix1(self, value: float) -> float: ...
    @property
    def wetMix2(self) -> float: ...
    @wetMix2.setter
    def wetMix2(self, value: float) -> float: ...
    @property
    def wetMix3(self) -> float: ...
    @wetMix3.setter
    def wetMix3(self, value: float) -> float: ...


class AudioClip(Object):
    @property
    def ambisonic(self) -> bool: ...
    @property
    def channels(self) -> int: ...
    @property
    def frequency(self) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def isReadyToPlay(self) -> bool: ...
    @property
    def length(self) -> float: ...
    @property
    def loadInBackground(self) -> bool: ...
    @property
    def loadState(self) -> AudioDataLoadState: ...
    @property
    def loadType(self) -> AudioClipLoadType: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def preloadAudioData(self) -> bool: ...
    @property
    def samples(self) -> int: ...
    def GetData(self, data: Array_1[float], offsetSamples: int) -> bool: ...
    def LoadAudioData(self) -> bool: ...
    def SetData(self, data: Array_1[float], offsetSamples: int) -> bool: ...
    def UnloadAudioData(self) -> bool: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self, name: str, lengthSamples: int, channels: int, frequency: int, stream: bool) -> AudioClip:...
        @typing.overload
        def __call__(self, name: str, lengthSamples: int, channels: int, frequency: int, stream: bool, pcmreadercallback: AudioClip.PCMReaderCallback) -> AudioClip:...
        @typing.overload
        def __call__(self, name: str, lengthSamples: int, channels: int, frequency: int, _3D: bool, stream: bool) -> AudioClip:...
        @typing.overload
        def __call__(self, name: str, lengthSamples: int, channels: int, frequency: int, stream: bool, pcmreadercallback: AudioClip.PCMReaderCallback, pcmsetpositioncallback: AudioClip.PCMSetPositionCallback) -> AudioClip:...
        @typing.overload
        def __call__(self, name: str, lengthSamples: int, channels: int, frequency: int, _3D: bool, stream: bool, pcmreadercallback: AudioClip.PCMReaderCallback) -> AudioClip:...
        @typing.overload
        def __call__(self, name: str, lengthSamples: int, channels: int, frequency: int, _3D: bool, stream: bool, pcmreadercallback: AudioClip.PCMReaderCallback, pcmsetpositioncallback: AudioClip.PCMSetPositionCallback) -> AudioClip:...


    class PCMReaderCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, data: Array_1[float], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, data: Array_1[float]) -> None: ...


    class PCMSetPositionCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, position: int, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, position: int) -> None: ...



class AudioClipLoadType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    DecompressOnLoad : AudioClipLoadType # 0
    CompressedInMemory : AudioClipLoadType # 1
    Streaming : AudioClipLoadType # 2


class AudioCompressionFormat(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    PCM : AudioCompressionFormat # 0
    Vorbis : AudioCompressionFormat # 1
    ADPCM : AudioCompressionFormat # 2
    MP3 : AudioCompressionFormat # 3
    VAG : AudioCompressionFormat # 4
    HEVAG : AudioCompressionFormat # 5
    XMA : AudioCompressionFormat # 6
    AAC : AudioCompressionFormat # 7
    GCADPCM : AudioCompressionFormat # 8
    ATRAC9 : AudioCompressionFormat # 9


class AudioConfiguration:
    dspBufferSize : int
    numRealVoices : int
    numVirtualVoices : int
    sampleRate : int
    speakerMode : AudioSpeakerMode


class AudioDataLoadState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unloaded : AudioDataLoadState # 0
    Loading : AudioDataLoadState # 1
    Loaded : AudioDataLoadState # 2
    Failed : AudioDataLoadState # 3


class AudioDistortionFilter(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def distortionLevel(self) -> float: ...
    @distortionLevel.setter
    def distortionLevel(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class AudioEchoFilter(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def decayRatio(self) -> float: ...
    @decayRatio.setter
    def decayRatio(self, value: float) -> float: ...
    @property
    def delay(self) -> float: ...
    @delay.setter
    def delay(self, value: float) -> float: ...
    @property
    def dryMix(self) -> float: ...
    @dryMix.setter
    def dryMix(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def wetMix(self) -> float: ...
    @wetMix.setter
    def wetMix(self, value: float) -> float: ...


class AudioHighPassFilter(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def cutoffFrequency(self) -> float: ...
    @cutoffFrequency.setter
    def cutoffFrequency(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def highpassResonaceQ(self) -> float: ...
    @highpassResonaceQ.setter
    def highpassResonaceQ(self, value: float) -> float: ...
    @property
    def highpassResonanceQ(self) -> float: ...
    @highpassResonanceQ.setter
    def highpassResonanceQ(self, value: float) -> float: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class AudioListener(AudioBehaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @classmethod
    @property
    def pause(cls) -> bool: ...
    @classmethod
    @pause.setter
    def pause(cls, value: bool) -> bool: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def velocityUpdateMode(self) -> AudioVelocityUpdateMode: ...
    @velocityUpdateMode.setter
    def velocityUpdateMode(self, value: AudioVelocityUpdateMode) -> AudioVelocityUpdateMode: ...
    @classmethod
    @property
    def volume(cls) -> float: ...
    @classmethod
    @volume.setter
    def volume(cls, value: float) -> float: ...
    # Skipped GetOutputData due to it being static, abstract and generic.

    GetOutputData : GetOutputData_MethodGroup
    class GetOutputData_MethodGroup:
        @typing.overload
        def __call__(self, numSamples: int, channel: int) -> Array_1[float]:...
        @typing.overload
        def __call__(self, samples: Array_1[float], channel: int) -> None:...

    # Skipped GetSpectrumData due to it being static, abstract and generic.

    GetSpectrumData : GetSpectrumData_MethodGroup
    class GetSpectrumData_MethodGroup:
        @typing.overload
        def __call__(self, numSamples: int, channel: int, window: FFTWindow) -> Array_1[float]:...
        @typing.overload
        def __call__(self, samples: Array_1[float], channel: int, window: FFTWindow) -> None:...



class AudioLowPassFilter(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def customCutoffCurve(self) -> AnimationCurve: ...
    @customCutoffCurve.setter
    def customCutoffCurve(self, value: AnimationCurve) -> AnimationCurve: ...
    @property
    def cutoffFrequency(self) -> float: ...
    @cutoffFrequency.setter
    def cutoffFrequency(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def lowpassResonaceQ(self) -> float: ...
    @lowpassResonaceQ.setter
    def lowpassResonaceQ(self, value: float) -> float: ...
    @property
    def lowpassResonanceQ(self) -> float: ...
    @lowpassResonanceQ.setter
    def lowpassResonanceQ(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class AudioRenderer:
    def __init__(self) -> None: ...
    @staticmethod
    def GetSampleCountForCaptureFrame() -> int: ...
    @staticmethod
    def Render(buffer: NativeArray_1[float]) -> bool: ...
    @staticmethod
    def Start() -> bool: ...
    @staticmethod
    def Stop() -> bool: ...


class AudioReverbFilter(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def decayHFRatio(self) -> float: ...
    @decayHFRatio.setter
    def decayHFRatio(self, value: float) -> float: ...
    @property
    def decayTime(self) -> float: ...
    @decayTime.setter
    def decayTime(self, value: float) -> float: ...
    @property
    def density(self) -> float: ...
    @density.setter
    def density(self, value: float) -> float: ...
    @property
    def diffusion(self) -> float: ...
    @diffusion.setter
    def diffusion(self, value: float) -> float: ...
    @property
    def dryLevel(self) -> float: ...
    @dryLevel.setter
    def dryLevel(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hfReference(self) -> float: ...
    @hfReference.setter
    def hfReference(self, value: float) -> float: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def lfReference(self) -> float: ...
    @lfReference.setter
    def lfReference(self, value: float) -> float: ...
    @property
    def lFReference(self) -> float: ...
    @lFReference.setter
    def lFReference(self, value: float) -> float: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def reflectionsDelay(self) -> float: ...
    @reflectionsDelay.setter
    def reflectionsDelay(self, value: float) -> float: ...
    @property
    def reflectionsLevel(self) -> float: ...
    @reflectionsLevel.setter
    def reflectionsLevel(self, value: float) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def reverbDelay(self) -> float: ...
    @reverbDelay.setter
    def reverbDelay(self, value: float) -> float: ...
    @property
    def reverbLevel(self) -> float: ...
    @reverbLevel.setter
    def reverbLevel(self, value: float) -> float: ...
    @property
    def reverbPreset(self) -> AudioReverbPreset: ...
    @reverbPreset.setter
    def reverbPreset(self, value: AudioReverbPreset) -> AudioReverbPreset: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def room(self) -> float: ...
    @room.setter
    def room(self, value: float) -> float: ...
    @property
    def roomHF(self) -> float: ...
    @roomHF.setter
    def roomHF(self, value: float) -> float: ...
    @property
    def roomLF(self) -> float: ...
    @roomLF.setter
    def roomLF(self, value: float) -> float: ...
    @property
    def roomRolloffFactor(self) -> float: ...
    @roomRolloffFactor.setter
    def roomRolloffFactor(self, value: float) -> float: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class AudioReverbPreset(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Off : AudioReverbPreset # 0
    Generic : AudioReverbPreset # 1
    PaddedCell : AudioReverbPreset # 2
    Room : AudioReverbPreset # 3
    Bathroom : AudioReverbPreset # 4
    Livingroom : AudioReverbPreset # 5
    Stoneroom : AudioReverbPreset # 6
    Auditorium : AudioReverbPreset # 7
    Concerthall : AudioReverbPreset # 8
    Cave : AudioReverbPreset # 9
    Arena : AudioReverbPreset # 10
    Hangar : AudioReverbPreset # 11
    CarpetedHallway : AudioReverbPreset # 12
    Hallway : AudioReverbPreset # 13
    StoneCorridor : AudioReverbPreset # 14
    Alley : AudioReverbPreset # 15
    Forest : AudioReverbPreset # 16
    City : AudioReverbPreset # 17
    Mountains : AudioReverbPreset # 18
    Quarry : AudioReverbPreset # 19
    Plain : AudioReverbPreset # 20
    ParkingLot : AudioReverbPreset # 21
    SewerPipe : AudioReverbPreset # 22
    Underwater : AudioReverbPreset # 23
    Drugged : AudioReverbPreset # 24
    Dizzy : AudioReverbPreset # 25
    Psychotic : AudioReverbPreset # 26
    User : AudioReverbPreset # 27


class AudioReverbZone(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def decayHFRatio(self) -> float: ...
    @decayHFRatio.setter
    def decayHFRatio(self, value: float) -> float: ...
    @property
    def decayTime(self) -> float: ...
    @decayTime.setter
    def decayTime(self, value: float) -> float: ...
    @property
    def density(self) -> float: ...
    @density.setter
    def density(self, value: float) -> float: ...
    @property
    def diffusion(self) -> float: ...
    @diffusion.setter
    def diffusion(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def HFReference(self) -> float: ...
    @HFReference.setter
    def HFReference(self, value: float) -> float: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def LFReference(self) -> float: ...
    @LFReference.setter
    def LFReference(self, value: float) -> float: ...
    @property
    def light(self) -> Component: ...
    @property
    def maxDistance(self) -> float: ...
    @maxDistance.setter
    def maxDistance(self, value: float) -> float: ...
    @property
    def minDistance(self) -> float: ...
    @minDistance.setter
    def minDistance(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def reflections(self) -> int: ...
    @reflections.setter
    def reflections(self, value: int) -> int: ...
    @property
    def reflectionsDelay(self) -> float: ...
    @reflectionsDelay.setter
    def reflectionsDelay(self, value: float) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def reverb(self) -> int: ...
    @reverb.setter
    def reverb(self, value: int) -> int: ...
    @property
    def reverbDelay(self) -> float: ...
    @reverbDelay.setter
    def reverbDelay(self, value: float) -> float: ...
    @property
    def reverbPreset(self) -> AudioReverbPreset: ...
    @reverbPreset.setter
    def reverbPreset(self, value: AudioReverbPreset) -> AudioReverbPreset: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def room(self) -> int: ...
    @room.setter
    def room(self, value: int) -> int: ...
    @property
    def roomHF(self) -> int: ...
    @roomHF.setter
    def roomHF(self, value: int) -> int: ...
    @property
    def roomLF(self) -> int: ...
    @roomLF.setter
    def roomLF(self, value: int) -> int: ...
    @property
    def roomRolloffFactor(self) -> float: ...
    @roomRolloffFactor.setter
    def roomRolloffFactor(self, value: float) -> float: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class AudioRolloffMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Logarithmic : AudioRolloffMode # 0
    Linear : AudioRolloffMode # 1
    Custom : AudioRolloffMode # 2


class AudioSettings:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def driverCapabilities(cls) -> AudioSpeakerMode: ...
    @classmethod
    @property
    def driverCaps(cls) -> AudioSpeakerMode: ...
    @classmethod
    @property
    def dspTime(cls) -> float: ...
    @classmethod
    @property
    def outputSampleRate(cls) -> int: ...
    @classmethod
    @outputSampleRate.setter
    def outputSampleRate(cls, value: int) -> int: ...
    @classmethod
    @property
    def speakerMode(cls) -> AudioSpeakerMode: ...
    @classmethod
    @speakerMode.setter
    def speakerMode(cls, value: AudioSpeakerMode) -> AudioSpeakerMode: ...
    @staticmethod
    def GetConfiguration() -> AudioConfiguration: ...
    @staticmethod
    def GetDSPBufferSize(bufferLength: clr.Reference[int], numBuffers: clr.Reference[int]) -> None: ...
    @staticmethod
    def GetSpatializerPluginName() -> str: ...
    @staticmethod
    def GetSpatializerPluginNames() -> Array_1[str]: ...
    @staticmethod
    def Reset(config: AudioConfiguration) -> bool: ...
    @staticmethod
    def SetDSPBufferSize(bufferLength: int, numBuffers: int) -> None: ...
    @staticmethod
    def SetSpatializerPluginName(pluginName: str) -> None: ...

    class AudioConfigurationChangeHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, deviceWasChanged: bool, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, deviceWasChanged: bool) -> None: ...


    class Mobile(abc.ABC):
        @classmethod
        @property
        def audioOutputStarted(cls) -> bool: ...
        @classmethod
        @property
        def muteState(cls) -> bool: ...
        @classmethod
        @property
        def stopAudioOutputOnMute(cls) -> bool: ...
        @classmethod
        @stopAudioOutputOnMute.setter
        def stopAudioOutputOnMute(cls, value: bool) -> bool: ...
        @staticmethod
        def StartAudioOutput() -> None: ...
        @staticmethod
        def StopAudioOutput() -> None: ...



class AudioSource(AudioBehaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bypassEffects(self) -> bool: ...
    @bypassEffects.setter
    def bypassEffects(self, value: bool) -> bool: ...
    @property
    def bypassListenerEffects(self) -> bool: ...
    @bypassListenerEffects.setter
    def bypassListenerEffects(self, value: bool) -> bool: ...
    @property
    def bypassReverbZones(self) -> bool: ...
    @bypassReverbZones.setter
    def bypassReverbZones(self, value: bool) -> bool: ...
    @property
    def camera(self) -> Component: ...
    @property
    def clip(self) -> AudioClip: ...
    @clip.setter
    def clip(self, value: AudioClip) -> AudioClip: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def dopplerLevel(self) -> float: ...
    @dopplerLevel.setter
    def dopplerLevel(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def gamepadSpeakerOutputType(self) -> GamepadSpeakerOutputType: ...
    @gamepadSpeakerOutputType.setter
    def gamepadSpeakerOutputType(self, value: GamepadSpeakerOutputType) -> GamepadSpeakerOutputType: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def ignoreListenerPause(self) -> bool: ...
    @ignoreListenerPause.setter
    def ignoreListenerPause(self, value: bool) -> bool: ...
    @property
    def ignoreListenerVolume(self) -> bool: ...
    @ignoreListenerVolume.setter
    def ignoreListenerVolume(self, value: bool) -> bool: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def isPlaying(self) -> bool: ...
    @property
    def isVirtual(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def loop(self) -> bool: ...
    @loop.setter
    def loop(self, value: bool) -> bool: ...
    @property
    def maxDistance(self) -> float: ...
    @maxDistance.setter
    def maxDistance(self, value: float) -> float: ...
    @property
    def maxVolume(self) -> float: ...
    @maxVolume.setter
    def maxVolume(self, value: float) -> float: ...
    @property
    def minDistance(self) -> float: ...
    @minDistance.setter
    def minDistance(self, value: float) -> float: ...
    @property
    def minVolume(self) -> float: ...
    @minVolume.setter
    def minVolume(self, value: float) -> float: ...
    @property
    def mute(self) -> bool: ...
    @mute.setter
    def mute(self, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def outputAudioMixerGroup(self) -> AudioMixerGroup: ...
    @outputAudioMixerGroup.setter
    def outputAudioMixerGroup(self, value: AudioMixerGroup) -> AudioMixerGroup: ...
    @property
    def pan(self) -> float: ...
    @pan.setter
    def pan(self, value: float) -> float: ...
    @property
    def panLevel(self) -> float: ...
    @panLevel.setter
    def panLevel(self, value: float) -> float: ...
    @property
    def panStereo(self) -> float: ...
    @panStereo.setter
    def panStereo(self, value: float) -> float: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def pitch(self) -> float: ...
    @pitch.setter
    def pitch(self, value: float) -> float: ...
    @property
    def playOnAwake(self) -> bool: ...
    @playOnAwake.setter
    def playOnAwake(self, value: bool) -> bool: ...
    @property
    def priority(self) -> int: ...
    @priority.setter
    def priority(self, value: int) -> int: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def reverbZoneMix(self) -> float: ...
    @reverbZoneMix.setter
    def reverbZoneMix(self, value: float) -> float: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def rolloffFactor(self) -> float: ...
    @rolloffFactor.setter
    def rolloffFactor(self, value: float) -> float: ...
    @property
    def rolloffMode(self) -> AudioRolloffMode: ...
    @rolloffMode.setter
    def rolloffMode(self, value: AudioRolloffMode) -> AudioRolloffMode: ...
    @property
    def spatialBlend(self) -> float: ...
    @spatialBlend.setter
    def spatialBlend(self, value: float) -> float: ...
    @property
    def spatialize(self) -> bool: ...
    @spatialize.setter
    def spatialize(self, value: bool) -> bool: ...
    @property
    def spatializePostEffects(self) -> bool: ...
    @spatializePostEffects.setter
    def spatializePostEffects(self, value: bool) -> bool: ...
    @property
    def spread(self) -> float: ...
    @spread.setter
    def spread(self, value: float) -> float: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def time(self) -> float: ...
    @time.setter
    def time(self, value: float) -> float: ...
    @property
    def timeSamples(self) -> int: ...
    @timeSamples.setter
    def timeSamples(self, value: int) -> int: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def velocityUpdateMode(self) -> AudioVelocityUpdateMode: ...
    @velocityUpdateMode.setter
    def velocityUpdateMode(self, value: AudioVelocityUpdateMode) -> AudioVelocityUpdateMode: ...
    @property
    def volume(self) -> float: ...
    @volume.setter
    def volume(self, value: float) -> float: ...
    def DisableGamepadOutput(self) -> bool: ...
    @staticmethod
    def GamepadSpeakerSupportsOutputType(outputType: GamepadSpeakerOutputType) -> bool: ...
    def GetAmbisonicDecoderFloat(self, index: int, value: clr.Reference[float]) -> bool: ...
    def GetCustomCurve(self, type: AudioSourceCurveType) -> AnimationCurve: ...
    def GetSpatializerFloat(self, index: int, value: clr.Reference[float]) -> bool: ...
    def Pause(self) -> None: ...
    def PlayDelayed(self, delay: float) -> None: ...
    def PlayOnGamepad(self, slot: int) -> bool: ...
    def PlayScheduled(self, time: float) -> None: ...
    def SetAmbisonicDecoderFloat(self, index: int, value: float) -> bool: ...
    def SetCustomCurve(self, type: AudioSourceCurveType, curve: AnimationCurve) -> None: ...
    def SetGamepadSpeakerMixLevel(self, slot: int, mixLevel: int) -> bool: ...
    def SetGamepadSpeakerMixLevelDefault(self, slot: int) -> bool: ...
    def SetGamepadSpeakerRestrictedAudio(self, slot: int, restricted: bool) -> bool: ...
    def SetScheduledEndTime(self, time: float) -> None: ...
    def SetScheduledStartTime(self, time: float) -> None: ...
    def SetSpatializerFloat(self, index: int, value: float) -> bool: ...
    def Stop(self) -> None: ...
    def UnPause(self) -> None: ...
    # Skipped GetOutputData due to it being static, abstract and generic.

    GetOutputData : GetOutputData_MethodGroup
    class GetOutputData_MethodGroup:
        @typing.overload
        def __call__(self, numSamples: int, channel: int) -> Array_1[float]:...
        @typing.overload
        def __call__(self, samples: Array_1[float], channel: int) -> None:...

    # Skipped GetSpectrumData due to it being static, abstract and generic.

    GetSpectrumData : GetSpectrumData_MethodGroup
    class GetSpectrumData_MethodGroup:
        @typing.overload
        def __call__(self, numSamples: int, channel: int, window: FFTWindow) -> Array_1[float]:...
        @typing.overload
        def __call__(self, samples: Array_1[float], channel: int, window: FFTWindow) -> None:...

    # Skipped Play due to it being static, abstract and generic.

    Play : Play_MethodGroup
    class Play_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, delay: int) -> None:...

    # Skipped PlayClipAtPoint due to it being static, abstract and generic.

    PlayClipAtPoint : PlayClipAtPoint_MethodGroup
    class PlayClipAtPoint_MethodGroup:
        @typing.overload
        def __call__(self, clip: AudioClip, position: Vector3) -> None:...
        @typing.overload
        def __call__(self, clip: AudioClip, position: Vector3, volume: float) -> None:...

    # Skipped PlayOneShot due to it being static, abstract and generic.

    PlayOneShot : PlayOneShot_MethodGroup
    class PlayOneShot_MethodGroup:
        @typing.overload
        def __call__(self, clip: AudioClip) -> None:...
        @typing.overload
        def __call__(self, clip: AudioClip, volumeScale: float) -> None:...



class AudioSourceCurveType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    CustomRolloff : AudioSourceCurveType # 0
    SpatialBlend : AudioSourceCurveType # 1
    ReverbZoneMix : AudioSourceCurveType # 2
    Spread : AudioSourceCurveType # 3


class AudioSpeakerMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Raw : AudioSpeakerMode # 0
    Mono : AudioSpeakerMode # 1
    Stereo : AudioSpeakerMode # 2
    Quad : AudioSpeakerMode # 3
    Surround : AudioSpeakerMode # 4
    Mode5point1 : AudioSpeakerMode # 5
    Mode7point1 : AudioSpeakerMode # 6
    Prologic : AudioSpeakerMode # 7


class AudioType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    UNKNOWN : AudioType # 0
    ACC : AudioType # 1
    AIFF : AudioType # 2
    IT : AudioType # 10
    MOD : AudioType # 12
    MPEG : AudioType # 13
    OGGVORBIS : AudioType # 14
    S3M : AudioType # 17
    WAV : AudioType # 20
    XM : AudioType # 21
    XMA : AudioType # 22
    VAG : AudioType # 23
    AUDIOQUEUE : AudioType # 24


class AudioVelocityUpdateMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Auto : AudioVelocityUpdateMode # 0
    Fixed : AudioVelocityUpdateMode # 1
    Dynamic : AudioVelocityUpdateMode # 2


class Avatar(Object):
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def humanDescription(self) -> HumanDescription: ...
    @property
    def isHuman(self) -> bool: ...
    @property
    def isValid(self) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...


class AvatarBuilder:
    def __init__(self) -> None: ...
    @staticmethod
    def BuildGenericAvatar(go: GameObject, rootMotionTransformName: str) -> Avatar: ...
    @staticmethod
    def BuildHumanAvatar(go: GameObject, humanDescription: HumanDescription) -> Avatar: ...


class AvatarIKGoal(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    LeftFoot : AvatarIKGoal # 0
    RightFoot : AvatarIKGoal # 1
    LeftHand : AvatarIKGoal # 2
    RightHand : AvatarIKGoal # 3


class AvatarIKHint(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    LeftKnee : AvatarIKHint # 0
    RightKnee : AvatarIKHint # 1
    LeftElbow : AvatarIKHint # 2
    RightElbow : AvatarIKHint # 3


class AvatarMask(Object):
    def __init__(self) -> None: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def humanoidBodyPartCount(self) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def transformCount(self) -> int: ...
    @transformCount.setter
    def transformCount(self, value: int) -> int: ...
    def GetHumanoidBodyPartActive(self, index: AvatarMaskBodyPart) -> bool: ...
    def GetTransformActive(self, index: int) -> bool: ...
    def GetTransformPath(self, index: int) -> str: ...
    def SetHumanoidBodyPartActive(self, index: AvatarMaskBodyPart, value: bool) -> None: ...
    def SetTransformActive(self, index: int, value: bool) -> None: ...
    def SetTransformPath(self, index: int, path: str) -> None: ...
    # Skipped AddTransformPath due to it being static, abstract and generic.

    AddTransformPath : AddTransformPath_MethodGroup
    class AddTransformPath_MethodGroup:
        @typing.overload
        def __call__(self, transform: Transform) -> None:...
        @typing.overload
        def __call__(self, transform: Transform, recursive: bool) -> None:...

    # Skipped RemoveTransformPath due to it being static, abstract and generic.

    RemoveTransformPath : RemoveTransformPath_MethodGroup
    class RemoveTransformPath_MethodGroup:
        @typing.overload
        def __call__(self, transform: Transform) -> None:...
        @typing.overload
        def __call__(self, transform: Transform, recursive: bool) -> None:...



class AvatarMaskBodyPart(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Root : AvatarMaskBodyPart # 0
    Body : AvatarMaskBodyPart # 1
    Head : AvatarMaskBodyPart # 2
    LeftLeg : AvatarMaskBodyPart # 3
    RightLeg : AvatarMaskBodyPart # 4
    LeftArm : AvatarMaskBodyPart # 5
    RightArm : AvatarMaskBodyPart # 6
    LeftFingers : AvatarMaskBodyPart # 7
    RightFingers : AvatarMaskBodyPart # 8
    LeftFootIK : AvatarMaskBodyPart # 9
    RightFootIK : AvatarMaskBodyPart # 10
    LeftHandIK : AvatarMaskBodyPart # 11
    RightHandIK : AvatarMaskBodyPart # 12
    LastBodyPart : AvatarMaskBodyPart # 13


class AvatarTarget(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Root : AvatarTarget # 0
    Body : AvatarTarget # 1
    LeftFoot : AvatarTarget # 2
    RightFoot : AvatarTarget # 3
    LeftHand : AvatarTarget # 4
    RightHand : AvatarTarget # 5


class BatteryStatus(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : BatteryStatus # 0
    Charging : BatteryStatus # 1
    Discharging : BatteryStatus # 2
    NotCharging : BatteryStatus # 3
    Full : BatteryStatus # 4


class BeforeRenderOrderAttribute(Attribute):
    def __init__(self, order: int) -> None: ...
    @property
    def order(self) -> int: ...
    @order.setter
    def order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class Behaviour(Component):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class BillboardAsset(Object):
    def __init__(self) -> None: ...
    @property
    def bottom(self) -> float: ...
    @bottom.setter
    def bottom(self, value: float) -> float: ...
    @property
    def height(self) -> float: ...
    @height.setter
    def height(self, value: float) -> float: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def imageCount(self) -> int: ...
    @property
    def indexCount(self) -> int: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> Material: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def vertexCount(self) -> int: ...
    @property
    def width(self) -> float: ...
    @width.setter
    def width(self, value: float) -> float: ...
    # Skipped GetImageTexCoords due to it being static, abstract and generic.

    GetImageTexCoords : GetImageTexCoords_MethodGroup
    class GetImageTexCoords_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[Vector4]:...
        @typing.overload
        def __call__(self, imageTexCoords: List_1[Vector4]) -> None:...

    # Skipped GetIndices due to it being static, abstract and generic.

    GetIndices : GetIndices_MethodGroup
    class GetIndices_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[int]:...
        @typing.overload
        def __call__(self, indices: List_1[int]) -> None:...

    # Skipped GetVertices due to it being static, abstract and generic.

    GetVertices : GetVertices_MethodGroup
    class GetVertices_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[Vector2]:...
        @typing.overload
        def __call__(self, vertices: List_1[Vector2]) -> None:...

    # Skipped SetImageTexCoords due to it being static, abstract and generic.

    SetImageTexCoords : SetImageTexCoords_MethodGroup
    class SetImageTexCoords_MethodGroup:
        @typing.overload
        def __call__(self, imageTexCoords: List_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, imageTexCoords: Array_1[Vector4]) -> None:...

    # Skipped SetIndices due to it being static, abstract and generic.

    SetIndices : SetIndices_MethodGroup
    class SetIndices_MethodGroup:
        @typing.overload
        def __call__(self, indices: List_1[int]) -> None:...
        @typing.overload
        def __call__(self, indices: Array_1[int]) -> None:...

    # Skipped SetVertices due to it being static, abstract and generic.

    SetVertices : SetVertices_MethodGroup
    class SetVertices_MethodGroup:
        @typing.overload
        def __call__(self, vertices: List_1[Vector2]) -> None:...
        @typing.overload
        def __call__(self, vertices: Array_1[Vector2]) -> None:...



class BillboardRenderer(Renderer):
    def __init__(self) -> None: ...
    @property
    def allowOcclusionWhenDynamic(self) -> bool: ...
    @allowOcclusionWhenDynamic.setter
    def allowOcclusionWhenDynamic(self, value: bool) -> bool: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def billboard(self) -> BillboardAsset: ...
    @billboard.setter
    def billboard(self, value: BillboardAsset) -> BillboardAsset: ...
    @property
    def bounds(self) -> Bounds: ...
    @bounds.setter
    def bounds(self, value: Bounds) -> Bounds: ...
    @property
    def camera(self) -> Component: ...
    @property
    def castShadows(self) -> bool: ...
    @castShadows.setter
    def castShadows(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def forceRenderingOff(self) -> bool: ...
    @forceRenderingOff.setter
    def forceRenderingOff(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isPartOfStaticBatch(self) -> bool: ...
    @property
    def isVisible(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def lightmapIndex(self) -> int: ...
    @lightmapIndex.setter
    def lightmapIndex(self, value: int) -> int: ...
    @property
    def lightmapScaleOffset(self) -> Vector4: ...
    @lightmapScaleOffset.setter
    def lightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightmapTilingOffset(self) -> Vector4: ...
    @lightmapTilingOffset.setter
    def lightmapTilingOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightProbeAnchor(self) -> Transform: ...
    @lightProbeAnchor.setter
    def lightProbeAnchor(self, value: Transform) -> Transform: ...
    @property
    def lightProbeProxyVolumeOverride(self) -> GameObject: ...
    @lightProbeProxyVolumeOverride.setter
    def lightProbeProxyVolumeOverride(self, value: GameObject) -> GameObject: ...
    @property
    def lightProbeUsage(self) -> LightProbeUsage: ...
    @lightProbeUsage.setter
    def lightProbeUsage(self, value: LightProbeUsage) -> LightProbeUsage: ...
    @property
    def localBounds(self) -> Bounds: ...
    @localBounds.setter
    def localBounds(self, value: Bounds) -> Bounds: ...
    @property
    def localToWorldMatrix(self) -> Matrix4x4: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> Material: ...
    @property
    def materials(self) -> Array_1[Material]: ...
    @materials.setter
    def materials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def motionVectorGenerationMode(self) -> MotionVectorGenerationMode: ...
    @motionVectorGenerationMode.setter
    def motionVectorGenerationMode(self, value: MotionVectorGenerationMode) -> MotionVectorGenerationMode: ...
    @property
    def motionVectors(self) -> bool: ...
    @motionVectors.setter
    def motionVectors(self, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def probeAnchor(self) -> Transform: ...
    @probeAnchor.setter
    def probeAnchor(self, value: Transform) -> Transform: ...
    @property
    def rayTracingMode(self) -> RayTracingMode: ...
    @rayTracingMode.setter
    def rayTracingMode(self, value: RayTracingMode) -> RayTracingMode: ...
    @property
    def realtimeLightmapIndex(self) -> int: ...
    @realtimeLightmapIndex.setter
    def realtimeLightmapIndex(self, value: int) -> int: ...
    @property
    def realtimeLightmapScaleOffset(self) -> Vector4: ...
    @realtimeLightmapScaleOffset.setter
    def realtimeLightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def receiveShadows(self) -> bool: ...
    @receiveShadows.setter
    def receiveShadows(self, value: bool) -> bool: ...
    @property
    def reflectionProbeUsage(self) -> ReflectionProbeUsage: ...
    @reflectionProbeUsage.setter
    def reflectionProbeUsage(self, value: ReflectionProbeUsage) -> ReflectionProbeUsage: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rendererPriority(self) -> int: ...
    @rendererPriority.setter
    def rendererPriority(self, value: int) -> int: ...
    @property
    def renderingLayerMask(self) -> int: ...
    @renderingLayerMask.setter
    def renderingLayerMask(self, value: int) -> int: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def shadowCastingMode(self) -> ShadowCastingMode: ...
    @shadowCastingMode.setter
    def shadowCastingMode(self, value: ShadowCastingMode) -> ShadowCastingMode: ...
    @property
    def sharedMaterial(self) -> Material: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: Material) -> Material: ...
    @property
    def sharedMaterials(self) -> Array_1[Material]: ...
    @sharedMaterials.setter
    def sharedMaterials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def sortingLayerID(self) -> int: ...
    @sortingLayerID.setter
    def sortingLayerID(self, value: int) -> int: ...
    @property
    def sortingLayerName(self) -> str: ...
    @sortingLayerName.setter
    def sortingLayerName(self, value: str) -> str: ...
    @property
    def sortingOrder(self) -> int: ...
    @sortingOrder.setter
    def sortingOrder(self, value: int) -> int: ...
    @property
    def staticShadowCaster(self) -> bool: ...
    @staticShadowCaster.setter
    def staticShadowCaster(self, value: bool) -> bool: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useLightProbes(self) -> bool: ...
    @useLightProbes.setter
    def useLightProbes(self, value: bool) -> bool: ...
    @property
    def worldToLocalMatrix(self) -> Matrix4x4: ...


class BitStream:
    def __init__(self) -> None: ...
    @property
    def isReading(self) -> bool: ...
    @property
    def isWriting(self) -> bool: ...
    # Skipped Serialize due to it being static, abstract and generic.

    Serialize : Serialize_MethodGroup
    class Serialize_MethodGroup:
        @typing.overload
        def __call__(self, value: clr.Reference[float]) -> None:...
        @typing.overload
        def __call__(self, value: clr.Reference[str]) -> None:...
        # Method Serialize(value : Int16&) was skipped since it collides with above method
        # Method Serialize(value : Int32&) was skipped since it collides with above method
        # Method Serialize(value : Boolean&) was skipped since it collides with above method
        @typing.overload
        def __call__(self, value: clr.Reference[Quaternion]) -> None:...
        @typing.overload
        def __call__(self, value: clr.Reference[Vector3]) -> None:...
        @typing.overload
        def __call__(self, value: clr.Reference[NetworkPlayer]) -> None:...
        @typing.overload
        def __call__(self, viewID: clr.Reference[NetworkViewID]) -> None:...
        @typing.overload
        def __call__(self, value: clr.Reference[float], maxDelta: float) -> None:...
        @typing.overload
        def __call__(self, value: clr.Reference[Quaternion], maxDelta: float) -> None:...
        @typing.overload
        def __call__(self, value: clr.Reference[Vector3], maxDelta: float) -> None:...



class BlendShapeBufferRange:
    @property
    def endIndex(self) -> int: ...
    @endIndex.setter
    def endIndex(self, value: int) -> int: ...
    @property
    def startIndex(self) -> int: ...
    @startIndex.setter
    def startIndex(self, value: int) -> int: ...


class BlendWeights(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    OneBone : BlendWeights # 1
    TwoBones : BlendWeights # 2
    FourBones : BlendWeights # 4


class BodyDof(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    SpineFrontBack : BodyDof # 0
    SpineLeftRight : BodyDof # 1
    SpineRollLeftRight : BodyDof # 2
    ChestFrontBack : BodyDof # 3
    ChestLeftRight : BodyDof # 4
    ChestRollLeftRight : BodyDof # 5
    UpperChestFrontBack : BodyDof # 6
    UpperChestLeftRight : BodyDof # 7
    UpperChestRollLeftRight : BodyDof # 8
    LastBodyDof : BodyDof # 9


class BoneWeight(IEquatable_1[BoneWeight]):
    @property
    def boneIndex0(self) -> int: ...
    @boneIndex0.setter
    def boneIndex0(self, value: int) -> int: ...
    @property
    def boneIndex1(self) -> int: ...
    @boneIndex1.setter
    def boneIndex1(self, value: int) -> int: ...
    @property
    def boneIndex2(self) -> int: ...
    @boneIndex2.setter
    def boneIndex2(self, value: int) -> int: ...
    @property
    def boneIndex3(self) -> int: ...
    @boneIndex3.setter
    def boneIndex3(self, value: int) -> int: ...
    @property
    def weight0(self) -> float: ...
    @weight0.setter
    def weight0(self, value: float) -> float: ...
    @property
    def weight1(self) -> float: ...
    @weight1.setter
    def weight1(self, value: float) -> float: ...
    @property
    def weight2(self) -> float: ...
    @weight2.setter
    def weight2(self, value: float) -> float: ...
    @property
    def weight3(self) -> float: ...
    @weight3.setter
    def weight3(self, value: float) -> float: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, lhs: BoneWeight, rhs: BoneWeight) -> bool: ...
    def __ne__(self, lhs: BoneWeight, rhs: BoneWeight) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: BoneWeight) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...



class BoneWeight1(IEquatable_1[BoneWeight1]):
    @property
    def boneIndex(self) -> int: ...
    @boneIndex.setter
    def boneIndex(self, value: int) -> int: ...
    @property
    def weight(self) -> float: ...
    @weight.setter
    def weight(self, value: float) -> float: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, lhs: BoneWeight1, rhs: BoneWeight1) -> bool: ...
    def __ne__(self, lhs: BoneWeight1, rhs: BoneWeight1) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: BoneWeight1) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...



class BoundingSphere:
    @typing.overload
    def __init__(self, packedSphere: Vector4) -> None: ...
    @typing.overload
    def __init__(self, pos: Vector3, rad: float) -> None: ...
    position : Vector3
    radius : float


class Bounds(IFormattable, IEquatable_1[Bounds]):
    def __init__(self, center: Vector3, size: Vector3) -> None: ...
    @property
    def center(self) -> Vector3: ...
    @center.setter
    def center(self, value: Vector3) -> Vector3: ...
    @property
    def extents(self) -> Vector3: ...
    @extents.setter
    def extents(self, value: Vector3) -> Vector3: ...
    @property
    def max(self) -> Vector3: ...
    @max.setter
    def max(self, value: Vector3) -> Vector3: ...
    @property
    def min(self) -> Vector3: ...
    @min.setter
    def min(self, value: Vector3) -> Vector3: ...
    @property
    def size(self) -> Vector3: ...
    @size.setter
    def size(self, value: Vector3) -> Vector3: ...
    def ClosestPoint(self, point: Vector3) -> Vector3: ...
    def Contains(self, point: Vector3) -> bool: ...
    def GetHashCode(self) -> int: ...
    def Intersects(self, bounds: Bounds) -> bool: ...
    def __eq__(self, lhs: Bounds, rhs: Bounds) -> bool: ...
    def __ne__(self, lhs: Bounds, rhs: Bounds) -> bool: ...
    def SetMinMax(self, min: Vector3, max: Vector3) -> None: ...
    def SqrDistance(self, point: Vector3) -> float: ...
    # Skipped Encapsulate due to it being static, abstract and generic.

    Encapsulate : Encapsulate_MethodGroup
    class Encapsulate_MethodGroup:
        @typing.overload
        def __call__(self, bounds: Bounds) -> None:...
        @typing.overload
        def __call__(self, point: Vector3) -> None:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Bounds) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped Expand due to it being static, abstract and generic.

    Expand : Expand_MethodGroup
    class Expand_MethodGroup:
        @typing.overload
        def __call__(self, amount: float) -> None:...
        @typing.overload
        def __call__(self, amount: Vector3) -> None:...

    # Skipped IntersectRay due to it being static, abstract and generic.

    IntersectRay : IntersectRay_MethodGroup
    class IntersectRay_MethodGroup:
        @typing.overload
        def __call__(self, ray: Ray) -> bool:...
        @typing.overload
        def __call__(self, ray: Ray, distance: clr.Reference[float]) -> bool:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...



class BoundsInt(IFormattable, IEquatable_1[BoundsInt]):
    @typing.overload
    def __init__(self, position: Vector3Int, size: Vector3Int) -> None: ...
    @typing.overload
    def __init__(self, xMin: int, yMin: int, zMin: int, sizeX: int, sizeY: int, sizeZ: int) -> None: ...
    @property
    def allPositionsWithin(self) -> BoundsInt.PositionEnumerator: ...
    @property
    def center(self) -> Vector3: ...
    @property
    def max(self) -> Vector3Int: ...
    @max.setter
    def max(self, value: Vector3Int) -> Vector3Int: ...
    @property
    def min(self) -> Vector3Int: ...
    @min.setter
    def min(self, value: Vector3Int) -> Vector3Int: ...
    @property
    def position(self) -> Vector3Int: ...
    @position.setter
    def position(self, value: Vector3Int) -> Vector3Int: ...
    @property
    def size(self) -> Vector3Int: ...
    @size.setter
    def size(self, value: Vector3Int) -> Vector3Int: ...
    @property
    def x(self) -> int: ...
    @x.setter
    def x(self, value: int) -> int: ...
    @property
    def xMax(self) -> int: ...
    @xMax.setter
    def xMax(self, value: int) -> int: ...
    @property
    def xMin(self) -> int: ...
    @xMin.setter
    def xMin(self, value: int) -> int: ...
    @property
    def y(self) -> int: ...
    @y.setter
    def y(self, value: int) -> int: ...
    @property
    def yMax(self) -> int: ...
    @yMax.setter
    def yMax(self, value: int) -> int: ...
    @property
    def yMin(self) -> int: ...
    @yMin.setter
    def yMin(self, value: int) -> int: ...
    @property
    def z(self) -> int: ...
    @z.setter
    def z(self, value: int) -> int: ...
    @property
    def zMax(self) -> int: ...
    @zMax.setter
    def zMax(self, value: int) -> int: ...
    @property
    def zMin(self) -> int: ...
    @zMin.setter
    def zMin(self, value: int) -> int: ...
    def ClampToBounds(self, bounds: BoundsInt) -> None: ...
    def Contains(self, position: Vector3Int) -> bool: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, lhs: BoundsInt, rhs: BoundsInt) -> bool: ...
    def __ne__(self, lhs: BoundsInt, rhs: BoundsInt) -> bool: ...
    def SetMinMax(self, minPosition: Vector3Int, maxPosition: Vector3Int) -> None: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: BoundsInt) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...


    class PositionEnumerator(IEnumerator_1[Vector3Int]):
        def __init__(self, min: Vector3Int, max: Vector3Int) -> None: ...
        @property
        def Current(self) -> Vector3Int: ...
        def GetEnumerator(self) -> BoundsInt.PositionEnumerator: ...
        def MoveNext(self) -> bool: ...
        def Reset(self) -> None: ...



class BoxcastCommand:
    @typing.overload
    def __init__(self, center: Vector3, halfExtents: Vector3, orientation: Quaternion, direction: Vector3, distance: float = ..., layerMask: int = ...) -> None: ...
    @typing.overload
    def __init__(self, center: Vector3, halfExtents: Vector3, orientation: Quaternion, direction: Vector3, queryParameters: QueryParameters, distance: float = ...) -> None: ...
    @typing.overload
    def __init__(self, physicsScene: PhysicsScene, center: Vector3, halfExtents: Vector3, orientation: Quaternion, direction: Vector3, distance: float = ..., layerMask: int = ...) -> None: ...
    @typing.overload
    def __init__(self, physicsScene: PhysicsScene, center: Vector3, halfExtents: Vector3, orientation: Quaternion, direction: Vector3, queryParameters: QueryParameters, distance: float = ...) -> None: ...
    queryParameters : QueryParameters
    @property
    def center(self) -> Vector3: ...
    @center.setter
    def center(self, value: Vector3) -> Vector3: ...
    @property
    def direction(self) -> Vector3: ...
    @direction.setter
    def direction(self, value: Vector3) -> Vector3: ...
    @property
    def distance(self) -> float: ...
    @distance.setter
    def distance(self, value: float) -> float: ...
    @property
    def halfExtents(self) -> Vector3: ...
    @halfExtents.setter
    def halfExtents(self, value: Vector3) -> Vector3: ...
    @property
    def layerMask(self) -> int: ...
    @layerMask.setter
    def layerMask(self, value: int) -> int: ...
    @property
    def orientation(self) -> Quaternion: ...
    @orientation.setter
    def orientation(self, value: Quaternion) -> Quaternion: ...
    @property
    def physicsScene(self) -> PhysicsScene: ...
    @physicsScene.setter
    def physicsScene(self, value: PhysicsScene) -> PhysicsScene: ...
    # Skipped ScheduleBatch due to it being static, abstract and generic.

    ScheduleBatch : ScheduleBatch_MethodGroup
    class ScheduleBatch_MethodGroup:
        @typing.overload
        def __call__(self, commands: NativeArray_1[BoxcastCommand], results: NativeArray_1[RaycastHit], minCommandsPerJob: int, dependsOn: JobHandle = ...) -> JobHandle:...
        @typing.overload
        def __call__(self, commands: NativeArray_1[BoxcastCommand], results: NativeArray_1[RaycastHit], minCommandsPerJob: int, maxHits: int, dependsOn: JobHandle = ...) -> JobHandle:...



class BoxCollider(Collider):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedArticulationBody(self) -> ArticulationBody: ...
    @property
    def attachedRigidbody(self) -> Rigidbody: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def camera(self) -> Component: ...
    @property
    def center(self) -> Vector3: ...
    @center.setter
    def center(self, value: Vector3) -> Vector3: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def contactOffset(self) -> float: ...
    @contactOffset.setter
    def contactOffset(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def extents(self) -> Vector3: ...
    @extents.setter
    def extents(self, value: Vector3) -> Vector3: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hasModifiableContacts(self) -> bool: ...
    @hasModifiableContacts.setter
    def hasModifiableContacts(self, value: bool) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def isTrigger(self) -> bool: ...
    @isTrigger.setter
    def isTrigger(self, value: bool) -> bool: ...
    @property
    def layerOverridePriority(self) -> int: ...
    @layerOverridePriority.setter
    def layerOverridePriority(self, value: int) -> int: ...
    @property
    def light(self) -> Component: ...
    @property
    def material(self) -> PhysicMaterial: ...
    @material.setter
    def material(self, value: PhysicMaterial) -> PhysicMaterial: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def providesContacts(self) -> bool: ...
    @providesContacts.setter
    def providesContacts(self, value: bool) -> bool: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def sharedMaterial(self) -> PhysicMaterial: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: PhysicMaterial) -> PhysicMaterial: ...
    @property
    def size(self) -> Vector3: ...
    @size.setter
    def size(self, value: Vector3) -> Vector3: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class BoxCollider2D(Collider2D):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoTiling(self) -> bool: ...
    @autoTiling.setter
    def autoTiling(self, value: bool) -> bool: ...
    @property
    def bounciness(self) -> float: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def callbackLayers(self) -> LayerMask: ...
    @callbackLayers.setter
    def callbackLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def camera(self) -> Component: ...
    @property
    def center(self) -> Vector2: ...
    @center.setter
    def center(self, value: Vector2) -> Vector2: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def composite(self) -> CompositeCollider2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def contactCaptureLayers(self) -> LayerMask: ...
    @contactCaptureLayers.setter
    def contactCaptureLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def density(self) -> float: ...
    @density.setter
    def density(self, value: float) -> float: ...
    @property
    def edgeRadius(self) -> float: ...
    @edgeRadius.setter
    def edgeRadius(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def errorState(self) -> ColliderErrorState2D: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def forceReceiveLayers(self) -> LayerMask: ...
    @forceReceiveLayers.setter
    def forceReceiveLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def forceSendLayers(self) -> LayerMask: ...
    @forceSendLayers.setter
    def forceSendLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def friction(self) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def isTrigger(self) -> bool: ...
    @isTrigger.setter
    def isTrigger(self, value: bool) -> bool: ...
    @property
    def layerOverridePriority(self) -> int: ...
    @layerOverridePriority.setter
    def layerOverridePriority(self, value: int) -> int: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def offset(self) -> Vector2: ...
    @offset.setter
    def offset(self, value: Vector2) -> Vector2: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def shapeCount(self) -> int: ...
    @property
    def sharedMaterial(self) -> PhysicsMaterial2D: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: PhysicsMaterial2D) -> PhysicsMaterial2D: ...
    @property
    def size(self) -> Vector2: ...
    @size.setter
    def size(self, value: Vector2) -> Vector2: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def usedByComposite(self) -> bool: ...
    @usedByComposite.setter
    def usedByComposite(self, value: bool) -> bool: ...
    @property
    def usedByEffector(self) -> bool: ...
    @usedByEffector.setter
    def usedByEffector(self, value: bool) -> bool: ...


class BuildCompression:
    LZ4 : BuildCompression
    LZ4Runtime : BuildCompression
    LZMA : BuildCompression
    Uncompressed : BuildCompression
    UncompressedRuntime : BuildCompression
    @property
    def blockSize(self) -> int: ...
    @blockSize.setter
    def blockSize(self, value: int) -> int: ...
    @property
    def compression(self) -> CompressionType: ...
    @compression.setter
    def compression(self, value: CompressionType) -> CompressionType: ...
    @property
    def level(self) -> CompressionLevel: ...
    @level.setter
    def level(self, value: CompressionLevel) -> CompressionLevel: ...


class BuoyancyEffector2D(Effector2D):
    def __init__(self) -> None: ...
    @property
    def angularDrag(self) -> float: ...
    @angularDrag.setter
    def angularDrag(self, value: float) -> float: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def colliderMask(self) -> int: ...
    @colliderMask.setter
    def colliderMask(self, value: int) -> int: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def density(self) -> float: ...
    @density.setter
    def density(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def flowAngle(self) -> float: ...
    @flowAngle.setter
    def flowAngle(self, value: float) -> float: ...
    @property
    def flowMagnitude(self) -> float: ...
    @flowMagnitude.setter
    def flowMagnitude(self, value: float) -> float: ...
    @property
    def flowVariation(self) -> float: ...
    @flowVariation.setter
    def flowVariation(self, value: float) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def linearDrag(self) -> float: ...
    @linearDrag.setter
    def linearDrag(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def surfaceLevel(self) -> float: ...
    @surfaceLevel.setter
    def surfaceLevel(self, value: float) -> float: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useColliderMask(self) -> bool: ...
    @useColliderMask.setter
    def useColliderMask(self, value: bool) -> bool: ...


class Cache(IEquatable_1[Cache]):
    @property
    def expirationDelay(self) -> int: ...
    @expirationDelay.setter
    def expirationDelay(self, value: int) -> int: ...
    @property
    def index(self) -> int: ...
    @property
    def maximumAvailableStorageSpace(self) -> int: ...
    @maximumAvailableStorageSpace.setter
    def maximumAvailableStorageSpace(self, value: int) -> int: ...
    @property
    def path(self) -> str: ...
    @property
    def readOnly(self) -> bool: ...
    @property
    def ready(self) -> bool: ...
    @property
    def spaceFree(self) -> int: ...
    @property
    def spaceOccupied(self) -> int: ...
    @property
    def valid(self) -> bool: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, lhs: Cache, rhs: Cache) -> bool: ...
    def __ne__(self, lhs: Cache, rhs: Cache) -> bool: ...
    # Skipped ClearCache due to it being static, abstract and generic.

    ClearCache : ClearCache_MethodGroup
    class ClearCache_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, expiration: int) -> bool:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Cache) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...



class CachedAssetBundle:
    def __init__(self, name: str, hash: Hash128) -> None: ...
    @property
    def hash(self) -> Hash128: ...
    @hash.setter
    def hash(self, value: Hash128) -> Hash128: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...


class CacheIndex:
    bytesUsed : int
    expires : int
    name : str


class Caching:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def cacheCount(cls) -> int: ...
    @classmethod
    @property
    def compressionEnabled(cls) -> bool: ...
    @classmethod
    @compressionEnabled.setter
    def compressionEnabled(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def currentCacheForWriting(cls) -> Cache: ...
    @classmethod
    @currentCacheForWriting.setter
    def currentCacheForWriting(cls, value: Cache) -> Cache: ...
    @classmethod
    @property
    def defaultCache(cls) -> Cache: ...
    @classmethod
    @property
    def expirationDelay(cls) -> int: ...
    @classmethod
    @expirationDelay.setter
    def expirationDelay(cls, value: int) -> int: ...
    @classmethod
    @property
    def maximumAvailableDiskSpace(cls) -> int: ...
    @classmethod
    @maximumAvailableDiskSpace.setter
    def maximumAvailableDiskSpace(cls, value: int) -> int: ...
    @classmethod
    @property
    def ready(cls) -> bool: ...
    @classmethod
    @property
    def spaceAvailable(cls) -> int: ...
    @classmethod
    @property
    def spaceFree(cls) -> int: ...
    @classmethod
    @property
    def spaceOccupied(cls) -> int: ...
    @classmethod
    @property
    def spaceUsed(cls) -> int: ...
    @staticmethod
    def AddCache(cachePath: str) -> Cache: ...
    @staticmethod
    def CleanCache() -> bool: ...
    @staticmethod
    def ClearAllCachedVersions(assetBundleName: str) -> bool: ...
    @staticmethod
    def ClearCachedVersion(assetBundleName: str, hash: Hash128) -> bool: ...
    @staticmethod
    def ClearOtherCachedVersions(assetBundleName: str, hash: Hash128) -> bool: ...
    @staticmethod
    def GetAllCachePaths(cachePaths: List_1[str]) -> None: ...
    @staticmethod
    def GetCacheAt(cacheIndex: int) -> Cache: ...
    @staticmethod
    def GetCacheByPath(cachePath: str) -> Cache: ...
    @staticmethod
    def GetCachedVersions(assetBundleName: str, outCachedVersions: List_1[Hash128]) -> None: ...
    @staticmethod
    def GetVersionFromCache(url: str) -> int: ...
    @staticmethod
    def MoveCacheAfter(src: Cache, dst: Cache) -> None: ...
    @staticmethod
    def MoveCacheBefore(src: Cache, dst: Cache) -> None: ...
    @staticmethod
    def RemoveCache(cache: Cache) -> bool: ...
    # Skipped ClearCache due to it being static, abstract and generic.

    ClearCache : ClearCache_MethodGroup
    class ClearCache_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, expiration: int) -> bool:...

    # Skipped IsVersionCached due to it being static, abstract and generic.

    IsVersionCached : IsVersionCached_MethodGroup
    class IsVersionCached_MethodGroup:
        @typing.overload
        def __call__(self, cachedBundle: CachedAssetBundle) -> bool:...
        @typing.overload
        def __call__(self, url: str, version: int) -> bool:...
        @typing.overload
        def __call__(self, url: str, hash: Hash128) -> bool:...

    # Skipped MarkAsUsed due to it being static, abstract and generic.

    MarkAsUsed : MarkAsUsed_MethodGroup
    class MarkAsUsed_MethodGroup:
        @typing.overload
        def __call__(self, cachedBundle: CachedAssetBundle) -> bool:...
        @typing.overload
        def __call__(self, url: str, version: int) -> bool:...
        @typing.overload
        def __call__(self, url: str, hash: Hash128) -> bool:...

    # Skipped ResetNoBackupFlag due to it being static, abstract and generic.

    ResetNoBackupFlag : ResetNoBackupFlag_MethodGroup
    class ResetNoBackupFlag_MethodGroup:
        @typing.overload
        def __call__(self, cachedBundle: CachedAssetBundle) -> None:...
        @typing.overload
        def __call__(self, url: str, version: int) -> None:...
        @typing.overload
        def __call__(self, url: str, hash: Hash128) -> None:...

    # Skipped SetNoBackupFlag due to it being static, abstract and generic.

    SetNoBackupFlag : SetNoBackupFlag_MethodGroup
    class SetNoBackupFlag_MethodGroup:
        @typing.overload
        def __call__(self, cachedBundle: CachedAssetBundle) -> None:...
        @typing.overload
        def __call__(self, url: str, version: int) -> None:...
        @typing.overload
        def __call__(self, url: str, hash: Hash128) -> None:...



class Camera(Behaviour):
    def __init__(self) -> None: ...
    kMaxAperture : float
    kMaxBladeCount : int
    kMinAperture : float
    kMinBladeCount : int
    onPostRender : Camera.CameraCallback
    onPreCull : Camera.CameraCallback
    onPreRender : Camera.CameraCallback
    @property
    def activeTexture(self) -> RenderTexture: ...
    @property
    def actualRenderingPath(self) -> RenderingPath: ...
    @classmethod
    @property
    def allCameras(cls) -> Array_1[Camera]: ...
    @classmethod
    @property
    def allCamerasCount(cls) -> int: ...
    @property
    def allowDynamicResolution(self) -> bool: ...
    @allowDynamicResolution.setter
    def allowDynamicResolution(self, value: bool) -> bool: ...
    @property
    def allowHDR(self) -> bool: ...
    @allowHDR.setter
    def allowHDR(self, value: bool) -> bool: ...
    @property
    def allowMSAA(self) -> bool: ...
    @allowMSAA.setter
    def allowMSAA(self, value: bool) -> bool: ...
    @property
    def anamorphism(self) -> float: ...
    @anamorphism.setter
    def anamorphism(self, value: float) -> float: ...
    @property
    def animation(self) -> Component: ...
    @property
    def aperture(self) -> float: ...
    @aperture.setter
    def aperture(self, value: float) -> float: ...
    @property
    def areVRStereoViewMatricesWithinSingleCullTolerance(self) -> bool: ...
    @property
    def aspect(self) -> float: ...
    @aspect.setter
    def aspect(self, value: float) -> float: ...
    @property
    def audio(self) -> Component: ...
    @property
    def backgroundColor(self) -> Color: ...
    @backgroundColor.setter
    def backgroundColor(self, value: Color) -> Color: ...
    @property
    def barrelClipping(self) -> float: ...
    @barrelClipping.setter
    def barrelClipping(self, value: float) -> float: ...
    @property
    def bladeCount(self) -> int: ...
    @bladeCount.setter
    def bladeCount(self, value: int) -> int: ...
    @property
    def camera(self) -> Component: ...
    @property
    def cameraToWorldMatrix(self) -> Matrix4x4: ...
    @property
    def cameraType(self) -> CameraType: ...
    @cameraType.setter
    def cameraType(self, value: CameraType) -> CameraType: ...
    @property
    def clearFlags(self) -> CameraClearFlags: ...
    @clearFlags.setter
    def clearFlags(self, value: CameraClearFlags) -> CameraClearFlags: ...
    @property
    def clearStencilAfterLightingPass(self) -> bool: ...
    @clearStencilAfterLightingPass.setter
    def clearStencilAfterLightingPass(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def commandBufferCount(self) -> int: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def cullingMask(self) -> int: ...
    @cullingMask.setter
    def cullingMask(self, value: int) -> int: ...
    @property
    def cullingMatrix(self) -> Matrix4x4: ...
    @cullingMatrix.setter
    def cullingMatrix(self, value: Matrix4x4) -> Matrix4x4: ...
    @classmethod
    @property
    def current(cls) -> Camera: ...
    @property
    def curvature(self) -> Vector2: ...
    @curvature.setter
    def curvature(self, value: Vector2) -> Vector2: ...
    @property
    def depth(self) -> float: ...
    @depth.setter
    def depth(self, value: float) -> float: ...
    @property
    def depthTextureMode(self) -> DepthTextureMode: ...
    @depthTextureMode.setter
    def depthTextureMode(self, value: DepthTextureMode) -> DepthTextureMode: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def eventMask(self) -> int: ...
    @eventMask.setter
    def eventMask(self, value: int) -> int: ...
    @property
    def far(self) -> float: ...
    @far.setter
    def far(self, value: float) -> float: ...
    @property
    def farClipPlane(self) -> float: ...
    @farClipPlane.setter
    def farClipPlane(self, value: float) -> float: ...
    @property
    def fieldOfView(self) -> float: ...
    @fieldOfView.setter
    def fieldOfView(self, value: float) -> float: ...
    @property
    def focalLength(self) -> float: ...
    @focalLength.setter
    def focalLength(self, value: float) -> float: ...
    @property
    def focusDistance(self) -> float: ...
    @focusDistance.setter
    def focusDistance(self, value: float) -> float: ...
    @property
    def forceIntoRenderTexture(self) -> bool: ...
    @forceIntoRenderTexture.setter
    def forceIntoRenderTexture(self, value: bool) -> bool: ...
    @property
    def fov(self) -> float: ...
    @fov.setter
    def fov(self, value: float) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def gateFit(self) -> Camera.GateFitMode: ...
    @gateFit.setter
    def gateFit(self, value: Camera.GateFitMode) -> Camera.GateFitMode: ...
    @property
    def hdr(self) -> bool: ...
    @hdr.setter
    def hdr(self, value: bool) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def iso(self) -> int: ...
    @iso.setter
    def iso(self, value: int) -> int: ...
    @property
    def isOrthoGraphic(self) -> bool: ...
    @isOrthoGraphic.setter
    def isOrthoGraphic(self, value: bool) -> bool: ...
    @property
    def layerCullDistances(self) -> Array_1[float]: ...
    @layerCullDistances.setter
    def layerCullDistances(self, value: Array_1[float]) -> Array_1[float]: ...
    @property
    def layerCullSpherical(self) -> bool: ...
    @layerCullSpherical.setter
    def layerCullSpherical(self, value: bool) -> bool: ...
    @property
    def lensShift(self) -> Vector2: ...
    @lensShift.setter
    def lensShift(self, value: Vector2) -> Vector2: ...
    @property
    def light(self) -> Component: ...
    @classmethod
    @property
    def main(cls) -> Camera: ...
    @classmethod
    @property
    def mainCamera(cls) -> Camera: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def near(self) -> float: ...
    @near.setter
    def near(self, value: float) -> float: ...
    @property
    def nearClipPlane(self) -> float: ...
    @nearClipPlane.setter
    def nearClipPlane(self, value: float) -> float: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def nonJitteredProjectionMatrix(self) -> Matrix4x4: ...
    @nonJitteredProjectionMatrix.setter
    def nonJitteredProjectionMatrix(self, value: Matrix4x4) -> Matrix4x4: ...
    @property
    def opaqueSortMode(self) -> OpaqueSortMode: ...
    @opaqueSortMode.setter
    def opaqueSortMode(self, value: OpaqueSortMode) -> OpaqueSortMode: ...
    @property
    def orthographic(self) -> bool: ...
    @orthographic.setter
    def orthographic(self, value: bool) -> bool: ...
    @property
    def orthographicSize(self) -> float: ...
    @orthographicSize.setter
    def orthographicSize(self, value: float) -> float: ...
    @property
    def overrideSceneCullingMask(self) -> int: ...
    @overrideSceneCullingMask.setter
    def overrideSceneCullingMask(self, value: int) -> int: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def pixelHeight(self) -> int: ...
    @property
    def pixelRect(self) -> Rect: ...
    @pixelRect.setter
    def pixelRect(self, value: Rect) -> Rect: ...
    @property
    def pixelWidth(self) -> int: ...
    @property
    def previousViewProjectionMatrix(self) -> Matrix4x4: ...
    @property
    def projectionMatrix(self) -> Matrix4x4: ...
    @projectionMatrix.setter
    def projectionMatrix(self, value: Matrix4x4) -> Matrix4x4: ...
    @property
    def rect(self) -> Rect: ...
    @rect.setter
    def rect(self, value: Rect) -> Rect: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def renderingPath(self) -> RenderingPath: ...
    @renderingPath.setter
    def renderingPath(self, value: RenderingPath) -> RenderingPath: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def scaledPixelHeight(self) -> int: ...
    @property
    def scaledPixelWidth(self) -> int: ...
    @property
    def scene(self) -> Scene: ...
    @scene.setter
    def scene(self, value: Scene) -> Scene: ...
    @property
    def sceneViewFilterMode(self) -> Camera.SceneViewFilterMode: ...
    @property
    def sensorSize(self) -> Vector2: ...
    @sensorSize.setter
    def sensorSize(self, value: Vector2) -> Vector2: ...
    @property
    def shutterSpeed(self) -> float: ...
    @shutterSpeed.setter
    def shutterSpeed(self, value: float) -> float: ...
    @property
    def stereoActiveEye(self) -> Camera.MonoOrStereoscopicEye: ...
    @property
    def stereoConvergence(self) -> float: ...
    @stereoConvergence.setter
    def stereoConvergence(self, value: float) -> float: ...
    @property
    def stereoEnabled(self) -> bool: ...
    @property
    def stereoMirrorMode(self) -> bool: ...
    @stereoMirrorMode.setter
    def stereoMirrorMode(self, value: bool) -> bool: ...
    @property
    def stereoSeparation(self) -> float: ...
    @stereoSeparation.setter
    def stereoSeparation(self, value: float) -> float: ...
    @property
    def stereoTargetEye(self) -> StereoTargetEyeMask: ...
    @stereoTargetEye.setter
    def stereoTargetEye(self, value: StereoTargetEyeMask) -> StereoTargetEyeMask: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def targetDisplay(self) -> int: ...
    @targetDisplay.setter
    def targetDisplay(self, value: int) -> int: ...
    @property
    def targetTexture(self) -> RenderTexture: ...
    @targetTexture.setter
    def targetTexture(self, value: RenderTexture) -> RenderTexture: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def transparencySortAxis(self) -> Vector3: ...
    @transparencySortAxis.setter
    def transparencySortAxis(self, value: Vector3) -> Vector3: ...
    @property
    def transparencySortMode(self) -> TransparencySortMode: ...
    @transparencySortMode.setter
    def transparencySortMode(self, value: TransparencySortMode) -> TransparencySortMode: ...
    @property
    def useJitteredProjectionMatrixForTransparentRendering(self) -> bool: ...
    @useJitteredProjectionMatrixForTransparentRendering.setter
    def useJitteredProjectionMatrixForTransparentRendering(self, value: bool) -> bool: ...
    @property
    def useOcclusionCulling(self) -> bool: ...
    @useOcclusionCulling.setter
    def useOcclusionCulling(self, value: bool) -> bool: ...
    @property
    def usePhysicalProperties(self) -> bool: ...
    @usePhysicalProperties.setter
    def usePhysicalProperties(self, value: bool) -> bool: ...
    @property
    def velocity(self) -> Vector3: ...
    @property
    def worldToCameraMatrix(self) -> Matrix4x4: ...
    @worldToCameraMatrix.setter
    def worldToCameraMatrix(self, value: Matrix4x4) -> Matrix4x4: ...
    def AddCommandBuffer(self, evt: CameraEvent, buffer: CommandBuffer) -> None: ...
    def AddCommandBufferAsync(self, evt: CameraEvent, buffer: CommandBuffer, queueType: ComputeQueueType) -> None: ...
    def CalculateFrustumCorners(self, viewport: Rect, z: float, eye: Camera.MonoOrStereoscopicEye, outCorners: Array_1[Vector3]) -> None: ...
    def CalculateObliqueMatrix(self, clipPlane: Vector4) -> Matrix4x4: ...
    @staticmethod
    def CalculateProjectionMatrixFromPhysicalProperties(output: clr.Reference[Matrix4x4], focalLength: float, sensorSize: Vector2, lensShift: Vector2, nearClip: float, farClip: float, gateFitParameters: Camera.GateFitParameters = ...) -> None: ...
    def CopyFrom(self, other: Camera) -> None: ...
    def CopyStereoDeviceProjectionMatrixToNonJittered(self, eye: Camera.StereoscopicEye) -> None: ...
    def DoClear(self) -> None: ...
    @staticmethod
    def FieldOfViewToFocalLength(fieldOfView: float, sensorSize: float) -> float: ...
    @staticmethod
    def FocalLengthToFieldOfView(focalLength: float, sensorSize: float) -> float: ...
    @staticmethod
    def GetAllCameras(cameras: Array_1[Camera]) -> int: ...
    def GetCommandBuffers(self, evt: CameraEvent) -> Array_1[CommandBuffer]: ...
    def GetGateFittedFieldOfView(self) -> float: ...
    def GetGateFittedLensShift(self) -> Vector2: ...
    def GetScreenHeight(self) -> float: ...
    def GetScreenWidth(self) -> float: ...
    def GetStereoNonJitteredProjectionMatrix(self, eye: Camera.StereoscopicEye) -> Matrix4x4: ...
    def GetStereoProjectionMatrices(self) -> Array_1[Matrix4x4]: ...
    def GetStereoProjectionMatrix(self, eye: Camera.StereoscopicEye) -> Matrix4x4: ...
    def GetStereoViewMatrices(self) -> Array_1[Matrix4x4]: ...
    def GetStereoViewMatrix(self, eye: Camera.StereoscopicEye) -> Matrix4x4: ...
    @staticmethod
    def HorizontalToVerticalFieldOfView(horizontalFieldOfView: float, aspectRatio: float) -> float: ...
    def RemoveAllCommandBuffers(self) -> None: ...
    def RemoveCommandBuffer(self, evt: CameraEvent, buffer: CommandBuffer) -> None: ...
    def RemoveCommandBuffers(self, evt: CameraEvent) -> None: ...
    def Render(self) -> None: ...
    def RenderDontRestore(self) -> None: ...
    def RenderWithShader(self, shader: Shader, replacementTag: str) -> None: ...
    def Reset(self) -> None: ...
    def ResetAspect(self) -> None: ...
    def ResetCullingMatrix(self) -> None: ...
    def ResetFieldOfView(self) -> None: ...
    def ResetProjectionMatrix(self) -> None: ...
    def ResetReplacementShader(self) -> None: ...
    def ResetStereoProjectionMatrices(self) -> None: ...
    def ResetStereoViewMatrices(self) -> None: ...
    def ResetTransparencySortSettings(self) -> None: ...
    def ResetWorldToCameraMatrix(self) -> None: ...
    def ScreenToViewportPoint(self, position: Vector3) -> Vector3: ...
    def SetReplacementShader(self, shader: Shader, replacementTag: str) -> None: ...
    def SetStereoProjectionMatrices(self, leftMatrix: Matrix4x4, rightMatrix: Matrix4x4) -> None: ...
    def SetStereoProjectionMatrix(self, eye: Camera.StereoscopicEye, matrix: Matrix4x4) -> None: ...
    def SetStereoViewMatrices(self, leftMatrix: Matrix4x4, rightMatrix: Matrix4x4) -> None: ...
    def SetStereoViewMatrix(self, eye: Camera.StereoscopicEye, matrix: Matrix4x4) -> None: ...
    @staticmethod
    def SetupCurrent(cur: Camera) -> None: ...
    def SubmitRenderRequests(self, renderRequests: List_1[Camera.RenderRequest]) -> None: ...
    @staticmethod
    def VerticalToHorizontalFieldOfView(verticalFieldOfView: float, aspectRatio: float) -> float: ...
    def ViewportToScreenPoint(self, position: Vector3) -> Vector3: ...
    # Skipped RenderToCubemap due to it being static, abstract and generic.

    RenderToCubemap : RenderToCubemap_MethodGroup
    class RenderToCubemap_MethodGroup:
        @typing.overload
        def __call__(self, cubemap: Cubemap) -> bool:...
        @typing.overload
        def __call__(self, cubemap: RenderTexture) -> bool:...
        @typing.overload
        def __call__(self, cubemap: Cubemap, faceMask: int) -> bool:...
        @typing.overload
        def __call__(self, cubemap: RenderTexture, faceMask: int) -> bool:...
        @typing.overload
        def __call__(self, cubemap: RenderTexture, faceMask: int, stereoEye: Camera.MonoOrStereoscopicEye) -> bool:...

    # Skipped ScreenPointToRay due to it being static, abstract and generic.

    ScreenPointToRay : ScreenPointToRay_MethodGroup
    class ScreenPointToRay_MethodGroup:
        @typing.overload
        def __call__(self, pos: Vector3) -> Ray:...
        @typing.overload
        def __call__(self, pos: Vector3, eye: Camera.MonoOrStereoscopicEye) -> Ray:...

    # Skipped ScreenToWorldPoint due to it being static, abstract and generic.

    ScreenToWorldPoint : ScreenToWorldPoint_MethodGroup
    class ScreenToWorldPoint_MethodGroup:
        @typing.overload
        def __call__(self, position: Vector3) -> Vector3:...
        @typing.overload
        def __call__(self, position: Vector3, eye: Camera.MonoOrStereoscopicEye) -> Vector3:...

    # Skipped SetTargetBuffers due to it being static, abstract and generic.

    SetTargetBuffers : SetTargetBuffers_MethodGroup
    class SetTargetBuffers_MethodGroup:
        @typing.overload
        def __call__(self, colorBuffer: Array_1[RenderBuffer], depthBuffer: RenderBuffer) -> None:...
        @typing.overload
        def __call__(self, colorBuffer: RenderBuffer, depthBuffer: RenderBuffer) -> None:...

    # Skipped SubmitRenderRequest due to it being static, abstract and generic.

    SubmitRenderRequest : SubmitRenderRequest_MethodGroup
    class SubmitRenderRequest_MethodGroup:
        def __getitem__(self, t:typing.Type[SubmitRenderRequest_1_T1]) -> SubmitRenderRequest_1[SubmitRenderRequest_1_T1]: ...

        SubmitRenderRequest_1_T1 = typing.TypeVar('SubmitRenderRequest_1_T1')
        class SubmitRenderRequest_1(typing.Generic[SubmitRenderRequest_1_T1]):
            SubmitRenderRequest_1_RequestData = Camera.SubmitRenderRequest_MethodGroup.SubmitRenderRequest_1_T1
            def __call__(self, renderRequest: SubmitRenderRequest_1_RequestData) -> None:...


    # Skipped TryGetCullingParameters due to it being static, abstract and generic.

    TryGetCullingParameters : TryGetCullingParameters_MethodGroup
    class TryGetCullingParameters_MethodGroup:
        @typing.overload
        def __call__(self, cullingParameters: clr.Reference[ScriptableCullingParameters]) -> bool:...
        @typing.overload
        def __call__(self, stereoAware: bool, cullingParameters: clr.Reference[ScriptableCullingParameters]) -> bool:...

    # Skipped ViewportPointToRay due to it being static, abstract and generic.

    ViewportPointToRay : ViewportPointToRay_MethodGroup
    class ViewportPointToRay_MethodGroup:
        @typing.overload
        def __call__(self, pos: Vector3) -> Ray:...
        @typing.overload
        def __call__(self, pos: Vector3, eye: Camera.MonoOrStereoscopicEye) -> Ray:...

    # Skipped ViewportToWorldPoint due to it being static, abstract and generic.

    ViewportToWorldPoint : ViewportToWorldPoint_MethodGroup
    class ViewportToWorldPoint_MethodGroup:
        @typing.overload
        def __call__(self, position: Vector3) -> Vector3:...
        @typing.overload
        def __call__(self, position: Vector3, eye: Camera.MonoOrStereoscopicEye) -> Vector3:...

    # Skipped WorldToScreenPoint due to it being static, abstract and generic.

    WorldToScreenPoint : WorldToScreenPoint_MethodGroup
    class WorldToScreenPoint_MethodGroup:
        @typing.overload
        def __call__(self, position: Vector3) -> Vector3:...
        @typing.overload
        def __call__(self, position: Vector3, eye: Camera.MonoOrStereoscopicEye) -> Vector3:...

    # Skipped WorldToViewportPoint due to it being static, abstract and generic.

    WorldToViewportPoint : WorldToViewportPoint_MethodGroup
    class WorldToViewportPoint_MethodGroup:
        @typing.overload
        def __call__(self, position: Vector3) -> Vector3:...
        @typing.overload
        def __call__(self, position: Vector3, eye: Camera.MonoOrStereoscopicEye) -> Vector3:...


    class CameraCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, cam: Camera, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, cam: Camera) -> None: ...


    class FieldOfViewAxis(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Vertical : Camera.FieldOfViewAxis # 0
        Horizontal : Camera.FieldOfViewAxis # 1


    class GateFitMode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        None_ : Camera.GateFitMode # 0
        Vertical : Camera.GateFitMode # 1
        Horizontal : Camera.GateFitMode # 2
        Fill : Camera.GateFitMode # 3
        Overscan : Camera.GateFitMode # 4


    class GateFitParameters:
        def __init__(self, mode: Camera.GateFitMode, aspect: float) -> None: ...
        @property
        def aspect(self) -> float: ...
        @aspect.setter
        def aspect(self, value: float) -> float: ...
        @property
        def mode(self) -> Camera.GateFitMode: ...
        @mode.setter
        def mode(self, value: Camera.GateFitMode) -> Camera.GateFitMode: ...


    class MonoOrStereoscopicEye(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Left : Camera.MonoOrStereoscopicEye # 0
        Right : Camera.MonoOrStereoscopicEye # 1
        Mono : Camera.MonoOrStereoscopicEye # 2


    class RenderRequest:
        @typing.overload
        def __init__(self, mode: Camera.RenderRequestMode, rt: RenderTexture) -> None: ...
        @typing.overload
        def __init__(self, mode: Camera.RenderRequestMode, space: Camera.RenderRequestOutputSpace, rt: RenderTexture) -> None: ...
        @property
        def isValid(self) -> bool: ...
        @property
        def mode(self) -> Camera.RenderRequestMode: ...
        @property
        def outputSpace(self) -> Camera.RenderRequestOutputSpace: ...
        @property
        def result(self) -> RenderTexture: ...


    class RenderRequestMode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        None_ : Camera.RenderRequestMode # 0
        ObjectId : Camera.RenderRequestMode # 1
        Depth : Camera.RenderRequestMode # 2
        VertexNormal : Camera.RenderRequestMode # 3
        WorldPosition : Camera.RenderRequestMode # 4
        EntityId : Camera.RenderRequestMode # 5
        BaseColor : Camera.RenderRequestMode # 6
        SpecularColor : Camera.RenderRequestMode # 7
        Metallic : Camera.RenderRequestMode # 8
        Emission : Camera.RenderRequestMode # 9
        Normal : Camera.RenderRequestMode # 10
        Smoothness : Camera.RenderRequestMode # 11
        Occlusion : Camera.RenderRequestMode # 12
        DiffuseColor : Camera.RenderRequestMode # 13


    class RenderRequestOutputSpace(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        UV0 : Camera.RenderRequestOutputSpace # 0
        UV1 : Camera.RenderRequestOutputSpace # 1
        UV2 : Camera.RenderRequestOutputSpace # 2
        UV3 : Camera.RenderRequestOutputSpace # 3
        UV4 : Camera.RenderRequestOutputSpace # 4
        UV5 : Camera.RenderRequestOutputSpace # 5
        UV6 : Camera.RenderRequestOutputSpace # 6
        UV7 : Camera.RenderRequestOutputSpace # 7
        UV8 : Camera.RenderRequestOutputSpace # 8
        ScreenSpace : Camera.RenderRequestOutputSpace # -1


    class SceneViewFilterMode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Off : Camera.SceneViewFilterMode # 0
        ShowFiltered : Camera.SceneViewFilterMode # 1


    class StereoscopicEye(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Left : Camera.StereoscopicEye # 0
        Right : Camera.StereoscopicEye # 1



class CameraClearFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Skybox : CameraClearFlags # 1
    Color : CameraClearFlags # 2
    SolidColor : CameraClearFlags # 2
    Depth : CameraClearFlags # 3
    Nothing : CameraClearFlags # 4


class CameraType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Game : CameraType # 1
    SceneView : CameraType # 2
    Preview : CameraType # 4
    VR : CameraType # 8
    Reflection : CameraType # 16


class Canvas(Behaviour):
    def __init__(self) -> None: ...
    @property
    def additionalShaderChannels(self) -> AdditionalCanvasShaderChannels: ...
    @additionalShaderChannels.setter
    def additionalShaderChannels(self, value: AdditionalCanvasShaderChannels) -> AdditionalCanvasShaderChannels: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def cachedSortingLayerValue(self) -> int: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def isRootCanvas(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def normalizedSortingGridSize(self) -> float: ...
    @normalizedSortingGridSize.setter
    def normalizedSortingGridSize(self, value: float) -> float: ...
    @property
    def overridePixelPerfect(self) -> bool: ...
    @overridePixelPerfect.setter
    def overridePixelPerfect(self, value: bool) -> bool: ...
    @property
    def overrideSorting(self) -> bool: ...
    @overrideSorting.setter
    def overrideSorting(self, value: bool) -> bool: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def pixelPerfect(self) -> bool: ...
    @pixelPerfect.setter
    def pixelPerfect(self, value: bool) -> bool: ...
    @property
    def pixelRect(self) -> Rect: ...
    @property
    def planeDistance(self) -> float: ...
    @planeDistance.setter
    def planeDistance(self, value: float) -> float: ...
    @property
    def referencePixelsPerUnit(self) -> float: ...
    @referencePixelsPerUnit.setter
    def referencePixelsPerUnit(self, value: float) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def renderingDisplaySize(self) -> Vector2: ...
    @property
    def renderMode(self) -> RenderMode: ...
    @renderMode.setter
    def renderMode(self, value: RenderMode) -> RenderMode: ...
    @property
    def renderOrder(self) -> int: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def rootCanvas(self) -> Canvas: ...
    @property
    def scaleFactor(self) -> float: ...
    @scaleFactor.setter
    def scaleFactor(self, value: float) -> float: ...
    @property
    def sortingGridNormalizedSize(self) -> int: ...
    @sortingGridNormalizedSize.setter
    def sortingGridNormalizedSize(self, value: int) -> int: ...
    @property
    def sortingLayerID(self) -> int: ...
    @sortingLayerID.setter
    def sortingLayerID(self, value: int) -> int: ...
    @property
    def sortingLayerName(self) -> str: ...
    @sortingLayerName.setter
    def sortingLayerName(self, value: str) -> str: ...
    @property
    def sortingOrder(self) -> int: ...
    @sortingOrder.setter
    def sortingOrder(self, value: int) -> int: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def targetDisplay(self) -> int: ...
    @targetDisplay.setter
    def targetDisplay(self, value: int) -> int: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def updateRectTransformForStandalone(self) -> StandaloneRenderResize: ...
    @updateRectTransformForStandalone.setter
    def updateRectTransformForStandalone(self, value: StandaloneRenderResize) -> StandaloneRenderResize: ...
    @property
    def vertexColorAlwaysGammaSpace(self) -> bool: ...
    @vertexColorAlwaysGammaSpace.setter
    def vertexColorAlwaysGammaSpace(self, value: bool) -> bool: ...
    @property
    def worldCamera(self) -> Camera: ...
    @worldCamera.setter
    def worldCamera(self, value: Camera) -> Camera: ...
    @staticmethod
    def ForceUpdateCanvases() -> None: ...
    @staticmethod
    def GetDefaultCanvasMaterial() -> Material: ...
    @staticmethod
    def GetDefaultCanvasTextMaterial() -> Material: ...
    @staticmethod
    def GetETC1SupportedCanvasMaterial() -> Material: ...

    class WillRenderCanvases(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self) -> None: ...



class CanvasGroup(Behaviour, ICanvasRaycastFilter):
    def __init__(self) -> None: ...
    @property
    def alpha(self) -> float: ...
    @alpha.setter
    def alpha(self, value: float) -> float: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def blocksRaycasts(self) -> bool: ...
    @blocksRaycasts.setter
    def blocksRaycasts(self, value: bool) -> bool: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def ignoreParentGroups(self) -> bool: ...
    @ignoreParentGroups.setter
    def ignoreParentGroups(self, value: bool) -> bool: ...
    @property
    def interactable(self) -> bool: ...
    @interactable.setter
    def interactable(self, value: bool) -> bool: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    def IsRaycastLocationValid(self, sp: Vector2, eventCamera: Camera) -> bool: ...


class CanvasRenderer(Component):
    def __init__(self) -> None: ...
    @property
    def absoluteDepth(self) -> int: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def clippingSoftness(self) -> Vector2: ...
    @clippingSoftness.setter
    def clippingSoftness(self, value: Vector2) -> Vector2: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def cull(self) -> bool: ...
    @cull.setter
    def cull(self, value: bool) -> bool: ...
    @property
    def cullTransparentMesh(self) -> bool: ...
    @cullTransparentMesh.setter
    def cullTransparentMesh(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hasMoved(self) -> bool: ...
    @property
    def hasPopInstruction(self) -> bool: ...
    @hasPopInstruction.setter
    def hasPopInstruction(self, value: bool) -> bool: ...
    @property
    def hasRectClipping(self) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isMask(self) -> bool: ...
    @isMask.setter
    def isMask(self, value: bool) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def materialCount(self) -> int: ...
    @materialCount.setter
    def materialCount(self, value: int) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def popMaterialCount(self) -> int: ...
    @popMaterialCount.setter
    def popMaterialCount(self, value: int) -> int: ...
    @property
    def relativeDepth(self) -> int: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    def Clear(self) -> None: ...
    def DisableRectClipping(self) -> None: ...
    def EnableRectClipping(self, rect: Rect) -> None: ...
    def GetAlpha(self) -> float: ...
    def GetColor(self) -> Color: ...
    def GetInheritedAlpha(self) -> float: ...
    def GetMesh(self) -> Mesh: ...
    def GetPopMaterial(self, index: int) -> Material: ...
    def SetAlpha(self, alpha: float) -> None: ...
    def SetAlphaTexture(self, texture: Texture) -> None: ...
    def SetColor(self, color: Color) -> None: ...
    def SetMesh(self, mesh: Mesh) -> None: ...
    def SetPopMaterial(self, material: Material, index: int) -> None: ...
    def SetTexture(self, texture: Texture) -> None: ...
    # Skipped AddUIVertexStream due to it being static, abstract and generic.

    AddUIVertexStream : AddUIVertexStream_MethodGroup
    class AddUIVertexStream_MethodGroup:
        @typing.overload
        def __call__(self, verts: List_1[UIVertex], positions: List_1[Vector3], colors: List_1[Color32], uv0S: List_1[Vector4], uv1S: List_1[Vector4], normals: List_1[Vector3], tangents: List_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, verts: List_1[UIVertex], positions: List_1[Vector3], colors: List_1[Color32], uv0S: List_1[Vector4], uv1S: List_1[Vector4], uv2S: List_1[Vector4], uv3S: List_1[Vector4], normals: List_1[Vector3], tangents: List_1[Vector4]) -> None:...

    # Skipped CreateUIVertexStream due to it being static, abstract and generic.

    CreateUIVertexStream : CreateUIVertexStream_MethodGroup
    class CreateUIVertexStream_MethodGroup:
        @typing.overload
        def __call__(self, verts: List_1[UIVertex], positions: List_1[Vector3], colors: List_1[Color32], uv0S: List_1[Vector4], uv1S: List_1[Vector4], normals: List_1[Vector3], tangents: List_1[Vector4], indices: List_1[int]) -> None:...
        @typing.overload
        def __call__(self, verts: List_1[UIVertex], positions: List_1[Vector3], colors: List_1[Color32], uv0S: List_1[Vector4], uv1S: List_1[Vector4], uv2S: List_1[Vector4], uv3S: List_1[Vector4], normals: List_1[Vector3], tangents: List_1[Vector4], indices: List_1[int]) -> None:...

    # Skipped GetMaterial due to it being static, abstract and generic.

    GetMaterial : GetMaterial_MethodGroup
    class GetMaterial_MethodGroup:
        @typing.overload
        def __call__(self) -> Material:...
        @typing.overload
        def __call__(self, index: int) -> Material:...

    # Skipped SetMaterial due to it being static, abstract and generic.

    SetMaterial : SetMaterial_MethodGroup
    class SetMaterial_MethodGroup:
        @typing.overload
        def __call__(self, material: Material, index: int) -> None:...
        @typing.overload
        def __call__(self, material: Material, texture: Texture) -> None:...

    # Skipped SetVertices due to it being static, abstract and generic.

    SetVertices : SetVertices_MethodGroup
    class SetVertices_MethodGroup:
        @typing.overload
        def __call__(self, vertices: List_1[UIVertex]) -> None:...
        @typing.overload
        def __call__(self, vertices: Array_1[UIVertex], size: int) -> None:...

    # Skipped SplitUIVertexStreams due to it being static, abstract and generic.

    SplitUIVertexStreams : SplitUIVertexStreams_MethodGroup
    class SplitUIVertexStreams_MethodGroup:
        @typing.overload
        def __call__(self, verts: List_1[UIVertex], positions: List_1[Vector3], colors: List_1[Color32], uv0S: List_1[Vector4], uv1S: List_1[Vector4], normals: List_1[Vector3], tangents: List_1[Vector4], indices: List_1[int]) -> None:...
        @typing.overload
        def __call__(self, verts: List_1[UIVertex], positions: List_1[Vector3], colors: List_1[Color32], uv0S: List_1[Vector4], uv1S: List_1[Vector4], uv2S: List_1[Vector4], uv3S: List_1[Vector4], normals: List_1[Vector3], tangents: List_1[Vector4], indices: List_1[int]) -> None:...


    class OnRequestRebuild(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self) -> None: ...



class CapsulecastCommand:
    @typing.overload
    def __init__(self, p1: Vector3, p2: Vector3, radius: float, direction: Vector3, distance: float = ..., layerMask: int = ...) -> None: ...
    @typing.overload
    def __init__(self, p1: Vector3, p2: Vector3, radius: float, direction: Vector3, queryParameters: QueryParameters, distance: float = ...) -> None: ...
    @typing.overload
    def __init__(self, physicsScene: PhysicsScene, p1: Vector3, p2: Vector3, radius: float, direction: Vector3, distance: float = ..., layerMask: int = ...) -> None: ...
    @typing.overload
    def __init__(self, physicsScene: PhysicsScene, p1: Vector3, p2: Vector3, radius: float, direction: Vector3, queryParameters: QueryParameters, distance: float = ...) -> None: ...
    queryParameters : QueryParameters
    @property
    def direction(self) -> Vector3: ...
    @direction.setter
    def direction(self, value: Vector3) -> Vector3: ...
    @property
    def distance(self) -> float: ...
    @distance.setter
    def distance(self, value: float) -> float: ...
    @property
    def layerMask(self) -> int: ...
    @layerMask.setter
    def layerMask(self, value: int) -> int: ...
    @property
    def physicsScene(self) -> PhysicsScene: ...
    @physicsScene.setter
    def physicsScene(self, value: PhysicsScene) -> PhysicsScene: ...
    @property
    def point1(self) -> Vector3: ...
    @point1.setter
    def point1(self, value: Vector3) -> Vector3: ...
    @property
    def point2(self) -> Vector3: ...
    @point2.setter
    def point2(self, value: Vector3) -> Vector3: ...
    @property
    def radius(self) -> float: ...
    @radius.setter
    def radius(self, value: float) -> float: ...
    # Skipped ScheduleBatch due to it being static, abstract and generic.

    ScheduleBatch : ScheduleBatch_MethodGroup
    class ScheduleBatch_MethodGroup:
        @typing.overload
        def __call__(self, commands: NativeArray_1[CapsulecastCommand], results: NativeArray_1[RaycastHit], minCommandsPerJob: int, dependsOn: JobHandle = ...) -> JobHandle:...
        @typing.overload
        def __call__(self, commands: NativeArray_1[CapsulecastCommand], results: NativeArray_1[RaycastHit], minCommandsPerJob: int, maxHits: int, dependsOn: JobHandle = ...) -> JobHandle:...



class CapsuleCollider(Collider):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedArticulationBody(self) -> ArticulationBody: ...
    @property
    def attachedRigidbody(self) -> Rigidbody: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def camera(self) -> Component: ...
    @property
    def center(self) -> Vector3: ...
    @center.setter
    def center(self, value: Vector3) -> Vector3: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def contactOffset(self) -> float: ...
    @contactOffset.setter
    def contactOffset(self, value: float) -> float: ...
    @property
    def direction(self) -> int: ...
    @direction.setter
    def direction(self, value: int) -> int: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hasModifiableContacts(self) -> bool: ...
    @hasModifiableContacts.setter
    def hasModifiableContacts(self, value: bool) -> bool: ...
    @property
    def height(self) -> float: ...
    @height.setter
    def height(self, value: float) -> float: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def isTrigger(self) -> bool: ...
    @isTrigger.setter
    def isTrigger(self, value: bool) -> bool: ...
    @property
    def layerOverridePriority(self) -> int: ...
    @layerOverridePriority.setter
    def layerOverridePriority(self, value: int) -> int: ...
    @property
    def light(self) -> Component: ...
    @property
    def material(self) -> PhysicMaterial: ...
    @material.setter
    def material(self, value: PhysicMaterial) -> PhysicMaterial: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def providesContacts(self) -> bool: ...
    @providesContacts.setter
    def providesContacts(self, value: bool) -> bool: ...
    @property
    def radius(self) -> float: ...
    @radius.setter
    def radius(self, value: float) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def sharedMaterial(self) -> PhysicMaterial: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: PhysicMaterial) -> PhysicMaterial: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class CapsuleCollider2D(Collider2D):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounciness(self) -> float: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def callbackLayers(self) -> LayerMask: ...
    @callbackLayers.setter
    def callbackLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def composite(self) -> CompositeCollider2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def contactCaptureLayers(self) -> LayerMask: ...
    @contactCaptureLayers.setter
    def contactCaptureLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def density(self) -> float: ...
    @density.setter
    def density(self, value: float) -> float: ...
    @property
    def direction(self) -> CapsuleDirection2D: ...
    @direction.setter
    def direction(self, value: CapsuleDirection2D) -> CapsuleDirection2D: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def errorState(self) -> ColliderErrorState2D: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def forceReceiveLayers(self) -> LayerMask: ...
    @forceReceiveLayers.setter
    def forceReceiveLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def forceSendLayers(self) -> LayerMask: ...
    @forceSendLayers.setter
    def forceSendLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def friction(self) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def isTrigger(self) -> bool: ...
    @isTrigger.setter
    def isTrigger(self, value: bool) -> bool: ...
    @property
    def layerOverridePriority(self) -> int: ...
    @layerOverridePriority.setter
    def layerOverridePriority(self, value: int) -> int: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def offset(self) -> Vector2: ...
    @offset.setter
    def offset(self, value: Vector2) -> Vector2: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def shapeCount(self) -> int: ...
    @property
    def sharedMaterial(self) -> PhysicsMaterial2D: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: PhysicsMaterial2D) -> PhysicsMaterial2D: ...
    @property
    def size(self) -> Vector2: ...
    @size.setter
    def size(self, value: Vector2) -> Vector2: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def usedByComposite(self) -> bool: ...
    @usedByComposite.setter
    def usedByComposite(self, value: bool) -> bool: ...
    @property
    def usedByEffector(self) -> bool: ...
    @usedByEffector.setter
    def usedByEffector(self, value: bool) -> bool: ...


class CapsuleDirection2D(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Vertical : CapsuleDirection2D # 0
    Horizontal : CapsuleDirection2D # 1


class CharacterController(Collider):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedArticulationBody(self) -> ArticulationBody: ...
    @property
    def attachedRigidbody(self) -> Rigidbody: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def camera(self) -> Component: ...
    @property
    def center(self) -> Vector3: ...
    @center.setter
    def center(self, value: Vector3) -> Vector3: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def collisionFlags(self) -> CollisionFlags: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def contactOffset(self) -> float: ...
    @contactOffset.setter
    def contactOffset(self, value: float) -> float: ...
    @property
    def detectCollisions(self) -> bool: ...
    @detectCollisions.setter
    def detectCollisions(self, value: bool) -> bool: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def enableOverlapRecovery(self) -> bool: ...
    @enableOverlapRecovery.setter
    def enableOverlapRecovery(self, value: bool) -> bool: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hasModifiableContacts(self) -> bool: ...
    @hasModifiableContacts.setter
    def hasModifiableContacts(self, value: bool) -> bool: ...
    @property
    def height(self) -> float: ...
    @height.setter
    def height(self, value: float) -> float: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def isGrounded(self) -> bool: ...
    @property
    def isTrigger(self) -> bool: ...
    @isTrigger.setter
    def isTrigger(self, value: bool) -> bool: ...
    @property
    def layerOverridePriority(self) -> int: ...
    @layerOverridePriority.setter
    def layerOverridePriority(self, value: int) -> int: ...
    @property
    def light(self) -> Component: ...
    @property
    def material(self) -> PhysicMaterial: ...
    @material.setter
    def material(self, value: PhysicMaterial) -> PhysicMaterial: ...
    @property
    def minMoveDistance(self) -> float: ...
    @minMoveDistance.setter
    def minMoveDistance(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def providesContacts(self) -> bool: ...
    @providesContacts.setter
    def providesContacts(self, value: bool) -> bool: ...
    @property
    def radius(self) -> float: ...
    @radius.setter
    def radius(self, value: float) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def sharedMaterial(self) -> PhysicMaterial: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: PhysicMaterial) -> PhysicMaterial: ...
    @property
    def skinWidth(self) -> float: ...
    @skinWidth.setter
    def skinWidth(self, value: float) -> float: ...
    @property
    def slopeLimit(self) -> float: ...
    @slopeLimit.setter
    def slopeLimit(self, value: float) -> float: ...
    @property
    def stepOffset(self) -> float: ...
    @stepOffset.setter
    def stepOffset(self, value: float) -> float: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def velocity(self) -> Vector3: ...
    def Move(self, motion: Vector3) -> CollisionFlags: ...
    def SimpleMove(self, speed: Vector3) -> bool: ...


class CharacterInfo:
    flipped : bool
    index : int
    size : int
    style : FontStyle
    uv : Rect
    vert : Rect
    width : float
    @property
    def advance(self) -> int: ...
    @advance.setter
    def advance(self, value: int) -> int: ...
    @property
    def bearing(self) -> int: ...
    @bearing.setter
    def bearing(self, value: int) -> int: ...
    @property
    def glyphHeight(self) -> int: ...
    @glyphHeight.setter
    def glyphHeight(self, value: int) -> int: ...
    @property
    def glyphWidth(self) -> int: ...
    @glyphWidth.setter
    def glyphWidth(self, value: int) -> int: ...
    @property
    def maxX(self) -> int: ...
    @maxX.setter
    def maxX(self, value: int) -> int: ...
    @property
    def maxY(self) -> int: ...
    @maxY.setter
    def maxY(self, value: int) -> int: ...
    @property
    def minX(self) -> int: ...
    @minX.setter
    def minX(self, value: int) -> int: ...
    @property
    def minY(self) -> int: ...
    @minY.setter
    def minY(self, value: int) -> int: ...
    @property
    def uvBottomLeft(self) -> Vector2: ...
    @uvBottomLeft.setter
    def uvBottomLeft(self, value: Vector2) -> Vector2: ...
    @property
    def uvBottomRight(self) -> Vector2: ...
    @uvBottomRight.setter
    def uvBottomRight(self, value: Vector2) -> Vector2: ...
    @property
    def uvTopLeft(self) -> Vector2: ...
    @uvTopLeft.setter
    def uvTopLeft(self, value: Vector2) -> Vector2: ...
    @property
    def uvTopRight(self) -> Vector2: ...
    @uvTopRight.setter
    def uvTopRight(self, value: Vector2) -> Vector2: ...


class CharacterJoint(Joint):
    def __init__(self) -> None: ...
    rotationDrive : JointDrive
    targetAngularVelocity : Vector3
    targetRotation : Quaternion
    @property
    def anchor(self) -> Vector3: ...
    @anchor.setter
    def anchor(self, value: Vector3) -> Vector3: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoConfigureConnectedAnchor(self) -> bool: ...
    @autoConfigureConnectedAnchor.setter
    def autoConfigureConnectedAnchor(self, value: bool) -> bool: ...
    @property
    def axis(self) -> Vector3: ...
    @axis.setter
    def axis(self, value: Vector3) -> Vector3: ...
    @property
    def breakForce(self) -> float: ...
    @breakForce.setter
    def breakForce(self, value: float) -> float: ...
    @property
    def breakTorque(self) -> float: ...
    @breakTorque.setter
    def breakTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def connectedAnchor(self) -> Vector3: ...
    @connectedAnchor.setter
    def connectedAnchor(self, value: Vector3) -> Vector3: ...
    @property
    def connectedArticulationBody(self) -> ArticulationBody: ...
    @connectedArticulationBody.setter
    def connectedArticulationBody(self, value: ArticulationBody) -> ArticulationBody: ...
    @property
    def connectedBody(self) -> Rigidbody: ...
    @connectedBody.setter
    def connectedBody(self, value: Rigidbody) -> Rigidbody: ...
    @property
    def connectedMassScale(self) -> float: ...
    @connectedMassScale.setter
    def connectedMassScale(self, value: float) -> float: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def currentForce(self) -> Vector3: ...
    @property
    def currentTorque(self) -> Vector3: ...
    @property
    def enableCollision(self) -> bool: ...
    @enableCollision.setter
    def enableCollision(self, value: bool) -> bool: ...
    @property
    def enablePreprocessing(self) -> bool: ...
    @enablePreprocessing.setter
    def enablePreprocessing(self, value: bool) -> bool: ...
    @property
    def enableProjection(self) -> bool: ...
    @enableProjection.setter
    def enableProjection(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def highTwistLimit(self) -> SoftJointLimit: ...
    @highTwistLimit.setter
    def highTwistLimit(self, value: SoftJointLimit) -> SoftJointLimit: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def light(self) -> Component: ...
    @property
    def lowTwistLimit(self) -> SoftJointLimit: ...
    @lowTwistLimit.setter
    def lowTwistLimit(self, value: SoftJointLimit) -> SoftJointLimit: ...
    @property
    def massScale(self) -> float: ...
    @massScale.setter
    def massScale(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def projectionAngle(self) -> float: ...
    @projectionAngle.setter
    def projectionAngle(self, value: float) -> float: ...
    @property
    def projectionDistance(self) -> float: ...
    @projectionDistance.setter
    def projectionDistance(self, value: float) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def swing1Limit(self) -> SoftJointLimit: ...
    @swing1Limit.setter
    def swing1Limit(self, value: SoftJointLimit) -> SoftJointLimit: ...
    @property
    def swing2Limit(self) -> SoftJointLimit: ...
    @swing2Limit.setter
    def swing2Limit(self, value: SoftJointLimit) -> SoftJointLimit: ...
    @property
    def swingAxis(self) -> Vector3: ...
    @swingAxis.setter
    def swingAxis(self, value: Vector3) -> Vector3: ...
    @property
    def swingLimitSpring(self) -> SoftJointLimitSpring: ...
    @swingLimitSpring.setter
    def swingLimitSpring(self, value: SoftJointLimitSpring) -> SoftJointLimitSpring: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def twistLimitSpring(self) -> SoftJointLimitSpring: ...
    @twistLimitSpring.setter
    def twistLimitSpring(self, value: SoftJointLimitSpring) -> SoftJointLimitSpring: ...


class CircleCollider2D(Collider2D):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounciness(self) -> float: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def callbackLayers(self) -> LayerMask: ...
    @callbackLayers.setter
    def callbackLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def camera(self) -> Component: ...
    @property
    def center(self) -> Vector2: ...
    @center.setter
    def center(self, value: Vector2) -> Vector2: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def composite(self) -> CompositeCollider2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def contactCaptureLayers(self) -> LayerMask: ...
    @contactCaptureLayers.setter
    def contactCaptureLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def density(self) -> float: ...
    @density.setter
    def density(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def errorState(self) -> ColliderErrorState2D: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def forceReceiveLayers(self) -> LayerMask: ...
    @forceReceiveLayers.setter
    def forceReceiveLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def forceSendLayers(self) -> LayerMask: ...
    @forceSendLayers.setter
    def forceSendLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def friction(self) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def isTrigger(self) -> bool: ...
    @isTrigger.setter
    def isTrigger(self, value: bool) -> bool: ...
    @property
    def layerOverridePriority(self) -> int: ...
    @layerOverridePriority.setter
    def layerOverridePriority(self, value: int) -> int: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def offset(self) -> Vector2: ...
    @offset.setter
    def offset(self, value: Vector2) -> Vector2: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def radius(self) -> float: ...
    @radius.setter
    def radius(self, value: float) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def shapeCount(self) -> int: ...
    @property
    def sharedMaterial(self) -> PhysicsMaterial2D: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: PhysicsMaterial2D) -> PhysicsMaterial2D: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def usedByComposite(self) -> bool: ...
    @usedByComposite.setter
    def usedByComposite(self, value: bool) -> bool: ...
    @property
    def usedByEffector(self) -> bool: ...
    @usedByEffector.setter
    def usedByEffector(self, value: bool) -> bool: ...


class ClosestPointCommand:
    @typing.overload
    def __init__(self, point: Vector3, collider: Collider, position: Vector3, rotation: Quaternion, scale: Vector3) -> None: ...
    @typing.overload
    def __init__(self, point: Vector3, colliderInstanceID: int, position: Vector3, rotation: Quaternion, scale: Vector3) -> None: ...
    @property
    def colliderInstanceID(self) -> int: ...
    @colliderInstanceID.setter
    def colliderInstanceID(self, value: int) -> int: ...
    @property
    def point(self) -> Vector3: ...
    @point.setter
    def point(self, value: Vector3) -> Vector3: ...
    @property
    def position(self) -> Vector3: ...
    @position.setter
    def position(self, value: Vector3) -> Vector3: ...
    @property
    def rotation(self) -> Quaternion: ...
    @rotation.setter
    def rotation(self, value: Quaternion) -> Quaternion: ...
    @property
    def scale(self) -> Vector3: ...
    @scale.setter
    def scale(self, value: Vector3) -> Vector3: ...
    @staticmethod
    def ScheduleBatch(commands: NativeArray_1[ClosestPointCommand], results: NativeArray_1[Vector3], minCommandsPerJob: int, dependsOn: JobHandle = ...) -> JobHandle: ...


class Cloth(Component):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bendingStiffness(self) -> float: ...
    @bendingStiffness.setter
    def bendingStiffness(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def capsuleColliders(self) -> Array_1[CapsuleCollider]: ...
    @capsuleColliders.setter
    def capsuleColliders(self, value: Array_1[CapsuleCollider]) -> Array_1[CapsuleCollider]: ...
    @property
    def clothSolverFrequency(self) -> float: ...
    @clothSolverFrequency.setter
    def clothSolverFrequency(self, value: float) -> float: ...
    @property
    def coefficients(self) -> Array_1[ClothSkinningCoefficient]: ...
    @coefficients.setter
    def coefficients(self, value: Array_1[ClothSkinningCoefficient]) -> Array_1[ClothSkinningCoefficient]: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def collisionMassScale(self) -> float: ...
    @collisionMassScale.setter
    def collisionMassScale(self, value: float) -> float: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def damping(self) -> float: ...
    @damping.setter
    def damping(self, value: float) -> float: ...
    @property
    def enableContinuousCollision(self) -> bool: ...
    @enableContinuousCollision.setter
    def enableContinuousCollision(self, value: bool) -> bool: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def externalAcceleration(self) -> Vector3: ...
    @externalAcceleration.setter
    def externalAcceleration(self, value: Vector3) -> Vector3: ...
    @property
    def friction(self) -> float: ...
    @friction.setter
    def friction(self, value: float) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def normals(self) -> Array_1[Vector3]: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def randomAcceleration(self) -> Vector3: ...
    @randomAcceleration.setter
    def randomAcceleration(self, value: Vector3) -> Vector3: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def selfCollision(self) -> bool: ...
    @property
    def selfCollisionDistance(self) -> float: ...
    @selfCollisionDistance.setter
    def selfCollisionDistance(self, value: float) -> float: ...
    @property
    def selfCollisionStiffness(self) -> float: ...
    @selfCollisionStiffness.setter
    def selfCollisionStiffness(self, value: float) -> float: ...
    @property
    def sleepThreshold(self) -> float: ...
    @sleepThreshold.setter
    def sleepThreshold(self, value: float) -> float: ...
    @property
    def solverFrequency(self) -> bool: ...
    @solverFrequency.setter
    def solverFrequency(self, value: bool) -> bool: ...
    @property
    def sphereColliders(self) -> Array_1[ClothSphereColliderPair]: ...
    @sphereColliders.setter
    def sphereColliders(self, value: Array_1[ClothSphereColliderPair]) -> Array_1[ClothSphereColliderPair]: ...
    @property
    def stiffnessFrequency(self) -> float: ...
    @stiffnessFrequency.setter
    def stiffnessFrequency(self, value: float) -> float: ...
    @property
    def stretchingStiffness(self) -> float: ...
    @stretchingStiffness.setter
    def stretchingStiffness(self, value: float) -> float: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useContinuousCollision(self) -> float: ...
    @useContinuousCollision.setter
    def useContinuousCollision(self, value: float) -> float: ...
    @property
    def useGravity(self) -> bool: ...
    @useGravity.setter
    def useGravity(self, value: bool) -> bool: ...
    @property
    def useTethers(self) -> bool: ...
    @useTethers.setter
    def useTethers(self, value: bool) -> bool: ...
    @property
    def useVirtualParticles(self) -> float: ...
    @useVirtualParticles.setter
    def useVirtualParticles(self, value: float) -> float: ...
    @property
    def vertices(self) -> Array_1[Vector3]: ...
    @property
    def worldAccelerationScale(self) -> float: ...
    @worldAccelerationScale.setter
    def worldAccelerationScale(self, value: float) -> float: ...
    @property
    def worldVelocityScale(self) -> float: ...
    @worldVelocityScale.setter
    def worldVelocityScale(self, value: float) -> float: ...
    def ClearTransformMotion(self) -> None: ...
    def GetSelfAndInterCollisionIndices(self, indices: List_1[int]) -> None: ...
    def GetVirtualParticleIndices(self, indicesOutList: List_1[int]) -> None: ...
    def GetVirtualParticleWeights(self, weightsOutList: List_1[Vector3]) -> None: ...
    def SetSelfAndInterCollisionIndices(self, indices: List_1[int]) -> None: ...
    def SetVirtualParticleIndices(self, indicesIn: List_1[int]) -> None: ...
    def SetVirtualParticleWeights(self, weights: List_1[Vector3]) -> None: ...
    # Skipped SetEnabledFading due to it being static, abstract and generic.

    SetEnabledFading : SetEnabledFading_MethodGroup
    class SetEnabledFading_MethodGroup:
        @typing.overload
        def __call__(self, enabled: bool) -> None:...
        @typing.overload
        def __call__(self, enabled: bool, interpolationTime: float) -> None:...



class ClothSkinningCoefficient:
    collisionSphereDistance : float
    maxDistance : float


class ClothSphereColliderPair:
    @typing.overload
    def __init__(self, a: SphereCollider) -> None: ...
    @typing.overload
    def __init__(self, a: SphereCollider, b: SphereCollider) -> None: ...
    @property
    def first(self) -> SphereCollider: ...
    @first.setter
    def first(self, value: SphereCollider) -> SphereCollider: ...
    @property
    def second(self) -> SphereCollider: ...
    @second.setter
    def second(self, value: SphereCollider) -> SphereCollider: ...


class ClusterInput:
    def __init__(self) -> None: ...
    @staticmethod
    def AddInput(name: str, deviceName: str, serverUrl: str, index: int, type: ClusterInputType) -> bool: ...
    @staticmethod
    def CheckConnectionToServer(name: str) -> bool: ...
    @staticmethod
    def EditInput(name: str, deviceName: str, serverUrl: str, index: int, type: ClusterInputType) -> bool: ...
    @staticmethod
    def GetAxis(name: str) -> float: ...
    @staticmethod
    def GetButton(name: str) -> bool: ...
    @staticmethod
    def GetTrackerPosition(name: str) -> Vector3: ...
    @staticmethod
    def GetTrackerRotation(name: str) -> Quaternion: ...
    @staticmethod
    def SetAxis(name: str, value: float) -> None: ...
    @staticmethod
    def SetButton(name: str, value: bool) -> None: ...
    @staticmethod
    def SetTrackerPosition(name: str, value: Vector3) -> None: ...
    @staticmethod
    def SetTrackerRotation(name: str, value: Quaternion) -> None: ...


class ClusterInputType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Button : ClusterInputType # 0
    Axis : ClusterInputType # 1
    Tracker : ClusterInputType # 2
    CustomProvidedInput : ClusterInputType # 3


class ClusterNetwork:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def isDisconnected(cls) -> bool: ...
    @classmethod
    @property
    def isMasterOfCluster(cls) -> bool: ...
    @classmethod
    @property
    def nodeIndex(cls) -> int: ...
    @classmethod
    @nodeIndex.setter
    def nodeIndex(cls, value: int) -> int: ...


class ClusterSerialization(abc.ABC):
    @staticmethod
    def RestoreClusterInputState(buffer: NativeArray_1[int]) -> bool: ...
    @staticmethod
    def RestoreInputManagerState(buffer: NativeArray_1[int]) -> bool: ...
    @staticmethod
    def RestoreTimeManagerState(buffer: NativeArray_1[int]) -> bool: ...
    @staticmethod
    def SaveClusterInputState(buffer: NativeArray_1[int]) -> int: ...
    @staticmethod
    def SaveInputManagerState(buffer: NativeArray_1[int]) -> int: ...
    @staticmethod
    def SaveTimeManagerState(buffer: NativeArray_1[int]) -> int: ...


class Collider(Component):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedArticulationBody(self) -> ArticulationBody: ...
    @property
    def attachedRigidbody(self) -> Rigidbody: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def contactOffset(self) -> float: ...
    @contactOffset.setter
    def contactOffset(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hasModifiableContacts(self) -> bool: ...
    @hasModifiableContacts.setter
    def hasModifiableContacts(self, value: bool) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def isTrigger(self) -> bool: ...
    @isTrigger.setter
    def isTrigger(self, value: bool) -> bool: ...
    @property
    def layerOverridePriority(self) -> int: ...
    @layerOverridePriority.setter
    def layerOverridePriority(self, value: int) -> int: ...
    @property
    def light(self) -> Component: ...
    @property
    def material(self) -> PhysicMaterial: ...
    @material.setter
    def material(self, value: PhysicMaterial) -> PhysicMaterial: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def providesContacts(self) -> bool: ...
    @providesContacts.setter
    def providesContacts(self, value: bool) -> bool: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def sharedMaterial(self) -> PhysicMaterial: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: PhysicMaterial) -> PhysicMaterial: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    def ClosestPoint(self, position: Vector3) -> Vector3: ...
    def ClosestPointOnBounds(self, position: Vector3) -> Vector3: ...
    def Raycast(self, ray: Ray, hitInfo: clr.Reference[RaycastHit], maxDistance: float) -> bool: ...


class Collider2D(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounciness(self) -> float: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def callbackLayers(self) -> LayerMask: ...
    @callbackLayers.setter
    def callbackLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def composite(self) -> CompositeCollider2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def contactCaptureLayers(self) -> LayerMask: ...
    @contactCaptureLayers.setter
    def contactCaptureLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def density(self) -> float: ...
    @density.setter
    def density(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def errorState(self) -> ColliderErrorState2D: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def forceReceiveLayers(self) -> LayerMask: ...
    @forceReceiveLayers.setter
    def forceReceiveLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def forceSendLayers(self) -> LayerMask: ...
    @forceSendLayers.setter
    def forceSendLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def friction(self) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def isTrigger(self) -> bool: ...
    @isTrigger.setter
    def isTrigger(self, value: bool) -> bool: ...
    @property
    def layerOverridePriority(self) -> int: ...
    @layerOverridePriority.setter
    def layerOverridePriority(self, value: int) -> int: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def offset(self) -> Vector2: ...
    @offset.setter
    def offset(self, value: Vector2) -> Vector2: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def shapeCount(self) -> int: ...
    @property
    def sharedMaterial(self) -> PhysicsMaterial2D: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: PhysicsMaterial2D) -> PhysicsMaterial2D: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def usedByComposite(self) -> bool: ...
    @usedByComposite.setter
    def usedByComposite(self, value: bool) -> bool: ...
    @property
    def usedByEffector(self) -> bool: ...
    @usedByEffector.setter
    def usedByEffector(self, value: bool) -> bool: ...
    def ClosestPoint(self, position: Vector2) -> Vector2: ...
    def CreateMesh(self, useBodyPosition: bool, useBodyRotation: bool) -> Mesh: ...
    def Distance(self, collider: Collider2D) -> ColliderDistance2D: ...
    def GetShapeHash(self) -> int: ...
    def OverlapPoint(self, point: Vector2) -> bool: ...
    # Skipped Cast due to it being static, abstract and generic.

    Cast : Cast_MethodGroup
    class Cast_MethodGroup:
        @typing.overload
        def __call__(self, direction: Vector2, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, results: Array_1[RaycastHit2D], distance: float) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, results: Array_1[RaycastHit2D], distance: float, ignoreSiblingColliders: bool) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D], distance: float) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D], distance: float, ignoreSiblingColliders: bool) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, contactFilter: ContactFilter2D, results: List_1[RaycastHit2D], distance: float = ..., ignoreSiblingColliders: bool = ...) -> int:...

    # Skipped GetContacts due to it being static, abstract and generic.

    GetContacts : GetContacts_MethodGroup
    class GetContacts_MethodGroup:
        @typing.overload
        def __call__(self, colliders: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, colliders: List_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, contacts: Array_1[ContactPoint2D]) -> int:...
        @typing.overload
        def __call__(self, contacts: List_1[ContactPoint2D]) -> int:...
        @typing.overload
        def __call__(self, contactFilter: ContactFilter2D, colliders: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, contactFilter: ContactFilter2D, colliders: List_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, contactFilter: ContactFilter2D, contacts: Array_1[ContactPoint2D]) -> int:...
        @typing.overload
        def __call__(self, contactFilter: ContactFilter2D, contacts: List_1[ContactPoint2D]) -> int:...

    # Skipped GetShapes due to it being static, abstract and generic.

    GetShapes : GetShapes_MethodGroup
    class GetShapes_MethodGroup:
        @typing.overload
        def __call__(self, physicsShapeGroup: PhysicsShapeGroup2D) -> int:...
        @typing.overload
        def __call__(self, physicsShapeGroup: PhysicsShapeGroup2D, shapeIndex: int, shapeCount: int = ...) -> int:...

    # Skipped IsTouching due to it being static, abstract and generic.

    IsTouching : IsTouching_MethodGroup
    class IsTouching_MethodGroup:
        @typing.overload
        def __call__(self, collider: Collider2D) -> bool:...
        @typing.overload
        def __call__(self, contactFilter: ContactFilter2D) -> bool:...
        @typing.overload
        def __call__(self, collider: Collider2D, contactFilter: ContactFilter2D) -> bool:...

    # Skipped IsTouchingLayers due to it being static, abstract and generic.

    IsTouchingLayers : IsTouchingLayers_MethodGroup
    class IsTouchingLayers_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, layerMask: int) -> bool:...

    # Skipped OverlapCollider due to it being static, abstract and generic.

    OverlapCollider : OverlapCollider_MethodGroup
    class OverlapCollider_MethodGroup:
        @typing.overload
        def __call__(self, contactFilter: ContactFilter2D, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, contactFilter: ContactFilter2D, results: List_1[Collider2D]) -> int:...

    # Skipped Raycast due to it being static, abstract and generic.

    Raycast : Raycast_MethodGroup
    class Raycast_MethodGroup:
        @typing.overload
        def __call__(self, direction: Vector2, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, results: Array_1[RaycastHit2D], distance: float) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, results: Array_1[RaycastHit2D], distance: float, layerMask: int) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D], distance: float) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, contactFilter: ContactFilter2D, results: List_1[RaycastHit2D], distance: float = ...) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, results: Array_1[RaycastHit2D], distance: float, layerMask: int, minDepth: float) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, results: Array_1[RaycastHit2D], distance: float, layerMask: int, minDepth: float, maxDepth: float) -> int:...



class ColliderDistance2D:
    @property
    def distance(self) -> float: ...
    @distance.setter
    def distance(self, value: float) -> float: ...
    @property
    def isOverlapped(self) -> bool: ...
    @property
    def isValid(self) -> bool: ...
    @isValid.setter
    def isValid(self, value: bool) -> bool: ...
    @property
    def normal(self) -> Vector2: ...
    @property
    def pointA(self) -> Vector2: ...
    @pointA.setter
    def pointA(self, value: Vector2) -> Vector2: ...
    @property
    def pointB(self) -> Vector2: ...
    @pointB.setter
    def pointB(self, value: Vector2) -> Vector2: ...


class ColliderErrorState2D(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : ColliderErrorState2D # 0
    NoShapes : ColliderErrorState2D # 1
    RemovedShapes : ColliderErrorState2D # 2


class ColliderHit:
    @property
    def collider(self) -> Collider: ...
    @property
    def instanceID(self) -> int: ...


class Collision:
    def __init__(self) -> None: ...
    @property
    def articulationBody(self) -> ArticulationBody: ...
    @property
    def body(self) -> Component: ...
    @property
    def collider(self) -> Collider: ...
    @property
    def contactCount(self) -> int: ...
    @property
    def contacts(self) -> Array_1[ContactPoint]: ...
    @property
    def frictionForceSum(self) -> Vector3: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def impactForceSum(self) -> Vector3: ...
    @property
    def impulse(self) -> Vector3: ...
    @property
    def other(self) -> Component: ...
    @property
    def relativeVelocity(self) -> Vector3: ...
    @property
    def rigidbody(self) -> Rigidbody: ...
    @property
    def transform(self) -> Transform: ...
    def GetContact(self, index: int) -> ContactPoint: ...
    def GetEnumerator(self) -> IEnumerator: ...
    # Skipped GetContacts due to it being static, abstract and generic.

    GetContacts : GetContacts_MethodGroup
    class GetContacts_MethodGroup:
        @typing.overload
        def __call__(self, contacts: Array_1[ContactPoint]) -> int:...
        @typing.overload
        def __call__(self, contacts: List_1[ContactPoint]) -> int:...



class Collision2D:
    def __init__(self) -> None: ...
    @property
    def collider(self) -> Collider2D: ...
    @property
    def contactCount(self) -> int: ...
    @property
    def contacts(self) -> Array_1[ContactPoint2D]: ...
    @property
    def enabled(self) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def otherCollider(self) -> Collider2D: ...
    @property
    def otherRigidbody(self) -> Rigidbody2D: ...
    @property
    def relativeVelocity(self) -> Vector2: ...
    @property
    def rigidbody(self) -> Rigidbody2D: ...
    @property
    def transform(self) -> Transform: ...
    def GetContact(self, index: int) -> ContactPoint2D: ...
    # Skipped GetContacts due to it being static, abstract and generic.

    GetContacts : GetContacts_MethodGroup
    class GetContacts_MethodGroup:
        @typing.overload
        def __call__(self, contacts: Array_1[ContactPoint2D]) -> int:...
        @typing.overload
        def __call__(self, contacts: List_1[ContactPoint2D]) -> int:...



class CollisionDetectionMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Discrete : CollisionDetectionMode # 0
    Continuous : CollisionDetectionMode # 1
    ContinuousDynamic : CollisionDetectionMode # 2
    ContinuousSpeculative : CollisionDetectionMode # 3


class CollisionDetectionMode2D(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : CollisionDetectionMode2D # 0
    Discrete : CollisionDetectionMode2D # 0
    Continuous : CollisionDetectionMode2D # 1


class CollisionFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : CollisionFlags # 0
    Sides : CollisionFlags # 1
    CollidedSides : CollisionFlags # 1
    Above : CollisionFlags # 2
    CollidedAbove : CollisionFlags # 2
    Below : CollisionFlags # 4
    CollidedBelow : CollisionFlags # 4


class Color(IFormattable, IEquatable_1[Color]):
    @typing.overload
    def __init__(self, r: float, g: float, b: float) -> None: ...
    @typing.overload
    def __init__(self, r: float, g: float, b: float, a: float) -> None: ...
    a : float
    b : float
    g : float
    r : float
    @classmethod
    @property
    def black(cls) -> Color: ...
    @classmethod
    @property
    def blue(cls) -> Color: ...
    @classmethod
    @property
    def clear(cls) -> Color: ...
    @classmethod
    @property
    def cyan(cls) -> Color: ...
    @property
    def gamma(self) -> Color: ...
    @classmethod
    @property
    def gray(cls) -> Color: ...
    @property
    def grayscale(self) -> float: ...
    @classmethod
    @property
    def green(cls) -> Color: ...
    @classmethod
    @property
    def grey(cls) -> Color: ...
    @property
    def Item(self) -> float: ...
    @Item.setter
    def Item(self, value: float) -> float: ...
    @property
    def linear(self) -> Color: ...
    @classmethod
    @property
    def magenta(cls) -> Color: ...
    @property
    def maxColorComponent(self) -> float: ...
    @classmethod
    @property
    def red(cls) -> Color: ...
    @classmethod
    @property
    def white(cls) -> Color: ...
    @classmethod
    @property
    def yellow(cls) -> Color: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Lerp(a: Color, b: Color, t: float) -> Color: ...
    @staticmethod
    def LerpUnclamped(a: Color, b: Color, t: float) -> Color: ...
    def __add__(self, a: Color, b: Color) -> Color: ...
    def __truediv__(self, a: Color, b: float) -> Color: ...
    def __eq__(self, lhs: Color, rhs: Color) -> bool: ...
    # Operator not supported op_Implicit(c: Color)
    # Operator not supported op_Implicit(v: Vector4)
    def __ne__(self, lhs: Color, rhs: Color) -> bool: ...
    @typing.overload
    def __mul__(self, b: float, a: Color) -> Color: ...
    @typing.overload
    def __mul__(self, a: Color, b: float) -> Color: ...
    @typing.overload
    def __mul__(self, a: Color, b: Color) -> Color: ...
    def __sub__(self, a: Color, b: Color) -> Color: ...
    @staticmethod
    def RGBToHSV(rgbColor: Color, H: clr.Reference[float], S: clr.Reference[float], V: clr.Reference[float]) -> None: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Color) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped HSVToRGB due to it being static, abstract and generic.

    HSVToRGB : HSVToRGB_MethodGroup
    class HSVToRGB_MethodGroup:
        @typing.overload
        def __call__(self, H: float, S: float, V: float) -> Color:...
        @typing.overload
        def __call__(self, H: float, S: float, V: float, hdr: bool) -> Color:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...



class Color32(IFormattable):
    def __init__(self, r: int, g: int, b: int, a: int) -> None: ...
    a : int
    b : int
    g : int
    r : int
    @property
    def Item(self) -> int: ...
    @Item.setter
    def Item(self, value: int) -> int: ...
    @staticmethod
    def Lerp(a: Color32, b: Color32, t: float) -> Color32: ...
    @staticmethod
    def LerpUnclamped(a: Color32, b: Color32, t: float) -> Color32: ...
    # Operator not supported op_Implicit(c: Color)
    # Operator not supported op_Implicit(c: Color32)
    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...



class ColorGamut(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    sRGB : ColorGamut # 0
    Rec709 : ColorGamut # 1
    Rec2020 : ColorGamut # 2
    DisplayP3 : ColorGamut # 3
    HDR10 : ColorGamut # 4
    DolbyHDR : ColorGamut # 5
    P3D65G22 : ColorGamut # 6


class ColorGamutUtility:
    def __init__(self) -> None: ...
    @staticmethod
    def GetColorPrimaries(gamut: ColorGamut) -> ColorPrimaries: ...
    @staticmethod
    def GetTransferFunction(gamut: ColorGamut) -> TransferFunction: ...
    @staticmethod
    def GetWhitePoint(gamut: ColorGamut) -> WhitePoint: ...


class ColorPrimaries(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Rec709 : ColorPrimaries # 0
    Rec2020 : ColorPrimaries # 1
    P3 : ColorPrimaries # 2
    Unknown : ColorPrimaries # -1


class ColorSpace(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Gamma : ColorSpace # 0
    Linear : ColorSpace # 1
    Uninitialized : ColorSpace # -1


class ColorUsageAttribute(PropertyAttribute):
    @typing.overload
    def __init__(self, showAlpha: bool) -> None: ...
    @typing.overload
    def __init__(self, showAlpha: bool, hdr: bool) -> None: ...
    @typing.overload
    def __init__(self, showAlpha: bool, hdr: bool, minBrightness: float, maxBrightness: float, minExposureValue: float, maxExposureValue: float) -> None: ...
    hdr : bool
    maxBrightness : float
    maxExposureValue : float
    minBrightness : float
    minExposureValue : float
    showAlpha : bool
    @property
    def order(self) -> int: ...
    @order.setter
    def order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class ColorUtility:
    def __init__(self) -> None: ...
    @staticmethod
    def ToHtmlStringRGB(color: Color) -> str: ...
    @staticmethod
    def ToHtmlStringRGBA(color: Color) -> str: ...
    @staticmethod
    def TryParseHtmlString(htmlString: str, color: clr.Reference[Color]) -> bool: ...


class CombineInstance:
    @property
    def lightmapScaleOffset(self) -> Vector4: ...
    @lightmapScaleOffset.setter
    def lightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def mesh(self) -> Mesh: ...
    @mesh.setter
    def mesh(self, value: Mesh) -> Mesh: ...
    @property
    def realtimeLightmapScaleOffset(self) -> Vector4: ...
    @realtimeLightmapScaleOffset.setter
    def realtimeLightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def subMeshIndex(self) -> int: ...
    @subMeshIndex.setter
    def subMeshIndex(self, value: int) -> int: ...
    @property
    def transform(self) -> Matrix4x4: ...
    @transform.setter
    def transform(self, value: Matrix4x4) -> Matrix4x4: ...


class Compass:
    def __init__(self) -> None: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def headingAccuracy(self) -> float: ...
    @property
    def magneticHeading(self) -> float: ...
    @property
    def rawVector(self) -> Vector3: ...
    @property
    def timestamp(self) -> float: ...
    @property
    def trueHeading(self) -> float: ...


class Component(Object):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    def CompareTag(self, tag: str) -> bool: ...
    def GetComponentIndex(self) -> int: ...
    # Skipped BroadcastMessage due to it being static, abstract and generic.

    BroadcastMessage : BroadcastMessage_MethodGroup
    class BroadcastMessage_MethodGroup:
        @typing.overload
        def __call__(self, methodName: str) -> None:...
        @typing.overload
        def __call__(self, methodName: str, options: SendMessageOptions) -> None:...
        @typing.overload
        def __call__(self, methodName: str, parameter: typing.Any) -> None:...
        @typing.overload
        def __call__(self, methodName: str, parameter: typing.Any, options: SendMessageOptions) -> None:...

    # Skipped GetComponent due to it being static, abstract and generic.

    GetComponent : GetComponent_MethodGroup
    class GetComponent_MethodGroup:
        def __getitem__(self, t:typing.Type[GetComponent_1_T1]) -> GetComponent_1[GetComponent_1_T1]: ...

        GetComponent_1_T1 = typing.TypeVar('GetComponent_1_T1')
        class GetComponent_1(typing.Generic[GetComponent_1_T1]):
            GetComponent_1_T = Component.GetComponent_MethodGroup.GetComponent_1_T1
            def __call__(self) -> GetComponent_1_T:...

        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> Component:...
        @typing.overload
        def __call__(self, type: str) -> Component:...

    # Skipped GetComponentInChildren due to it being static, abstract and generic.

    GetComponentInChildren : GetComponentInChildren_MethodGroup
    class GetComponentInChildren_MethodGroup:
        def __getitem__(self, t:typing.Type[GetComponentInChildren_1_T1]) -> GetComponentInChildren_1[GetComponentInChildren_1_T1]: ...

        GetComponentInChildren_1_T1 = typing.TypeVar('GetComponentInChildren_1_T1')
        class GetComponentInChildren_1(typing.Generic[GetComponentInChildren_1_T1]):
            GetComponentInChildren_1_T = Component.GetComponentInChildren_MethodGroup.GetComponentInChildren_1_T1
            @typing.overload
            def __call__(self) -> GetComponentInChildren_1_T:...
            @typing.overload
            def __call__(self, includeInactive: bool) -> GetComponentInChildren_1_T:...

        @typing.overload
        def __call__(self, t: typing.Type[typing.Any]) -> Component:...
        @typing.overload
        def __call__(self, t: typing.Type[typing.Any], includeInactive: bool) -> Component:...

    # Skipped GetComponentInParent due to it being static, abstract and generic.

    GetComponentInParent : GetComponentInParent_MethodGroup
    class GetComponentInParent_MethodGroup:
        def __getitem__(self, t:typing.Type[GetComponentInParent_1_T1]) -> GetComponentInParent_1[GetComponentInParent_1_T1]: ...

        GetComponentInParent_1_T1 = typing.TypeVar('GetComponentInParent_1_T1')
        class GetComponentInParent_1(typing.Generic[GetComponentInParent_1_T1]):
            GetComponentInParent_1_T = Component.GetComponentInParent_MethodGroup.GetComponentInParent_1_T1
            @typing.overload
            def __call__(self) -> GetComponentInParent_1_T:...
            @typing.overload
            def __call__(self, includeInactive: bool) -> GetComponentInParent_1_T:...

        @typing.overload
        def __call__(self, t: typing.Type[typing.Any]) -> Component:...
        @typing.overload
        def __call__(self, t: typing.Type[typing.Any], includeInactive: bool) -> Component:...

    # Skipped GetComponents due to it being static, abstract and generic.

    GetComponents : GetComponents_MethodGroup
    class GetComponents_MethodGroup:
        def __getitem__(self, t:typing.Type[GetComponents_1_T1]) -> GetComponents_1[GetComponents_1_T1]: ...

        GetComponents_1_T1 = typing.TypeVar('GetComponents_1_T1')
        class GetComponents_1(typing.Generic[GetComponents_1_T1]):
            GetComponents_1_T = Component.GetComponents_MethodGroup.GetComponents_1_T1
            @typing.overload
            def __call__(self) -> Array_1[GetComponents_1_T]:...
            @typing.overload
            def __call__(self, results: List_1[GetComponents_1_T]) -> None:...

        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> Array_1[Component]:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], results: List_1[Component]) -> None:...

    # Skipped GetComponentsInChildren due to it being static, abstract and generic.

    GetComponentsInChildren : GetComponentsInChildren_MethodGroup
    class GetComponentsInChildren_MethodGroup:
        def __getitem__(self, t:typing.Type[GetComponentsInChildren_1_T1]) -> GetComponentsInChildren_1[GetComponentsInChildren_1_T1]: ...

        GetComponentsInChildren_1_T1 = typing.TypeVar('GetComponentsInChildren_1_T1')
        class GetComponentsInChildren_1(typing.Generic[GetComponentsInChildren_1_T1]):
            GetComponentsInChildren_1_T = Component.GetComponentsInChildren_MethodGroup.GetComponentsInChildren_1_T1
            @typing.overload
            def __call__(self) -> Array_1[GetComponentsInChildren_1_T]:...
            @typing.overload
            def __call__(self, results: List_1[GetComponentsInChildren_1_T]) -> None:...
            @typing.overload
            def __call__(self, includeInactive: bool) -> Array_1[GetComponentsInChildren_1_T]:...
            @typing.overload
            def __call__(self, includeInactive: bool, result: List_1[GetComponentsInChildren_1_T]) -> None:...

        @typing.overload
        def __call__(self, t: typing.Type[typing.Any]) -> Array_1[Component]:...
        @typing.overload
        def __call__(self, t: typing.Type[typing.Any], includeInactive: bool) -> Array_1[Component]:...

    # Skipped GetComponentsInParent due to it being static, abstract and generic.

    GetComponentsInParent : GetComponentsInParent_MethodGroup
    class GetComponentsInParent_MethodGroup:
        def __getitem__(self, t:typing.Type[GetComponentsInParent_1_T1]) -> GetComponentsInParent_1[GetComponentsInParent_1_T1]: ...

        GetComponentsInParent_1_T1 = typing.TypeVar('GetComponentsInParent_1_T1')
        class GetComponentsInParent_1(typing.Generic[GetComponentsInParent_1_T1]):
            GetComponentsInParent_1_T = Component.GetComponentsInParent_MethodGroup.GetComponentsInParent_1_T1
            @typing.overload
            def __call__(self) -> Array_1[GetComponentsInParent_1_T]:...
            @typing.overload
            def __call__(self, includeInactive: bool) -> Array_1[GetComponentsInParent_1_T]:...
            @typing.overload
            def __call__(self, includeInactive: bool, results: List_1[GetComponentsInParent_1_T]) -> None:...

        @typing.overload
        def __call__(self, t: typing.Type[typing.Any]) -> Array_1[Component]:...
        @typing.overload
        def __call__(self, t: typing.Type[typing.Any], includeInactive: bool) -> Array_1[Component]:...

    # Skipped SendMessage due to it being static, abstract and generic.

    SendMessage : SendMessage_MethodGroup
    class SendMessage_MethodGroup:
        @typing.overload
        def __call__(self, methodName: str) -> None:...
        @typing.overload
        def __call__(self, methodName: str, options: SendMessageOptions) -> None:...
        @typing.overload
        def __call__(self, methodName: str, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, methodName: str, value: typing.Any, options: SendMessageOptions) -> None:...

    # Skipped SendMessageUpwards due to it being static, abstract and generic.

    SendMessageUpwards : SendMessageUpwards_MethodGroup
    class SendMessageUpwards_MethodGroup:
        @typing.overload
        def __call__(self, methodName: str) -> None:...
        @typing.overload
        def __call__(self, methodName: str, options: SendMessageOptions) -> None:...
        @typing.overload
        def __call__(self, methodName: str, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, methodName: str, value: typing.Any, options: SendMessageOptions) -> None:...

    # Skipped TryGetComponent due to it being static, abstract and generic.

    TryGetComponent : TryGetComponent_MethodGroup
    class TryGetComponent_MethodGroup:
        def __getitem__(self, t:typing.Type[TryGetComponent_1_T1]) -> TryGetComponent_1[TryGetComponent_1_T1]: ...

        TryGetComponent_1_T1 = typing.TypeVar('TryGetComponent_1_T1')
        class TryGetComponent_1(typing.Generic[TryGetComponent_1_T1]):
            TryGetComponent_1_T = Component.TryGetComponent_MethodGroup.TryGetComponent_1_T1
            def __call__(self, component: clr.Reference[TryGetComponent_1_T]) -> bool:...

        def __call__(self, type: typing.Type[typing.Any], component: clr.Reference[Component]) -> bool:...



class CompositeCollider2D(Collider2D):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounciness(self) -> float: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def callbackLayers(self) -> LayerMask: ...
    @callbackLayers.setter
    def callbackLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def composite(self) -> CompositeCollider2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def contactCaptureLayers(self) -> LayerMask: ...
    @contactCaptureLayers.setter
    def contactCaptureLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def density(self) -> float: ...
    @density.setter
    def density(self, value: float) -> float: ...
    @property
    def edgeRadius(self) -> float: ...
    @edgeRadius.setter
    def edgeRadius(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def errorState(self) -> ColliderErrorState2D: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def forceReceiveLayers(self) -> LayerMask: ...
    @forceReceiveLayers.setter
    def forceReceiveLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def forceSendLayers(self) -> LayerMask: ...
    @forceSendLayers.setter
    def forceSendLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def friction(self) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def generationType(self) -> CompositeCollider2D.GenerationType: ...
    @generationType.setter
    def generationType(self, value: CompositeCollider2D.GenerationType) -> CompositeCollider2D.GenerationType: ...
    @property
    def geometryType(self) -> CompositeCollider2D.GeometryType: ...
    @geometryType.setter
    def geometryType(self, value: CompositeCollider2D.GeometryType) -> CompositeCollider2D.GeometryType: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def isTrigger(self) -> bool: ...
    @isTrigger.setter
    def isTrigger(self, value: bool) -> bool: ...
    @property
    def layerOverridePriority(self) -> int: ...
    @layerOverridePriority.setter
    def layerOverridePriority(self, value: int) -> int: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def offset(self) -> Vector2: ...
    @offset.setter
    def offset(self, value: Vector2) -> Vector2: ...
    @property
    def offsetDistance(self) -> float: ...
    @offsetDistance.setter
    def offsetDistance(self, value: float) -> float: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def pathCount(self) -> int: ...
    @property
    def pointCount(self) -> int: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def shapeCount(self) -> int: ...
    @property
    def sharedMaterial(self) -> PhysicsMaterial2D: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: PhysicsMaterial2D) -> PhysicsMaterial2D: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def usedByComposite(self) -> bool: ...
    @usedByComposite.setter
    def usedByComposite(self, value: bool) -> bool: ...
    @property
    def usedByEffector(self) -> bool: ...
    @usedByEffector.setter
    def usedByEffector(self, value: bool) -> bool: ...
    @property
    def useDelaunayMesh(self) -> bool: ...
    @useDelaunayMesh.setter
    def useDelaunayMesh(self, value: bool) -> bool: ...
    @property
    def vertexDistance(self) -> float: ...
    @vertexDistance.setter
    def vertexDistance(self, value: float) -> float: ...
    def GenerateGeometry(self) -> None: ...
    def GetPathPointCount(self, index: int) -> int: ...
    # Skipped GetPath due to it being static, abstract and generic.

    GetPath : GetPath_MethodGroup
    class GetPath_MethodGroup:
        @typing.overload
        def __call__(self, index: int, points: Array_1[Vector2]) -> int:...
        @typing.overload
        def __call__(self, index: int, points: List_1[Vector2]) -> int:...


    class GenerationType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Synchronous : CompositeCollider2D.GenerationType # 0
        Manual : CompositeCollider2D.GenerationType # 1


    class GeometryType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Outlines : CompositeCollider2D.GeometryType # 0
        Polygons : CompositeCollider2D.GeometryType # 1



class CompressionLevel(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : CompressionLevel # 0
    Fastest : CompressionLevel # 1
    Fast : CompressionLevel # 2
    Normal : CompressionLevel # 3
    High : CompressionLevel # 4
    Maximum : CompressionLevel # 5


class CompressionType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : CompressionType # 0
    Lzma : CompressionType # 1
    Lz4 : CompressionType # 2
    Lz4HC : CompressionType # 3


class ComputeBuffer(IDisposable):
    @typing.overload
    def __init__(self, count: int, stride: int) -> None: ...
    @typing.overload
    def __init__(self, count: int, stride: int, type: ComputeBufferType) -> None: ...
    @typing.overload
    def __init__(self, count: int, stride: int, type: ComputeBufferType, usage: ComputeBufferMode) -> None: ...
    @property
    def count(self) -> int: ...
    @property
    def name(self) -> None: ...
    @name.setter
    def name(self, value: str) -> None: ...
    @property
    def stride(self) -> int: ...
    @staticmethod
    def CopyCount(src: ComputeBuffer, dst: ComputeBuffer, dstOffsetBytes: int) -> None: ...
    def Dispose(self) -> None: ...
    def GetNativeBufferPtr(self) -> int: ...
    def IsValid(self) -> bool: ...
    def Release(self) -> None: ...
    def SetCounterValue(self, counterValue: int) -> None: ...
    # Skipped BeginWrite due to it being static, abstract and generic.

    BeginWrite : BeginWrite_MethodGroup
    class BeginWrite_MethodGroup:
        def __getitem__(self, t:typing.Type[BeginWrite_1_T1]) -> BeginWrite_1[BeginWrite_1_T1]: ...

        BeginWrite_1_T1 = typing.TypeVar('BeginWrite_1_T1')
        class BeginWrite_1(typing.Generic[BeginWrite_1_T1]):
            BeginWrite_1_T = ComputeBuffer.BeginWrite_MethodGroup.BeginWrite_1_T1
            def __call__(self, computeBufferStartIndex: int, count: int) -> NativeArray_1[BeginWrite_1_T]:...


    # Skipped EndWrite due to it being static, abstract and generic.

    EndWrite : EndWrite_MethodGroup
    class EndWrite_MethodGroup:
        def __getitem__(self, t:typing.Type[EndWrite_1_T1]) -> EndWrite_1[EndWrite_1_T1]: ...

        EndWrite_1_T1 = typing.TypeVar('EndWrite_1_T1')
        class EndWrite_1(typing.Generic[EndWrite_1_T1]):
            EndWrite_1_T = ComputeBuffer.EndWrite_MethodGroup.EndWrite_1_T1
            def __call__(self, countWritten: int) -> None:...


    # Skipped GetData due to it being static, abstract and generic.

    GetData : GetData_MethodGroup
    class GetData_MethodGroup:
        @typing.overload
        def __call__(self, data: Array) -> None:...
        @typing.overload
        def __call__(self, data: Array, managedBufferStartIndex: int, computeBufferStartIndex: int, count: int) -> None:...

    # Skipped SetData due to it being static, abstract and generic.

    SetData : SetData_MethodGroup
    class SetData_MethodGroup:
        def __getitem__(self, t:typing.Type[SetData_1_T1]) -> SetData_1[SetData_1_T1]: ...

        SetData_1_T1 = typing.TypeVar('SetData_1_T1')
        class SetData_1(typing.Generic[SetData_1_T1]):
            SetData_1_T = ComputeBuffer.SetData_MethodGroup.SetData_1_T1
            @typing.overload
            def __call__(self, data: List_1[SetData_1_T]) -> None:...
            @typing.overload
            def __call__(self, data: NativeArray_1[SetData_1_T]) -> None:...
            @typing.overload
            def __call__(self, data: List_1[SetData_1_T], managedBufferStartIndex: int, computeBufferStartIndex: int, count: int) -> None:...
            @typing.overload
            def __call__(self, data: NativeArray_1[SetData_1_T], nativeBufferStartIndex: int, computeBufferStartIndex: int, count: int) -> None:...

        @typing.overload
        def __call__(self, data: Array) -> None:...
        @typing.overload
        def __call__(self, data: Array, managedBufferStartIndex: int, computeBufferStartIndex: int, count: int) -> None:...



class ComputeBufferMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Immutable : ComputeBufferMode # 0
    Dynamic : ComputeBufferMode # 1
    Circular : ComputeBufferMode # 2
    StreamOut : ComputeBufferMode # 3
    SubUpdates : ComputeBufferMode # 4


class ComputeBufferType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Default : ComputeBufferType # 0
    Raw : ComputeBufferType # 1
    Append : ComputeBufferType # 2
    Counter : ComputeBufferType # 4
    Constant : ComputeBufferType # 8
    Structured : ComputeBufferType # 16
    DrawIndirect : ComputeBufferType # 256
    IndirectArguments : ComputeBufferType # 256
    GPUMemory : ComputeBufferType # 512


class ComputeShader(Object):
    @property
    def enabledKeywords(self) -> Array_1[LocalKeyword]: ...
    @enabledKeywords.setter
    def enabledKeywords(self, value: Array_1[LocalKeyword]) -> Array_1[LocalKeyword]: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def keywordSpace(self) -> LocalKeywordSpace: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def shaderKeywords(self) -> Array_1[str]: ...
    @shaderKeywords.setter
    def shaderKeywords(self, value: Array_1[str]) -> Array_1[str]: ...
    def Dispatch(self, kernelIndex: int, threadGroupsX: int, threadGroupsY: int, threadGroupsZ: int) -> None: ...
    def FindKernel(self, name: str) -> int: ...
    def GetKernelThreadGroupSizes(self, kernelIndex: int, x: clr.Reference[int], y: clr.Reference[int], z: clr.Reference[int]) -> None: ...
    def HasKernel(self, name: str) -> bool: ...
    def IsSupported(self, kernelIndex: int) -> bool: ...
    def SetKeyword(self, keyword: clr.Reference[LocalKeyword], value: bool) -> None: ...
    # Skipped DisableKeyword due to it being static, abstract and generic.

    DisableKeyword : DisableKeyword_MethodGroup
    class DisableKeyword_MethodGroup:
        @typing.overload
        def __call__(self, keyword: str) -> None:...
        @typing.overload
        def __call__(self, keyword: clr.Reference[LocalKeyword]) -> None:...

    # Skipped DispatchIndirect due to it being static, abstract and generic.

    DispatchIndirect : DispatchIndirect_MethodGroup
    class DispatchIndirect_MethodGroup:
        @typing.overload
        def __call__(self, kernelIndex: int, argsBuffer: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, kernelIndex: int, argsBuffer: GraphicsBuffer) -> None:...
        @typing.overload
        def __call__(self, kernelIndex: int, argsBuffer: ComputeBuffer, argsOffset: int) -> None:...
        @typing.overload
        def __call__(self, kernelIndex: int, argsBuffer: GraphicsBuffer, argsOffset: int) -> None:...

    # Skipped EnableKeyword due to it being static, abstract and generic.

    EnableKeyword : EnableKeyword_MethodGroup
    class EnableKeyword_MethodGroup:
        @typing.overload
        def __call__(self, keyword: str) -> None:...
        @typing.overload
        def __call__(self, keyword: clr.Reference[LocalKeyword]) -> None:...

    # Skipped IsKeywordEnabled due to it being static, abstract and generic.

    IsKeywordEnabled : IsKeywordEnabled_MethodGroup
    class IsKeywordEnabled_MethodGroup:
        @typing.overload
        def __call__(self, keyword: str) -> bool:...
        @typing.overload
        def __call__(self, keyword: clr.Reference[LocalKeyword]) -> bool:...

    # Skipped SetBool due to it being static, abstract and generic.

    SetBool : SetBool_MethodGroup
    class SetBool_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, val: bool) -> None:...
        @typing.overload
        def __call__(self, name: str, val: bool) -> None:...

    # Skipped SetBuffer due to it being static, abstract and generic.

    SetBuffer : SetBuffer_MethodGroup
    class SetBuffer_MethodGroup:
        @typing.overload
        def __call__(self, kernelIndex: int, nameID: int, buffer: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, kernelIndex: int, nameID: int, buffer: GraphicsBuffer) -> None:...
        @typing.overload
        def __call__(self, kernelIndex: int, name: str, buffer: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, kernelIndex: int, name: str, buffer: GraphicsBuffer) -> None:...

    # Skipped SetConstantBuffer due to it being static, abstract and generic.

    SetConstantBuffer : SetConstantBuffer_MethodGroup
    class SetConstantBuffer_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, buffer: ComputeBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, nameID: int, buffer: GraphicsBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, name: str, buffer: ComputeBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, name: str, buffer: GraphicsBuffer, offset: int, size: int) -> None:...

    # Skipped SetFloat due to it being static, abstract and generic.

    SetFloat : SetFloat_MethodGroup
    class SetFloat_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, val: float) -> None:...
        @typing.overload
        def __call__(self, name: str, val: float) -> None:...

    # Skipped SetFloats due to it being static, abstract and generic.

    SetFloats : SetFloats_MethodGroup
    class SetFloats_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, values: Array_1[float]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: Array_1[float]) -> None:...

    # Skipped SetInt due to it being static, abstract and generic.

    SetInt : SetInt_MethodGroup
    class SetInt_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, val: int) -> None:...
        @typing.overload
        def __call__(self, name: str, val: int) -> None:...

    # Skipped SetInts due to it being static, abstract and generic.

    SetInts : SetInts_MethodGroup
    class SetInts_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, values: Array_1[int]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: Array_1[int]) -> None:...

    # Skipped SetMatrix due to it being static, abstract and generic.

    SetMatrix : SetMatrix_MethodGroup
    class SetMatrix_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, val: Matrix4x4) -> None:...
        @typing.overload
        def __call__(self, name: str, val: Matrix4x4) -> None:...

    # Skipped SetMatrixArray due to it being static, abstract and generic.

    SetMatrixArray : SetMatrixArray_MethodGroup
    class SetMatrixArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, values: Array_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: Array_1[Matrix4x4]) -> None:...

    # Skipped SetTexture due to it being static, abstract and generic.

    SetTexture : SetTexture_MethodGroup
    class SetTexture_MethodGroup:
        @typing.overload
        def __call__(self, kernelIndex: int, nameID: int, texture: Texture) -> None:...
        @typing.overload
        def __call__(self, kernelIndex: int, name: str, texture: Texture) -> None:...
        @typing.overload
        def __call__(self, kernelIndex: int, nameID: int, texture: Texture, mipLevel: int) -> None:...
        @typing.overload
        def __call__(self, kernelIndex: int, name: str, texture: Texture, mipLevel: int) -> None:...
        @typing.overload
        def __call__(self, kernelIndex: int, nameID: int, texture: RenderTexture, mipLevel: int, element: RenderTextureSubElement) -> None:...
        @typing.overload
        def __call__(self, kernelIndex: int, name: str, texture: RenderTexture, mipLevel: int, element: RenderTextureSubElement) -> None:...

    # Skipped SetTextureFromGlobal due to it being static, abstract and generic.

    SetTextureFromGlobal : SetTextureFromGlobal_MethodGroup
    class SetTextureFromGlobal_MethodGroup:
        @typing.overload
        def __call__(self, kernelIndex: int, nameID: int, globalTextureNameID: int) -> None:...
        @typing.overload
        def __call__(self, kernelIndex: int, name: str, globalTextureName: str) -> None:...

    # Skipped SetVector due to it being static, abstract and generic.

    SetVector : SetVector_MethodGroup
    class SetVector_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, val: Vector4) -> None:...
        @typing.overload
        def __call__(self, name: str, val: Vector4) -> None:...

    # Skipped SetVectorArray due to it being static, abstract and generic.

    SetVectorArray : SetVectorArray_MethodGroup
    class SetVectorArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, values: Array_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: Array_1[Vector4]) -> None:...



class ConfigurableJoint(Joint):
    def __init__(self) -> None: ...
    @property
    def anchor(self) -> Vector3: ...
    @anchor.setter
    def anchor(self, value: Vector3) -> Vector3: ...
    @property
    def angularXDrive(self) -> JointDrive: ...
    @angularXDrive.setter
    def angularXDrive(self, value: JointDrive) -> JointDrive: ...
    @property
    def angularXLimitSpring(self) -> SoftJointLimitSpring: ...
    @angularXLimitSpring.setter
    def angularXLimitSpring(self, value: SoftJointLimitSpring) -> SoftJointLimitSpring: ...
    @property
    def angularXMotion(self) -> ConfigurableJointMotion: ...
    @angularXMotion.setter
    def angularXMotion(self, value: ConfigurableJointMotion) -> ConfigurableJointMotion: ...
    @property
    def angularYLimit(self) -> SoftJointLimit: ...
    @angularYLimit.setter
    def angularYLimit(self, value: SoftJointLimit) -> SoftJointLimit: ...
    @property
    def angularYMotion(self) -> ConfigurableJointMotion: ...
    @angularYMotion.setter
    def angularYMotion(self, value: ConfigurableJointMotion) -> ConfigurableJointMotion: ...
    @property
    def angularYZDrive(self) -> JointDrive: ...
    @angularYZDrive.setter
    def angularYZDrive(self, value: JointDrive) -> JointDrive: ...
    @property
    def angularYZLimitSpring(self) -> SoftJointLimitSpring: ...
    @angularYZLimitSpring.setter
    def angularYZLimitSpring(self, value: SoftJointLimitSpring) -> SoftJointLimitSpring: ...
    @property
    def angularZLimit(self) -> SoftJointLimit: ...
    @angularZLimit.setter
    def angularZLimit(self, value: SoftJointLimit) -> SoftJointLimit: ...
    @property
    def angularZMotion(self) -> ConfigurableJointMotion: ...
    @angularZMotion.setter
    def angularZMotion(self, value: ConfigurableJointMotion) -> ConfigurableJointMotion: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoConfigureConnectedAnchor(self) -> bool: ...
    @autoConfigureConnectedAnchor.setter
    def autoConfigureConnectedAnchor(self, value: bool) -> bool: ...
    @property
    def axis(self) -> Vector3: ...
    @axis.setter
    def axis(self, value: Vector3) -> Vector3: ...
    @property
    def breakForce(self) -> float: ...
    @breakForce.setter
    def breakForce(self, value: float) -> float: ...
    @property
    def breakTorque(self) -> float: ...
    @breakTorque.setter
    def breakTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def configuredInWorldSpace(self) -> bool: ...
    @configuredInWorldSpace.setter
    def configuredInWorldSpace(self, value: bool) -> bool: ...
    @property
    def connectedAnchor(self) -> Vector3: ...
    @connectedAnchor.setter
    def connectedAnchor(self, value: Vector3) -> Vector3: ...
    @property
    def connectedArticulationBody(self) -> ArticulationBody: ...
    @connectedArticulationBody.setter
    def connectedArticulationBody(self, value: ArticulationBody) -> ArticulationBody: ...
    @property
    def connectedBody(self) -> Rigidbody: ...
    @connectedBody.setter
    def connectedBody(self, value: Rigidbody) -> Rigidbody: ...
    @property
    def connectedMassScale(self) -> float: ...
    @connectedMassScale.setter
    def connectedMassScale(self, value: float) -> float: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def currentForce(self) -> Vector3: ...
    @property
    def currentTorque(self) -> Vector3: ...
    @property
    def enableCollision(self) -> bool: ...
    @enableCollision.setter
    def enableCollision(self, value: bool) -> bool: ...
    @property
    def enablePreprocessing(self) -> bool: ...
    @enablePreprocessing.setter
    def enablePreprocessing(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def highAngularXLimit(self) -> SoftJointLimit: ...
    @highAngularXLimit.setter
    def highAngularXLimit(self, value: SoftJointLimit) -> SoftJointLimit: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def light(self) -> Component: ...
    @property
    def linearLimit(self) -> SoftJointLimit: ...
    @linearLimit.setter
    def linearLimit(self, value: SoftJointLimit) -> SoftJointLimit: ...
    @property
    def linearLimitSpring(self) -> SoftJointLimitSpring: ...
    @linearLimitSpring.setter
    def linearLimitSpring(self, value: SoftJointLimitSpring) -> SoftJointLimitSpring: ...
    @property
    def lowAngularXLimit(self) -> SoftJointLimit: ...
    @lowAngularXLimit.setter
    def lowAngularXLimit(self, value: SoftJointLimit) -> SoftJointLimit: ...
    @property
    def massScale(self) -> float: ...
    @massScale.setter
    def massScale(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def projectionAngle(self) -> float: ...
    @projectionAngle.setter
    def projectionAngle(self, value: float) -> float: ...
    @property
    def projectionDistance(self) -> float: ...
    @projectionDistance.setter
    def projectionDistance(self, value: float) -> float: ...
    @property
    def projectionMode(self) -> JointProjectionMode: ...
    @projectionMode.setter
    def projectionMode(self, value: JointProjectionMode) -> JointProjectionMode: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def rotationDriveMode(self) -> RotationDriveMode: ...
    @rotationDriveMode.setter
    def rotationDriveMode(self, value: RotationDriveMode) -> RotationDriveMode: ...
    @property
    def secondaryAxis(self) -> Vector3: ...
    @secondaryAxis.setter
    def secondaryAxis(self, value: Vector3) -> Vector3: ...
    @property
    def slerpDrive(self) -> JointDrive: ...
    @slerpDrive.setter
    def slerpDrive(self, value: JointDrive) -> JointDrive: ...
    @property
    def swapBodies(self) -> bool: ...
    @swapBodies.setter
    def swapBodies(self, value: bool) -> bool: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def targetAngularVelocity(self) -> Vector3: ...
    @targetAngularVelocity.setter
    def targetAngularVelocity(self, value: Vector3) -> Vector3: ...
    @property
    def targetPosition(self) -> Vector3: ...
    @targetPosition.setter
    def targetPosition(self, value: Vector3) -> Vector3: ...
    @property
    def targetRotation(self) -> Quaternion: ...
    @targetRotation.setter
    def targetRotation(self, value: Quaternion) -> Quaternion: ...
    @property
    def targetVelocity(self) -> Vector3: ...
    @targetVelocity.setter
    def targetVelocity(self, value: Vector3) -> Vector3: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def xDrive(self) -> JointDrive: ...
    @xDrive.setter
    def xDrive(self, value: JointDrive) -> JointDrive: ...
    @property
    def xMotion(self) -> ConfigurableJointMotion: ...
    @xMotion.setter
    def xMotion(self, value: ConfigurableJointMotion) -> ConfigurableJointMotion: ...
    @property
    def yDrive(self) -> JointDrive: ...
    @yDrive.setter
    def yDrive(self, value: JointDrive) -> JointDrive: ...
    @property
    def yMotion(self) -> ConfigurableJointMotion: ...
    @yMotion.setter
    def yMotion(self, value: ConfigurableJointMotion) -> ConfigurableJointMotion: ...
    @property
    def zDrive(self) -> JointDrive: ...
    @zDrive.setter
    def zDrive(self, value: JointDrive) -> JointDrive: ...
    @property
    def zMotion(self) -> ConfigurableJointMotion: ...
    @zMotion.setter
    def zMotion(self, value: ConfigurableJointMotion) -> ConfigurableJointMotion: ...


class ConfigurableJointMotion(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Locked : ConfigurableJointMotion # 0
    Limited : ConfigurableJointMotion # 1
    Free : ConfigurableJointMotion # 2


class ConnectionTesterStatus(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:


class ConstantForce(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def force(self) -> Vector3: ...
    @force.setter
    def force(self, value: Vector3) -> Vector3: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def relativeForce(self) -> Vector3: ...
    @relativeForce.setter
    def relativeForce(self, value: Vector3) -> Vector3: ...
    @property
    def relativeTorque(self) -> Vector3: ...
    @relativeTorque.setter
    def relativeTorque(self, value: Vector3) -> Vector3: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def torque(self) -> Vector3: ...
    @torque.setter
    def torque(self, value: Vector3) -> Vector3: ...
    @property
    def transform(self) -> Transform: ...


class ConstantForce2D(PhysicsUpdateBehaviour2D):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def force(self) -> Vector2: ...
    @force.setter
    def force(self, value: Vector2) -> Vector2: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def relativeForce(self) -> Vector2: ...
    @relativeForce.setter
    def relativeForce(self, value: Vector2) -> Vector2: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def torque(self) -> float: ...
    @torque.setter
    def torque(self, value: float) -> float: ...
    @property
    def transform(self) -> Transform: ...


class ContactFilter2D:
    layerMask : LayerMask
    maxDepth : float
    maxNormalAngle : float
    minDepth : float
    minNormalAngle : float
    NormalAngleUpperLimit : float
    useDepth : bool
    useLayerMask : bool
    useNormalAngle : bool
    useOutsideDepth : bool
    useOutsideNormalAngle : bool
    useTriggers : bool
    @property
    def isFiltering(self) -> bool: ...
    def ClearDepth(self) -> None: ...
    def ClearLayerMask(self) -> None: ...
    def ClearNormalAngle(self) -> None: ...
    def IsFilteringDepth(self, obj: GameObject) -> bool: ...
    def IsFilteringLayerMask(self, obj: GameObject) -> bool: ...
    def IsFilteringTrigger(self, collider: Collider2D) -> bool: ...
    def NoFilter(self) -> ContactFilter2D: ...
    def SetDepth(self, minDepth: float, maxDepth: float) -> None: ...
    def SetLayerMask(self, layerMask: LayerMask) -> None: ...
    def SetNormalAngle(self, minNormalAngle: float, maxNormalAngle: float) -> None: ...
    # Skipped IsFilteringNormalAngle due to it being static, abstract and generic.

    IsFilteringNormalAngle : IsFilteringNormalAngle_MethodGroup
    class IsFilteringNormalAngle_MethodGroup:
        @typing.overload
        def __call__(self, angle: float) -> bool:...
        @typing.overload
        def __call__(self, normal: Vector2) -> bool:...



class ContactPair:
    @property
    def Collider(self) -> Collider: ...
    @property
    def ColliderInstanceID(self) -> int: ...
    @property
    def ContactCount(self) -> int: ...
    @property
    def ImpulseSum(self) -> Vector3: ...
    @property
    def IsCollisionEnter(self) -> bool: ...
    @property
    def IsCollisionExit(self) -> bool: ...
    @property
    def IsCollisionStay(self) -> bool: ...
    @property
    def OtherCollider(self) -> Collider: ...
    @property
    def OtherColliderInstanceID(self) -> int: ...
    def CopyToNativeArray(self, buffer: NativeArray_1[ContactPairPoint]) -> None: ...
    def GetContactPoint(self, index: int) -> clr.Reference[ContactPairPoint]: ...
    def GetContactPointFaceIndex(self, contactIndex: int) -> int: ...


class ContactPairHeader:
    @property
    def Body(self) -> Component: ...
    @property
    def BodyInstanceID(self) -> int: ...
    @property
    def OtherBody(self) -> Component: ...
    @property
    def OtherBodyInstanceID(self) -> int: ...
    @property
    def PairCount(self) -> int: ...
    def GetContactPair(self, index: int) -> clr.Reference[ContactPair]: ...


class ContactPairPoint:
    @property
    def Impulse(self) -> Vector3: ...
    @property
    def Normal(self) -> Vector3: ...
    @property
    def Position(self) -> Vector3: ...
    @property
    def Separation(self) -> float: ...


class ContactPoint:
    @property
    def impulse(self) -> Vector3: ...
    @property
    def normal(self) -> Vector3: ...
    @property
    def otherCollider(self) -> Collider: ...
    @property
    def point(self) -> Vector3: ...
    @property
    def separation(self) -> float: ...
    @property
    def thisCollider(self) -> Collider: ...


class ContactPoint2D:
    @property
    def collider(self) -> Collider2D: ...
    @property
    def enabled(self) -> bool: ...
    @property
    def normal(self) -> Vector2: ...
    @property
    def normalImpulse(self) -> float: ...
    @property
    def otherCollider(self) -> Collider2D: ...
    @property
    def otherRigidbody(self) -> Rigidbody2D: ...
    @property
    def point(self) -> Vector2: ...
    @property
    def relativeVelocity(self) -> Vector2: ...
    @property
    def rigidbody(self) -> Rigidbody2D: ...
    @property
    def separation(self) -> float: ...
    @property
    def tangentImpulse(self) -> float: ...


class ContextMenu(Attribute):
    @typing.overload
    def __init__(self, itemName: str) -> None: ...
    @typing.overload
    def __init__(self, itemName: str, isValidateFunction: bool) -> None: ...
    @typing.overload
    def __init__(self, itemName: str, isValidateFunction: bool, priority: int) -> None: ...
    menuItem : str
    priority : int
    validate : bool
    @property
    def TypeId(self) -> typing.Any: ...


class ContextMenuItemAttribute(PropertyAttribute):
    def __init__(self, name: str, function: str) -> None: ...
    function : str
    name : str
    @property
    def order(self) -> int: ...
    @order.setter
    def order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class ControllerColliderHit:
    def __init__(self) -> None: ...
    @property
    def collider(self) -> Collider: ...
    @property
    def controller(self) -> CharacterController: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def moveDirection(self) -> Vector3: ...
    @property
    def moveLength(self) -> float: ...
    @property
    def normal(self) -> Vector3: ...
    @property
    def point(self) -> Vector3: ...
    @property
    def rigidbody(self) -> Rigidbody: ...
    @property
    def transform(self) -> Transform: ...


class Coroutine(YieldInstruction):
    pass


class CrashReport:
    text : str
    time : DateTime
    @classmethod
    @property
    def lastReport(cls) -> CrashReport: ...
    @classmethod
    @property
    def reports(cls) -> Array_1[CrashReport]: ...
    def Remove(self) -> None: ...
    @staticmethod
    def RemoveAll() -> None: ...


class CreateAssetMenuAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def fileName(self) -> str: ...
    @fileName.setter
    def fileName(self, value: str) -> str: ...
    @property
    def menuName(self) -> str: ...
    @menuName.setter
    def menuName(self, value: str) -> str: ...
    @property
    def order(self) -> int: ...
    @order.setter
    def order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class Cubemap(Texture):
    # Constructor .ctor(width : Int32, textureFormat : TextureFormat, mipChain : Boolean) was skipped since it collides with above method
    # Constructor .ctor(width : Int32, textureFormat : TextureFormat, mipChain : Boolean, createUninitialized : Boolean) was skipped since it collides with above method
    @typing.overload
    def __init__(self, width: int, format: DefaultFormat, flags: TextureCreationFlags) -> None: ...
    @typing.overload
    def __init__(self, width: int, format: GraphicsFormat, flags: TextureCreationFlags) -> None: ...
    @typing.overload
    def __init__(self, width: int, format: DefaultFormat, flags: TextureCreationFlags, mipCount: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, format: GraphicsFormat, flags: TextureCreationFlags, mipCount: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, format: TextureFormat, mipCount: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, format: TextureFormat, mipCount: int, createUninitialized: bool) -> None: ...
    @property
    def anisoLevel(self) -> int: ...
    @anisoLevel.setter
    def anisoLevel(self, value: int) -> int: ...
    @property
    def desiredMipmapLevel(self) -> int: ...
    @property
    def dimension(self) -> TextureDimension: ...
    @dimension.setter
    def dimension(self, value: TextureDimension) -> TextureDimension: ...
    @property
    def filterMode(self) -> FilterMode: ...
    @filterMode.setter
    def filterMode(self, value: FilterMode) -> FilterMode: ...
    @property
    def format(self) -> TextureFormat: ...
    @property
    def graphicsFormat(self) -> GraphicsFormat: ...
    @property
    def height(self) -> int: ...
    @height.setter
    def height(self, value: int) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def imageContentsHash(self) -> Hash128: ...
    @imageContentsHash.setter
    def imageContentsHash(self, value: Hash128) -> Hash128: ...
    @property
    def isDataSRGB(self) -> bool: ...
    @property
    def isReadable(self) -> bool: ...
    @property
    def loadedMipmapLevel(self) -> int: ...
    @property
    def loadingMipmapLevel(self) -> int: ...
    @property
    def mipMapBias(self) -> float: ...
    @mipMapBias.setter
    def mipMapBias(self, value: float) -> float: ...
    @property
    def mipmapCount(self) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def requestedMipmapLevel(self) -> int: ...
    @requestedMipmapLevel.setter
    def requestedMipmapLevel(self, value: int) -> int: ...
    @property
    def streamingMipmaps(self) -> bool: ...
    @property
    def streamingMipmapsPriority(self) -> int: ...
    @property
    def texelSize(self) -> Vector2: ...
    @property
    def updateCount(self) -> int: ...
    @property
    def width(self) -> int: ...
    @width.setter
    def width(self, value: int) -> int: ...
    @property
    def wrapMode(self) -> TextureWrapMode: ...
    @wrapMode.setter
    def wrapMode(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeU(self) -> TextureWrapMode: ...
    @wrapModeU.setter
    def wrapModeU(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeV(self) -> TextureWrapMode: ...
    @wrapModeV.setter
    def wrapModeV(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeW(self) -> TextureWrapMode: ...
    @wrapModeW.setter
    def wrapModeW(self, value: TextureWrapMode) -> TextureWrapMode: ...
    def ClearRequestedMipmapLevel(self) -> None: ...
    @staticmethod
    def CreateExternalTexture(width: int, format: TextureFormat, mipmap: bool, nativeTex: int) -> Cubemap: ...
    def IsRequestedMipmapLevelLoaded(self) -> bool: ...
    def UpdateExternalTexture(self, nativeTexture: int) -> None: ...
    # Skipped Apply due to it being static, abstract and generic.

    Apply : Apply_MethodGroup
    class Apply_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, updateMipmaps: bool) -> None:...
        @typing.overload
        def __call__(self, updateMipmaps: bool, makeNoLongerReadable: bool) -> None:...

    # Skipped GetPixel due to it being static, abstract and generic.

    GetPixel : GetPixel_MethodGroup
    class GetPixel_MethodGroup:
        @typing.overload
        def __call__(self, face: CubemapFace, x: int, y: int) -> Color:...
        @typing.overload
        def __call__(self, face: CubemapFace, x: int, y: int, mip: int) -> Color:...

    # Skipped GetPixelData due to it being static, abstract and generic.

    GetPixelData : GetPixelData_MethodGroup
    class GetPixelData_MethodGroup:
        def __getitem__(self, t:typing.Type[GetPixelData_1_T1]) -> GetPixelData_1[GetPixelData_1_T1]: ...

        GetPixelData_1_T1 = typing.TypeVar('GetPixelData_1_T1')
        class GetPixelData_1(typing.Generic[GetPixelData_1_T1]):
            GetPixelData_1_T = Cubemap.GetPixelData_MethodGroup.GetPixelData_1_T1
            def __call__(self, mipLevel: int, face: CubemapFace) -> NativeArray_1[GetPixelData_1_T]:...


    # Skipped GetPixels due to it being static, abstract and generic.

    GetPixels : GetPixels_MethodGroup
    class GetPixels_MethodGroup:
        @typing.overload
        def __call__(self, face: CubemapFace) -> Array_1[Color]:...
        @typing.overload
        def __call__(self, face: CubemapFace, miplevel: int) -> Array_1[Color]:...

    # Skipped SetPixel due to it being static, abstract and generic.

    SetPixel : SetPixel_MethodGroup
    class SetPixel_MethodGroup:
        @typing.overload
        def __call__(self, face: CubemapFace, x: int, y: int, color: Color) -> None:...
        @typing.overload
        def __call__(self, face: CubemapFace, x: int, y: int, color: Color, mip: int) -> None:...

    # Skipped SetPixelData due to it being static, abstract and generic.

    SetPixelData : SetPixelData_MethodGroup
    class SetPixelData_MethodGroup:
        def __getitem__(self, t:typing.Type[SetPixelData_1_T1]) -> SetPixelData_1[SetPixelData_1_T1]: ...

        SetPixelData_1_T1 = typing.TypeVar('SetPixelData_1_T1')
        class SetPixelData_1(typing.Generic[SetPixelData_1_T1]):
            SetPixelData_1_T = Cubemap.SetPixelData_MethodGroup.SetPixelData_1_T1
            @typing.overload
            def __call__(self, data: Array_1[SetPixelData_1_T], mipLevel: int, face: CubemapFace, sourceDataStartIndex: int = ...) -> None:...
            @typing.overload
            def __call__(self, data: NativeArray_1[SetPixelData_1_T], mipLevel: int, face: CubemapFace, sourceDataStartIndex: int = ...) -> None:...


    # Skipped SetPixels due to it being static, abstract and generic.

    SetPixels : SetPixels_MethodGroup
    class SetPixels_MethodGroup:
        @typing.overload
        def __call__(self, colors: Array_1[Color], face: CubemapFace) -> None:...
        @typing.overload
        def __call__(self, colors: Array_1[Color], face: CubemapFace, miplevel: int) -> None:...

    # Skipped SmoothEdges due to it being static, abstract and generic.

    SmoothEdges : SmoothEdges_MethodGroup
    class SmoothEdges_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, smoothRegionWidthInPixels: int) -> None:...



class CubemapArray(Texture):
    # Constructor .ctor(width : Int32, cubemapCount : Int32, textureFormat : TextureFormat, mipCount : Int32, linear : Boolean) was skipped since it collides with above method
    # Constructor .ctor(width : Int32, cubemapCount : Int32, textureFormat : TextureFormat, mipCount : Int32, linear : Boolean, createUninitialized : Boolean) was skipped since it collides with above method
    @typing.overload
    def __init__(self, width: int, cubemapCount: int, format: DefaultFormat, flags: TextureCreationFlags) -> None: ...
    @typing.overload
    def __init__(self, width: int, cubemapCount: int, format: GraphicsFormat, flags: TextureCreationFlags) -> None: ...
    @typing.overload
    def __init__(self, width: int, cubemapCount: int, format: DefaultFormat, flags: TextureCreationFlags, mipCount: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, cubemapCount: int, format: GraphicsFormat, flags: TextureCreationFlags, mipCount: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, cubemapCount: int, textureFormat: TextureFormat, mipChain: bool) -> None: ...
    @typing.overload
    def __init__(self, width: int, cubemapCount: int, textureFormat: TextureFormat, mipChain: bool, linear: bool) -> None: ...
    @typing.overload
    def __init__(self, width: int, cubemapCount: int, textureFormat: TextureFormat, mipChain: bool, linear: bool, createUninitialized: bool) -> None: ...
    @property
    def anisoLevel(self) -> int: ...
    @anisoLevel.setter
    def anisoLevel(self, value: int) -> int: ...
    @property
    def cubemapCount(self) -> int: ...
    @property
    def dimension(self) -> TextureDimension: ...
    @dimension.setter
    def dimension(self, value: TextureDimension) -> TextureDimension: ...
    @property
    def filterMode(self) -> FilterMode: ...
    @filterMode.setter
    def filterMode(self, value: FilterMode) -> FilterMode: ...
    @property
    def format(self) -> TextureFormat: ...
    @property
    def graphicsFormat(self) -> GraphicsFormat: ...
    @property
    def height(self) -> int: ...
    @height.setter
    def height(self, value: int) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def imageContentsHash(self) -> Hash128: ...
    @imageContentsHash.setter
    def imageContentsHash(self, value: Hash128) -> Hash128: ...
    @property
    def isDataSRGB(self) -> bool: ...
    @property
    def isReadable(self) -> bool: ...
    @property
    def mipMapBias(self) -> float: ...
    @mipMapBias.setter
    def mipMapBias(self, value: float) -> float: ...
    @property
    def mipmapCount(self) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def texelSize(self) -> Vector2: ...
    @property
    def updateCount(self) -> int: ...
    @property
    def width(self) -> int: ...
    @width.setter
    def width(self, value: int) -> int: ...
    @property
    def wrapMode(self) -> TextureWrapMode: ...
    @wrapMode.setter
    def wrapMode(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeU(self) -> TextureWrapMode: ...
    @wrapModeU.setter
    def wrapModeU(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeV(self) -> TextureWrapMode: ...
    @wrapModeV.setter
    def wrapModeV(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeW(self) -> TextureWrapMode: ...
    @wrapModeW.setter
    def wrapModeW(self, value: TextureWrapMode) -> TextureWrapMode: ...
    # Skipped Apply due to it being static, abstract and generic.

    Apply : Apply_MethodGroup
    class Apply_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, updateMipmaps: bool) -> None:...
        @typing.overload
        def __call__(self, updateMipmaps: bool, makeNoLongerReadable: bool) -> None:...

    # Skipped GetPixelData due to it being static, abstract and generic.

    GetPixelData : GetPixelData_MethodGroup
    class GetPixelData_MethodGroup:
        def __getitem__(self, t:typing.Type[GetPixelData_1_T1]) -> GetPixelData_1[GetPixelData_1_T1]: ...

        GetPixelData_1_T1 = typing.TypeVar('GetPixelData_1_T1')
        class GetPixelData_1(typing.Generic[GetPixelData_1_T1]):
            GetPixelData_1_T = CubemapArray.GetPixelData_MethodGroup.GetPixelData_1_T1
            def __call__(self, mipLevel: int, face: CubemapFace, element: int) -> NativeArray_1[GetPixelData_1_T]:...


    # Skipped GetPixels due to it being static, abstract and generic.

    GetPixels : GetPixels_MethodGroup
    class GetPixels_MethodGroup:
        @typing.overload
        def __call__(self, face: CubemapFace, arrayElement: int) -> Array_1[Color]:...
        @typing.overload
        def __call__(self, face: CubemapFace, arrayElement: int, miplevel: int) -> Array_1[Color]:...

    # Skipped GetPixels32 due to it being static, abstract and generic.

    GetPixels32 : GetPixels32_MethodGroup
    class GetPixels32_MethodGroup:
        @typing.overload
        def __call__(self, face: CubemapFace, arrayElement: int) -> Array_1[Color32]:...
        @typing.overload
        def __call__(self, face: CubemapFace, arrayElement: int, miplevel: int) -> Array_1[Color32]:...

    # Skipped SetPixelData due to it being static, abstract and generic.

    SetPixelData : SetPixelData_MethodGroup
    class SetPixelData_MethodGroup:
        def __getitem__(self, t:typing.Type[SetPixelData_1_T1]) -> SetPixelData_1[SetPixelData_1_T1]: ...

        SetPixelData_1_T1 = typing.TypeVar('SetPixelData_1_T1')
        class SetPixelData_1(typing.Generic[SetPixelData_1_T1]):
            SetPixelData_1_T = CubemapArray.SetPixelData_MethodGroup.SetPixelData_1_T1
            @typing.overload
            def __call__(self, data: Array_1[SetPixelData_1_T], mipLevel: int, face: CubemapFace, element: int, sourceDataStartIndex: int = ...) -> None:...
            @typing.overload
            def __call__(self, data: NativeArray_1[SetPixelData_1_T], mipLevel: int, face: CubemapFace, element: int, sourceDataStartIndex: int = ...) -> None:...


    # Skipped SetPixels due to it being static, abstract and generic.

    SetPixels : SetPixels_MethodGroup
    class SetPixels_MethodGroup:
        @typing.overload
        def __call__(self, colors: Array_1[Color], face: CubemapFace, arrayElement: int) -> None:...
        @typing.overload
        def __call__(self, colors: Array_1[Color], face: CubemapFace, arrayElement: int, miplevel: int) -> None:...

    # Skipped SetPixels32 due to it being static, abstract and generic.

    SetPixels32 : SetPixels32_MethodGroup
    class SetPixels32_MethodGroup:
        @typing.overload
        def __call__(self, colors: Array_1[Color32], face: CubemapFace, arrayElement: int) -> None:...
        @typing.overload
        def __call__(self, colors: Array_1[Color32], face: CubemapFace, arrayElement: int, miplevel: int) -> None:...



class CubemapFace(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    PositiveX : CubemapFace # 0
    NegativeX : CubemapFace # 1
    PositiveY : CubemapFace # 2
    NegativeY : CubemapFace # 3
    PositiveZ : CubemapFace # 4
    NegativeZ : CubemapFace # 5
    Unknown : CubemapFace # -1


class CullingGroup(IDisposable):
    def __init__(self) -> None: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def onStateChanged(self) -> CullingGroup.StateChanged: ...
    @onStateChanged.setter
    def onStateChanged(self, value: CullingGroup.StateChanged) -> CullingGroup.StateChanged: ...
    @property
    def targetCamera(self) -> Camera: ...
    @targetCamera.setter
    def targetCamera(self, value: Camera) -> Camera: ...
    def Dispose(self) -> None: ...
    def GetDistance(self, index: int) -> int: ...
    def IsVisible(self, index: int) -> bool: ...
    def SetBoundingDistances(self, distances: Array_1[float]) -> None: ...
    def SetBoundingSphereCount(self, count: int) -> None: ...
    def SetBoundingSpheres(self, array: Array_1[BoundingSphere]) -> None: ...
    # Skipped EraseSwapBack due to it being static, abstract and generic.

    EraseSwapBack : EraseSwapBack_MethodGroup
    class EraseSwapBack_MethodGroup:
        def __getitem__(self, t:typing.Type[EraseSwapBack_1_T1]) -> EraseSwapBack_1[EraseSwapBack_1_T1]: ...

        EraseSwapBack_1_T1 = typing.TypeVar('EraseSwapBack_1_T1')
        class EraseSwapBack_1(typing.Generic[EraseSwapBack_1_T1]):
            EraseSwapBack_1_T = CullingGroup.EraseSwapBack_MethodGroup.EraseSwapBack_1_T1
            def __call__(self, index: int, myArray: Array_1[EraseSwapBack_1_T], size: clr.Reference[int]) -> None:...

        def __call__(self, index: int) -> None:...

    # Skipped QueryIndices due to it being static, abstract and generic.

    QueryIndices : QueryIndices_MethodGroup
    class QueryIndices_MethodGroup:
        @typing.overload
        def __call__(self, distanceIndex: int, result: Array_1[int], firstIndex: int) -> int:...
        # Method QueryIndices(visible : Boolean, result : Int32[], firstIndex : Int32) was skipped since it collides with above method
        @typing.overload
        def __call__(self, visible: bool, distanceIndex: int, result: Array_1[int], firstIndex: int) -> int:...

    # Skipped SetDistanceReferencePoint due to it being static, abstract and generic.

    SetDistanceReferencePoint : SetDistanceReferencePoint_MethodGroup
    class SetDistanceReferencePoint_MethodGroup:
        @typing.overload
        def __call__(self, transform: Transform) -> None:...
        @typing.overload
        def __call__(self, point: Vector3) -> None:...


    class StateChanged(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, sphere: CullingGroupEvent, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, sphere: CullingGroupEvent) -> None: ...



class CullingGroupEvent:
    @property
    def currentDistance(self) -> int: ...
    @property
    def hasBecomeInvisible(self) -> bool: ...
    @property
    def hasBecomeVisible(self) -> bool: ...
    @property
    def index(self) -> int: ...
    @property
    def isVisible(self) -> bool: ...
    @property
    def previousDistance(self) -> int: ...
    @property
    def wasVisible(self) -> bool: ...


class Cursor:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def lockState(cls) -> CursorLockMode: ...
    @classmethod
    @lockState.setter
    def lockState(cls, value: CursorLockMode) -> CursorLockMode: ...
    @classmethod
    @property
    def visible(cls) -> bool: ...
    @classmethod
    @visible.setter
    def visible(cls, value: bool) -> bool: ...
    @staticmethod
    def SetCursor(texture: Texture2D, hotspot: Vector2, cursorMode: CursorMode) -> None: ...


class CursorLockMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : CursorLockMode # 0
    Locked : CursorLockMode # 1
    Confined : CursorLockMode # 2


class CursorMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Auto : CursorMode # 0
    ForceSoftware : CursorMode # 1


class CustomCollider2D(Collider2D):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounciness(self) -> float: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def callbackLayers(self) -> LayerMask: ...
    @callbackLayers.setter
    def callbackLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def composite(self) -> CompositeCollider2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def contactCaptureLayers(self) -> LayerMask: ...
    @contactCaptureLayers.setter
    def contactCaptureLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def customShapeCount(self) -> int: ...
    @property
    def customVertexCount(self) -> int: ...
    @property
    def density(self) -> float: ...
    @density.setter
    def density(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def errorState(self) -> ColliderErrorState2D: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def forceReceiveLayers(self) -> LayerMask: ...
    @forceReceiveLayers.setter
    def forceReceiveLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def forceSendLayers(self) -> LayerMask: ...
    @forceSendLayers.setter
    def forceSendLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def friction(self) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def isTrigger(self) -> bool: ...
    @isTrigger.setter
    def isTrigger(self, value: bool) -> bool: ...
    @property
    def layerOverridePriority(self) -> int: ...
    @layerOverridePriority.setter
    def layerOverridePriority(self, value: int) -> int: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def offset(self) -> Vector2: ...
    @offset.setter
    def offset(self, value: Vector2) -> Vector2: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def shapeCount(self) -> int: ...
    @property
    def sharedMaterial(self) -> PhysicsMaterial2D: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: PhysicsMaterial2D) -> PhysicsMaterial2D: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def usedByComposite(self) -> bool: ...
    @usedByComposite.setter
    def usedByComposite(self, value: bool) -> bool: ...
    @property
    def usedByEffector(self) -> bool: ...
    @usedByEffector.setter
    def usedByEffector(self, value: bool) -> bool: ...
    # Skipped ClearCustomShapes due to it being static, abstract and generic.

    ClearCustomShapes : ClearCustomShapes_MethodGroup
    class ClearCustomShapes_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, shapeIndex: int, shapeCount: int) -> None:...

    # Skipped GetCustomShapes due to it being static, abstract and generic.

    GetCustomShapes : GetCustomShapes_MethodGroup
    class GetCustomShapes_MethodGroup:
        @typing.overload
        def __call__(self, physicsShapeGroup: PhysicsShapeGroup2D) -> int:...
        @typing.overload
        def __call__(self, shapes: NativeArray_1[PhysicsShape2D], vertices: NativeArray_1[Vector2]) -> int:...
        @typing.overload
        def __call__(self, physicsShapeGroup: PhysicsShapeGroup2D, shapeIndex: int, shapeCount: int = ...) -> int:...

    # Skipped SetCustomShape due to it being static, abstract and generic.

    SetCustomShape : SetCustomShape_MethodGroup
    class SetCustomShape_MethodGroup:
        @typing.overload
        def __call__(self, physicsShapeGroup: PhysicsShapeGroup2D, srcShapeIndex: int, dstShapeIndex: int) -> None:...
        @typing.overload
        def __call__(self, shapes: NativeArray_1[PhysicsShape2D], vertices: NativeArray_1[Vector2], srcShapeIndex: int, dstShapeIndex: int) -> None:...

    # Skipped SetCustomShapes due to it being static, abstract and generic.

    SetCustomShapes : SetCustomShapes_MethodGroup
    class SetCustomShapes_MethodGroup:
        @typing.overload
        def __call__(self, physicsShapeGroup: PhysicsShapeGroup2D) -> None:...
        @typing.overload
        def __call__(self, shapes: NativeArray_1[PhysicsShape2D], vertices: NativeArray_1[Vector2]) -> None:...



class CustomGridBrushAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, hideAssetInstances: bool, hideDefaultInstance: bool, defaultBrush: bool, defaultName: str) -> None: ...
    @property
    def defaultBrush(self) -> bool: ...
    @property
    def defaultName(self) -> str: ...
    @property
    def hideAssetInstances(self) -> bool: ...
    @property
    def hideDefaultInstance(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...


class CustomRenderTexture(RenderTexture):
    @typing.overload
    def __init__(self, width: int, height: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, defaultFormat: DefaultFormat) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, format: RenderTextureFormat) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, format: GraphicsFormat) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, format: RenderTextureFormat, readWrite: RenderTextureReadWrite) -> None: ...
    @property
    def anisoLevel(self) -> int: ...
    @anisoLevel.setter
    def anisoLevel(self, value: int) -> int: ...
    @property
    def antiAliasing(self) -> int: ...
    @antiAliasing.setter
    def antiAliasing(self, value: int) -> int: ...
    @property
    def autoGenerateMips(self) -> bool: ...
    @autoGenerateMips.setter
    def autoGenerateMips(self, value: bool) -> bool: ...
    @property
    def bindTextureMS(self) -> bool: ...
    @bindTextureMS.setter
    def bindTextureMS(self, value: bool) -> bool: ...
    @property
    def colorBuffer(self) -> RenderBuffer: ...
    @property
    def cubemapFaceMask(self) -> int: ...
    @cubemapFaceMask.setter
    def cubemapFaceMask(self, value: int) -> int: ...
    @property
    def depth(self) -> int: ...
    @depth.setter
    def depth(self, value: int) -> int: ...
    @property
    def depthBuffer(self) -> RenderBuffer: ...
    @property
    def depthStencilFormat(self) -> GraphicsFormat: ...
    @depthStencilFormat.setter
    def depthStencilFormat(self, value: GraphicsFormat) -> GraphicsFormat: ...
    @property
    def descriptor(self) -> RenderTextureDescriptor: ...
    @descriptor.setter
    def descriptor(self, value: RenderTextureDescriptor) -> RenderTextureDescriptor: ...
    @property
    def dimension(self) -> TextureDimension: ...
    @dimension.setter
    def dimension(self, value: TextureDimension) -> TextureDimension: ...
    @property
    def doubleBuffered(self) -> bool: ...
    @doubleBuffered.setter
    def doubleBuffered(self, value: bool) -> bool: ...
    @property
    def enableRandomWrite(self) -> bool: ...
    @enableRandomWrite.setter
    def enableRandomWrite(self, value: bool) -> bool: ...
    @property
    def filterMode(self) -> FilterMode: ...
    @filterMode.setter
    def filterMode(self, value: FilterMode) -> FilterMode: ...
    @property
    def format(self) -> RenderTextureFormat: ...
    @format.setter
    def format(self, value: RenderTextureFormat) -> RenderTextureFormat: ...
    @property
    def generateMips(self) -> bool: ...
    @generateMips.setter
    def generateMips(self, value: bool) -> bool: ...
    @property
    def graphicsFormat(self) -> GraphicsFormat: ...
    @graphicsFormat.setter
    def graphicsFormat(self, value: GraphicsFormat) -> GraphicsFormat: ...
    @property
    def height(self) -> int: ...
    @height.setter
    def height(self, value: int) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def imageContentsHash(self) -> Hash128: ...
    @imageContentsHash.setter
    def imageContentsHash(self, value: Hash128) -> Hash128: ...
    @property
    def initializationColor(self) -> Color: ...
    @initializationColor.setter
    def initializationColor(self, value: Color) -> Color: ...
    @property
    def initializationMaterial(self) -> Material: ...
    @initializationMaterial.setter
    def initializationMaterial(self, value: Material) -> Material: ...
    @property
    def initializationMode(self) -> CustomRenderTextureUpdateMode: ...
    @initializationMode.setter
    def initializationMode(self, value: CustomRenderTextureUpdateMode) -> CustomRenderTextureUpdateMode: ...
    @property
    def initializationSource(self) -> CustomRenderTextureInitializationSource: ...
    @initializationSource.setter
    def initializationSource(self, value: CustomRenderTextureInitializationSource) -> CustomRenderTextureInitializationSource: ...
    @property
    def initializationTexture(self) -> Texture: ...
    @initializationTexture.setter
    def initializationTexture(self, value: Texture) -> Texture: ...
    @property
    def isCubemap(self) -> bool: ...
    @isCubemap.setter
    def isCubemap(self, value: bool) -> bool: ...
    @property
    def isDataSRGB(self) -> bool: ...
    @property
    def isPowerOfTwo(self) -> bool: ...
    @isPowerOfTwo.setter
    def isPowerOfTwo(self, value: bool) -> bool: ...
    @property
    def isReadable(self) -> bool: ...
    @property
    def isVolume(self) -> bool: ...
    @isVolume.setter
    def isVolume(self, value: bool) -> bool: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> Material: ...
    @property
    def memorylessMode(self) -> RenderTextureMemoryless: ...
    @memorylessMode.setter
    def memorylessMode(self, value: RenderTextureMemoryless) -> RenderTextureMemoryless: ...
    @property
    def mipMapBias(self) -> float: ...
    @mipMapBias.setter
    def mipMapBias(self, value: float) -> float: ...
    @property
    def mipmapCount(self) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def shaderPass(self) -> int: ...
    @shaderPass.setter
    def shaderPass(self, value: int) -> int: ...
    @property
    def sRGB(self) -> bool: ...
    @property
    def stencilFormat(self) -> GraphicsFormat: ...
    @stencilFormat.setter
    def stencilFormat(self, value: GraphicsFormat) -> GraphicsFormat: ...
    @property
    def texelSize(self) -> Vector2: ...
    @property
    def updateCount(self) -> int: ...
    @property
    def updateMode(self) -> CustomRenderTextureUpdateMode: ...
    @updateMode.setter
    def updateMode(self, value: CustomRenderTextureUpdateMode) -> CustomRenderTextureUpdateMode: ...
    @property
    def updatePeriod(self) -> float: ...
    @updatePeriod.setter
    def updatePeriod(self, value: float) -> float: ...
    @property
    def updateZoneSpace(self) -> CustomRenderTextureUpdateZoneSpace: ...
    @updateZoneSpace.setter
    def updateZoneSpace(self, value: CustomRenderTextureUpdateZoneSpace) -> CustomRenderTextureUpdateZoneSpace: ...
    @property
    def useDynamicScale(self) -> bool: ...
    @useDynamicScale.setter
    def useDynamicScale(self, value: bool) -> bool: ...
    @property
    def useMipMap(self) -> bool: ...
    @useMipMap.setter
    def useMipMap(self, value: bool) -> bool: ...
    @property
    def volumeDepth(self) -> int: ...
    @volumeDepth.setter
    def volumeDepth(self, value: int) -> int: ...
    @property
    def vrUsage(self) -> VRTextureUsage: ...
    @vrUsage.setter
    def vrUsage(self, value: VRTextureUsage) -> VRTextureUsage: ...
    @property
    def width(self) -> int: ...
    @width.setter
    def width(self, value: int) -> int: ...
    @property
    def wrapMode(self) -> TextureWrapMode: ...
    @wrapMode.setter
    def wrapMode(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeU(self) -> TextureWrapMode: ...
    @wrapModeU.setter
    def wrapModeU(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeV(self) -> TextureWrapMode: ...
    @wrapModeV.setter
    def wrapModeV(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeW(self) -> TextureWrapMode: ...
    @wrapModeW.setter
    def wrapModeW(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapUpdateZones(self) -> bool: ...
    @wrapUpdateZones.setter
    def wrapUpdateZones(self, value: bool) -> bool: ...
    def ClearUpdateZones(self) -> None: ...
    def EnsureDoubleBufferConsistency(self) -> None: ...
    def GetDoubleBufferRenderTexture(self) -> RenderTexture: ...
    def GetUpdateZones(self, updateZones: List_1[CustomRenderTextureUpdateZone]) -> None: ...
    def Initialize(self) -> None: ...
    def SetUpdateZones(self, updateZones: Array_1[CustomRenderTextureUpdateZone]) -> None: ...
    # Skipped Update due to it being static, abstract and generic.

    Update : Update_MethodGroup
    class Update_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, count: int) -> None:...



class CustomRenderTextureInitializationSource(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    TextureAndColor : CustomRenderTextureInitializationSource # 0
    Material : CustomRenderTextureInitializationSource # 1


class CustomRenderTextureManager(abc.ABC):
    @staticmethod
    def GetAllCustomRenderTextures(currentCustomRenderTextures: List_1[CustomRenderTexture]) -> None: ...


class CustomRenderTextureUpdateMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    OnLoad : CustomRenderTextureUpdateMode # 0
    Realtime : CustomRenderTextureUpdateMode # 1
    OnDemand : CustomRenderTextureUpdateMode # 2


class CustomRenderTextureUpdateZone:
    needSwap : bool
    passIndex : int
    rotation : float
    updateZoneCenter : Vector3
    updateZoneSize : Vector3


class CustomRenderTextureUpdateZoneSpace(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Normalized : CustomRenderTextureUpdateZoneSpace # 0
    Pixel : CustomRenderTextureUpdateZoneSpace # 1


class CustomYieldInstruction(IEnumerator, abc.ABC):
    @property
    def Current(self) -> typing.Any: ...
    @property
    def keepWaiting(self) -> bool: ...
    def MoveNext(self) -> bool: ...
    def Reset(self) -> None: ...


class D3DHDRDisplayBitDepth(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    D3DHDRDisplayBitDepth10 : D3DHDRDisplayBitDepth # 0
    D3DHDRDisplayBitDepth16 : D3DHDRDisplayBitDepth # 1


class Debug:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def developerConsoleEnabled(cls) -> bool: ...
    @classmethod
    @developerConsoleEnabled.setter
    def developerConsoleEnabled(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def developerConsoleVisible(cls) -> bool: ...
    @classmethod
    @developerConsoleVisible.setter
    def developerConsoleVisible(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def isDebugBuild(cls) -> bool: ...
    @classmethod
    @property
    def logger(cls) -> ILogger: ...
    @classmethod
    @property
    def unityLogger(cls) -> ILogger: ...
    @staticmethod
    def Break() -> None: ...
    @staticmethod
    def ClearDeveloperConsole() -> None: ...
    @staticmethod
    def DebugBreak() -> None: ...
    @staticmethod
    def ExtractStackTraceNoAlloc(buffer: clr.Reference[int], bufferMax: int, projectFolder: str) -> int: ...
    # Skipped Assert due to it being static, abstract and generic.

    Assert : Assert_MethodGroup
    class Assert_MethodGroup:
        @typing.overload
        def __call__(self, condition: bool) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, context: Object) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: typing.Any) -> None:...
        @typing.overload
        def __call__(self, condition: bool, format: str, args: Array_1[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: str, context: Object) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: typing.Any, context: Object) -> None:...

    # Skipped AssertFormat due to it being static, abstract and generic.

    AssertFormat : AssertFormat_MethodGroup
    class AssertFormat_MethodGroup:
        @typing.overload
        def __call__(self, condition: bool, format: str, args: Array_1[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, condition: bool, context: Object, format: str, args: Array_1[typing.Any]) -> None:...

    # Skipped DrawLine due to it being static, abstract and generic.

    DrawLine : DrawLine_MethodGroup
    class DrawLine_MethodGroup:
        @typing.overload
        def __call__(self, start: Vector3, end: Vector3) -> None:...
        @typing.overload
        def __call__(self, start: Vector3, end: Vector3, color: Color) -> None:...
        @typing.overload
        def __call__(self, start: Vector3, end: Vector3, color: Color, duration: float) -> None:...
        @typing.overload
        def __call__(self, start: Vector3, end: Vector3, color: Color, duration: float, depthTest: bool) -> None:...

    # Skipped DrawRay due to it being static, abstract and generic.

    DrawRay : DrawRay_MethodGroup
    class DrawRay_MethodGroup:
        @typing.overload
        def __call__(self, start: Vector3, dir: Vector3) -> None:...
        @typing.overload
        def __call__(self, start: Vector3, dir: Vector3, color: Color) -> None:...
        @typing.overload
        def __call__(self, start: Vector3, dir: Vector3, color: Color, duration: float) -> None:...
        @typing.overload
        def __call__(self, start: Vector3, dir: Vector3, color: Color, duration: float, depthTest: bool) -> None:...

    # Skipped Log due to it being static, abstract and generic.

    Log : Log_MethodGroup
    class Log_MethodGroup:
        @typing.overload
        def __call__(self, message: typing.Any) -> None:...
        @typing.overload
        def __call__(self, message: typing.Any, context: Object) -> None:...

    # Skipped LogAssertion due to it being static, abstract and generic.

    LogAssertion : LogAssertion_MethodGroup
    class LogAssertion_MethodGroup:
        @typing.overload
        def __call__(self, message: typing.Any) -> None:...
        @typing.overload
        def __call__(self, message: typing.Any, context: Object) -> None:...

    # Skipped LogAssertionFormat due to it being static, abstract and generic.

    LogAssertionFormat : LogAssertionFormat_MethodGroup
    class LogAssertionFormat_MethodGroup:
        @typing.overload
        def __call__(self, format: str, args: Array_1[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, context: Object, format: str, args: Array_1[typing.Any]) -> None:...

    # Skipped LogError due to it being static, abstract and generic.

    LogError : LogError_MethodGroup
    class LogError_MethodGroup:
        @typing.overload
        def __call__(self, message: typing.Any) -> None:...
        @typing.overload
        def __call__(self, message: typing.Any, context: Object) -> None:...

    # Skipped LogErrorFormat due to it being static, abstract and generic.

    LogErrorFormat : LogErrorFormat_MethodGroup
    class LogErrorFormat_MethodGroup:
        @typing.overload
        def __call__(self, format: str, args: Array_1[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, context: Object, format: str, args: Array_1[typing.Any]) -> None:...

    # Skipped LogException due to it being static, abstract and generic.

    LogException : LogException_MethodGroup
    class LogException_MethodGroup:
        @typing.overload
        def __call__(self, exception: Exception) -> None:...
        @typing.overload
        def __call__(self, exception: Exception, context: Object) -> None:...

    # Skipped LogFormat due to it being static, abstract and generic.

    LogFormat : LogFormat_MethodGroup
    class LogFormat_MethodGroup:
        @typing.overload
        def __call__(self, format: str, args: Array_1[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, context: Object, format: str, args: Array_1[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, logType: LogType, logOptions: LogOption, context: Object, format: str, args: Array_1[typing.Any]) -> None:...

    # Skipped LogWarning due to it being static, abstract and generic.

    LogWarning : LogWarning_MethodGroup
    class LogWarning_MethodGroup:
        @typing.overload
        def __call__(self, message: typing.Any) -> None:...
        @typing.overload
        def __call__(self, message: typing.Any, context: Object) -> None:...

    # Skipped LogWarningFormat due to it being static, abstract and generic.

    LogWarningFormat : LogWarningFormat_MethodGroup
    class LogWarningFormat_MethodGroup:
        @typing.overload
        def __call__(self, format: str, args: Array_1[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, context: Object, format: str, args: Array_1[typing.Any]) -> None:...



class DefaultExecutionOrder(Attribute):
    def __init__(self, order: int) -> None: ...
    @property
    def order(self) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DelayedAttribute(PropertyAttribute):
    def __init__(self) -> None: ...
    @property
    def order(self) -> int: ...
    @order.setter
    def order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DepthTextureMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : DepthTextureMode # 0
    Depth : DepthTextureMode # 1
    DepthNormals : DepthTextureMode # 2
    MotionVectors : DepthTextureMode # 4


class DetailInstanceTransform:
    posX : float
    posY : float
    posZ : float
    rotationY : float
    scaleXZ : float
    scaleY : float


class DetailPrototype:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, other: DetailPrototype) -> None: ...
    @property
    def alignToGround(self) -> float: ...
    @alignToGround.setter
    def alignToGround(self, value: float) -> float: ...
    @property
    def bendFactor(self) -> float: ...
    @bendFactor.setter
    def bendFactor(self, value: float) -> float: ...
    @property
    def density(self) -> float: ...
    @density.setter
    def density(self, value: float) -> float: ...
    @property
    def dryColor(self) -> Color: ...
    @dryColor.setter
    def dryColor(self, value: Color) -> Color: ...
    @property
    def healthyColor(self) -> Color: ...
    @healthyColor.setter
    def healthyColor(self, value: Color) -> Color: ...
    @property
    def holeEdgePadding(self) -> float: ...
    @holeEdgePadding.setter
    def holeEdgePadding(self, value: float) -> float: ...
    @property
    def maxHeight(self) -> float: ...
    @maxHeight.setter
    def maxHeight(self, value: float) -> float: ...
    @property
    def maxWidth(self) -> float: ...
    @maxWidth.setter
    def maxWidth(self, value: float) -> float: ...
    @property
    def minHeight(self) -> float: ...
    @minHeight.setter
    def minHeight(self, value: float) -> float: ...
    @property
    def minWidth(self) -> float: ...
    @minWidth.setter
    def minWidth(self, value: float) -> float: ...
    @property
    def noiseSeed(self) -> int: ...
    @noiseSeed.setter
    def noiseSeed(self, value: int) -> int: ...
    @property
    def noiseSpread(self) -> float: ...
    @noiseSpread.setter
    def noiseSpread(self, value: float) -> float: ...
    @property
    def positionJitter(self) -> float: ...
    @positionJitter.setter
    def positionJitter(self, value: float) -> float: ...
    @property
    def prototype(self) -> GameObject: ...
    @prototype.setter
    def prototype(self, value: GameObject) -> GameObject: ...
    @property
    def prototypeTexture(self) -> Texture2D: ...
    @prototypeTexture.setter
    def prototypeTexture(self, value: Texture2D) -> Texture2D: ...
    @property
    def renderMode(self) -> DetailRenderMode: ...
    @renderMode.setter
    def renderMode(self, value: DetailRenderMode) -> DetailRenderMode: ...
    @property
    def targetCoverage(self) -> float: ...
    @targetCoverage.setter
    def targetCoverage(self, value: float) -> float: ...
    @property
    def useDensityScaling(self) -> bool: ...
    @useDensityScaling.setter
    def useDensityScaling(self, value: bool) -> bool: ...
    @property
    def useInstancing(self) -> bool: ...
    @useInstancing.setter
    def useInstancing(self, value: bool) -> bool: ...
    @property
    def usePrototypeMesh(self) -> bool: ...
    @usePrototypeMesh.setter
    def usePrototypeMesh(self, value: bool) -> bool: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    # Skipped Validate due to it being static, abstract and generic.

    Validate : Validate_MethodGroup
    class Validate_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, errorMessage: clr.Reference[str]) -> bool:...



class DetailRenderMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    GrassBillboard : DetailRenderMode # 0
    VertexLit : DetailRenderMode # 1
    Grass : DetailRenderMode # 2


class DetailScatterMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    CoverageMode : DetailScatterMode # 0
    InstanceCountMode : DetailScatterMode # 1


class DeviceOrientation(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : DeviceOrientation # 0
    Portrait : DeviceOrientation # 1
    PortraitUpsideDown : DeviceOrientation # 2
    LandscapeLeft : DeviceOrientation # 3
    LandscapeRight : DeviceOrientation # 4
    FaceUp : DeviceOrientation # 5
    FaceDown : DeviceOrientation # 6


class DeviceType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : DeviceType # 0
    Handheld : DeviceType # 1
    Console : DeviceType # 2
    Desktop : DeviceType # 3


class DisallowMultipleComponent(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class Display:
    displays : Array_1[Display]
    @property
    def active(self) -> bool: ...
    @classmethod
    @property
    def activeEditorGameViewTarget(cls) -> int: ...
    @classmethod
    @activeEditorGameViewTarget.setter
    def activeEditorGameViewTarget(cls, value: int) -> int: ...
    @property
    def colorBuffer(self) -> RenderBuffer: ...
    @property
    def depthBuffer(self) -> RenderBuffer: ...
    @classmethod
    @property
    def main(cls) -> Display: ...
    @property
    def renderingHeight(self) -> int: ...
    @property
    def renderingWidth(self) -> int: ...
    @property
    def requiresBlitToBackbuffer(self) -> bool: ...
    @property
    def requiresSrgbBlitToBackbuffer(self) -> bool: ...
    @property
    def systemHeight(self) -> int: ...
    @property
    def systemWidth(self) -> int: ...
    @staticmethod
    def MultiDisplayLicense() -> bool: ...
    @staticmethod
    def RelativeMouseAt(inputMouseCoordinates: Vector3) -> Vector3: ...
    def SetParams(self, width: int, height: int, x: int, y: int) -> None: ...
    def SetRenderingResolution(self, w: int, h: int) -> None: ...
    # Skipped Activate due to it being static, abstract and generic.

    Activate : Activate_MethodGroup
    class Activate_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, width: int, height: int, refreshRate: int) -> None:...
        @typing.overload
        def __call__(self, width: int, height: int, refreshRate: RefreshRate) -> None:...


    class DisplaysUpdatedDelegate(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self) -> None: ...



class DisplayInfo(IEquatable_1[DisplayInfo]):
    height : int
    name : str
    refreshRate : RefreshRate
    width : int
    workArea : RectInt
    def Equals(self, other: DisplayInfo) -> bool: ...


class DistanceJoint2D(AnchoredJoint2D):
    def __init__(self) -> None: ...
    @property
    def anchor(self) -> Vector2: ...
    @anchor.setter
    def anchor(self, value: Vector2) -> Vector2: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoConfigureConnectedAnchor(self) -> bool: ...
    @autoConfigureConnectedAnchor.setter
    def autoConfigureConnectedAnchor(self, value: bool) -> bool: ...
    @property
    def autoConfigureDistance(self) -> bool: ...
    @autoConfigureDistance.setter
    def autoConfigureDistance(self, value: bool) -> bool: ...
    @property
    def breakAction(self) -> JointBreakAction2D: ...
    @breakAction.setter
    def breakAction(self, value: JointBreakAction2D) -> JointBreakAction2D: ...
    @property
    def breakForce(self) -> float: ...
    @breakForce.setter
    def breakForce(self, value: float) -> float: ...
    @property
    def breakTorque(self) -> float: ...
    @breakTorque.setter
    def breakTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collideConnected(self) -> bool: ...
    @collideConnected.setter
    def collideConnected(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def connectedAnchor(self) -> Vector2: ...
    @connectedAnchor.setter
    def connectedAnchor(self, value: Vector2) -> Vector2: ...
    @property
    def connectedBody(self) -> Rigidbody2D: ...
    @connectedBody.setter
    def connectedBody(self, value: Rigidbody2D) -> Rigidbody2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def distance(self) -> float: ...
    @distance.setter
    def distance(self, value: float) -> float: ...
    @property
    def enableCollision(self) -> bool: ...
    @enableCollision.setter
    def enableCollision(self, value: bool) -> bool: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def maxDistanceOnly(self) -> bool: ...
    @maxDistanceOnly.setter
    def maxDistanceOnly(self, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def reactionForce(self) -> Vector2: ...
    @property
    def reactionTorque(self) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class DrivenRectTransformTracker:
    def Add(self, driver: Object, rectTransform: RectTransform, drivenProperties: DrivenTransformProperties) -> None: ...
    @staticmethod
    def StartRecordingUndo() -> None: ...
    @staticmethod
    def StopRecordingUndo() -> None: ...
    # Skipped Clear due to it being static, abstract and generic.

    Clear : Clear_MethodGroup
    class Clear_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, revertValues: bool) -> None:...



class DrivenTransformProperties(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : DrivenTransformProperties # 0
    AnchoredPositionX : DrivenTransformProperties # 2
    AnchoredPositionY : DrivenTransformProperties # 4
    AnchoredPosition : DrivenTransformProperties # 6
    AnchoredPositionZ : DrivenTransformProperties # 8
    AnchoredPosition3D : DrivenTransformProperties # 14
    Rotation : DrivenTransformProperties # 16
    ScaleX : DrivenTransformProperties # 32
    ScaleY : DrivenTransformProperties # 64
    ScaleZ : DrivenTransformProperties # 128
    Scale : DrivenTransformProperties # 224
    AnchorMinX : DrivenTransformProperties # 256
    AnchorMinY : DrivenTransformProperties # 512
    AnchorMin : DrivenTransformProperties # 768
    AnchorMaxX : DrivenTransformProperties # 1024
    AnchorMaxY : DrivenTransformProperties # 2048
    AnchorMax : DrivenTransformProperties # 3072
    Anchors : DrivenTransformProperties # 3840
    SizeDeltaX : DrivenTransformProperties # 4096
    SizeDeltaY : DrivenTransformProperties # 8192
    SizeDelta : DrivenTransformProperties # 12288
    PivotX : DrivenTransformProperties # 16384
    PivotY : DrivenTransformProperties # 32768
    Pivot : DrivenTransformProperties # 49152
    All : DrivenTransformProperties # -1


class DurationUnit(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Fixed : DurationUnit # 0
    Normalized : DurationUnit # 1


class DynamicGI:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def indirectScale(cls) -> float: ...
    @classmethod
    @indirectScale.setter
    def indirectScale(cls, value: float) -> float: ...
    @classmethod
    @property
    def isConverged(cls) -> bool: ...
    @classmethod
    @property
    def materialUpdateTimeSlice(cls) -> int: ...
    @classmethod
    @materialUpdateTimeSlice.setter
    def materialUpdateTimeSlice(cls, value: int) -> int: ...
    @classmethod
    @property
    def synchronousMode(cls) -> bool: ...
    @classmethod
    @synchronousMode.setter
    def synchronousMode(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def updateThreshold(cls) -> float: ...
    @classmethod
    @updateThreshold.setter
    def updateThreshold(cls, value: float) -> float: ...
    @staticmethod
    def SetEmissive(renderer: Renderer, color: Color) -> None: ...
    @staticmethod
    def SetEnvironmentData(input: Array_1[float]) -> None: ...
    @staticmethod
    def UpdateEnvironment() -> None: ...
    # Skipped UpdateMaterials due to it being static, abstract and generic.

    UpdateMaterials : UpdateMaterials_MethodGroup
    class UpdateMaterials_MethodGroup:
        @typing.overload
        def __call__(self, renderer: Renderer) -> None:...
        @typing.overload
        def __call__(self, renderer: Object) -> None:...
        @typing.overload
        def __call__(self, renderer: Object, x: int, y: int, width: int, height: int) -> None:...



class EdgeCollider2D(Collider2D):
    def __init__(self) -> None: ...
    @property
    def adjacentEndPoint(self) -> Vector2: ...
    @adjacentEndPoint.setter
    def adjacentEndPoint(self, value: Vector2) -> Vector2: ...
    @property
    def adjacentStartPoint(self) -> Vector2: ...
    @adjacentStartPoint.setter
    def adjacentStartPoint(self, value: Vector2) -> Vector2: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounciness(self) -> float: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def callbackLayers(self) -> LayerMask: ...
    @callbackLayers.setter
    def callbackLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def composite(self) -> CompositeCollider2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def contactCaptureLayers(self) -> LayerMask: ...
    @contactCaptureLayers.setter
    def contactCaptureLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def density(self) -> float: ...
    @density.setter
    def density(self, value: float) -> float: ...
    @property
    def edgeCount(self) -> int: ...
    @property
    def edgeRadius(self) -> float: ...
    @edgeRadius.setter
    def edgeRadius(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def errorState(self) -> ColliderErrorState2D: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def forceReceiveLayers(self) -> LayerMask: ...
    @forceReceiveLayers.setter
    def forceReceiveLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def forceSendLayers(self) -> LayerMask: ...
    @forceSendLayers.setter
    def forceSendLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def friction(self) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def isTrigger(self) -> bool: ...
    @isTrigger.setter
    def isTrigger(self, value: bool) -> bool: ...
    @property
    def layerOverridePriority(self) -> int: ...
    @layerOverridePriority.setter
    def layerOverridePriority(self, value: int) -> int: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def offset(self) -> Vector2: ...
    @offset.setter
    def offset(self, value: Vector2) -> Vector2: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def pointCount(self) -> int: ...
    @property
    def points(self) -> Array_1[Vector2]: ...
    @points.setter
    def points(self, value: Array_1[Vector2]) -> Array_1[Vector2]: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def shapeCount(self) -> int: ...
    @property
    def sharedMaterial(self) -> PhysicsMaterial2D: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: PhysicsMaterial2D) -> PhysicsMaterial2D: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useAdjacentEndPoint(self) -> bool: ...
    @useAdjacentEndPoint.setter
    def useAdjacentEndPoint(self, value: bool) -> bool: ...
    @property
    def useAdjacentStartPoint(self) -> bool: ...
    @useAdjacentStartPoint.setter
    def useAdjacentStartPoint(self, value: bool) -> bool: ...
    @property
    def usedByComposite(self) -> bool: ...
    @usedByComposite.setter
    def usedByComposite(self, value: bool) -> bool: ...
    @property
    def usedByEffector(self) -> bool: ...
    @usedByEffector.setter
    def usedByEffector(self, value: bool) -> bool: ...
    def GetPoints(self, points: List_1[Vector2]) -> int: ...
    def Reset(self) -> None: ...
    def SetPoints(self, points: List_1[Vector2]) -> bool: ...


class Effector2D(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def colliderMask(self) -> int: ...
    @colliderMask.setter
    def colliderMask(self, value: int) -> int: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useColliderMask(self) -> bool: ...
    @useColliderMask.setter
    def useColliderMask(self, value: bool) -> bool: ...


class EffectorForceMode2D(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Constant : EffectorForceMode2D # 0
    InverseLinear : EffectorForceMode2D # 1
    InverseSquared : EffectorForceMode2D # 2


class EffectorSelection2D(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Rigidbody : EffectorSelection2D # 0
    Collider : EffectorSelection2D # 1


class Event:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, displayIndex: int) -> None: ...
    @typing.overload
    def __init__(self, other: Event) -> None: ...
    @property
    def alt(self) -> bool: ...
    @alt.setter
    def alt(self, value: bool) -> bool: ...
    @property
    def button(self) -> int: ...
    @button.setter
    def button(self, value: int) -> int: ...
    @property
    def capsLock(self) -> bool: ...
    @capsLock.setter
    def capsLock(self, value: bool) -> bool: ...
    @property
    def character(self) -> str: ...
    @character.setter
    def character(self, value: str) -> str: ...
    @property
    def clickCount(self) -> int: ...
    @clickCount.setter
    def clickCount(self, value: int) -> int: ...
    @property
    def command(self) -> bool: ...
    @command.setter
    def command(self, value: bool) -> bool: ...
    @property
    def commandName(self) -> str: ...
    @commandName.setter
    def commandName(self, value: str) -> str: ...
    @property
    def control(self) -> bool: ...
    @control.setter
    def control(self, value: bool) -> bool: ...
    @classmethod
    @property
    def current(cls) -> Event: ...
    @classmethod
    @current.setter
    def current(cls, value: Event) -> Event: ...
    @property
    def delta(self) -> Vector2: ...
    @delta.setter
    def delta(self, value: Vector2) -> Vector2: ...
    @property
    def displayIndex(self) -> int: ...
    @displayIndex.setter
    def displayIndex(self, value: int) -> int: ...
    @property
    def functionKey(self) -> bool: ...
    @property
    def isKey(self) -> bool: ...
    @property
    def isMouse(self) -> bool: ...
    @property
    def isScrollWheel(self) -> bool: ...
    @property
    def keyCode(self) -> KeyCode: ...
    @keyCode.setter
    def keyCode(self, value: KeyCode) -> KeyCode: ...
    @property
    def modifiers(self) -> EventModifiers: ...
    @modifiers.setter
    def modifiers(self, value: EventModifiers) -> EventModifiers: ...
    @property
    def mousePosition(self) -> Vector2: ...
    @mousePosition.setter
    def mousePosition(self, value: Vector2) -> Vector2: ...
    @property
    def mouseRay(self) -> Ray: ...
    @mouseRay.setter
    def mouseRay(self, value: Ray) -> Ray: ...
    @property
    def numeric(self) -> bool: ...
    @numeric.setter
    def numeric(self, value: bool) -> bool: ...
    @property
    def penStatus(self) -> PenStatus: ...
    @penStatus.setter
    def penStatus(self, value: PenStatus) -> PenStatus: ...
    @property
    def pointerType(self) -> PointerType: ...
    @pointerType.setter
    def pointerType(self, value: PointerType) -> PointerType: ...
    @property
    def pressure(self) -> float: ...
    @pressure.setter
    def pressure(self, value: float) -> float: ...
    @property
    def rawType(self) -> EventType: ...
    @property
    def shift(self) -> bool: ...
    @shift.setter
    def shift(self, value: bool) -> bool: ...
    @property
    def tilt(self) -> Vector2: ...
    @tilt.setter
    def tilt(self, value: Vector2) -> Vector2: ...
    @property
    def twist(self) -> float: ...
    @twist.setter
    def twist(self, value: float) -> float: ...
    @property
    def type(self) -> EventType: ...
    @type.setter
    def type(self, value: EventType) -> EventType: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    @staticmethod
    def GetEventCount() -> int: ...
    def GetHashCode(self) -> int: ...
    def GetTypeForControl(self, controlID: int) -> EventType: ...
    @staticmethod
    def KeyboardEvent(key: str) -> Event: ...
    @staticmethod
    def PopEvent(outEvent: Event) -> bool: ...
    def ToString(self) -> str: ...
    def Use(self) -> None: ...


class EventModifiers(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : EventModifiers # 0
    Shift : EventModifiers # 1
    Control : EventModifiers # 2
    Alt : EventModifiers # 4
    Command : EventModifiers # 8
    Numeric : EventModifiers # 16
    CapsLock : EventModifiers # 32
    FunctionKey : EventModifiers # 64


class EventProvider:
    def __init__(self) -> None: ...
    @staticmethod
    def WriteCustomEvent(value: int, text: str) -> None: ...


class EventType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    mouseDown : EventType # 0
    MouseDown : EventType # 0
    MouseUp : EventType # 1
    mouseUp : EventType # 1
    MouseMove : EventType # 2
    mouseMove : EventType # 2
    MouseDrag : EventType # 3
    mouseDrag : EventType # 3
    KeyDown : EventType # 4
    keyDown : EventType # 4
    KeyUp : EventType # 5
    keyUp : EventType # 5
    ScrollWheel : EventType # 6
    scrollWheel : EventType # 6
    Repaint : EventType # 7
    repaint : EventType # 7
    Layout : EventType # 8
    layout : EventType # 8
    DragUpdated : EventType # 9
    dragUpdated : EventType # 9
    DragPerform : EventType # 10
    dragPerform : EventType # 10
    Ignore : EventType # 11
    ignore : EventType # 11
    Used : EventType # 12
    used : EventType # 12
    ValidateCommand : EventType # 13
    ExecuteCommand : EventType # 14
    DragExited : EventType # 15
    ContextClick : EventType # 16
    MouseEnterWindow : EventType # 20
    MouseLeaveWindow : EventType # 21
    TouchDown : EventType # 30
    TouchUp : EventType # 31
    TouchMove : EventType # 32
    TouchEnter : EventType # 33
    TouchLeave : EventType # 34
    TouchStationary : EventType # 35


class ExcludeFromObjectFactoryAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class ExcludeFromPresetAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class ExecuteAlways(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class ExecuteInEditMode(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class ExitGUIException(Exception):
    def __init__(self) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class ExposedPropertyResolver:
    pass


class ExposedReference_GenericClasses(abc.ABCMeta):
    Generic_ExposedReference_GenericClasses_ExposedReference_1_T = typing.TypeVar('Generic_ExposedReference_GenericClasses_ExposedReference_1_T')
    def __getitem__(self, types : typing.Type[Generic_ExposedReference_GenericClasses_ExposedReference_1_T]) -> typing.Type[ExposedReference_1[Generic_ExposedReference_GenericClasses_ExposedReference_1_T]]: ...

ExposedReference : ExposedReference_GenericClasses

ExposedReference_1_T = typing.TypeVar('ExposedReference_1_T')
class ExposedReference_1(typing.Generic[ExposedReference_1_T]):
    defaultValue : Object
    exposedName : PropertyName
    def Resolve(self, resolver: IExposedPropertyTable) -> ExposedReference_1_T: ...


class ExpressionEvaluator:
    def __init__(self) -> None: ...
    # Skipped Evaluate due to it being static, abstract and generic.

    Evaluate : Evaluate_MethodGroup
    class Evaluate_MethodGroup:
        def __getitem__(self, t:typing.Type[Evaluate_1_T1]) -> Evaluate_1[Evaluate_1_T1]: ...

        Evaluate_1_T1 = typing.TypeVar('Evaluate_1_T1')
        class Evaluate_1(typing.Generic[Evaluate_1_T1]):
            Evaluate_1_T = ExpressionEvaluator.Evaluate_MethodGroup.Evaluate_1_T1
            def __call__(self, expression: str, value: clr.Reference[Evaluate_1_T]) -> bool:...




class FFTWindow(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Rectangular : FFTWindow # 0
    Triangle : FFTWindow # 1
    Hamming : FFTWindow # 2
    Hanning : FFTWindow # 3
    Blackman : FFTWindow # 4
    BlackmanHarris : FFTWindow # 5


class FilterMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Point : FilterMode # 0
    Bilinear : FilterMode # 1
    Trilinear : FilterMode # 2


class FindObjectsInactive(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Exclude : FindObjectsInactive # 0
    Include : FindObjectsInactive # 1


class FindObjectsSortMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : FindObjectsSortMode # 0
    InstanceID : FindObjectsSortMode # 1


class FingerDof(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    ProximalDownUp : FingerDof # 0
    ProximalInOut : FingerDof # 1
    IntermediateCloseOpen : FingerDof # 2
    DistalCloseOpen : FingerDof # 3
    LastFingerDof : FingerDof # 4


class FixedJoint(Joint):
    def __init__(self) -> None: ...
    @property
    def anchor(self) -> Vector3: ...
    @anchor.setter
    def anchor(self, value: Vector3) -> Vector3: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoConfigureConnectedAnchor(self) -> bool: ...
    @autoConfigureConnectedAnchor.setter
    def autoConfigureConnectedAnchor(self, value: bool) -> bool: ...
    @property
    def axis(self) -> Vector3: ...
    @axis.setter
    def axis(self, value: Vector3) -> Vector3: ...
    @property
    def breakForce(self) -> float: ...
    @breakForce.setter
    def breakForce(self, value: float) -> float: ...
    @property
    def breakTorque(self) -> float: ...
    @breakTorque.setter
    def breakTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def connectedAnchor(self) -> Vector3: ...
    @connectedAnchor.setter
    def connectedAnchor(self, value: Vector3) -> Vector3: ...
    @property
    def connectedArticulationBody(self) -> ArticulationBody: ...
    @connectedArticulationBody.setter
    def connectedArticulationBody(self, value: ArticulationBody) -> ArticulationBody: ...
    @property
    def connectedBody(self) -> Rigidbody: ...
    @connectedBody.setter
    def connectedBody(self, value: Rigidbody) -> Rigidbody: ...
    @property
    def connectedMassScale(self) -> float: ...
    @connectedMassScale.setter
    def connectedMassScale(self, value: float) -> float: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def currentForce(self) -> Vector3: ...
    @property
    def currentTorque(self) -> Vector3: ...
    @property
    def enableCollision(self) -> bool: ...
    @enableCollision.setter
    def enableCollision(self, value: bool) -> bool: ...
    @property
    def enablePreprocessing(self) -> bool: ...
    @enablePreprocessing.setter
    def enablePreprocessing(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def light(self) -> Component: ...
    @property
    def massScale(self) -> float: ...
    @massScale.setter
    def massScale(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class FixedJoint2D(AnchoredJoint2D):
    def __init__(self) -> None: ...
    @property
    def anchor(self) -> Vector2: ...
    @anchor.setter
    def anchor(self, value: Vector2) -> Vector2: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoConfigureConnectedAnchor(self) -> bool: ...
    @autoConfigureConnectedAnchor.setter
    def autoConfigureConnectedAnchor(self, value: bool) -> bool: ...
    @property
    def breakAction(self) -> JointBreakAction2D: ...
    @breakAction.setter
    def breakAction(self, value: JointBreakAction2D) -> JointBreakAction2D: ...
    @property
    def breakForce(self) -> float: ...
    @breakForce.setter
    def breakForce(self, value: float) -> float: ...
    @property
    def breakTorque(self) -> float: ...
    @breakTorque.setter
    def breakTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collideConnected(self) -> bool: ...
    @collideConnected.setter
    def collideConnected(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def connectedAnchor(self) -> Vector2: ...
    @connectedAnchor.setter
    def connectedAnchor(self, value: Vector2) -> Vector2: ...
    @property
    def connectedBody(self) -> Rigidbody2D: ...
    @connectedBody.setter
    def connectedBody(self, value: Rigidbody2D) -> Rigidbody2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def dampingRatio(self) -> float: ...
    @dampingRatio.setter
    def dampingRatio(self, value: float) -> float: ...
    @property
    def enableCollision(self) -> bool: ...
    @enableCollision.setter
    def enableCollision(self, value: bool) -> bool: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def frequency(self) -> float: ...
    @frequency.setter
    def frequency(self, value: float) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def reactionForce(self) -> Vector2: ...
    @property
    def reactionTorque(self) -> float: ...
    @property
    def referenceAngle(self) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class Flare(Object):
    def __init__(self) -> None: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...


class FlareLayer(Behaviour):
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class FocusType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Native : FocusType # 0
    Keyboard : FocusType # 1
    Passive : FocusType # 2


class FogMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Linear : FogMode # 1
    Exponential : FogMode # 2
    ExponentialSquared : FogMode # 3


class Font(Object):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @property
    def ascent(self) -> int: ...
    @property
    def characterInfo(self) -> Array_1[CharacterInfo]: ...
    @characterInfo.setter
    def characterInfo(self, value: Array_1[CharacterInfo]) -> Array_1[CharacterInfo]: ...
    @property
    def dynamic(self) -> bool: ...
    @property
    def fontNames(self) -> Array_1[str]: ...
    @fontNames.setter
    def fontNames(self, value: Array_1[str]) -> Array_1[str]: ...
    @property
    def fontSize(self) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def lineHeight(self) -> int: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> Material: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def textureRebuildCallback(self) -> Font.FontTextureRebuildCallback: ...
    @textureRebuildCallback.setter
    def textureRebuildCallback(self, value: Font.FontTextureRebuildCallback) -> Font.FontTextureRebuildCallback: ...
    @staticmethod
    def GetMaxVertsForString(str: str) -> int: ...
    @staticmethod
    def GetOSInstalledFontNames() -> Array_1[str]: ...
    @staticmethod
    def GetPathsToOSFonts() -> Array_1[str]: ...
    def HasCharacter(self, c: str) -> bool: ...
    # Skipped CreateDynamicFontFromOSFont due to it being static, abstract and generic.

    CreateDynamicFontFromOSFont : CreateDynamicFontFromOSFont_MethodGroup
    class CreateDynamicFontFromOSFont_MethodGroup:
        @typing.overload
        def __call__(self, fontnames: Array_1[str], size: int) -> Font:...
        @typing.overload
        def __call__(self, fontname: str, size: int) -> Font:...

    # Skipped GetCharacterInfo due to it being static, abstract and generic.

    GetCharacterInfo : GetCharacterInfo_MethodGroup
    class GetCharacterInfo_MethodGroup:
        @typing.overload
        def __call__(self, ch: str, info: clr.Reference[CharacterInfo]) -> bool:...
        @typing.overload
        def __call__(self, ch: str, info: clr.Reference[CharacterInfo], size: int) -> bool:...
        @typing.overload
        def __call__(self, ch: str, info: clr.Reference[CharacterInfo], size: int, style: FontStyle) -> bool:...

    # Skipped RequestCharactersInTexture due to it being static, abstract and generic.

    RequestCharactersInTexture : RequestCharactersInTexture_MethodGroup
    class RequestCharactersInTexture_MethodGroup:
        @typing.overload
        def __call__(self, characters: str) -> None:...
        @typing.overload
        def __call__(self, characters: str, size: int) -> None:...
        @typing.overload
        def __call__(self, characters: str, size: int, style: FontStyle) -> None:...


    class FontTextureRebuildCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self) -> None: ...



class FontStyle(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Normal : FontStyle # 0
    Bold : FontStyle # 1
    Italic : FontStyle # 2
    BoldAndItalic : FontStyle # 3


class ForceMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Force : ForceMode # 0
    Impulse : ForceMode # 1
    VelocityChange : ForceMode # 2
    Acceleration : ForceMode # 5


class ForceMode2D(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Force : ForceMode2D # 0
    Impulse : ForceMode2D # 1


class FrameDebugger(abc.ABC):
    @classmethod
    @property
    def enabled(cls) -> bool: ...


class FrameTiming:
    cpuFrameTime : float
    cpuMainThreadFrameTime : float
    cpuMainThreadPresentWaitTime : float
    cpuRenderThreadFrameTime : float
    cpuTimeFrameComplete : int
    cpuTimePresentCalled : int
    firstSubmitTimestamp : int
    frameStartTimestamp : int
    gpuFrameTime : float
    heightScale : float
    syncInterval : int
    widthScale : float


class FrameTimingManager(abc.ABC):
    @staticmethod
    def CaptureFrameTimings() -> None: ...
    @staticmethod
    def GetCpuTimerFrequency() -> int: ...
    @staticmethod
    def GetGpuTimerFrequency() -> int: ...
    @staticmethod
    def GetLatestTimings(numFrames: int, timings: Array_1[FrameTiming]) -> int: ...
    @staticmethod
    def GetVSyncsPerSecond() -> float: ...
    @staticmethod
    def IsFeatureEnabled() -> bool: ...


class FrictionJoint2D(AnchoredJoint2D):
    def __init__(self) -> None: ...
    @property
    def anchor(self) -> Vector2: ...
    @anchor.setter
    def anchor(self, value: Vector2) -> Vector2: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoConfigureConnectedAnchor(self) -> bool: ...
    @autoConfigureConnectedAnchor.setter
    def autoConfigureConnectedAnchor(self, value: bool) -> bool: ...
    @property
    def breakAction(self) -> JointBreakAction2D: ...
    @breakAction.setter
    def breakAction(self, value: JointBreakAction2D) -> JointBreakAction2D: ...
    @property
    def breakForce(self) -> float: ...
    @breakForce.setter
    def breakForce(self, value: float) -> float: ...
    @property
    def breakTorque(self) -> float: ...
    @breakTorque.setter
    def breakTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collideConnected(self) -> bool: ...
    @collideConnected.setter
    def collideConnected(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def connectedAnchor(self) -> Vector2: ...
    @connectedAnchor.setter
    def connectedAnchor(self, value: Vector2) -> Vector2: ...
    @property
    def connectedBody(self) -> Rigidbody2D: ...
    @connectedBody.setter
    def connectedBody(self, value: Rigidbody2D) -> Rigidbody2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enableCollision(self) -> bool: ...
    @enableCollision.setter
    def enableCollision(self, value: bool) -> bool: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def maxForce(self) -> float: ...
    @maxForce.setter
    def maxForce(self, value: float) -> float: ...
    @property
    def maxTorque(self) -> float: ...
    @maxTorque.setter
    def maxTorque(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def reactionForce(self) -> Vector2: ...
    @property
    def reactionTorque(self) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class FrustumPlanes:
    bottom : float
    left : float
    right : float
    top : float
    zFar : float
    zNear : float


class FullScreenMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    ExclusiveFullScreen : FullScreenMode # 0
    FullScreenWindow : FullScreenMode # 1
    MaximizedWindow : FullScreenMode # 2
    Windowed : FullScreenMode # 3


class FullScreenMovieControlMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Full : FullScreenMovieControlMode # 0
    Minimal : FullScreenMovieControlMode # 1
    CancelOnInput : FullScreenMovieControlMode # 2
    Hidden : FullScreenMovieControlMode # 3


class FullScreenMovieScalingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : FullScreenMovieScalingMode # 0
    AspectFit : FullScreenMovieScalingMode # 1
    AspectFill : FullScreenMovieScalingMode # 2
    Fill : FullScreenMovieScalingMode # 3


class GameObject(Object):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: str, components: Array_1[typing.Type[typing.Any]]) -> None: ...
    @property
    def active(self) -> bool: ...
    @active.setter
    def active(self, value: bool) -> bool: ...
    @property
    def activeInHierarchy(self) -> bool: ...
    @property
    def activeSelf(self) -> bool: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isStatic(self) -> bool: ...
    @isStatic.setter
    def isStatic(self, value: bool) -> bool: ...
    @property
    def layer(self) -> int: ...
    @layer.setter
    def layer(self, value: int) -> int: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def scene(self) -> Scene: ...
    @property
    def sceneCullingMask(self) -> int: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    def CompareTag(self, tag: str) -> bool: ...
    @staticmethod
    def CreatePrimitive(type: PrimitiveType) -> GameObject: ...
    @staticmethod
    def Find(name: str) -> GameObject: ...
    @staticmethod
    def FindGameObjectsWithTag(tag: str) -> Array_1[GameObject]: ...
    @staticmethod
    def FindGameObjectWithTag(tag: str) -> GameObject: ...
    @staticmethod
    def FindWithTag(tag: str) -> GameObject: ...
    def GetComponentCount(self) -> int: ...
    def GetComponentIndex(self, component: Component) -> int: ...
    @staticmethod
    def GetScene(instanceID: int) -> Scene: ...
    @staticmethod
    def InstantiateGameObjects(sourceInstanceID: int, count: int, newInstanceIDs: NativeArray_1[int], newTransformInstanceIDs: NativeArray_1[int], destinationScene: Scene = ...) -> None: ...
    def PlayAnimation(self, animation: Object) -> None: ...
    def SampleAnimation(self, clip: Object, time: float) -> None: ...
    def SetActive(self, value: bool) -> None: ...
    def SetActiveRecursively(self, state: bool) -> None: ...
    def StopAnimation(self) -> None: ...
    # Skipped AddComponent due to it being static, abstract and generic.

    AddComponent : AddComponent_MethodGroup
    class AddComponent_MethodGroup:
        def __getitem__(self, t:typing.Type[AddComponent_1_T1]) -> AddComponent_1[AddComponent_1_T1]: ...

        AddComponent_1_T1 = typing.TypeVar('AddComponent_1_T1')
        class AddComponent_1(typing.Generic[AddComponent_1_T1]):
            AddComponent_1_T = GameObject.AddComponent_MethodGroup.AddComponent_1_T1
            def __call__(self) -> AddComponent_1_T:...

        @typing.overload
        def __call__(self, className: str) -> Component:...
        @typing.overload
        def __call__(self, componentType: typing.Type[typing.Any]) -> Component:...

    # Skipped BroadcastMessage due to it being static, abstract and generic.

    BroadcastMessage : BroadcastMessage_MethodGroup
    class BroadcastMessage_MethodGroup:
        @typing.overload
        def __call__(self, methodName: str) -> None:...
        @typing.overload
        def __call__(self, methodName: str, options: SendMessageOptions) -> None:...
        @typing.overload
        def __call__(self, methodName: str, parameter: typing.Any) -> None:...
        @typing.overload
        def __call__(self, methodName: str, parameter: typing.Any, options: SendMessageOptions) -> None:...

    # Skipped GetComponent due to it being static, abstract and generic.

    GetComponent : GetComponent_MethodGroup
    class GetComponent_MethodGroup:
        def __getitem__(self, t:typing.Type[GetComponent_1_T1]) -> GetComponent_1[GetComponent_1_T1]: ...

        GetComponent_1_T1 = typing.TypeVar('GetComponent_1_T1')
        class GetComponent_1(typing.Generic[GetComponent_1_T1]):
            GetComponent_1_T = GameObject.GetComponent_MethodGroup.GetComponent_1_T1
            def __call__(self) -> GetComponent_1_T:...

        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> Component:...
        @typing.overload
        def __call__(self, type: str) -> Component:...

    # Skipped GetComponentAtIndex due to it being static, abstract and generic.

    GetComponentAtIndex : GetComponentAtIndex_MethodGroup
    class GetComponentAtIndex_MethodGroup:
        def __getitem__(self, t:typing.Type[GetComponentAtIndex_1_T1]) -> GetComponentAtIndex_1[GetComponentAtIndex_1_T1]: ...

        GetComponentAtIndex_1_T1 = typing.TypeVar('GetComponentAtIndex_1_T1')
        class GetComponentAtIndex_1(typing.Generic[GetComponentAtIndex_1_T1]):
            GetComponentAtIndex_1_T = GameObject.GetComponentAtIndex_MethodGroup.GetComponentAtIndex_1_T1
            def __call__(self, index: int) -> GetComponentAtIndex_1_T:...

        def __call__(self, index: int) -> Component:...

    # Skipped GetComponentInChildren due to it being static, abstract and generic.

    GetComponentInChildren : GetComponentInChildren_MethodGroup
    class GetComponentInChildren_MethodGroup:
        def __getitem__(self, t:typing.Type[GetComponentInChildren_1_T1]) -> GetComponentInChildren_1[GetComponentInChildren_1_T1]: ...

        GetComponentInChildren_1_T1 = typing.TypeVar('GetComponentInChildren_1_T1')
        class GetComponentInChildren_1(typing.Generic[GetComponentInChildren_1_T1]):
            GetComponentInChildren_1_T = GameObject.GetComponentInChildren_MethodGroup.GetComponentInChildren_1_T1
            @typing.overload
            def __call__(self) -> GetComponentInChildren_1_T:...
            @typing.overload
            def __call__(self, includeInactive: bool) -> GetComponentInChildren_1_T:...

        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> Component:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], includeInactive: bool) -> Component:...

    # Skipped GetComponentInParent due to it being static, abstract and generic.

    GetComponentInParent : GetComponentInParent_MethodGroup
    class GetComponentInParent_MethodGroup:
        def __getitem__(self, t:typing.Type[GetComponentInParent_1_T1]) -> GetComponentInParent_1[GetComponentInParent_1_T1]: ...

        GetComponentInParent_1_T1 = typing.TypeVar('GetComponentInParent_1_T1')
        class GetComponentInParent_1(typing.Generic[GetComponentInParent_1_T1]):
            GetComponentInParent_1_T = GameObject.GetComponentInParent_MethodGroup.GetComponentInParent_1_T1
            @typing.overload
            def __call__(self) -> GetComponentInParent_1_T:...
            @typing.overload
            def __call__(self, includeInactive: bool) -> GetComponentInParent_1_T:...

        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> Component:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], includeInactive: bool) -> Component:...

    # Skipped GetComponents due to it being static, abstract and generic.

    GetComponents : GetComponents_MethodGroup
    class GetComponents_MethodGroup:
        def __getitem__(self, t:typing.Type[GetComponents_1_T1]) -> GetComponents_1[GetComponents_1_T1]: ...

        GetComponents_1_T1 = typing.TypeVar('GetComponents_1_T1')
        class GetComponents_1(typing.Generic[GetComponents_1_T1]):
            GetComponents_1_T = GameObject.GetComponents_MethodGroup.GetComponents_1_T1
            @typing.overload
            def __call__(self) -> Array_1[GetComponents_1_T]:...
            @typing.overload
            def __call__(self, results: List_1[GetComponents_1_T]) -> None:...

        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> Array_1[Component]:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], results: List_1[Component]) -> None:...

    # Skipped GetComponentsInChildren due to it being static, abstract and generic.

    GetComponentsInChildren : GetComponentsInChildren_MethodGroup
    class GetComponentsInChildren_MethodGroup:
        def __getitem__(self, t:typing.Type[GetComponentsInChildren_1_T1]) -> GetComponentsInChildren_1[GetComponentsInChildren_1_T1]: ...

        GetComponentsInChildren_1_T1 = typing.TypeVar('GetComponentsInChildren_1_T1')
        class GetComponentsInChildren_1(typing.Generic[GetComponentsInChildren_1_T1]):
            GetComponentsInChildren_1_T = GameObject.GetComponentsInChildren_MethodGroup.GetComponentsInChildren_1_T1
            @typing.overload
            def __call__(self) -> Array_1[GetComponentsInChildren_1_T]:...
            @typing.overload
            def __call__(self, results: List_1[GetComponentsInChildren_1_T]) -> None:...
            @typing.overload
            def __call__(self, includeInactive: bool) -> Array_1[GetComponentsInChildren_1_T]:...
            @typing.overload
            def __call__(self, includeInactive: bool, results: List_1[GetComponentsInChildren_1_T]) -> None:...

        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> Array_1[Component]:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], includeInactive: bool) -> Array_1[Component]:...

    # Skipped GetComponentsInParent due to it being static, abstract and generic.

    GetComponentsInParent : GetComponentsInParent_MethodGroup
    class GetComponentsInParent_MethodGroup:
        def __getitem__(self, t:typing.Type[GetComponentsInParent_1_T1]) -> GetComponentsInParent_1[GetComponentsInParent_1_T1]: ...

        GetComponentsInParent_1_T1 = typing.TypeVar('GetComponentsInParent_1_T1')
        class GetComponentsInParent_1(typing.Generic[GetComponentsInParent_1_T1]):
            GetComponentsInParent_1_T = GameObject.GetComponentsInParent_MethodGroup.GetComponentsInParent_1_T1
            @typing.overload
            def __call__(self) -> Array_1[GetComponentsInParent_1_T]:...
            @typing.overload
            def __call__(self, includeInactive: bool) -> Array_1[GetComponentsInParent_1_T]:...
            @typing.overload
            def __call__(self, includeInactive: bool, results: List_1[GetComponentsInParent_1_T]) -> None:...

        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> Array_1[Component]:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], includeInactive: bool) -> Array_1[Component]:...

    # Skipped SendMessage due to it being static, abstract and generic.

    SendMessage : SendMessage_MethodGroup
    class SendMessage_MethodGroup:
        @typing.overload
        def __call__(self, methodName: str) -> None:...
        @typing.overload
        def __call__(self, methodName: str, options: SendMessageOptions) -> None:...
        @typing.overload
        def __call__(self, methodName: str, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, methodName: str, value: typing.Any, options: SendMessageOptions) -> None:...

    # Skipped SendMessageUpwards due to it being static, abstract and generic.

    SendMessageUpwards : SendMessageUpwards_MethodGroup
    class SendMessageUpwards_MethodGroup:
        @typing.overload
        def __call__(self, methodName: str) -> None:...
        @typing.overload
        def __call__(self, methodName: str, options: SendMessageOptions) -> None:...
        @typing.overload
        def __call__(self, methodName: str, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, methodName: str, value: typing.Any, options: SendMessageOptions) -> None:...

    # Skipped SetGameObjectsActive due to it being static, abstract and generic.

    SetGameObjectsActive : SetGameObjectsActive_MethodGroup
    class SetGameObjectsActive_MethodGroup:
        @typing.overload
        def __call__(self, instanceIDs: NativeArray_1[int], active: bool) -> None:...
        @typing.overload
        def __call__(self, instanceIDs: ReadOnlySpan_1[int], active: bool) -> None:...

    # Skipped TryGetComponent due to it being static, abstract and generic.

    TryGetComponent : TryGetComponent_MethodGroup
    class TryGetComponent_MethodGroup:
        def __getitem__(self, t:typing.Type[TryGetComponent_1_T1]) -> TryGetComponent_1[TryGetComponent_1_T1]: ...

        TryGetComponent_1_T1 = typing.TypeVar('TryGetComponent_1_T1')
        class TryGetComponent_1(typing.Generic[TryGetComponent_1_T1]):
            TryGetComponent_1_T = GameObject.TryGetComponent_MethodGroup.TryGetComponent_1_T1
            def __call__(self, component: clr.Reference[TryGetComponent_1_T]) -> bool:...

        def __call__(self, type: typing.Type[typing.Any], component: clr.Reference[Component]) -> bool:...



class GamepadSpeakerOutputType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Speaker : GamepadSpeakerOutputType # 0
    Vibration : GamepadSpeakerOutputType # 1
    SecondaryVibration : GamepadSpeakerOutputType # 2


class GeometryUtility:
    def __init__(self) -> None: ...
    @staticmethod
    def CalculateBounds(positions: Array_1[Vector3], transform: Matrix4x4) -> Bounds: ...
    @staticmethod
    def TestPlanesAABB(planes: Array_1[Plane], bounds: Bounds) -> bool: ...
    @staticmethod
    def TryCreatePlaneFromPolygon(vertices: Array_1[Vector3], plane: clr.Reference[Plane]) -> bool: ...
    # Skipped CalculateFrustumPlanes due to it being static, abstract and generic.

    CalculateFrustumPlanes : CalculateFrustumPlanes_MethodGroup
    class CalculateFrustumPlanes_MethodGroup:
        @typing.overload
        def __call__(self, camera: Camera) -> Array_1[Plane]:...
        @typing.overload
        def __call__(self, worldToProjectionMatrix: Matrix4x4) -> Array_1[Plane]:...
        @typing.overload
        def __call__(self, camera: Camera, planes: Array_1[Plane]) -> None:...
        @typing.overload
        def __call__(self, worldToProjectionMatrix: Matrix4x4, planes: Array_1[Plane]) -> None:...



class Gizmos:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def color(cls) -> Color: ...
    @classmethod
    @color.setter
    def color(cls, value: Color) -> Color: ...
    @classmethod
    @property
    def exposure(cls) -> Texture: ...
    @classmethod
    @exposure.setter
    def exposure(cls, value: Texture) -> Texture: ...
    @classmethod
    @property
    def matrix(cls) -> Matrix4x4: ...
    @classmethod
    @matrix.setter
    def matrix(cls, value: Matrix4x4) -> Matrix4x4: ...
    @classmethod
    @property
    def probeSize(cls) -> float: ...
    @staticmethod
    def DrawCube(center: Vector3, size: Vector3) -> None: ...
    @staticmethod
    def DrawFrustum(center: Vector3, fov: float, maxRange: float, minRange: float, aspect: float) -> None: ...
    @staticmethod
    def DrawLine(from_: Vector3, to: Vector3) -> None: ...
    @staticmethod
    def DrawLineList(points: ReadOnlySpan_1[Vector3]) -> None: ...
    @staticmethod
    def DrawLineStrip(points: ReadOnlySpan_1[Vector3], looped: bool) -> None: ...
    @staticmethod
    def DrawSphere(center: Vector3, radius: float) -> None: ...
    @staticmethod
    def DrawWireCube(center: Vector3, size: Vector3) -> None: ...
    @staticmethod
    def DrawWireSphere(center: Vector3, radius: float) -> None: ...
    # Skipped DrawGUITexture due to it being static, abstract and generic.

    DrawGUITexture : DrawGUITexture_MethodGroup
    class DrawGUITexture_MethodGroup:
        @typing.overload
        def __call__(self, screenRect: Rect, texture: Texture) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, texture: Texture, mat: Material) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, texture: Texture, leftBorder: int, rightBorder: int, topBorder: int, bottomBorder: int) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, texture: Texture, leftBorder: int, rightBorder: int, topBorder: int, bottomBorder: int, mat: Material) -> None:...

    # Skipped DrawIcon due to it being static, abstract and generic.

    DrawIcon : DrawIcon_MethodGroup
    class DrawIcon_MethodGroup:
        @typing.overload
        def __call__(self, center: Vector3, name: str) -> None:...
        @typing.overload
        def __call__(self, center: Vector3, name: str, allowScaling: bool) -> None:...
        @typing.overload
        def __call__(self, center: Vector3, name: str, allowScaling: bool, tint: Color) -> None:...

    # Skipped DrawMesh due to it being static, abstract and generic.

    DrawMesh : DrawMesh_MethodGroup
    class DrawMesh_MethodGroup:
        @typing.overload
        def __call__(self, mesh: Mesh) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, position: Vector3) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, position: Vector3, rotation: Quaternion) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion, scale: Vector3) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, position: Vector3, rotation: Quaternion, scale: Vector3) -> None:...

    # Skipped DrawRay due to it being static, abstract and generic.

    DrawRay : DrawRay_MethodGroup
    class DrawRay_MethodGroup:
        @typing.overload
        def __call__(self, r: Ray) -> None:...
        @typing.overload
        def __call__(self, from_: Vector3, direction: Vector3) -> None:...

    # Skipped DrawWireMesh due to it being static, abstract and generic.

    DrawWireMesh : DrawWireMesh_MethodGroup
    class DrawWireMesh_MethodGroup:
        @typing.overload
        def __call__(self, mesh: Mesh) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, position: Vector3) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, position: Vector3, rotation: Quaternion) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion, scale: Vector3) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, position: Vector3, rotation: Quaternion, scale: Vector3) -> None:...



class GL:
    def __init__(self) -> None: ...
    LINE_STRIP : int
    LINES : int
    QUADS : int
    TRIANGLE_STRIP : int
    TRIANGLES : int
    @classmethod
    @property
    def invertCulling(cls) -> bool: ...
    @classmethod
    @invertCulling.setter
    def invertCulling(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def modelview(cls) -> Matrix4x4: ...
    @classmethod
    @modelview.setter
    def modelview(cls, value: Matrix4x4) -> Matrix4x4: ...
    @classmethod
    @property
    def sRGBWrite(cls) -> bool: ...
    @classmethod
    @sRGBWrite.setter
    def sRGBWrite(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def wireframe(cls) -> bool: ...
    @classmethod
    @wireframe.setter
    def wireframe(cls, value: bool) -> bool: ...
    @staticmethod
    def Begin(mode: int) -> None: ...
    @staticmethod
    def ClearWithSkybox(clearDepth: bool, camera: Camera) -> None: ...
    @staticmethod
    def Color(c: Color) -> None: ...
    @staticmethod
    def End() -> None: ...
    @staticmethod
    def Flush() -> None: ...
    @staticmethod
    def GetGPUProjectionMatrix(proj: Matrix4x4, renderIntoTexture: bool) -> Matrix4x4: ...
    @staticmethod
    def InvalidateState() -> None: ...
    @staticmethod
    def LoadIdentity() -> None: ...
    @staticmethod
    def LoadOrtho() -> None: ...
    @staticmethod
    def LoadProjectionMatrix(mat: Matrix4x4) -> None: ...
    @staticmethod
    def MultiTexCoord(unit: int, v: Vector3) -> None: ...
    @staticmethod
    def MultiTexCoord2(unit: int, x: float, y: float) -> None: ...
    @staticmethod
    def MultiTexCoord3(unit: int, x: float, y: float, z: float) -> None: ...
    @staticmethod
    def MultMatrix(m: Matrix4x4) -> None: ...
    @staticmethod
    def PopMatrix() -> None: ...
    @staticmethod
    def PushMatrix() -> None: ...
    @staticmethod
    def RenderTargetBarrier() -> None: ...
    @staticmethod
    def SetRevertBackfacing(revertBackFaces: bool) -> None: ...
    @staticmethod
    def TexCoord(v: Vector3) -> None: ...
    @staticmethod
    def TexCoord2(x: float, y: float) -> None: ...
    @staticmethod
    def TexCoord3(x: float, y: float, z: float) -> None: ...
    @staticmethod
    def Vertex(v: Vector3) -> None: ...
    @staticmethod
    def Vertex3(x: float, y: float, z: float) -> None: ...
    @staticmethod
    def Viewport(pixelRect: Rect) -> None: ...
    # Skipped Clear due to it being static, abstract and generic.

    Clear : Clear_MethodGroup
    class Clear_MethodGroup:
        @typing.overload
        def __call__(self, clearDepth: bool, clearColor: bool, backgroundColor: Color) -> None:...
        @typing.overload
        def __call__(self, clearDepth: bool, clearColor: bool, backgroundColor: Color, depth: float) -> None:...

    # Skipped IssuePluginEvent due to it being static, abstract and generic.

    IssuePluginEvent : IssuePluginEvent_MethodGroup
    class IssuePluginEvent_MethodGroup:
        @typing.overload
        def __call__(self, eventID: int) -> None:...
        @typing.overload
        def __call__(self, callback: int, eventID: int) -> None:...

    # Skipped LoadPixelMatrix due to it being static, abstract and generic.

    LoadPixelMatrix : LoadPixelMatrix_MethodGroup
    class LoadPixelMatrix_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, left: float, right: float, bottom: float, top: float) -> None:...



class Gradient(IEquatable_1[Gradient]):
    def __init__(self) -> None: ...
    @property
    def alphaKeys(self) -> Array_1[GradientAlphaKey]: ...
    @alphaKeys.setter
    def alphaKeys(self, value: Array_1[GradientAlphaKey]) -> Array_1[GradientAlphaKey]: ...
    @property
    def colorKeys(self) -> Array_1[GradientColorKey]: ...
    @colorKeys.setter
    def colorKeys(self, value: Array_1[GradientColorKey]) -> Array_1[GradientColorKey]: ...
    @property
    def colorSpace(self) -> ColorSpace: ...
    @colorSpace.setter
    def colorSpace(self, value: ColorSpace) -> ColorSpace: ...
    @property
    def mode(self) -> GradientMode: ...
    @mode.setter
    def mode(self, value: GradientMode) -> GradientMode: ...
    def Evaluate(self, time: float) -> Color: ...
    def GetHashCode(self) -> int: ...
    def SetKeys(self, colorKeys: Array_1[GradientColorKey], alphaKeys: Array_1[GradientAlphaKey]) -> None: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Gradient) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...



class GradientAlphaKey:
    def __init__(self, alpha: float, time: float) -> None: ...
    alpha : float
    time : float


class GradientColorKey:
    def __init__(self, col: Color, time: float) -> None: ...
    color : Color
    time : float


class GradientMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Blend : GradientMode # 0
    Fixed : GradientMode # 1
    PerceptualBlend : GradientMode # 2


class GradientUsageAttribute(PropertyAttribute):
    @typing.overload
    def __init__(self, hdr: bool) -> None: ...
    @typing.overload
    def __init__(self, hdr: bool, colorSpace: ColorSpace) -> None: ...
    colorSpace : ColorSpace
    hdr : bool
    @property
    def order(self) -> int: ...
    @order.setter
    def order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class Graphics:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def activeColorBuffer(cls) -> RenderBuffer: ...
    @classmethod
    @property
    def activeColorGamut(cls) -> ColorGamut: ...
    @classmethod
    @property
    def activeDepthBuffer(cls) -> RenderBuffer: ...
    @classmethod
    @property
    def activeTier(cls) -> GraphicsTier: ...
    @classmethod
    @activeTier.setter
    def activeTier(cls, value: GraphicsTier) -> GraphicsTier: ...
    @classmethod
    @property
    def deviceName(cls) -> str: ...
    @classmethod
    @property
    def deviceVendor(cls) -> str: ...
    @classmethod
    @property
    def deviceVersion(cls) -> str: ...
    @classmethod
    @property
    def minOpenGLESVersion(cls) -> OpenGLESVersion: ...
    @classmethod
    @property
    def preserveFramebufferAlpha(cls) -> bool: ...
    @staticmethod
    def ClearRandomWriteTargets() -> None: ...
    @staticmethod
    def CopyBuffer(source: GraphicsBuffer, dest: GraphicsBuffer) -> None: ...
    @staticmethod
    def CreateGraphicsFence(fenceType: GraphicsFenceType, stage: SynchronisationStageFlags) -> GraphicsFence: ...
    @staticmethod
    def DrawMeshInstancedProcedural(mesh: Mesh, submeshIndex: int, material: Material, bounds: Bounds, count: int, properties: MaterialPropertyBlock = ..., castShadows: ShadowCastingMode = ..., receiveShadows: bool = ..., layer: int = ..., camera: Camera = ..., lightProbeUsage: LightProbeUsage = ..., lightProbeProxyVolume: LightProbeProxyVolume = ...) -> None: ...
    @staticmethod
    def ExecuteCommandBuffer(buffer: CommandBuffer) -> None: ...
    @staticmethod
    def ExecuteCommandBufferAsync(buffer: CommandBuffer, queueType: ComputeQueueType) -> None: ...
    @staticmethod
    def RenderMesh(rparams: clr.Reference[RenderParams], mesh: Mesh, submeshIndex: int, objectToWorld: Matrix4x4, prevObjectToWorld: typing.Optional[Matrix4x4] = ...) -> None: ...
    @staticmethod
    def RenderMeshIndirect(rparams: clr.Reference[RenderParams], mesh: Mesh, commandBuffer: GraphicsBuffer, commandCount: int = ..., startCommand: int = ...) -> None: ...
    @staticmethod
    def RenderMeshPrimitives(rparams: clr.Reference[RenderParams], mesh: Mesh, submeshIndex: int, instanceCount: int = ...) -> None: ...
    @staticmethod
    def RenderPrimitives(rparams: clr.Reference[RenderParams], topology: MeshTopology, vertexCount: int, instanceCount: int = ...) -> None: ...
    @staticmethod
    def RenderPrimitivesIndexed(rparams: clr.Reference[RenderParams], topology: MeshTopology, indexBuffer: GraphicsBuffer, indexCount: int, startIndex: int = ..., instanceCount: int = ...) -> None: ...
    @staticmethod
    def RenderPrimitivesIndexedIndirect(rparams: clr.Reference[RenderParams], topology: MeshTopology, indexBuffer: GraphicsBuffer, commandBuffer: GraphicsBuffer, commandCount: int = ..., startCommand: int = ...) -> None: ...
    @staticmethod
    def RenderPrimitivesIndirect(rparams: clr.Reference[RenderParams], topology: MeshTopology, commandBuffer: GraphicsBuffer, commandCount: int = ..., startCommand: int = ...) -> None: ...
    # Skipped Blit due to it being static, abstract and generic.

    Blit : Blit_MethodGroup
    class Blit_MethodGroup:
        @typing.overload
        def __call__(self, source: Texture, dest: RenderTexture) -> None:...
        @typing.overload
        def __call__(self, source: Texture, mat: Material) -> None:...
        @typing.overload
        def __call__(self, source: Texture, dest: RenderTexture, mat: Material) -> None:...
        @typing.overload
        def __call__(self, source: Texture, mat: Material, pass: int) -> None:...
        @typing.overload
        def __call__(self, source: Texture, dest: RenderTexture, sourceDepthSlice: int, destDepthSlice: int) -> None:...
        @typing.overload
        def __call__(self, source: Texture, dest: RenderTexture, mat: Material, pass: int) -> None:...
        @typing.overload
        def __call__(self, source: Texture, dest: RenderTexture, scale: Vector2, offset: Vector2) -> None:...
        @typing.overload
        def __call__(self, source: Texture, mat: Material, pass: int, destDepthSlice: int) -> None:...
        @typing.overload
        def __call__(self, source: Texture, dest: RenderTexture, mat: Material, pass: int, destDepthSlice: int) -> None:...
        @typing.overload
        def __call__(self, source: Texture, dest: RenderTexture, scale: Vector2, offset: Vector2, sourceDepthSlice: int, destDepthSlice: int) -> None:...

    # Skipped BlitMultiTap due to it being static, abstract and generic.

    BlitMultiTap : BlitMultiTap_MethodGroup
    class BlitMultiTap_MethodGroup:
        @typing.overload
        def __call__(self, source: Texture, dest: RenderTexture, mat: Material, offsets: Array_1[Vector2]) -> None:...
        @typing.overload
        def __call__(self, source: Texture, dest: RenderTexture, mat: Material, destDepthSlice: int, offsets: Array_1[Vector2]) -> None:...

    # Skipped ConvertTexture due to it being static, abstract and generic.

    ConvertTexture : ConvertTexture_MethodGroup
    class ConvertTexture_MethodGroup:
        @typing.overload
        def __call__(self, src: Texture, dst: Texture) -> bool:...
        @typing.overload
        def __call__(self, src: Texture, srcElement: int, dst: Texture, dstElement: int) -> bool:...

    # Skipped CopyTexture due to it being static, abstract and generic.

    CopyTexture : CopyTexture_MethodGroup
    class CopyTexture_MethodGroup:
        @typing.overload
        def __call__(self, src: Texture, dst: Texture) -> None:...
        @typing.overload
        def __call__(self, src: Texture, srcElement: int, dst: Texture, dstElement: int) -> None:...
        @typing.overload
        def __call__(self, src: Texture, srcElement: int, srcMip: int, dst: Texture, dstElement: int, dstMip: int) -> None:...
        @typing.overload
        def __call__(self, src: Texture, srcElement: int, srcMip: int, srcX: int, srcY: int, srcWidth: int, srcHeight: int, dst: Texture, dstElement: int, dstMip: int, dstX: int, dstY: int) -> None:...

    # Skipped CreateAsyncGraphicsFence due to it being static, abstract and generic.

    CreateAsyncGraphicsFence : CreateAsyncGraphicsFence_MethodGroup
    class CreateAsyncGraphicsFence_MethodGroup:
        @typing.overload
        def __call__(self) -> GraphicsFence:...
        @typing.overload
        def __call__(self, stage: SynchronisationStage) -> GraphicsFence:...

    # Skipped CreateGPUFence due to it being static, abstract and generic.

    CreateGPUFence : CreateGPUFence_MethodGroup
    class CreateGPUFence_MethodGroup:
        @typing.overload
        def __call__(self) -> GPUFence:...
        @typing.overload
        def __call__(self, stage: SynchronisationStage) -> GPUFence:...

    # Skipped DrawMesh due to it being static, abstract and generic.

    DrawMesh : DrawMesh_MethodGroup
    class DrawMesh_MethodGroup:
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, materialIndex: int) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, material: Material, layer: int) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion, materialIndex: int) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, material: Material, layer: int, camera: Camera) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: int) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, material: Material, layer: int, camera: Camera, submeshIndex: int) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: int, camera: Camera) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: int, camera: Camera, submeshIndex: int) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock, castShadows: bool) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock, castShadows: bool, receiveShadows: bool) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock, castShadows: bool) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool, probeAnchor: Transform) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock, castShadows: bool, receiveShadows: bool, useLightProbes: bool) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock, castShadows: bool, receiveShadows: bool) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool, probeAnchor: Transform, lightProbeUsage: LightProbeUsage) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool, probeAnchor: Transform, useLightProbes: bool) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool, probeAnchor: Transform) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock, castShadows: bool, receiveShadows: bool, useLightProbes: bool) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool, probeAnchor: Transform, lightProbeUsage: LightProbeUsage, lightProbeProxyVolume: LightProbeProxyVolume) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: int, camera: Camera, submeshIndex: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool, probeAnchor: Transform, useLightProbes: bool) -> None:...

    # Skipped DrawMeshInstanced due to it being static, abstract and generic.

    DrawMeshInstanced : DrawMeshInstanced_MethodGroup
    class DrawMeshInstanced_MethodGroup:
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, matrices: Array_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, matrices: List_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, matrices: Array_1[Matrix4x4], count: int) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, matrices: List_1[Matrix4x4], properties: MaterialPropertyBlock) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, matrices: Array_1[Matrix4x4], count: int, properties: MaterialPropertyBlock) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, matrices: List_1[Matrix4x4], properties: MaterialPropertyBlock, castShadows: ShadowCastingMode) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, matrices: Array_1[Matrix4x4], count: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, matrices: List_1[Matrix4x4], properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, matrices: Array_1[Matrix4x4], count: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, matrices: List_1[Matrix4x4], properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool, layer: int) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, matrices: Array_1[Matrix4x4], count: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool, layer: int) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, matrices: List_1[Matrix4x4], properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool, layer: int, camera: Camera) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, matrices: Array_1[Matrix4x4], count: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool, layer: int, camera: Camera) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, matrices: List_1[Matrix4x4], properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool, layer: int, camera: Camera, lightProbeUsage: LightProbeUsage) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, matrices: Array_1[Matrix4x4], count: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool, layer: int, camera: Camera, lightProbeUsage: LightProbeUsage) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, matrices: List_1[Matrix4x4], properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool, layer: int, camera: Camera, lightProbeUsage: LightProbeUsage, lightProbeProxyVolume: LightProbeProxyVolume) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, matrices: Array_1[Matrix4x4], count: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool, layer: int, camera: Camera, lightProbeUsage: LightProbeUsage, lightProbeProxyVolume: LightProbeProxyVolume) -> None:...

    # Skipped DrawMeshInstancedIndirect due to it being static, abstract and generic.

    DrawMeshInstancedIndirect : DrawMeshInstancedIndirect_MethodGroup
    class DrawMeshInstancedIndirect_MethodGroup:
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, bounds: Bounds, bufferWithArgs: ComputeBuffer, argsOffset: int = ..., properties: MaterialPropertyBlock = ..., castShadows: ShadowCastingMode = ..., receiveShadows: bool = ..., layer: int = ..., camera: Camera = ..., lightProbeUsage: LightProbeUsage = ...) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, bounds: Bounds, bufferWithArgs: GraphicsBuffer, argsOffset: int = ..., properties: MaterialPropertyBlock = ..., castShadows: ShadowCastingMode = ..., receiveShadows: bool = ..., layer: int = ..., camera: Camera = ..., lightProbeUsage: LightProbeUsage = ...) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, bounds: Bounds, bufferWithArgs: ComputeBuffer, argsOffset: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool, layer: int, camera: Camera, lightProbeUsage: LightProbeUsage, lightProbeProxyVolume: LightProbeProxyVolume) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, bounds: Bounds, bufferWithArgs: GraphicsBuffer, argsOffset: int, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: bool, layer: int, camera: Camera, lightProbeUsage: LightProbeUsage, lightProbeProxyVolume: LightProbeProxyVolume) -> None:...

    # Skipped DrawMeshNow due to it being static, abstract and generic.

    DrawMeshNow : DrawMeshNow_MethodGroup
    class DrawMeshNow_MethodGroup:
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, materialIndex: int) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, position: Vector3, rotation: Quaternion, materialIndex: int) -> None:...

    # Skipped DrawProcedural due to it being static, abstract and generic.

    DrawProcedural : DrawProcedural_MethodGroup
    class DrawProcedural_MethodGroup:
        @typing.overload
        def __call__(self, topology: MeshTopology, vertexCount: int, instanceCount: int = ...) -> None:...
        @typing.overload
        def __call__(self, material: Material, bounds: Bounds, topology: MeshTopology, vertexCount: int, instanceCount: int = ..., camera: Camera = ..., properties: MaterialPropertyBlock = ..., castShadows: ShadowCastingMode = ..., receiveShadows: bool = ..., layer: int = ...) -> None:...
        @typing.overload
        def __call__(self, material: Material, bounds: Bounds, topology: MeshTopology, indexBuffer: GraphicsBuffer, indexCount: int, instanceCount: int = ..., camera: Camera = ..., properties: MaterialPropertyBlock = ..., castShadows: ShadowCastingMode = ..., receiveShadows: bool = ..., layer: int = ...) -> None:...

    # Skipped DrawProceduralIndirect due to it being static, abstract and generic.

    DrawProceduralIndirect : DrawProceduralIndirect_MethodGroup
    class DrawProceduralIndirect_MethodGroup:
        @typing.overload
        def __call__(self, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: int = ...) -> None:...
        @typing.overload
        def __call__(self, material: Material, bounds: Bounds, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: int = ..., camera: Camera = ..., properties: MaterialPropertyBlock = ..., castShadows: ShadowCastingMode = ..., receiveShadows: bool = ..., layer: int = ...) -> None:...
        @typing.overload
        def __call__(self, material: Material, bounds: Bounds, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: int = ..., camera: Camera = ..., properties: MaterialPropertyBlock = ..., castShadows: ShadowCastingMode = ..., receiveShadows: bool = ..., layer: int = ...) -> None:...
        @typing.overload
        def __call__(self, material: Material, bounds: Bounds, topology: MeshTopology, indexBuffer: GraphicsBuffer, bufferWithArgs: ComputeBuffer, argsOffset: int = ..., camera: Camera = ..., properties: MaterialPropertyBlock = ..., castShadows: ShadowCastingMode = ..., receiveShadows: bool = ..., layer: int = ...) -> None:...
        @typing.overload
        def __call__(self, material: Material, bounds: Bounds, topology: MeshTopology, indexBuffer: GraphicsBuffer, bufferWithArgs: GraphicsBuffer, argsOffset: int = ..., camera: Camera = ..., properties: MaterialPropertyBlock = ..., castShadows: ShadowCastingMode = ..., receiveShadows: bool = ..., layer: int = ...) -> None:...

    # Skipped DrawProceduralIndirectNow due to it being static, abstract and generic.

    DrawProceduralIndirectNow : DrawProceduralIndirectNow_MethodGroup
    class DrawProceduralIndirectNow_MethodGroup:
        @typing.overload
        def __call__(self, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: int = ...) -> None:...
        @typing.overload
        def __call__(self, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: int = ...) -> None:...
        @typing.overload
        def __call__(self, topology: MeshTopology, indexBuffer: GraphicsBuffer, bufferWithArgs: ComputeBuffer, argsOffset: int = ...) -> None:...
        @typing.overload
        def __call__(self, topology: MeshTopology, indexBuffer: GraphicsBuffer, bufferWithArgs: GraphicsBuffer, argsOffset: int = ...) -> None:...

    # Skipped DrawProceduralNow due to it being static, abstract and generic.

    DrawProceduralNow : DrawProceduralNow_MethodGroup
    class DrawProceduralNow_MethodGroup:
        @typing.overload
        def __call__(self, topology: MeshTopology, vertexCount: int, instanceCount: int = ...) -> None:...
        @typing.overload
        def __call__(self, topology: MeshTopology, indexBuffer: GraphicsBuffer, indexCount: int, instanceCount: int = ...) -> None:...

    # Skipped DrawTexture due to it being static, abstract and generic.

    DrawTexture : DrawTexture_MethodGroup
    class DrawTexture_MethodGroup:
        @typing.overload
        def __call__(self, screenRect: Rect, texture: Texture) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, texture: Texture, mat: Material) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, texture: Texture, mat: Material, pass: int) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, texture: Texture, leftBorder: int, rightBorder: int, topBorder: int, bottomBorder: int) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, texture: Texture, leftBorder: int, rightBorder: int, topBorder: int, bottomBorder: int, mat: Material) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: int, rightBorder: int, topBorder: int, bottomBorder: int) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, texture: Texture, leftBorder: int, rightBorder: int, topBorder: int, bottomBorder: int, mat: Material, pass: int) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: int, rightBorder: int, topBorder: int, bottomBorder: int, color: Color) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: int, rightBorder: int, topBorder: int, bottomBorder: int, mat: Material) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: int, rightBorder: int, topBorder: int, bottomBorder: int, mat: Material, pass: int) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: int, rightBorder: int, topBorder: int, bottomBorder: int, color: Color, mat: Material) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: int, rightBorder: int, topBorder: int, bottomBorder: int, color: Color, mat: Material, pass: int) -> None:...

    # Skipped RenderMeshInstanced due to it being static, abstract and generic.

    RenderMeshInstanced : RenderMeshInstanced_MethodGroup
    class RenderMeshInstanced_MethodGroup:
        def __getitem__(self, t:typing.Type[RenderMeshInstanced_1_T1]) -> RenderMeshInstanced_1[RenderMeshInstanced_1_T1]: ...

        RenderMeshInstanced_1_T1 = typing.TypeVar('RenderMeshInstanced_1_T1')
        class RenderMeshInstanced_1(typing.Generic[RenderMeshInstanced_1_T1]):
            RenderMeshInstanced_1_T = Graphics.RenderMeshInstanced_MethodGroup.RenderMeshInstanced_1_T1
            @typing.overload
            def __call__(self, rparams: RenderParams, mesh: Mesh, submeshIndex: int, instanceData: NativeArray_1[RenderMeshInstanced_1_T], instanceCount: int = ..., startInstance: int = ...) -> None:...
            @typing.overload
            def __call__(self, rparams: clr.Reference[RenderParams], mesh: Mesh, submeshIndex: int, instanceData: Array_1[RenderMeshInstanced_1_T], instanceCount: int = ..., startInstance: int = ...) -> None:...
            @typing.overload
            def __call__(self, rparams: clr.Reference[RenderParams], mesh: Mesh, submeshIndex: int, instanceData: List_1[RenderMeshInstanced_1_T], instanceCount: int = ..., startInstance: int = ...) -> None:...


    # Skipped SetRandomWriteTarget due to it being static, abstract and generic.

    SetRandomWriteTarget : SetRandomWriteTarget_MethodGroup
    class SetRandomWriteTarget_MethodGroup:
        @typing.overload
        def __call__(self, index: int, uav: RenderTexture) -> None:...
        @typing.overload
        def __call__(self, index: int, uav: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, index: int, uav: GraphicsBuffer) -> None:...
        @typing.overload
        def __call__(self, index: int, uav: ComputeBuffer, preserveCounterValue: bool) -> None:...
        @typing.overload
        def __call__(self, index: int, uav: GraphicsBuffer, preserveCounterValue: bool) -> None:...

    # Skipped SetRenderTarget due to it being static, abstract and generic.

    SetRenderTarget : SetRenderTarget_MethodGroup
    class SetRenderTarget_MethodGroup:
        @typing.overload
        def __call__(self, rt: RenderTexture) -> None:...
        @typing.overload
        def __call__(self, setup: RenderTargetSetup) -> None:...
        @typing.overload
        def __call__(self, colorBuffers: Array_1[RenderBuffer], depthBuffer: RenderBuffer) -> None:...
        @typing.overload
        def __call__(self, rt: RenderTexture, mipLevel: int) -> None:...
        @typing.overload
        def __call__(self, colorBuffer: RenderBuffer, depthBuffer: RenderBuffer) -> None:...
        @typing.overload
        def __call__(self, rt: RenderTexture, mipLevel: int, face: CubemapFace) -> None:...
        @typing.overload
        def __call__(self, colorBuffer: RenderBuffer, depthBuffer: RenderBuffer, mipLevel: int) -> None:...
        @typing.overload
        def __call__(self, rt: RenderTexture, mipLevel: int, face: CubemapFace, depthSlice: int) -> None:...
        @typing.overload
        def __call__(self, colorBuffer: RenderBuffer, depthBuffer: RenderBuffer, mipLevel: int, face: CubemapFace) -> None:...
        @typing.overload
        def __call__(self, colorBuffer: RenderBuffer, depthBuffer: RenderBuffer, mipLevel: int, face: CubemapFace, depthSlice: int) -> None:...

    # Skipped WaitOnAsyncGraphicsFence due to it being static, abstract and generic.

    WaitOnAsyncGraphicsFence : WaitOnAsyncGraphicsFence_MethodGroup
    class WaitOnAsyncGraphicsFence_MethodGroup:
        @typing.overload
        def __call__(self, fence: GraphicsFence) -> None:...
        @typing.overload
        def __call__(self, fence: GraphicsFence, stage: SynchronisationStage) -> None:...

    # Skipped WaitOnGPUFence due to it being static, abstract and generic.

    WaitOnGPUFence : WaitOnGPUFence_MethodGroup
    class WaitOnGPUFence_MethodGroup:
        @typing.overload
        def __call__(self, fence: GPUFence) -> None:...
        @typing.overload
        def __call__(self, fence: GPUFence, stage: SynchronisationStage) -> None:...



class GraphicsBuffer(IDisposable):
    @typing.overload
    def __init__(self, target: GraphicsBuffer.Target, count: int, stride: int) -> None: ...
    @typing.overload
    def __init__(self, target: GraphicsBuffer.Target, usageFlags: GraphicsBuffer.UsageFlags, count: int, stride: int) -> None: ...
    @property
    def bufferHandle(self) -> GraphicsBufferHandle: ...
    @property
    def count(self) -> int: ...
    @property
    def name(self) -> None: ...
    @name.setter
    def name(self, value: str) -> None: ...
    @property
    def stride(self) -> int: ...
    @property
    def target(self) -> GraphicsBuffer.Target: ...
    @property
    def usageFlags(self) -> GraphicsBuffer.UsageFlags: ...
    def Dispose(self) -> None: ...
    def GetNativeBufferPtr(self) -> int: ...
    def IsValid(self) -> bool: ...
    def Release(self) -> None: ...
    def SetCounterValue(self, counterValue: int) -> None: ...
    # Skipped CopyCount due to it being static, abstract and generic.

    CopyCount : CopyCount_MethodGroup
    class CopyCount_MethodGroup:
        @typing.overload
        def __call__(self, src: ComputeBuffer, dst: ComputeBuffer, dstOffsetBytes: int) -> None:...
        @typing.overload
        def __call__(self, src: GraphicsBuffer, dst: ComputeBuffer, dstOffsetBytes: int) -> None:...
        @typing.overload
        def __call__(self, src: ComputeBuffer, dst: GraphicsBuffer, dstOffsetBytes: int) -> None:...
        @typing.overload
        def __call__(self, src: GraphicsBuffer, dst: GraphicsBuffer, dstOffsetBytes: int) -> None:...

    # Skipped GetData due to it being static, abstract and generic.

    GetData : GetData_MethodGroup
    class GetData_MethodGroup:
        @typing.overload
        def __call__(self, data: Array) -> None:...
        @typing.overload
        def __call__(self, data: Array, managedBufferStartIndex: int, computeBufferStartIndex: int, count: int) -> None:...

    # Skipped LockBufferForWrite due to it being static, abstract and generic.

    LockBufferForWrite : LockBufferForWrite_MethodGroup
    class LockBufferForWrite_MethodGroup:
        def __getitem__(self, t:typing.Type[LockBufferForWrite_1_T1]) -> LockBufferForWrite_1[LockBufferForWrite_1_T1]: ...

        LockBufferForWrite_1_T1 = typing.TypeVar('LockBufferForWrite_1_T1')
        class LockBufferForWrite_1(typing.Generic[LockBufferForWrite_1_T1]):
            LockBufferForWrite_1_T = GraphicsBuffer.LockBufferForWrite_MethodGroup.LockBufferForWrite_1_T1
            def __call__(self, bufferStartIndex: int, count: int) -> NativeArray_1[LockBufferForWrite_1_T]:...


    # Skipped SetData due to it being static, abstract and generic.

    SetData : SetData_MethodGroup
    class SetData_MethodGroup:
        def __getitem__(self, t:typing.Type[SetData_1_T1]) -> SetData_1[SetData_1_T1]: ...

        SetData_1_T1 = typing.TypeVar('SetData_1_T1')
        class SetData_1(typing.Generic[SetData_1_T1]):
            SetData_1_T = GraphicsBuffer.SetData_MethodGroup.SetData_1_T1
            @typing.overload
            def __call__(self, data: List_1[SetData_1_T]) -> None:...
            @typing.overload
            def __call__(self, data: NativeArray_1[SetData_1_T]) -> None:...
            @typing.overload
            def __call__(self, data: List_1[SetData_1_T], managedBufferStartIndex: int, graphicsBufferStartIndex: int, count: int) -> None:...
            @typing.overload
            def __call__(self, data: NativeArray_1[SetData_1_T], nativeBufferStartIndex: int, graphicsBufferStartIndex: int, count: int) -> None:...

        @typing.overload
        def __call__(self, data: Array) -> None:...
        @typing.overload
        def __call__(self, data: Array, managedBufferStartIndex: int, graphicsBufferStartIndex: int, count: int) -> None:...

    # Skipped UnlockBufferAfterWrite due to it being static, abstract and generic.

    UnlockBufferAfterWrite : UnlockBufferAfterWrite_MethodGroup
    class UnlockBufferAfterWrite_MethodGroup:
        def __getitem__(self, t:typing.Type[UnlockBufferAfterWrite_1_T1]) -> UnlockBufferAfterWrite_1[UnlockBufferAfterWrite_1_T1]: ...

        UnlockBufferAfterWrite_1_T1 = typing.TypeVar('UnlockBufferAfterWrite_1_T1')
        class UnlockBufferAfterWrite_1(typing.Generic[UnlockBufferAfterWrite_1_T1]):
            UnlockBufferAfterWrite_1_T = GraphicsBuffer.UnlockBufferAfterWrite_MethodGroup.UnlockBufferAfterWrite_1_T1
            def __call__(self, countWritten: int) -> None:...



    class IndirectDrawArgs:
        size : int
        @property
        def instanceCount(self) -> int: ...
        @instanceCount.setter
        def instanceCount(self, value: int) -> int: ...
        @property
        def startInstance(self) -> int: ...
        @startInstance.setter
        def startInstance(self, value: int) -> int: ...
        @property
        def startVertex(self) -> int: ...
        @startVertex.setter
        def startVertex(self, value: int) -> int: ...
        @property
        def vertexCountPerInstance(self) -> int: ...
        @vertexCountPerInstance.setter
        def vertexCountPerInstance(self, value: int) -> int: ...


    class IndirectDrawIndexedArgs:
        size : int
        @property
        def baseVertexIndex(self) -> int: ...
        @baseVertexIndex.setter
        def baseVertexIndex(self, value: int) -> int: ...
        @property
        def indexCountPerInstance(self) -> int: ...
        @indexCountPerInstance.setter
        def indexCountPerInstance(self, value: int) -> int: ...
        @property
        def instanceCount(self) -> int: ...
        @instanceCount.setter
        def instanceCount(self, value: int) -> int: ...
        @property
        def startIndex(self) -> int: ...
        @startIndex.setter
        def startIndex(self, value: int) -> int: ...
        @property
        def startInstance(self) -> int: ...
        @startInstance.setter
        def startInstance(self, value: int) -> int: ...


    class Target(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Vertex : GraphicsBuffer.Target # 1
        Index : GraphicsBuffer.Target # 2
        CopySource : GraphicsBuffer.Target # 4
        CopyDestination : GraphicsBuffer.Target # 8
        Structured : GraphicsBuffer.Target # 16
        Raw : GraphicsBuffer.Target # 32
        Append : GraphicsBuffer.Target # 64
        Counter : GraphicsBuffer.Target # 128
        IndirectArguments : GraphicsBuffer.Target # 256
        Constant : GraphicsBuffer.Target # 512


    class UsageFlags(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        None_ : GraphicsBuffer.UsageFlags # 0
        LockBufferForWrite : GraphicsBuffer.UsageFlags # 1



class GraphicsBufferHandle(IEquatable_1[GraphicsBufferHandle]):
    value : int
    def CompareTo(self, other: GraphicsBufferHandle) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, a: GraphicsBufferHandle, b: GraphicsBufferHandle) -> bool: ...
    def __ne__(self, a: GraphicsBufferHandle, b: GraphicsBufferHandle) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: GraphicsBufferHandle) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class Grid(GridLayout):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def cellGap(self) -> Vector3: ...
    @cellGap.setter
    def cellGap(self, value: Vector3) -> Vector3: ...
    @property
    def cellLayout(self) -> GridLayout.CellLayout: ...
    @cellLayout.setter
    def cellLayout(self, value: GridLayout.CellLayout) -> GridLayout.CellLayout: ...
    @property
    def cellSize(self) -> Vector3: ...
    @cellSize.setter
    def cellSize(self, value: Vector3) -> Vector3: ...
    @property
    def cellSwizzle(self) -> GridLayout.CellSwizzle: ...
    @cellSwizzle.setter
    def cellSwizzle(self, value: GridLayout.CellSwizzle) -> GridLayout.CellSwizzle: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    def GetCellCenterLocal(self, position: Vector3Int) -> Vector3: ...
    def GetCellCenterWorld(self, position: Vector3Int) -> Vector3: ...
    @staticmethod
    def InverseSwizzle(swizzle: GridLayout.CellSwizzle, position: Vector3) -> Vector3: ...
    @staticmethod
    def Swizzle(swizzle: GridLayout.CellSwizzle, position: Vector3) -> Vector3: ...


class GridBrushBase(ScriptableObject, abc.ABC):
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    def BoxErase(self, gridLayout: GridLayout, brushTarget: GameObject, position: BoundsInt) -> None: ...
    def BoxFill(self, gridLayout: GridLayout, brushTarget: GameObject, position: BoundsInt) -> None: ...
    def ChangeZPosition(self, change: int) -> None: ...
    def Erase(self, gridLayout: GridLayout, brushTarget: GameObject, position: Vector3Int) -> None: ...
    def Flip(self, flip: GridBrushBase.FlipAxis, layout: GridLayout.CellLayout) -> None: ...
    def FloodFill(self, gridLayout: GridLayout, brushTarget: GameObject, position: Vector3Int) -> None: ...
    def Move(self, gridLayout: GridLayout, brushTarget: GameObject, from_: BoundsInt, to: BoundsInt) -> None: ...
    def MoveEnd(self, gridLayout: GridLayout, brushTarget: GameObject, position: BoundsInt) -> None: ...
    def MoveStart(self, gridLayout: GridLayout, brushTarget: GameObject, position: BoundsInt) -> None: ...
    def Paint(self, gridLayout: GridLayout, brushTarget: GameObject, position: Vector3Int) -> None: ...
    def Pick(self, gridLayout: GridLayout, brushTarget: GameObject, position: BoundsInt, pivot: Vector3Int) -> None: ...
    def ResetZPosition(self) -> None: ...
    def Rotate(self, direction: GridBrushBase.RotationDirection, layout: GridLayout.CellLayout) -> None: ...
    def Select(self, gridLayout: GridLayout, brushTarget: GameObject, position: BoundsInt) -> None: ...

    class FlipAxis(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        X : GridBrushBase.FlipAxis # 0
        Y : GridBrushBase.FlipAxis # 1


    class RotationDirection(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Clockwise : GridBrushBase.RotationDirection # 0
        CounterClockwise : GridBrushBase.RotationDirection # 1


    class Tool(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Select : GridBrushBase.Tool # 0
        Move : GridBrushBase.Tool # 1
        Paint : GridBrushBase.Tool # 2
        Box : GridBrushBase.Tool # 3
        Pick : GridBrushBase.Tool # 4
        Erase : GridBrushBase.Tool # 5
        FloodFill : GridBrushBase.Tool # 6
        Other : GridBrushBase.Tool # 7



class GridLayout(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def cellGap(self) -> Vector3: ...
    @property
    def cellLayout(self) -> GridLayout.CellLayout: ...
    @property
    def cellSize(self) -> Vector3: ...
    @property
    def cellSwizzle(self) -> GridLayout.CellSwizzle: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    def CellToLocal(self, cellPosition: Vector3Int) -> Vector3: ...
    def CellToLocalInterpolated(self, cellPosition: Vector3) -> Vector3: ...
    def CellToWorld(self, cellPosition: Vector3Int) -> Vector3: ...
    def GetLayoutCellCenter(self) -> Vector3: ...
    def LocalToCell(self, localPosition: Vector3) -> Vector3Int: ...
    def LocalToCellInterpolated(self, localPosition: Vector3) -> Vector3: ...
    def LocalToWorld(self, localPosition: Vector3) -> Vector3: ...
    def WorldToCell(self, worldPosition: Vector3) -> Vector3Int: ...
    def WorldToLocal(self, worldPosition: Vector3) -> Vector3: ...
    # Skipped GetBoundsLocal due to it being static, abstract and generic.

    GetBoundsLocal : GetBoundsLocal_MethodGroup
    class GetBoundsLocal_MethodGroup:
        @typing.overload
        def __call__(self, cellPosition: Vector3Int) -> Bounds:...
        @typing.overload
        def __call__(self, origin: Vector3, size: Vector3) -> Bounds:...


    class CellLayout(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Rectangle : GridLayout.CellLayout # 0
        Hexagon : GridLayout.CellLayout # 1
        Isometric : GridLayout.CellLayout # 2
        IsometricZAsY : GridLayout.CellLayout # 3


    class CellSwizzle(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        XYZ : GridLayout.CellSwizzle # 0
        XZY : GridLayout.CellSwizzle # 1
        YXZ : GridLayout.CellSwizzle # 2
        YZX : GridLayout.CellSwizzle # 3
        ZXY : GridLayout.CellSwizzle # 4
        ZYX : GridLayout.CellSwizzle # 5



class GUI:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def backgroundColor(cls) -> Color: ...
    @classmethod
    @backgroundColor.setter
    def backgroundColor(cls, value: Color) -> Color: ...
    @classmethod
    @property
    def changed(cls) -> bool: ...
    @classmethod
    @changed.setter
    def changed(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def color(cls) -> Color: ...
    @classmethod
    @color.setter
    def color(cls, value: Color) -> Color: ...
    @classmethod
    @property
    def contentColor(cls) -> Color: ...
    @classmethod
    @contentColor.setter
    def contentColor(cls, value: Color) -> Color: ...
    @classmethod
    @property
    def depth(cls) -> int: ...
    @classmethod
    @depth.setter
    def depth(cls, value: int) -> int: ...
    @classmethod
    @property
    def enabled(cls) -> bool: ...
    @classmethod
    @enabled.setter
    def enabled(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def matrix(cls) -> Matrix4x4: ...
    @classmethod
    @matrix.setter
    def matrix(cls, value: Matrix4x4) -> Matrix4x4: ...
    @classmethod
    @property
    def skin(cls) -> GUISkin: ...
    @classmethod
    @skin.setter
    def skin(cls, value: GUISkin) -> GUISkin: ...
    @classmethod
    @property
    def tooltip(cls) -> str: ...
    @classmethod
    @tooltip.setter
    def tooltip(cls, value: str) -> str: ...
    @staticmethod
    def BringWindowToBack(windowID: int) -> None: ...
    @staticmethod
    def BringWindowToFront(windowID: int) -> None: ...
    @staticmethod
    def EndClip() -> None: ...
    @staticmethod
    def EndGroup() -> None: ...
    @staticmethod
    def FocusControl(name: str) -> None: ...
    @staticmethod
    def FocusWindow(windowID: int) -> None: ...
    @staticmethod
    def GetNameOfFocusedControl() -> str: ...
    @staticmethod
    def ScrollTo(position: Rect) -> None: ...
    @staticmethod
    def ScrollTowards(position: Rect, maxDelta: float) -> bool: ...
    @staticmethod
    def SetNextControlName(name: str) -> None: ...
    @staticmethod
    def Slider(position: Rect, value: float, size: float, start: float, end: float, slider: GUIStyle, thumb: GUIStyle, horiz: bool, id: int, thumbExtent: GUIStyle = ...) -> float: ...
    @staticmethod
    def UnfocusWindow() -> None: ...
    # Skipped BeginClip due to it being static, abstract and generic.

    BeginClip : BeginClip_MethodGroup
    class BeginClip_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect) -> None:...
        @typing.overload
        def __call__(self, position: Rect, scrollOffset: Vector2, renderOffset: Vector2, resetOffset: bool) -> None:...

    # Skipped BeginGroup due to it being static, abstract and generic.

    BeginGroup : BeginGroup_MethodGroup
    class BeginGroup_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect) -> None:...
        @typing.overload
        def __call__(self, position: Rect, image: Texture) -> None:...
        @typing.overload
        def __call__(self, position: Rect, text: str) -> None:...
        @typing.overload
        def __call__(self, position: Rect, content: GUIContent) -> None:...
        @typing.overload
        def __call__(self, position: Rect, style: GUIStyle) -> None:...
        @typing.overload
        def __call__(self, position: Rect, image: Texture, style: GUIStyle) -> None:...
        @typing.overload
        def __call__(self, position: Rect, text: str, style: GUIStyle) -> None:...
        @typing.overload
        def __call__(self, position: Rect, content: GUIContent, style: GUIStyle) -> None:...

    # Skipped BeginScrollView due to it being static, abstract and generic.

    BeginScrollView : BeginScrollView_MethodGroup
    class BeginScrollView_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, scrollPosition: Vector2, viewRect: Rect) -> Vector2:...
        @typing.overload
        def __call__(self, position: Rect, scrollPosition: Vector2, viewRect: Rect, alwaysShowHorizontal: bool, alwaysShowVertical: bool) -> Vector2:...
        @typing.overload
        def __call__(self, position: Rect, scrollPosition: Vector2, viewRect: Rect, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle) -> Vector2:...
        @typing.overload
        def __call__(self, position: Rect, scrollPosition: Vector2, viewRect: Rect, alwaysShowHorizontal: bool, alwaysShowVertical: bool, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle) -> Vector2:...

    # Skipped Box due to it being static, abstract and generic.

    Box : Box_MethodGroup
    class Box_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, image: Texture) -> None:...
        @typing.overload
        def __call__(self, position: Rect, text: str) -> None:...
        @typing.overload
        def __call__(self, position: Rect, content: GUIContent) -> None:...
        @typing.overload
        def __call__(self, position: Rect, image: Texture, style: GUIStyle) -> None:...
        @typing.overload
        def __call__(self, position: Rect, text: str, style: GUIStyle) -> None:...
        @typing.overload
        def __call__(self, position: Rect, content: GUIContent, style: GUIStyle) -> None:...

    # Skipped Button due to it being static, abstract and generic.

    Button : Button_MethodGroup
    class Button_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, image: Texture) -> bool:...
        @typing.overload
        def __call__(self, position: Rect, text: str) -> bool:...
        @typing.overload
        def __call__(self, position: Rect, content: GUIContent) -> bool:...
        @typing.overload
        def __call__(self, position: Rect, image: Texture, style: GUIStyle) -> bool:...
        @typing.overload
        def __call__(self, position: Rect, text: str, style: GUIStyle) -> bool:...
        @typing.overload
        def __call__(self, position: Rect, content: GUIContent, style: GUIStyle) -> bool:...

    # Skipped DragWindow due to it being static, abstract and generic.

    DragWindow : DragWindow_MethodGroup
    class DragWindow_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, position: Rect) -> None:...

    # Skipped DrawTexture due to it being static, abstract and generic.

    DrawTexture : DrawTexture_MethodGroup
    class DrawTexture_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, image: Texture) -> None:...
        @typing.overload
        def __call__(self, position: Rect, image: Texture, scaleMode: ScaleMode) -> None:...
        @typing.overload
        def __call__(self, position: Rect, image: Texture, scaleMode: ScaleMode, alphaBlend: bool) -> None:...
        @typing.overload
        def __call__(self, position: Rect, image: Texture, scaleMode: ScaleMode, alphaBlend: bool, imageAspect: float) -> None:...
        @typing.overload
        def __call__(self, position: Rect, image: Texture, scaleMode: ScaleMode, alphaBlend: bool, imageAspect: float, color: Color, borderWidth: float, borderRadius: float) -> None:...
        @typing.overload
        def __call__(self, position: Rect, image: Texture, scaleMode: ScaleMode, alphaBlend: bool, imageAspect: float, color: Color, borderWidths: Vector4, borderRadius: float) -> None:...
        @typing.overload
        def __call__(self, position: Rect, image: Texture, scaleMode: ScaleMode, alphaBlend: bool, imageAspect: float, color: Color, borderWidths: Vector4, borderRadiuses: Vector4) -> None:...

    # Skipped DrawTextureWithTexCoords due to it being static, abstract and generic.

    DrawTextureWithTexCoords : DrawTextureWithTexCoords_MethodGroup
    class DrawTextureWithTexCoords_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, image: Texture, texCoords: Rect) -> None:...
        @typing.overload
        def __call__(self, position: Rect, image: Texture, texCoords: Rect, alphaBlend: bool) -> None:...

    # Skipped EndScrollView due to it being static, abstract and generic.

    EndScrollView : EndScrollView_MethodGroup
    class EndScrollView_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, handleScrollWheel: bool) -> None:...

    # Skipped HorizontalScrollbar due to it being static, abstract and generic.

    HorizontalScrollbar : HorizontalScrollbar_MethodGroup
    class HorizontalScrollbar_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, value: float, size: float, leftValue: float, rightValue: float) -> float:...
        @typing.overload
        def __call__(self, position: Rect, value: float, size: float, leftValue: float, rightValue: float, style: GUIStyle) -> float:...

    # Skipped HorizontalSlider due to it being static, abstract and generic.

    HorizontalSlider : HorizontalSlider_MethodGroup
    class HorizontalSlider_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, value: float, leftValue: float, rightValue: float) -> float:...
        @typing.overload
        def __call__(self, position: Rect, value: float, leftValue: float, rightValue: float, slider: GUIStyle, thumb: GUIStyle) -> float:...
        @typing.overload
        def __call__(self, position: Rect, value: float, leftValue: float, rightValue: float, slider: GUIStyle, thumb: GUIStyle, thumbExtent: GUIStyle) -> float:...

    # Skipped Label due to it being static, abstract and generic.

    Label : Label_MethodGroup
    class Label_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, image: Texture) -> None:...
        @typing.overload
        def __call__(self, position: Rect, text: str) -> None:...
        @typing.overload
        def __call__(self, position: Rect, content: GUIContent) -> None:...
        @typing.overload
        def __call__(self, position: Rect, image: Texture, style: GUIStyle) -> None:...
        @typing.overload
        def __call__(self, position: Rect, text: str, style: GUIStyle) -> None:...
        @typing.overload
        def __call__(self, position: Rect, content: GUIContent, style: GUIStyle) -> None:...

    # Skipped ModalWindow due to it being static, abstract and generic.

    ModalWindow : ModalWindow_MethodGroup
    class ModalWindow_MethodGroup:
        @typing.overload
        def __call__(self, id: int, clientRect: Rect, func: GUI.WindowFunction, image: Texture) -> Rect:...
        @typing.overload
        def __call__(self, id: int, clientRect: Rect, func: GUI.WindowFunction, text: str) -> Rect:...
        @typing.overload
        def __call__(self, id: int, clientRect: Rect, func: GUI.WindowFunction, content: GUIContent) -> Rect:...
        @typing.overload
        def __call__(self, id: int, clientRect: Rect, func: GUI.WindowFunction, image: Texture, style: GUIStyle) -> Rect:...
        @typing.overload
        def __call__(self, id: int, clientRect: Rect, func: GUI.WindowFunction, text: str, style: GUIStyle) -> Rect:...
        @typing.overload
        def __call__(self, id: int, clientRect: Rect, func: GUI.WindowFunction, content: GUIContent, style: GUIStyle) -> Rect:...

    # Skipped PasswordField due to it being static, abstract and generic.

    PasswordField : PasswordField_MethodGroup
    class PasswordField_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, password: str, maskChar: str) -> str:...
        @typing.overload
        def __call__(self, position: Rect, password: str, maskChar: str, maxLength: int) -> str:...
        @typing.overload
        def __call__(self, position: Rect, password: str, maskChar: str, style: GUIStyle) -> str:...
        @typing.overload
        def __call__(self, position: Rect, password: str, maskChar: str, maxLength: int, style: GUIStyle) -> str:...

    # Skipped RepeatButton due to it being static, abstract and generic.

    RepeatButton : RepeatButton_MethodGroup
    class RepeatButton_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, image: Texture) -> bool:...
        @typing.overload
        def __call__(self, position: Rect, text: str) -> bool:...
        @typing.overload
        def __call__(self, position: Rect, content: GUIContent) -> bool:...
        @typing.overload
        def __call__(self, position: Rect, image: Texture, style: GUIStyle) -> bool:...
        @typing.overload
        def __call__(self, position: Rect, text: str, style: GUIStyle) -> bool:...
        @typing.overload
        def __call__(self, position: Rect, content: GUIContent, style: GUIStyle) -> bool:...

    # Skipped SelectionGrid due to it being static, abstract and generic.

    SelectionGrid : SelectionGrid_MethodGroup
    class SelectionGrid_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, selected: int, images: Array_1[Texture], xCount: int) -> int:...
        @typing.overload
        def __call__(self, position: Rect, selected: int, texts: Array_1[str], xCount: int) -> int:...
        @typing.overload
        def __call__(self, position: Rect, selected: int, content: Array_1[GUIContent], xCount: int) -> int:...
        @typing.overload
        def __call__(self, position: Rect, selected: int, images: Array_1[Texture], xCount: int, style: GUIStyle) -> int:...
        @typing.overload
        def __call__(self, position: Rect, selected: int, texts: Array_1[str], xCount: int, style: GUIStyle) -> int:...
        @typing.overload
        def __call__(self, position: Rect, selected: int, contents: Array_1[GUIContent], xCount: int, style: GUIStyle) -> int:...

    # Skipped TextArea due to it being static, abstract and generic.

    TextArea : TextArea_MethodGroup
    class TextArea_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, text: str) -> str:...
        @typing.overload
        def __call__(self, position: Rect, text: str, maxLength: int) -> str:...
        @typing.overload
        def __call__(self, position: Rect, text: str, style: GUIStyle) -> str:...
        @typing.overload
        def __call__(self, position: Rect, text: str, maxLength: int, style: GUIStyle) -> str:...

    # Skipped TextField due to it being static, abstract and generic.

    TextField : TextField_MethodGroup
    class TextField_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, text: str) -> str:...
        @typing.overload
        def __call__(self, position: Rect, text: str, maxLength: int) -> str:...
        @typing.overload
        def __call__(self, position: Rect, text: str, style: GUIStyle) -> str:...
        @typing.overload
        def __call__(self, position: Rect, text: str, maxLength: int, style: GUIStyle) -> str:...

    # Skipped Toggle due to it being static, abstract and generic.

    Toggle : Toggle_MethodGroup
    class Toggle_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, value: bool, image: Texture) -> bool:...
        @typing.overload
        def __call__(self, position: Rect, value: bool, text: str) -> bool:...
        @typing.overload
        def __call__(self, position: Rect, value: bool, content: GUIContent) -> bool:...
        @typing.overload
        def __call__(self, position: Rect, value: bool, image: Texture, style: GUIStyle) -> bool:...
        @typing.overload
        def __call__(self, position: Rect, value: bool, text: str, style: GUIStyle) -> bool:...
        @typing.overload
        def __call__(self, position: Rect, value: bool, content: GUIContent, style: GUIStyle) -> bool:...
        @typing.overload
        def __call__(self, position: Rect, id: int, value: bool, content: GUIContent, style: GUIStyle) -> bool:...

    # Skipped Toolbar due to it being static, abstract and generic.

    Toolbar : Toolbar_MethodGroup
    class Toolbar_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, selected: int, images: Array_1[Texture]) -> int:...
        @typing.overload
        def __call__(self, position: Rect, selected: int, texts: Array_1[str]) -> int:...
        @typing.overload
        def __call__(self, position: Rect, selected: int, contents: Array_1[GUIContent]) -> int:...
        @typing.overload
        def __call__(self, position: Rect, selected: int, images: Array_1[Texture], style: GUIStyle) -> int:...
        @typing.overload
        def __call__(self, position: Rect, selected: int, texts: Array_1[str], style: GUIStyle) -> int:...
        @typing.overload
        def __call__(self, position: Rect, selected: int, contents: Array_1[GUIContent], style: GUIStyle) -> int:...
        @typing.overload
        def __call__(self, position: Rect, selected: int, contents: Array_1[GUIContent], style: GUIStyle, buttonSize: GUI.ToolbarButtonSize) -> int:...

    # Skipped VerticalScrollbar due to it being static, abstract and generic.

    VerticalScrollbar : VerticalScrollbar_MethodGroup
    class VerticalScrollbar_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, value: float, size: float, topValue: float, bottomValue: float) -> float:...
        @typing.overload
        def __call__(self, position: Rect, value: float, size: float, topValue: float, bottomValue: float, style: GUIStyle) -> float:...

    # Skipped VerticalSlider due to it being static, abstract and generic.

    VerticalSlider : VerticalSlider_MethodGroup
    class VerticalSlider_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, value: float, topValue: float, bottomValue: float) -> float:...
        @typing.overload
        def __call__(self, position: Rect, value: float, topValue: float, bottomValue: float, slider: GUIStyle, thumb: GUIStyle) -> float:...
        @typing.overload
        def __call__(self, position: Rect, value: float, topValue: float, bottomValue: float, slider: GUIStyle, thumb: GUIStyle, thumbExtent: GUIStyle) -> float:...

    # Skipped Window due to it being static, abstract and generic.

    Window : Window_MethodGroup
    class Window_MethodGroup:
        @typing.overload
        def __call__(self, id: int, clientRect: Rect, func: GUI.WindowFunction, image: Texture) -> Rect:...
        @typing.overload
        def __call__(self, id: int, clientRect: Rect, func: GUI.WindowFunction, text: str) -> Rect:...
        @typing.overload
        def __call__(self, id: int, clientRect: Rect, func: GUI.WindowFunction, content: GUIContent) -> Rect:...
        @typing.overload
        def __call__(self, id: int, clientRect: Rect, func: GUI.WindowFunction, image: Texture, style: GUIStyle) -> Rect:...
        @typing.overload
        def __call__(self, id: int, clientRect: Rect, func: GUI.WindowFunction, text: str, style: GUIStyle) -> Rect:...
        @typing.overload
        def __call__(self, id: int, clientRect: Rect, func: GUI.WindowFunction, title: GUIContent, style: GUIStyle) -> Rect:...


    class ClipScope(GUI.Scope):
        def __init__(self, position: Rect) -> None: ...


    class GroupScope(GUI.Scope):
        @typing.overload
        def __init__(self, position: Rect) -> None: ...
        @typing.overload
        def __init__(self, position: Rect, content: GUIContent) -> None: ...
        @typing.overload
        def __init__(self, position: Rect, image: Texture) -> None: ...
        @typing.overload
        def __init__(self, position: Rect, image: Texture, style: GUIStyle) -> None: ...
        @typing.overload
        def __init__(self, position: Rect, style: GUIStyle) -> None: ...
        @typing.overload
        def __init__(self, position: Rect, text: str) -> None: ...
        @typing.overload
        def __init__(self, position: Rect, text: str, style: GUIStyle) -> None: ...


    class Scope(IDisposable, abc.ABC):
        def Dispose(self) -> None: ...


    class ScrollViewScope(GUI.Scope):
        @typing.overload
        def __init__(self, position: Rect, scrollPosition: Vector2, viewRect: Rect) -> None: ...
        @typing.overload
        def __init__(self, position: Rect, scrollPosition: Vector2, viewRect: Rect, alwaysShowHorizontal: bool, alwaysShowVertical: bool) -> None: ...
        @typing.overload
        def __init__(self, position: Rect, scrollPosition: Vector2, viewRect: Rect, alwaysShowHorizontal: bool, alwaysShowVertical: bool, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle) -> None: ...
        @typing.overload
        def __init__(self, position: Rect, scrollPosition: Vector2, viewRect: Rect, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle) -> None: ...
        @property
        def handleScrollWheel(self) -> bool: ...
        @handleScrollWheel.setter
        def handleScrollWheel(self, value: bool) -> bool: ...
        @property
        def scrollPosition(self) -> Vector2: ...
        @scrollPosition.setter
        def scrollPosition(self, value: Vector2) -> Vector2: ...


    class ToolbarButtonSize(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Fixed : GUI.ToolbarButtonSize # 0
        FitToContents : GUI.ToolbarButtonSize # 1


    class WindowFunction(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, id: int, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, id: int) -> None: ...



class GUIContent:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, image: Texture) -> None: ...
    @typing.overload
    def __init__(self, image: Texture, tooltip: str) -> None: ...
    @typing.overload
    def __init__(self, src: GUIContent) -> None: ...
    @typing.overload
    def __init__(self, text: str) -> None: ...
    @typing.overload
    def __init__(self, text: str, image: Texture) -> None: ...
    @typing.overload
    def __init__(self, text: str, image: Texture, tooltip: str) -> None: ...
    @typing.overload
    def __init__(self, text: str, tooltip: str) -> None: ...
    none : GUIContent
    @property
    def image(self) -> Texture: ...
    @image.setter
    def image(self, value: Texture) -> Texture: ...
    @property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> str: ...
    @property
    def tooltip(self) -> str: ...
    @tooltip.setter
    def tooltip(self, value: str) -> str: ...
    def ToString(self) -> str: ...


class GUIElement:
    def __init__(self) -> None: ...
    # Skipped GetScreenRect due to it being static, abstract and generic.

    GetScreenRect : GetScreenRect_MethodGroup
    class GetScreenRect_MethodGroup:
        @typing.overload
        def __call__(self) -> Rect:...
        @typing.overload
        def __call__(self, camera: Camera) -> Rect:...

    # Skipped HitTest due to it being static, abstract and generic.

    HitTest : HitTest_MethodGroup
    class HitTest_MethodGroup:
        @typing.overload
        def __call__(self, screenPosition: Vector3) -> bool:...
        @typing.overload
        def __call__(self, screenPosition: Vector3, camera: Camera) -> bool:...



class GUILayer:
    def __init__(self) -> None: ...
    def HitTest(self, screenPosition: Vector3) -> GUIElement: ...


class GUILayout:
    def __init__(self) -> None: ...
    @staticmethod
    def EndArea() -> None: ...
    @staticmethod
    def EndHorizontal() -> None: ...
    @staticmethod
    def EndScrollView() -> None: ...
    @staticmethod
    def EndVertical() -> None: ...
    @staticmethod
    def ExpandHeight(expand: bool) -> GUILayoutOption: ...
    @staticmethod
    def ExpandWidth(expand: bool) -> GUILayoutOption: ...
    @staticmethod
    def FlexibleSpace() -> None: ...
    @staticmethod
    def Height(height: float) -> GUILayoutOption: ...
    @staticmethod
    def MaxHeight(maxHeight: float) -> GUILayoutOption: ...
    @staticmethod
    def MaxWidth(maxWidth: float) -> GUILayoutOption: ...
    @staticmethod
    def MinHeight(minHeight: float) -> GUILayoutOption: ...
    @staticmethod
    def MinWidth(minWidth: float) -> GUILayoutOption: ...
    @staticmethod
    def Space(pixels: float) -> None: ...
    @staticmethod
    def Width(width: float) -> GUILayoutOption: ...
    # Skipped BeginArea due to it being static, abstract and generic.

    BeginArea : BeginArea_MethodGroup
    class BeginArea_MethodGroup:
        @typing.overload
        def __call__(self, screenRect: Rect) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, image: Texture) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, text: str) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, content: GUIContent) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, style: GUIStyle) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, image: Texture, style: GUIStyle) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, text: str, style: GUIStyle) -> None:...
        @typing.overload
        def __call__(self, screenRect: Rect, content: GUIContent, style: GUIStyle) -> None:...

    # Skipped BeginHorizontal due to it being static, abstract and generic.

    BeginHorizontal : BeginHorizontal_MethodGroup
    class BeginHorizontal_MethodGroup:
        @typing.overload
        def __call__(self, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, image: Texture, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, text: str, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, content: GUIContent, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None:...

    # Skipped BeginScrollView due to it being static, abstract and generic.

    BeginScrollView : BeginScrollView_MethodGroup
    class BeginScrollView_MethodGroup:
        @typing.overload
        def __call__(self, scrollPosition: Vector2, options: Array_1[GUILayoutOption]) -> Vector2:...
        @typing.overload
        def __call__(self, scrollPosition: Vector2, style: GUIStyle) -> Vector2:...
        @typing.overload
        def __call__(self, scrollPosition: Vector2, style: GUIStyle, options: Array_1[GUILayoutOption]) -> Vector2:...
        @typing.overload
        def __call__(self, scrollPosition: Vector2, alwaysShowHorizontal: bool, alwaysShowVertical: bool, options: Array_1[GUILayoutOption]) -> Vector2:...
        @typing.overload
        def __call__(self, scrollPosition: Vector2, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, options: Array_1[GUILayoutOption]) -> Vector2:...
        @typing.overload
        def __call__(self, scrollPosition: Vector2, alwaysShowHorizontal: bool, alwaysShowVertical: bool, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, options: Array_1[GUILayoutOption]) -> Vector2:...
        @typing.overload
        def __call__(self, scrollPosition: Vector2, alwaysShowHorizontal: bool, alwaysShowVertical: bool, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, background: GUIStyle, options: Array_1[GUILayoutOption]) -> Vector2:...

    # Skipped BeginVertical due to it being static, abstract and generic.

    BeginVertical : BeginVertical_MethodGroup
    class BeginVertical_MethodGroup:
        @typing.overload
        def __call__(self, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, image: Texture, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, text: str, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, content: GUIContent, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None:...

    # Skipped Box due to it being static, abstract and generic.

    Box : Box_MethodGroup
    class Box_MethodGroup:
        @typing.overload
        def __call__(self, image: Texture, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, text: str, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, content: GUIContent, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, image: Texture, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, text: str, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, content: GUIContent, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None:...

    # Skipped Button due to it being static, abstract and generic.

    Button : Button_MethodGroup
    class Button_MethodGroup:
        @typing.overload
        def __call__(self, image: Texture, options: Array_1[GUILayoutOption]) -> bool:...
        @typing.overload
        def __call__(self, text: str, options: Array_1[GUILayoutOption]) -> bool:...
        @typing.overload
        def __call__(self, content: GUIContent, options: Array_1[GUILayoutOption]) -> bool:...
        @typing.overload
        def __call__(self, image: Texture, style: GUIStyle, options: Array_1[GUILayoutOption]) -> bool:...
        @typing.overload
        def __call__(self, text: str, style: GUIStyle, options: Array_1[GUILayoutOption]) -> bool:...
        @typing.overload
        def __call__(self, content: GUIContent, style: GUIStyle, options: Array_1[GUILayoutOption]) -> bool:...

    # Skipped HorizontalScrollbar due to it being static, abstract and generic.

    HorizontalScrollbar : HorizontalScrollbar_MethodGroup
    class HorizontalScrollbar_MethodGroup:
        @typing.overload
        def __call__(self, value: float, size: float, leftValue: float, rightValue: float, options: Array_1[GUILayoutOption]) -> float:...
        @typing.overload
        def __call__(self, value: float, size: float, leftValue: float, rightValue: float, style: GUIStyle, options: Array_1[GUILayoutOption]) -> float:...

    # Skipped HorizontalSlider due to it being static, abstract and generic.

    HorizontalSlider : HorizontalSlider_MethodGroup
    class HorizontalSlider_MethodGroup:
        @typing.overload
        def __call__(self, value: float, leftValue: float, rightValue: float, options: Array_1[GUILayoutOption]) -> float:...
        @typing.overload
        def __call__(self, value: float, leftValue: float, rightValue: float, slider: GUIStyle, thumb: GUIStyle, options: Array_1[GUILayoutOption]) -> float:...

    # Skipped Label due to it being static, abstract and generic.

    Label : Label_MethodGroup
    class Label_MethodGroup:
        @typing.overload
        def __call__(self, image: Texture, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, text: str, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, content: GUIContent, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, image: Texture, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, text: str, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None:...
        @typing.overload
        def __call__(self, content: GUIContent, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None:...

    # Skipped PasswordField due to it being static, abstract and generic.

    PasswordField : PasswordField_MethodGroup
    class PasswordField_MethodGroup:
        @typing.overload
        def __call__(self, password: str, maskChar: str, options: Array_1[GUILayoutOption]) -> str:...
        @typing.overload
        def __call__(self, password: str, maskChar: str, maxLength: int, options: Array_1[GUILayoutOption]) -> str:...
        @typing.overload
        def __call__(self, password: str, maskChar: str, style: GUIStyle, options: Array_1[GUILayoutOption]) -> str:...
        @typing.overload
        def __call__(self, password: str, maskChar: str, maxLength: int, style: GUIStyle, options: Array_1[GUILayoutOption]) -> str:...

    # Skipped RepeatButton due to it being static, abstract and generic.

    RepeatButton : RepeatButton_MethodGroup
    class RepeatButton_MethodGroup:
        @typing.overload
        def __call__(self, image: Texture, options: Array_1[GUILayoutOption]) -> bool:...
        @typing.overload
        def __call__(self, text: str, options: Array_1[GUILayoutOption]) -> bool:...
        @typing.overload
        def __call__(self, content: GUIContent, options: Array_1[GUILayoutOption]) -> bool:...
        @typing.overload
        def __call__(self, image: Texture, style: GUIStyle, options: Array_1[GUILayoutOption]) -> bool:...
        @typing.overload
        def __call__(self, text: str, style: GUIStyle, options: Array_1[GUILayoutOption]) -> bool:...
        @typing.overload
        def __call__(self, content: GUIContent, style: GUIStyle, options: Array_1[GUILayoutOption]) -> bool:...

    # Skipped SelectionGrid due to it being static, abstract and generic.

    SelectionGrid : SelectionGrid_MethodGroup
    class SelectionGrid_MethodGroup:
        @typing.overload
        def __call__(self, selected: int, images: Array_1[Texture], xCount: int, options: Array_1[GUILayoutOption]) -> int:...
        @typing.overload
        def __call__(self, selected: int, texts: Array_1[str], xCount: int, options: Array_1[GUILayoutOption]) -> int:...
        @typing.overload
        def __call__(self, selected: int, content: Array_1[GUIContent], xCount: int, options: Array_1[GUILayoutOption]) -> int:...
        @typing.overload
        def __call__(self, selected: int, images: Array_1[Texture], xCount: int, style: GUIStyle, options: Array_1[GUILayoutOption]) -> int:...
        @typing.overload
        def __call__(self, selected: int, texts: Array_1[str], xCount: int, style: GUIStyle, options: Array_1[GUILayoutOption]) -> int:...
        @typing.overload
        def __call__(self, selected: int, contents: Array_1[GUIContent], xCount: int, style: GUIStyle, options: Array_1[GUILayoutOption]) -> int:...

    # Skipped TextArea due to it being static, abstract and generic.

    TextArea : TextArea_MethodGroup
    class TextArea_MethodGroup:
        @typing.overload
        def __call__(self, text: str, options: Array_1[GUILayoutOption]) -> str:...
        @typing.overload
        def __call__(self, text: str, maxLength: int, options: Array_1[GUILayoutOption]) -> str:...
        @typing.overload
        def __call__(self, text: str, style: GUIStyle, options: Array_1[GUILayoutOption]) -> str:...
        @typing.overload
        def __call__(self, text: str, maxLength: int, style: GUIStyle, options: Array_1[GUILayoutOption]) -> str:...

    # Skipped TextField due to it being static, abstract and generic.

    TextField : TextField_MethodGroup
    class TextField_MethodGroup:
        @typing.overload
        def __call__(self, text: str, options: Array_1[GUILayoutOption]) -> str:...
        @typing.overload
        def __call__(self, text: str, maxLength: int, options: Array_1[GUILayoutOption]) -> str:...
        @typing.overload
        def __call__(self, text: str, style: GUIStyle, options: Array_1[GUILayoutOption]) -> str:...
        @typing.overload
        def __call__(self, text: str, maxLength: int, style: GUIStyle, options: Array_1[GUILayoutOption]) -> str:...

    # Skipped Toggle due to it being static, abstract and generic.

    Toggle : Toggle_MethodGroup
    class Toggle_MethodGroup:
        @typing.overload
        def __call__(self, value: bool, image: Texture, options: Array_1[GUILayoutOption]) -> bool:...
        @typing.overload
        def __call__(self, value: bool, text: str, options: Array_1[GUILayoutOption]) -> bool:...
        @typing.overload
        def __call__(self, value: bool, content: GUIContent, options: Array_1[GUILayoutOption]) -> bool:...
        @typing.overload
        def __call__(self, value: bool, image: Texture, style: GUIStyle, options: Array_1[GUILayoutOption]) -> bool:...
        @typing.overload
        def __call__(self, value: bool, text: str, style: GUIStyle, options: Array_1[GUILayoutOption]) -> bool:...
        @typing.overload
        def __call__(self, value: bool, content: GUIContent, style: GUIStyle, options: Array_1[GUILayoutOption]) -> bool:...

    # Skipped Toolbar due to it being static, abstract and generic.

    Toolbar : Toolbar_MethodGroup
    class Toolbar_MethodGroup:
        @typing.overload
        def __call__(self, selected: int, images: Array_1[Texture], options: Array_1[GUILayoutOption]) -> int:...
        @typing.overload
        def __call__(self, selected: int, texts: Array_1[str], options: Array_1[GUILayoutOption]) -> int:...
        @typing.overload
        def __call__(self, selected: int, contents: Array_1[GUIContent], options: Array_1[GUILayoutOption]) -> int:...
        @typing.overload
        def __call__(self, selected: int, images: Array_1[Texture], style: GUIStyle, options: Array_1[GUILayoutOption]) -> int:...
        @typing.overload
        def __call__(self, selected: int, texts: Array_1[str], style: GUIStyle, options: Array_1[GUILayoutOption]) -> int:...
        @typing.overload
        def __call__(self, selected: int, contents: Array_1[GUIContent], style: GUIStyle, options: Array_1[GUILayoutOption]) -> int:...
        @typing.overload
        def __call__(self, selected: int, images: Array_1[Texture], style: GUIStyle, buttonSize: GUI.ToolbarButtonSize, options: Array_1[GUILayoutOption]) -> int:...
        @typing.overload
        def __call__(self, selected: int, texts: Array_1[str], style: GUIStyle, buttonSize: GUI.ToolbarButtonSize, options: Array_1[GUILayoutOption]) -> int:...
        @typing.overload
        def __call__(self, selected: int, contents: Array_1[GUIContent], enabled: Array_1[bool], style: GUIStyle, options: Array_1[GUILayoutOption]) -> int:...
        @typing.overload
        def __call__(self, selected: int, contents: Array_1[GUIContent], style: GUIStyle, buttonSize: GUI.ToolbarButtonSize, options: Array_1[GUILayoutOption]) -> int:...
        @typing.overload
        def __call__(self, selected: int, contents: Array_1[GUIContent], enabled: Array_1[bool], style: GUIStyle, buttonSize: GUI.ToolbarButtonSize, options: Array_1[GUILayoutOption]) -> int:...

    # Skipped VerticalScrollbar due to it being static, abstract and generic.

    VerticalScrollbar : VerticalScrollbar_MethodGroup
    class VerticalScrollbar_MethodGroup:
        @typing.overload
        def __call__(self, value: float, size: float, topValue: float, bottomValue: float, options: Array_1[GUILayoutOption]) -> float:...
        @typing.overload
        def __call__(self, value: float, size: float, topValue: float, bottomValue: float, style: GUIStyle, options: Array_1[GUILayoutOption]) -> float:...

    # Skipped VerticalSlider due to it being static, abstract and generic.

    VerticalSlider : VerticalSlider_MethodGroup
    class VerticalSlider_MethodGroup:
        @typing.overload
        def __call__(self, value: float, leftValue: float, rightValue: float, options: Array_1[GUILayoutOption]) -> float:...
        @typing.overload
        def __call__(self, value: float, leftValue: float, rightValue: float, slider: GUIStyle, thumb: GUIStyle, options: Array_1[GUILayoutOption]) -> float:...

    # Skipped Window due to it being static, abstract and generic.

    Window : Window_MethodGroup
    class Window_MethodGroup:
        @typing.overload
        def __call__(self, id: int, screenRect: Rect, func: GUI.WindowFunction, image: Texture, options: Array_1[GUILayoutOption]) -> Rect:...
        @typing.overload
        def __call__(self, id: int, screenRect: Rect, func: GUI.WindowFunction, text: str, options: Array_1[GUILayoutOption]) -> Rect:...
        @typing.overload
        def __call__(self, id: int, screenRect: Rect, func: GUI.WindowFunction, content: GUIContent, options: Array_1[GUILayoutOption]) -> Rect:...
        @typing.overload
        def __call__(self, id: int, screenRect: Rect, func: GUI.WindowFunction, image: Texture, style: GUIStyle, options: Array_1[GUILayoutOption]) -> Rect:...
        @typing.overload
        def __call__(self, id: int, screenRect: Rect, func: GUI.WindowFunction, text: str, style: GUIStyle, options: Array_1[GUILayoutOption]) -> Rect:...
        @typing.overload
        def __call__(self, id: int, screenRect: Rect, func: GUI.WindowFunction, content: GUIContent, style: GUIStyle, options: Array_1[GUILayoutOption]) -> Rect:...


    class AreaScope(GUI.Scope):
        @typing.overload
        def __init__(self, screenRect: Rect) -> None: ...
        @typing.overload
        def __init__(self, screenRect: Rect, content: GUIContent) -> None: ...
        @typing.overload
        def __init__(self, screenRect: Rect, content: GUIContent, style: GUIStyle) -> None: ...
        @typing.overload
        def __init__(self, screenRect: Rect, image: Texture) -> None: ...
        @typing.overload
        def __init__(self, screenRect: Rect, image: Texture, style: GUIStyle) -> None: ...
        @typing.overload
        def __init__(self, screenRect: Rect, text: str) -> None: ...
        @typing.overload
        def __init__(self, screenRect: Rect, text: str, style: GUIStyle) -> None: ...


    class HorizontalScope(GUI.Scope):
        @typing.overload
        def __init__(self, content: GUIContent, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None: ...
        @typing.overload
        def __init__(self, image: Texture, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None: ...
        @typing.overload
        def __init__(self, options: Array_1[GUILayoutOption]) -> None: ...
        @typing.overload
        def __init__(self, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None: ...
        @typing.overload
        def __init__(self, text: str, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None: ...


    class ScrollViewScope(GUI.Scope):
        @typing.overload
        def __init__(self, scrollPosition: Vector2, alwaysShowHorizontal: bool, alwaysShowVertical: bool, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, background: GUIStyle, options: Array_1[GUILayoutOption]) -> None: ...
        @typing.overload
        def __init__(self, scrollPosition: Vector2, alwaysShowHorizontal: bool, alwaysShowVertical: bool, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, options: Array_1[GUILayoutOption]) -> None: ...
        @typing.overload
        def __init__(self, scrollPosition: Vector2, alwaysShowHorizontal: bool, alwaysShowVertical: bool, options: Array_1[GUILayoutOption]) -> None: ...
        @typing.overload
        def __init__(self, scrollPosition: Vector2, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, options: Array_1[GUILayoutOption]) -> None: ...
        @typing.overload
        def __init__(self, scrollPosition: Vector2, options: Array_1[GUILayoutOption]) -> None: ...
        @typing.overload
        def __init__(self, scrollPosition: Vector2, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None: ...
        @property
        def handleScrollWheel(self) -> bool: ...
        @handleScrollWheel.setter
        def handleScrollWheel(self, value: bool) -> bool: ...
        @property
        def scrollPosition(self) -> Vector2: ...
        @scrollPosition.setter
        def scrollPosition(self, value: Vector2) -> Vector2: ...


    class VerticalScope(GUI.Scope):
        @typing.overload
        def __init__(self, content: GUIContent, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None: ...
        @typing.overload
        def __init__(self, image: Texture, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None: ...
        @typing.overload
        def __init__(self, options: Array_1[GUILayoutOption]) -> None: ...
        @typing.overload
        def __init__(self, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None: ...
        @typing.overload
        def __init__(self, text: str, style: GUIStyle, options: Array_1[GUILayoutOption]) -> None: ...



class GUILayoutOption:
    pass


class GUILayoutUtility:
    def __init__(self) -> None: ...
    @staticmethod
    def BeginGroup(GroupName: str) -> None: ...
    @staticmethod
    def EndGroup(groupName: str) -> None: ...
    @staticmethod
    def GetLastRect() -> Rect: ...
    # Skipped GetAspectRect due to it being static, abstract and generic.

    GetAspectRect : GetAspectRect_MethodGroup
    class GetAspectRect_MethodGroup:
        @typing.overload
        def __call__(self, aspect: float) -> Rect:...
        @typing.overload
        def __call__(self, aspect: float, options: Array_1[GUILayoutOption]) -> Rect:...
        @typing.overload
        def __call__(self, aspect: float, style: GUIStyle) -> Rect:...
        @typing.overload
        def __call__(self, aspect: float, style: GUIStyle, options: Array_1[GUILayoutOption]) -> Rect:...

    # Skipped GetRect due to it being static, abstract and generic.

    GetRect : GetRect_MethodGroup
    class GetRect_MethodGroup:
        @typing.overload
        def __call__(self, width: float, height: float) -> Rect:...
        @typing.overload
        def __call__(self, content: GUIContent, style: GUIStyle) -> Rect:...
        @typing.overload
        def __call__(self, width: float, height: float, options: Array_1[GUILayoutOption]) -> Rect:...
        @typing.overload
        def __call__(self, width: float, height: float, style: GUIStyle) -> Rect:...
        @typing.overload
        def __call__(self, content: GUIContent, style: GUIStyle, options: Array_1[GUILayoutOption]) -> Rect:...
        @typing.overload
        def __call__(self, minWidth: float, maxWidth: float, minHeight: float, maxHeight: float) -> Rect:...
        @typing.overload
        def __call__(self, width: float, height: float, style: GUIStyle, options: Array_1[GUILayoutOption]) -> Rect:...
        @typing.overload
        def __call__(self, minWidth: float, maxWidth: float, minHeight: float, maxHeight: float, options: Array_1[GUILayoutOption]) -> Rect:...
        @typing.overload
        def __call__(self, minWidth: float, maxWidth: float, minHeight: float, maxHeight: float, style: GUIStyle) -> Rect:...
        @typing.overload
        def __call__(self, minWidth: float, maxWidth: float, minHeight: float, maxHeight: float, style: GUIStyle, options: Array_1[GUILayoutOption]) -> Rect:...



class GUISettings:
    def __init__(self) -> None: ...
    @property
    def cursorColor(self) -> Color: ...
    @cursorColor.setter
    def cursorColor(self, value: Color) -> Color: ...
    @property
    def cursorFlashSpeed(self) -> float: ...
    @cursorFlashSpeed.setter
    def cursorFlashSpeed(self, value: float) -> float: ...
    @property
    def doubleClickSelectsWord(self) -> bool: ...
    @doubleClickSelectsWord.setter
    def doubleClickSelectsWord(self, value: bool) -> bool: ...
    @property
    def selectionColor(self) -> Color: ...
    @selectionColor.setter
    def selectionColor(self, value: Color) -> Color: ...
    @property
    def tripleClickSelectsLine(self) -> bool: ...
    @tripleClickSelectsLine.setter
    def tripleClickSelectsLine(self, value: bool) -> bool: ...


class GUISkin(ScriptableObject):
    def __init__(self) -> None: ...
    @property
    def box(self) -> GUIStyle: ...
    @box.setter
    def box(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def button(self) -> GUIStyle: ...
    @button.setter
    def button(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def customStyles(self) -> Array_1[GUIStyle]: ...
    @customStyles.setter
    def customStyles(self, value: Array_1[GUIStyle]) -> Array_1[GUIStyle]: ...
    @property
    def font(self) -> Font: ...
    @font.setter
    def font(self, value: Font) -> Font: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def horizontalScrollbar(self) -> GUIStyle: ...
    @horizontalScrollbar.setter
    def horizontalScrollbar(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def horizontalScrollbarLeftButton(self) -> GUIStyle: ...
    @horizontalScrollbarLeftButton.setter
    def horizontalScrollbarLeftButton(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def horizontalScrollbarRightButton(self) -> GUIStyle: ...
    @horizontalScrollbarRightButton.setter
    def horizontalScrollbarRightButton(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def horizontalScrollbarThumb(self) -> GUIStyle: ...
    @horizontalScrollbarThumb.setter
    def horizontalScrollbarThumb(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def horizontalSlider(self) -> GUIStyle: ...
    @horizontalSlider.setter
    def horizontalSlider(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def horizontalSliderThumb(self) -> GUIStyle: ...
    @horizontalSliderThumb.setter
    def horizontalSliderThumb(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def label(self) -> GUIStyle: ...
    @label.setter
    def label(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def scrollView(self) -> GUIStyle: ...
    @scrollView.setter
    def scrollView(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def settings(self) -> GUISettings: ...
    @property
    def textArea(self) -> GUIStyle: ...
    @textArea.setter
    def textArea(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def textField(self) -> GUIStyle: ...
    @textField.setter
    def textField(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def toggle(self) -> GUIStyle: ...
    @toggle.setter
    def toggle(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def verticalScrollbar(self) -> GUIStyle: ...
    @verticalScrollbar.setter
    def verticalScrollbar(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def verticalScrollbarDownButton(self) -> GUIStyle: ...
    @verticalScrollbarDownButton.setter
    def verticalScrollbarDownButton(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def verticalScrollbarThumb(self) -> GUIStyle: ...
    @verticalScrollbarThumb.setter
    def verticalScrollbarThumb(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def verticalScrollbarUpButton(self) -> GUIStyle: ...
    @verticalScrollbarUpButton.setter
    def verticalScrollbarUpButton(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def verticalSlider(self) -> GUIStyle: ...
    @verticalSlider.setter
    def verticalSlider(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def verticalSliderThumb(self) -> GUIStyle: ...
    @verticalSliderThumb.setter
    def verticalSliderThumb(self, value: GUIStyle) -> GUIStyle: ...
    @property
    def window(self) -> GUIStyle: ...
    @window.setter
    def window(self, value: GUIStyle) -> GUIStyle: ...
    def FindStyle(self, styleName: str) -> GUIStyle: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def GetStyle(self, styleName: str) -> GUIStyle: ...


class GUIStyle:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, other: GUIStyle) -> None: ...
    @property
    def active(self) -> GUIStyleState: ...
    @active.setter
    def active(self, value: GUIStyleState) -> GUIStyleState: ...
    @property
    def alignment(self) -> TextAnchor: ...
    @alignment.setter
    def alignment(self, value: TextAnchor) -> TextAnchor: ...
    @property
    def border(self) -> RectOffset: ...
    @border.setter
    def border(self, value: RectOffset) -> RectOffset: ...
    @property
    def clipOffset(self) -> Vector2: ...
    @clipOffset.setter
    def clipOffset(self, value: Vector2) -> Vector2: ...
    @property
    def clipping(self) -> TextClipping: ...
    @clipping.setter
    def clipping(self, value: TextClipping) -> TextClipping: ...
    @property
    def contentOffset(self) -> Vector2: ...
    @contentOffset.setter
    def contentOffset(self, value: Vector2) -> Vector2: ...
    @property
    def fixedHeight(self) -> float: ...
    @fixedHeight.setter
    def fixedHeight(self, value: float) -> float: ...
    @property
    def fixedWidth(self) -> float: ...
    @fixedWidth.setter
    def fixedWidth(self, value: float) -> float: ...
    @property
    def focused(self) -> GUIStyleState: ...
    @focused.setter
    def focused(self, value: GUIStyleState) -> GUIStyleState: ...
    @property
    def font(self) -> Font: ...
    @font.setter
    def font(self, value: Font) -> Font: ...
    @property
    def fontSize(self) -> int: ...
    @fontSize.setter
    def fontSize(self, value: int) -> int: ...
    @property
    def fontStyle(self) -> FontStyle: ...
    @fontStyle.setter
    def fontStyle(self, value: FontStyle) -> FontStyle: ...
    @property
    def hover(self) -> GUIStyleState: ...
    @hover.setter
    def hover(self, value: GUIStyleState) -> GUIStyleState: ...
    @property
    def imagePosition(self) -> ImagePosition: ...
    @imagePosition.setter
    def imagePosition(self, value: ImagePosition) -> ImagePosition: ...
    @property
    def isHeightDependantOnWidth(self) -> bool: ...
    @property
    def lineHeight(self) -> float: ...
    @property
    def margin(self) -> RectOffset: ...
    @margin.setter
    def margin(self, value: RectOffset) -> RectOffset: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @classmethod
    @property
    def none(cls) -> GUIStyle: ...
    @property
    def normal(self) -> GUIStyleState: ...
    @normal.setter
    def normal(self, value: GUIStyleState) -> GUIStyleState: ...
    @property
    def onActive(self) -> GUIStyleState: ...
    @onActive.setter
    def onActive(self, value: GUIStyleState) -> GUIStyleState: ...
    @property
    def onFocused(self) -> GUIStyleState: ...
    @onFocused.setter
    def onFocused(self, value: GUIStyleState) -> GUIStyleState: ...
    @property
    def onHover(self) -> GUIStyleState: ...
    @onHover.setter
    def onHover(self, value: GUIStyleState) -> GUIStyleState: ...
    @property
    def onNormal(self) -> GUIStyleState: ...
    @onNormal.setter
    def onNormal(self, value: GUIStyleState) -> GUIStyleState: ...
    @property
    def overflow(self) -> RectOffset: ...
    @overflow.setter
    def overflow(self, value: RectOffset) -> RectOffset: ...
    @property
    def padding(self) -> RectOffset: ...
    @padding.setter
    def padding(self, value: RectOffset) -> RectOffset: ...
    @property
    def richText(self) -> bool: ...
    @richText.setter
    def richText(self, value: bool) -> bool: ...
    @property
    def stretchHeight(self) -> bool: ...
    @stretchHeight.setter
    def stretchHeight(self, value: bool) -> bool: ...
    @property
    def stretchWidth(self) -> bool: ...
    @stretchWidth.setter
    def stretchWidth(self, value: bool) -> bool: ...
    @property
    def wordWrap(self) -> bool: ...
    @wordWrap.setter
    def wordWrap(self, value: bool) -> bool: ...
    def CalcHeight(self, content: GUIContent, width: float) -> float: ...
    def CalcMinMaxWidth(self, content: GUIContent, minWidth: clr.Reference[float], maxWidth: clr.Reference[float]) -> None: ...
    def CalcScreenSize(self, contentSize: Vector2) -> Vector2: ...
    def CalcSize(self, content: GUIContent) -> Vector2: ...
    def DrawCursor(self, position: Rect, content: GUIContent, controlID: int, character: int) -> None: ...
    def DrawWithTextSelection(self, position: Rect, content: GUIContent, controlID: int, firstSelectedCharacter: int, lastSelectedCharacter: int) -> None: ...
    def GetCursorPixelPosition(self, position: Rect, content: GUIContent, cursorStringIndex: int) -> Vector2: ...
    def GetCursorStringIndex(self, position: Rect, content: GUIContent, cursorPixelPosition: Vector2) -> int: ...
    # Operator not supported op_Implicit(str: String)
    def ToString(self) -> str: ...
    # Skipped Draw due to it being static, abstract and generic.

    Draw : Draw_MethodGroup
    class Draw_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, content: GUIContent, controlID: int) -> None:...
        @typing.overload
        def __call__(self, position: Rect, content: GUIContent, controlID: int, on: bool) -> None:...
        @typing.overload
        def __call__(self, position: Rect, isHover: bool, isActive: bool, on: bool, hasKeyboardFocus: bool) -> None:...
        @typing.overload
        def __call__(self, position: Rect, content: GUIContent, controlID: int, on: bool, hover: bool) -> None:...
        @typing.overload
        def __call__(self, position: Rect, image: Texture, isHover: bool, isActive: bool, on: bool, hasKeyboardFocus: bool) -> None:...
        @typing.overload
        def __call__(self, position: Rect, text: str, isHover: bool, isActive: bool, on: bool, hasKeyboardFocus: bool) -> None:...
        @typing.overload
        def __call__(self, position: Rect, content: GUIContent, isHover: bool, isActive: bool, on: bool, hasKeyboardFocus: bool) -> None:...



class GUIStyleState:
    def __init__(self) -> None: ...
    @property
    def background(self) -> Texture2D: ...
    @background.setter
    def background(self, value: Texture2D) -> Texture2D: ...
    @property
    def scaledBackgrounds(self) -> Array_1[Texture2D]: ...
    @scaledBackgrounds.setter
    def scaledBackgrounds(self, value: Array_1[Texture2D]) -> Array_1[Texture2D]: ...
    @property
    def textColor(self) -> Color: ...
    @textColor.setter
    def textColor(self, value: Color) -> Color: ...


class GUITargetAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, displayIndex: int) -> None: ...
    @typing.overload
    def __init__(self, displayIndex: int, displayIndex1: int) -> None: ...
    @typing.overload
    def __init__(self, displayIndex: int, displayIndex1: int, displayIndexList: Array_1[int]) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class GUIText:
    def __init__(self) -> None: ...
    @property
    def alignment(self) -> TextAlignment: ...
    @alignment.setter
    def alignment(self, value: TextAlignment) -> TextAlignment: ...
    @property
    def anchor(self) -> TextAnchor: ...
    @anchor.setter
    def anchor(self, value: TextAnchor) -> TextAnchor: ...
    @property
    def color(self) -> Color: ...
    @color.setter
    def color(self, value: Color) -> Color: ...
    @property
    def font(self) -> Font: ...
    @font.setter
    def font(self, value: Font) -> Font: ...
    @property
    def fontSize(self) -> int: ...
    @fontSize.setter
    def fontSize(self, value: int) -> int: ...
    @property
    def fontStyle(self) -> FontStyle: ...
    @fontStyle.setter
    def fontStyle(self, value: FontStyle) -> FontStyle: ...
    @property
    def lineSpacing(self) -> float: ...
    @lineSpacing.setter
    def lineSpacing(self, value: float) -> float: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> Material: ...
    @property
    def pixelOffset(self) -> Vector2: ...
    @pixelOffset.setter
    def pixelOffset(self, value: Vector2) -> Vector2: ...
    @property
    def richText(self) -> bool: ...
    @richText.setter
    def richText(self, value: bool) -> bool: ...
    @property
    def tabSize(self) -> float: ...
    @tabSize.setter
    def tabSize(self, value: float) -> float: ...
    @property
    def text(self) -> bool: ...
    @text.setter
    def text(self, value: bool) -> bool: ...


class GUITexture:
    def __init__(self) -> None: ...
    @property
    def border(self) -> RectOffset: ...
    @border.setter
    def border(self, value: RectOffset) -> RectOffset: ...
    @property
    def color(self) -> Color: ...
    @color.setter
    def color(self, value: Color) -> Color: ...
    @property
    def pixelInset(self) -> Rect: ...
    @pixelInset.setter
    def pixelInset(self, value: Rect) -> Rect: ...
    @property
    def texture(self) -> Texture: ...
    @texture.setter
    def texture(self, value: Texture) -> Texture: ...


class GUIUtility:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def hasModalWindow(cls) -> bool: ...
    @classmethod
    @property
    def hotControl(cls) -> int: ...
    @classmethod
    @hotControl.setter
    def hotControl(cls, value: int) -> int: ...
    @classmethod
    @property
    def keyboardControl(cls) -> int: ...
    @classmethod
    @keyboardControl.setter
    def keyboardControl(cls, value: int) -> int: ...
    @classmethod
    @property
    def systemCopyBuffer(cls) -> str: ...
    @classmethod
    @systemCopyBuffer.setter
    def systemCopyBuffer(cls, value: str) -> str: ...
    @staticmethod
    def ExitGUI() -> None: ...
    @staticmethod
    def GetStateObject(t: typing.Type[typing.Any], controlID: int) -> typing.Any: ...
    @staticmethod
    def GUIToScreenPoint(guiPoint: Vector2) -> Vector2: ...
    @staticmethod
    def GUIToScreenRect(guiRect: Rect) -> Rect: ...
    @staticmethod
    def QueryStateObject(t: typing.Type[typing.Any], controlID: int) -> typing.Any: ...
    @staticmethod
    def RotateAroundPivot(angle: float, pivotPoint: Vector2) -> None: ...
    @staticmethod
    def ScaleAroundPivot(scale: Vector2, pivotPoint: Vector2) -> None: ...
    @staticmethod
    def ScreenToGUIPoint(screenPoint: Vector2) -> Vector2: ...
    @staticmethod
    def ScreenToGUIRect(screenRect: Rect) -> Rect: ...
    # Skipped AlignRectToDevice due to it being static, abstract and generic.

    AlignRectToDevice : AlignRectToDevice_MethodGroup
    class AlignRectToDevice_MethodGroup:
        @typing.overload
        def __call__(self, rect: Rect) -> Rect:...
        @typing.overload
        def __call__(self, rect: Rect, widthInPixels: clr.Reference[int], heightInPixels: clr.Reference[int]) -> Rect:...

    # Skipped GetControlID due to it being static, abstract and generic.

    GetControlID : GetControlID_MethodGroup
    class GetControlID_MethodGroup:
        @typing.overload
        def __call__(self, focus: FocusType) -> int:...
        @typing.overload
        def __call__(self, hint: int, focus: FocusType) -> int:...
        @typing.overload
        def __call__(self, focus: FocusType, position: Rect) -> int:...
        @typing.overload
        def __call__(self, contents: GUIContent, focus: FocusType) -> int:...
        @typing.overload
        def __call__(self, hint: int, focusType: FocusType, rect: Rect) -> int:...
        @typing.overload
        def __call__(self, contents: GUIContent, focus: FocusType, position: Rect) -> int:...



class Gyroscope:
    @property
    def attitude(self) -> Quaternion: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gravity(self) -> Vector3: ...
    @property
    def rotationRate(self) -> Vector3: ...
    @property
    def rotationRateUnbiased(self) -> Vector3: ...
    @property
    def updateInterval(self) -> float: ...
    @updateInterval.setter
    def updateInterval(self, value: float) -> float: ...
    @property
    def userAcceleration(self) -> Vector3: ...


class Handheld:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def use32BitDisplayBuffer(cls) -> bool: ...
    @classmethod
    @use32BitDisplayBuffer.setter
    def use32BitDisplayBuffer(cls, value: bool) -> bool: ...
    @staticmethod
    def ClearShaderCache() -> None: ...
    @staticmethod
    def GetActivityIndicatorStyle() -> int: ...
    @staticmethod
    def StartActivityIndicator() -> None: ...
    @staticmethod
    def StopActivityIndicator() -> None: ...
    @staticmethod
    def Vibrate() -> None: ...
    # Skipped PlayFullScreenMovie due to it being static, abstract and generic.

    PlayFullScreenMovie : PlayFullScreenMovie_MethodGroup
    class PlayFullScreenMovie_MethodGroup:
        @typing.overload
        def __call__(self, path: str) -> bool:...
        @typing.overload
        def __call__(self, path: str, bgColor: Color) -> bool:...
        @typing.overload
        def __call__(self, path: str, bgColor: Color, controlMode: FullScreenMovieControlMode) -> bool:...
        @typing.overload
        def __call__(self, path: str, bgColor: Color, controlMode: FullScreenMovieControlMode, scalingMode: FullScreenMovieScalingMode) -> bool:...

    # Skipped SetActivityIndicatorStyle due to it being static, abstract and generic.

    SetActivityIndicatorStyle : SetActivityIndicatorStyle_MethodGroup
    class SetActivityIndicatorStyle_MethodGroup:
        @typing.overload
        def __call__(self, style: ActivityIndicatorStyle) -> None:...
        @typing.overload
        def __call__(self, style: AndroidActivityIndicatorStyle) -> None:...



class Hash128(IEquatable_1[Hash128], IComparable_1[Hash128], IComparable):
    @typing.overload
    def __init__(self, u32_0: int, u32_1: int, u32_2: int, u32_3: int) -> None: ...
    @typing.overload
    def __init__(self, u64_0: int, u64_1: int) -> None: ...
    @property
    def isValid(self) -> bool: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, hash1: Hash128, hash2: Hash128) -> bool: ...
    def __gt__(self, x: Hash128, y: Hash128) -> bool: ...
    def __ne__(self, hash1: Hash128, hash2: Hash128) -> bool: ...
    def __lt__(self, x: Hash128, y: Hash128) -> bool: ...
    @staticmethod
    def Parse(hashString: str) -> Hash128: ...
    def ToString(self) -> str: ...
    # Skipped Append due to it being static, abstract and generic.

    Append : Append_MethodGroup
    class Append_MethodGroup:
        def __getitem__(self, t:typing.Type[Append_1_T1]) -> Append_1[Append_1_T1]: ...

        Append_1_T1 = typing.TypeVar('Append_1_T1')
        class Append_1(typing.Generic[Append_1_T1]):
            Append_1_T = Hash128.Append_MethodGroup.Append_1_T1
            @typing.overload
            def __call__(self, data: Array_1[Append_1_T]) -> None:...
            @typing.overload
            def __call__(self, data: List_1[Append_1_T]) -> None:...
            @typing.overload
            def __call__(self, data: NativeArray_1[Append_1_T]) -> None:...
            @typing.overload
            def __call__(self, val: clr.Reference[Append_1_T]) -> None:...
            @typing.overload
            def __call__(self, data: Array_1[Append_1_T], start: int, count: int) -> None:...
            @typing.overload
            def __call__(self, data: List_1[Append_1_T], start: int, count: int) -> None:...
            @typing.overload
            def __call__(self, data: NativeArray_1[Append_1_T], start: int, count: int) -> None:...

        @typing.overload
        def __call__(self, val: float) -> None:...
        # Method Append(val : Int32) was skipped since it collides with above method
        @typing.overload
        def __call__(self, data: str) -> None:...
        @typing.overload
        def __call__(self, data: clr.Reference[None], size: int) -> None:...

    # Skipped CompareTo due to it being static, abstract and generic.

    CompareTo : CompareTo_MethodGroup
    class CompareTo_MethodGroup:
        @typing.overload
        def __call__(self, rhs: Hash128) -> int:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> int:...

    # Skipped Compute due to it being static, abstract and generic.

    Compute : Compute_MethodGroup
    class Compute_MethodGroup:
        def __getitem__(self, t:typing.Type[Compute_1_T1]) -> Compute_1[Compute_1_T1]: ...

        Compute_1_T1 = typing.TypeVar('Compute_1_T1')
        class Compute_1(typing.Generic[Compute_1_T1]):
            Compute_1_T = Hash128.Compute_MethodGroup.Compute_1_T1
            @typing.overload
            def __call__(self, data: Array_1[Compute_1_T]) -> Hash128:...
            @typing.overload
            def __call__(self, data: List_1[Compute_1_T]) -> Hash128:...
            @typing.overload
            def __call__(self, data: NativeArray_1[Compute_1_T]) -> Hash128:...
            @typing.overload
            def __call__(self, val: clr.Reference[Compute_1_T]) -> Hash128:...
            @typing.overload
            def __call__(self, data: Array_1[Compute_1_T], start: int, count: int) -> Hash128:...
            @typing.overload
            def __call__(self, data: List_1[Compute_1_T], start: int, count: int) -> Hash128:...
            @typing.overload
            def __call__(self, data: NativeArray_1[Compute_1_T], start: int, count: int) -> Hash128:...

        @typing.overload
        def __call__(self, val: float) -> Hash128:...
        # Method Compute(val : Int32) was skipped since it collides with above method
        @typing.overload
        def __call__(self, data: str) -> Hash128:...
        @typing.overload
        def __call__(self, data: clr.Reference[None], size: int) -> Hash128:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, obj: Hash128) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class HashUnsafeUtilities(abc.ABC):
    # Skipped ComputeHash128 due to it being static, abstract and generic.

    ComputeHash128 : ComputeHash128_MethodGroup
    class ComputeHash128_MethodGroup:
        @typing.overload
        def __call__(self, data: clr.Reference[None], dataSize: int, hash: clr.Reference[Hash128]) -> None:...
        @typing.overload
        def __call__(self, data: clr.Reference[None], dataSize: int, hash1: clr.Reference[int], hash2: clr.Reference[int]) -> None:...



class HashUtilities(abc.ABC):
    @staticmethod
    def AppendHash(inHash: clr.Reference[Hash128], outHash: clr.Reference[Hash128]) -> None: ...
    @staticmethod
    def QuantisedMatrixHash(value: clr.Reference[Matrix4x4], hash: clr.Reference[Hash128]) -> None: ...
    @staticmethod
    def QuantisedVectorHash(value: clr.Reference[Vector3], hash: clr.Reference[Hash128]) -> None: ...
    # Skipped ComputeHash128 due to it being static, abstract and generic.

    ComputeHash128 : ComputeHash128_MethodGroup
    class ComputeHash128_MethodGroup:
        def __getitem__(self, t:typing.Type[ComputeHash128_1_T1]) -> ComputeHash128_1[ComputeHash128_1_T1]: ...

        ComputeHash128_1_T1 = typing.TypeVar('ComputeHash128_1_T1')
        class ComputeHash128_1(typing.Generic[ComputeHash128_1_T1]):
            ComputeHash128_1_T = HashUtilities.ComputeHash128_MethodGroup.ComputeHash128_1_T1
            def __call__(self, value: clr.Reference[ComputeHash128_1_T], hash: clr.Reference[Hash128]) -> None:...

        def __call__(self, value: Array_1[int], hash: clr.Reference[Hash128]) -> None:...



class HDRDisplayBitDepth(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    BitDepth10 : HDRDisplayBitDepth # 0
    BitDepth16 : HDRDisplayBitDepth # 1


class HDRDisplaySupportFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : HDRDisplaySupportFlags # 0
    Supported : HDRDisplaySupportFlags # 1
    RuntimeSwitchable : HDRDisplaySupportFlags # 2
    AutomaticTonemapping : HDRDisplaySupportFlags # 4


class HDROutputSettings:
    displays : Array_1[HDROutputSettings]
    @property
    def active(self) -> bool: ...
    @property
    def automaticHDRTonemapping(self) -> bool: ...
    @automaticHDRTonemapping.setter
    def automaticHDRTonemapping(self, value: bool) -> bool: ...
    @property
    def available(self) -> bool: ...
    @property
    def displayColorGamut(self) -> ColorGamut: ...
    @property
    def format(self) -> RenderTextureFormat: ...
    @property
    def graphicsFormat(self) -> GraphicsFormat: ...
    @property
    def HDRModeChangeRequested(self) -> bool: ...
    @classmethod
    @property
    def main(cls) -> HDROutputSettings: ...
    @property
    def maxFullFrameToneMapLuminance(self) -> int: ...
    @property
    def maxToneMapLuminance(self) -> int: ...
    @property
    def minToneMapLuminance(self) -> int: ...
    @property
    def paperWhiteNits(self) -> float: ...
    @paperWhiteNits.setter
    def paperWhiteNits(self, value: float) -> float: ...
    def RequestHDRModeChange(self, enabled: bool) -> None: ...
    @staticmethod
    def SetPaperWhiteInNits(paperWhite: float) -> None: ...


class HeadDof(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    NeckFrontBack : HeadDof # 0
    NeckLeftRight : HeadDof # 1
    NeckRollLeftRight : HeadDof # 2
    HeadFrontBack : HeadDof # 3
    HeadLeftRight : HeadDof # 4
    HeadRollLeftRight : HeadDof # 5
    LeftEyeDownUp : HeadDof # 6
    LeftEyeInOut : HeadDof # 7
    RightEyeDownUp : HeadDof # 8
    RightEyeInOut : HeadDof # 9
    JawDownUp : HeadDof # 10
    JawLeftRight : HeadDof # 11
    LastHeadDof : HeadDof # 12


class HeaderAttribute(PropertyAttribute):
    def __init__(self, header: str) -> None: ...
    header : str
    @property
    def order(self) -> int: ...
    @order.setter
    def order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class HelpURLAttribute(Attribute):
    def __init__(self, url: str) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def URL(self) -> str: ...


class HideFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : HideFlags # 0
    HideInHierarchy : HideFlags # 1
    HideInInspector : HideFlags # 2
    DontSaveInEditor : HideFlags # 4
    NotEditable : HideFlags # 8
    DontSaveInBuild : HideFlags # 16
    DontUnloadUnusedAsset : HideFlags # 32
    DontSave : HideFlags # 52
    HideAndDontSave : HideFlags # 61


class HideInCallstackAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class HideInInspector(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class HingeJoint(Joint):
    def __init__(self) -> None: ...
    @property
    def anchor(self) -> Vector3: ...
    @anchor.setter
    def anchor(self, value: Vector3) -> Vector3: ...
    @property
    def angle(self) -> float: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoConfigureConnectedAnchor(self) -> bool: ...
    @autoConfigureConnectedAnchor.setter
    def autoConfigureConnectedAnchor(self, value: bool) -> bool: ...
    @property
    def axis(self) -> Vector3: ...
    @axis.setter
    def axis(self, value: Vector3) -> Vector3: ...
    @property
    def breakForce(self) -> float: ...
    @breakForce.setter
    def breakForce(self, value: float) -> float: ...
    @property
    def breakTorque(self) -> float: ...
    @breakTorque.setter
    def breakTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def connectedAnchor(self) -> Vector3: ...
    @connectedAnchor.setter
    def connectedAnchor(self, value: Vector3) -> Vector3: ...
    @property
    def connectedArticulationBody(self) -> ArticulationBody: ...
    @connectedArticulationBody.setter
    def connectedArticulationBody(self, value: ArticulationBody) -> ArticulationBody: ...
    @property
    def connectedBody(self) -> Rigidbody: ...
    @connectedBody.setter
    def connectedBody(self, value: Rigidbody) -> Rigidbody: ...
    @property
    def connectedMassScale(self) -> float: ...
    @connectedMassScale.setter
    def connectedMassScale(self, value: float) -> float: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def currentForce(self) -> Vector3: ...
    @property
    def currentTorque(self) -> Vector3: ...
    @property
    def enableCollision(self) -> bool: ...
    @enableCollision.setter
    def enableCollision(self, value: bool) -> bool: ...
    @property
    def enablePreprocessing(self) -> bool: ...
    @enablePreprocessing.setter
    def enablePreprocessing(self, value: bool) -> bool: ...
    @property
    def extendedLimits(self) -> bool: ...
    @extendedLimits.setter
    def extendedLimits(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def light(self) -> Component: ...
    @property
    def limits(self) -> JointLimits: ...
    @limits.setter
    def limits(self, value: JointLimits) -> JointLimits: ...
    @property
    def massScale(self) -> float: ...
    @massScale.setter
    def massScale(self, value: float) -> float: ...
    @property
    def motor(self) -> JointMotor: ...
    @motor.setter
    def motor(self, value: JointMotor) -> JointMotor: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def spring(self) -> JointSpring: ...
    @spring.setter
    def spring(self, value: JointSpring) -> JointSpring: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useAcceleration(self) -> bool: ...
    @useAcceleration.setter
    def useAcceleration(self, value: bool) -> bool: ...
    @property
    def useLimits(self) -> bool: ...
    @useLimits.setter
    def useLimits(self, value: bool) -> bool: ...
    @property
    def useMotor(self) -> bool: ...
    @useMotor.setter
    def useMotor(self, value: bool) -> bool: ...
    @property
    def useSpring(self) -> bool: ...
    @useSpring.setter
    def useSpring(self, value: bool) -> bool: ...
    @property
    def velocity(self) -> float: ...


class HingeJoint2D(AnchoredJoint2D):
    def __init__(self) -> None: ...
    @property
    def anchor(self) -> Vector2: ...
    @anchor.setter
    def anchor(self, value: Vector2) -> Vector2: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoConfigureConnectedAnchor(self) -> bool: ...
    @autoConfigureConnectedAnchor.setter
    def autoConfigureConnectedAnchor(self, value: bool) -> bool: ...
    @property
    def breakAction(self) -> JointBreakAction2D: ...
    @breakAction.setter
    def breakAction(self, value: JointBreakAction2D) -> JointBreakAction2D: ...
    @property
    def breakForce(self) -> float: ...
    @breakForce.setter
    def breakForce(self, value: float) -> float: ...
    @property
    def breakTorque(self) -> float: ...
    @breakTorque.setter
    def breakTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collideConnected(self) -> bool: ...
    @collideConnected.setter
    def collideConnected(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def connectedAnchor(self) -> Vector2: ...
    @connectedAnchor.setter
    def connectedAnchor(self, value: Vector2) -> Vector2: ...
    @property
    def connectedBody(self) -> Rigidbody2D: ...
    @connectedBody.setter
    def connectedBody(self, value: Rigidbody2D) -> Rigidbody2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enableCollision(self) -> bool: ...
    @enableCollision.setter
    def enableCollision(self, value: bool) -> bool: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def jointAngle(self) -> float: ...
    @property
    def jointSpeed(self) -> float: ...
    @property
    def light(self) -> Component: ...
    @property
    def limits(self) -> JointAngleLimits2D: ...
    @limits.setter
    def limits(self, value: JointAngleLimits2D) -> JointAngleLimits2D: ...
    @property
    def limitState(self) -> JointLimitState2D: ...
    @property
    def motor(self) -> JointMotor2D: ...
    @motor.setter
    def motor(self, value: JointMotor2D) -> JointMotor2D: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def reactionForce(self) -> Vector2: ...
    @property
    def reactionTorque(self) -> float: ...
    @property
    def referenceAngle(self) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useLimits(self) -> bool: ...
    @useLimits.setter
    def useLimits(self, value: bool) -> bool: ...
    @property
    def useMotor(self) -> bool: ...
    @useMotor.setter
    def useMotor(self, value: bool) -> bool: ...
    def GetMotorTorque(self, timeStep: float) -> float: ...


class HorizontalWrapMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Wrap : HorizontalWrapMode # 0
    Overflow : HorizontalWrapMode # 1


class HostData:
    def __init__(self) -> None: ...
    @property
    def comment(self) -> str: ...
    @comment.setter
    def comment(self, value: str) -> str: ...
    @property
    def connectedPlayers(self) -> int: ...
    @connectedPlayers.setter
    def connectedPlayers(self, value: int) -> int: ...
    @property
    def gameName(self) -> str: ...
    @gameName.setter
    def gameName(self, value: str) -> str: ...
    @property
    def gameType(self) -> str: ...
    @gameType.setter
    def gameType(self, value: str) -> str: ...
    @property
    def guid(self) -> str: ...
    @guid.setter
    def guid(self, value: str) -> str: ...
    @property
    def ip(self) -> Array_1[str]: ...
    @ip.setter
    def ip(self, value: Array_1[str]) -> Array_1[str]: ...
    @property
    def passwordProtected(self) -> bool: ...
    @passwordProtected.setter
    def passwordProtected(self, value: bool) -> bool: ...
    @property
    def playerLimit(self) -> int: ...
    @playerLimit.setter
    def playerLimit(self, value: int) -> int: ...
    @property
    def port(self) -> int: ...
    @port.setter
    def port(self, value: int) -> int: ...
    @property
    def useNat(self) -> bool: ...
    @useNat.setter
    def useNat(self, value: bool) -> bool: ...


class HumanBodyBones(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Hips : HumanBodyBones # 0
    LeftUpperLeg : HumanBodyBones # 1
    RightUpperLeg : HumanBodyBones # 2
    LeftLowerLeg : HumanBodyBones # 3
    RightLowerLeg : HumanBodyBones # 4
    LeftFoot : HumanBodyBones # 5
    RightFoot : HumanBodyBones # 6
    Spine : HumanBodyBones # 7
    Chest : HumanBodyBones # 8
    Neck : HumanBodyBones # 9
    Head : HumanBodyBones # 10
    LeftShoulder : HumanBodyBones # 11
    RightShoulder : HumanBodyBones # 12
    LeftUpperArm : HumanBodyBones # 13
    RightUpperArm : HumanBodyBones # 14
    LeftLowerArm : HumanBodyBones # 15
    RightLowerArm : HumanBodyBones # 16
    LeftHand : HumanBodyBones # 17
    RightHand : HumanBodyBones # 18
    LeftToes : HumanBodyBones # 19
    RightToes : HumanBodyBones # 20
    LeftEye : HumanBodyBones # 21
    RightEye : HumanBodyBones # 22
    Jaw : HumanBodyBones # 23
    LeftThumbProximal : HumanBodyBones # 24
    LeftThumbIntermediate : HumanBodyBones # 25
    LeftThumbDistal : HumanBodyBones # 26
    LeftIndexProximal : HumanBodyBones # 27
    LeftIndexIntermediate : HumanBodyBones # 28
    LeftIndexDistal : HumanBodyBones # 29
    LeftMiddleProximal : HumanBodyBones # 30
    LeftMiddleIntermediate : HumanBodyBones # 31
    LeftMiddleDistal : HumanBodyBones # 32
    LeftRingProximal : HumanBodyBones # 33
    LeftRingIntermediate : HumanBodyBones # 34
    LeftRingDistal : HumanBodyBones # 35
    LeftLittleProximal : HumanBodyBones # 36
    LeftLittleIntermediate : HumanBodyBones # 37
    LeftLittleDistal : HumanBodyBones # 38
    RightThumbProximal : HumanBodyBones # 39
    RightThumbIntermediate : HumanBodyBones # 40
    RightThumbDistal : HumanBodyBones # 41
    RightIndexProximal : HumanBodyBones # 42
    RightIndexIntermediate : HumanBodyBones # 43
    RightIndexDistal : HumanBodyBones # 44
    RightMiddleProximal : HumanBodyBones # 45
    RightMiddleIntermediate : HumanBodyBones # 46
    RightMiddleDistal : HumanBodyBones # 47
    RightRingProximal : HumanBodyBones # 48
    RightRingIntermediate : HumanBodyBones # 49
    RightRingDistal : HumanBodyBones # 50
    RightLittleProximal : HumanBodyBones # 51
    RightLittleIntermediate : HumanBodyBones # 52
    RightLittleDistal : HumanBodyBones # 53
    UpperChest : HumanBodyBones # 54
    LastBone : HumanBodyBones # 55


class HumanBone:
    limit : HumanLimit
    @property
    def boneName(self) -> str: ...
    @boneName.setter
    def boneName(self, value: str) -> str: ...
    @property
    def humanName(self) -> str: ...
    @humanName.setter
    def humanName(self, value: str) -> str: ...


class HumanDescription:
    human : Array_1[HumanBone]
    skeleton : Array_1[SkeletonBone]
    @property
    def armStretch(self) -> float: ...
    @armStretch.setter
    def armStretch(self, value: float) -> float: ...
    @property
    def feetSpacing(self) -> float: ...
    @feetSpacing.setter
    def feetSpacing(self, value: float) -> float: ...
    @property
    def hasTranslationDoF(self) -> bool: ...
    @hasTranslationDoF.setter
    def hasTranslationDoF(self, value: bool) -> bool: ...
    @property
    def legStretch(self) -> float: ...
    @legStretch.setter
    def legStretch(self, value: float) -> float: ...
    @property
    def lowerArmTwist(self) -> float: ...
    @lowerArmTwist.setter
    def lowerArmTwist(self, value: float) -> float: ...
    @property
    def lowerLegTwist(self) -> float: ...
    @lowerLegTwist.setter
    def lowerLegTwist(self, value: float) -> float: ...
    @property
    def upperArmTwist(self) -> float: ...
    @upperArmTwist.setter
    def upperArmTwist(self, value: float) -> float: ...
    @property
    def upperLegTwist(self) -> float: ...
    @upperLegTwist.setter
    def upperLegTwist(self, value: float) -> float: ...


class HumanLimit:
    @property
    def axisLength(self) -> float: ...
    @axisLength.setter
    def axisLength(self, value: float) -> float: ...
    @property
    def center(self) -> Vector3: ...
    @center.setter
    def center(self, value: Vector3) -> Vector3: ...
    @property
    def max(self) -> Vector3: ...
    @max.setter
    def max(self, value: Vector3) -> Vector3: ...
    @property
    def min(self) -> Vector3: ...
    @min.setter
    def min(self, value: Vector3) -> Vector3: ...
    @property
    def useDefaultValues(self) -> bool: ...
    @useDefaultValues.setter
    def useDefaultValues(self, value: bool) -> bool: ...


class HumanPartDof(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Body : HumanPartDof # 0
    Head : HumanPartDof # 1
    LeftLeg : HumanPartDof # 2
    RightLeg : HumanPartDof # 3
    LeftArm : HumanPartDof # 4
    RightArm : HumanPartDof # 5
    LeftThumb : HumanPartDof # 6
    LeftIndex : HumanPartDof # 7
    LeftMiddle : HumanPartDof # 8
    LeftRing : HumanPartDof # 9
    LeftLittle : HumanPartDof # 10
    RightThumb : HumanPartDof # 11
    RightIndex : HumanPartDof # 12
    RightMiddle : HumanPartDof # 13
    RightRing : HumanPartDof # 14
    RightLittle : HumanPartDof # 15
    LastHumanPartDof : HumanPartDof # 16


class HumanPose:
    bodyPosition : Vector3
    bodyRotation : Quaternion
    muscles : Array_1[float]


class HumanPoseHandler(IDisposable):
    @typing.overload
    def __init__(self, avatar: Avatar, jointPaths: Array_1[str]) -> None: ...
    @typing.overload
    def __init__(self, avatar: Avatar, root: Transform) -> None: ...
    def Dispose(self) -> None: ...
    def GetHumanPose(self, humanPose: clr.Reference[HumanPose]) -> None: ...
    def GetInternalAvatarPose(self, avatarPose: NativeArray_1[float]) -> None: ...
    def GetInternalHumanPose(self, humanPose: clr.Reference[HumanPose]) -> None: ...
    def SetHumanPose(self, humanPose: clr.Reference[HumanPose]) -> None: ...
    def SetInternalAvatarPose(self, avatarPose: NativeArray_1[float]) -> None: ...
    def SetInternalHumanPose(self, humanPose: clr.Reference[HumanPose]) -> None: ...


class HumanTrait:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def BoneCount(cls) -> int: ...
    @classmethod
    @property
    def BoneName(cls) -> Array_1[str]: ...
    @classmethod
    @property
    def MuscleCount(cls) -> int: ...
    @classmethod
    @property
    def MuscleName(cls) -> Array_1[str]: ...
    @classmethod
    @property
    def RequiredBoneCount(cls) -> int: ...
    @staticmethod
    def BoneFromMuscle(i: int) -> int: ...
    @staticmethod
    def GetBoneDefaultHierarchyMass(i: int) -> float: ...
    @staticmethod
    def GetMuscleDefaultMax(i: int) -> float: ...
    @staticmethod
    def GetMuscleDefaultMin(i: int) -> float: ...
    @staticmethod
    def GetParentBone(i: int) -> int: ...
    @staticmethod
    def MuscleFromBone(i: int, dofIndex: int) -> int: ...
    @staticmethod
    def RequiredBone(i: int) -> bool: ...


class IAnimationClipSource(typing.Protocol):
    @abc.abstractmethod
    def GetAnimationClips(self, results: List_1[AnimationClip]) -> None: ...


class ICanvasRaycastFilter(typing.Protocol):
    @abc.abstractmethod
    def IsRaycastLocationValid(self, sp: Vector2, eventCamera: Camera) -> bool: ...


class IconAttribute(Attribute):
    def __init__(self, path: str) -> None: ...
    @property
    def path(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...


class IExposedPropertyTable(typing.Protocol):
    @abc.abstractmethod
    def ClearReferenceValue(self, id: PropertyName) -> None: ...
    @abc.abstractmethod
    def GetReferenceValue(self, id: PropertyName, idValid: clr.Reference[bool]) -> Object: ...
    @abc.abstractmethod
    def SetReferenceValue(self, id: PropertyName, value: Object) -> None: ...


class ILogger(ILogHandler, typing.Protocol):
    @property
    def filterLogType(self) -> LogType: ...
    @filterLogType.setter
    def filterLogType(self, value: LogType) -> LogType: ...
    @property
    def logEnabled(self) -> bool: ...
    @logEnabled.setter
    def logEnabled(self, value: bool) -> bool: ...
    @property
    def logHandler(self) -> ILogHandler: ...
    @logHandler.setter
    def logHandler(self, value: ILogHandler) -> ILogHandler: ...
    @abc.abstractmethod
    def IsLogTypeAllowed(self, logType: LogType) -> bool: ...
    @abc.abstractmethod
    def LogException(self, exception: Exception) -> None: ...
    @abc.abstractmethod
    def LogFormat(self, logType: LogType, format: str, args: Array_1[typing.Any]) -> None: ...
    # Skipped Log due to it being static, abstract and generic.

    Log : Log_MethodGroup
    class Log_MethodGroup:
        @typing.overload
        def __call__(self, message: typing.Any) -> None:...
        @typing.overload
        def __call__(self, logType: LogType, message: typing.Any) -> None:...
        @typing.overload
        def __call__(self, tag: str, message: typing.Any) -> None:...
        @typing.overload
        def __call__(self, logType: LogType, tag: str, message: typing.Any) -> None:...
        @typing.overload
        def __call__(self, logType: LogType, message: typing.Any, context: Object) -> None:...
        @typing.overload
        def __call__(self, tag: str, message: typing.Any, context: Object) -> None:...
        @typing.overload
        def __call__(self, logType: LogType, tag: str, message: typing.Any, context: Object) -> None:...

    # Skipped LogError due to it being static, abstract and generic.

    LogError : LogError_MethodGroup
    class LogError_MethodGroup:
        @typing.overload
        def __call__(self, tag: str, message: typing.Any) -> None:...
        @typing.overload
        def __call__(self, tag: str, message: typing.Any, context: Object) -> None:...

    # Skipped LogWarning due to it being static, abstract and generic.

    LogWarning : LogWarning_MethodGroup
    class LogWarning_MethodGroup:
        @typing.overload
        def __call__(self, tag: str, message: typing.Any) -> None:...
        @typing.overload
        def __call__(self, tag: str, message: typing.Any, context: Object) -> None:...



class ILogHandler(typing.Protocol):
    @abc.abstractmethod
    def LogException(self, exception: Exception, context: Object) -> None: ...
    @abc.abstractmethod
    def LogFormat(self, logType: LogType, context: Object, format: str, args: Array_1[typing.Any]) -> None: ...


class ImageConversion(abc.ABC):
    @classmethod
    @property
    def EnableLegacyPngGammaRuntimeLoadBehavior(cls) -> bool: ...
    @classmethod
    @EnableLegacyPngGammaRuntimeLoadBehavior.setter
    def EnableLegacyPngGammaRuntimeLoadBehavior(cls, value: bool) -> bool: ...
    @staticmethod
    def EncodeArrayToEXR(array: Array, format: GraphicsFormat, width: int, height: int, rowBytes: int = ..., flags: Texture2D.EXRFlags = ...) -> Array_1[int]: ...
    @staticmethod
    def EncodeArrayToJPG(array: Array, format: GraphicsFormat, width: int, height: int, rowBytes: int = ..., quality: int = ...) -> Array_1[int]: ...
    @staticmethod
    def EncodeArrayToPNG(array: Array, format: GraphicsFormat, width: int, height: int, rowBytes: int = ...) -> Array_1[int]: ...
    @staticmethod
    def EncodeArrayToTGA(array: Array, format: GraphicsFormat, width: int, height: int, rowBytes: int = ...) -> Array_1[int]: ...
    @staticmethod
    def EncodeToPNG(tex: Texture2D) -> Array_1[int]: ...
    @staticmethod
    def EncodeToTGA(tex: Texture2D) -> Array_1[int]: ...
    # Skipped EncodeNativeArrayToEXR due to it being static, abstract and generic.

    EncodeNativeArrayToEXR : EncodeNativeArrayToEXR_MethodGroup
    class EncodeNativeArrayToEXR_MethodGroup:
        def __getitem__(self, t:typing.Type[EncodeNativeArrayToEXR_1_T1]) -> EncodeNativeArrayToEXR_1[EncodeNativeArrayToEXR_1_T1]: ...

        EncodeNativeArrayToEXR_1_T1 = typing.TypeVar('EncodeNativeArrayToEXR_1_T1')
        class EncodeNativeArrayToEXR_1(typing.Generic[EncodeNativeArrayToEXR_1_T1]):
            EncodeNativeArrayToEXR_1_T = ImageConversion.EncodeNativeArrayToEXR_MethodGroup.EncodeNativeArrayToEXR_1_T1
            def __call__(self, input: NativeArray_1[EncodeNativeArrayToEXR_1_T], format: GraphicsFormat, width: int, height: int, rowBytes: int = ..., flags: Texture2D.EXRFlags = ...) -> NativeArray_1[int]:...


    # Skipped EncodeNativeArrayToJPG due to it being static, abstract and generic.

    EncodeNativeArrayToJPG : EncodeNativeArrayToJPG_MethodGroup
    class EncodeNativeArrayToJPG_MethodGroup:
        def __getitem__(self, t:typing.Type[EncodeNativeArrayToJPG_1_T1]) -> EncodeNativeArrayToJPG_1[EncodeNativeArrayToJPG_1_T1]: ...

        EncodeNativeArrayToJPG_1_T1 = typing.TypeVar('EncodeNativeArrayToJPG_1_T1')
        class EncodeNativeArrayToJPG_1(typing.Generic[EncodeNativeArrayToJPG_1_T1]):
            EncodeNativeArrayToJPG_1_T = ImageConversion.EncodeNativeArrayToJPG_MethodGroup.EncodeNativeArrayToJPG_1_T1
            def __call__(self, input: NativeArray_1[EncodeNativeArrayToJPG_1_T], format: GraphicsFormat, width: int, height: int, rowBytes: int = ..., quality: int = ...) -> NativeArray_1[int]:...


    # Skipped EncodeNativeArrayToPNG due to it being static, abstract and generic.

    EncodeNativeArrayToPNG : EncodeNativeArrayToPNG_MethodGroup
    class EncodeNativeArrayToPNG_MethodGroup:
        def __getitem__(self, t:typing.Type[EncodeNativeArrayToPNG_1_T1]) -> EncodeNativeArrayToPNG_1[EncodeNativeArrayToPNG_1_T1]: ...

        EncodeNativeArrayToPNG_1_T1 = typing.TypeVar('EncodeNativeArrayToPNG_1_T1')
        class EncodeNativeArrayToPNG_1(typing.Generic[EncodeNativeArrayToPNG_1_T1]):
            EncodeNativeArrayToPNG_1_T = ImageConversion.EncodeNativeArrayToPNG_MethodGroup.EncodeNativeArrayToPNG_1_T1
            def __call__(self, input: NativeArray_1[EncodeNativeArrayToPNG_1_T], format: GraphicsFormat, width: int, height: int, rowBytes: int = ...) -> NativeArray_1[int]:...


    # Skipped EncodeNativeArrayToTGA due to it being static, abstract and generic.

    EncodeNativeArrayToTGA : EncodeNativeArrayToTGA_MethodGroup
    class EncodeNativeArrayToTGA_MethodGroup:
        def __getitem__(self, t:typing.Type[EncodeNativeArrayToTGA_1_T1]) -> EncodeNativeArrayToTGA_1[EncodeNativeArrayToTGA_1_T1]: ...

        EncodeNativeArrayToTGA_1_T1 = typing.TypeVar('EncodeNativeArrayToTGA_1_T1')
        class EncodeNativeArrayToTGA_1(typing.Generic[EncodeNativeArrayToTGA_1_T1]):
            EncodeNativeArrayToTGA_1_T = ImageConversion.EncodeNativeArrayToTGA_MethodGroup.EncodeNativeArrayToTGA_1_T1
            def __call__(self, input: NativeArray_1[EncodeNativeArrayToTGA_1_T], format: GraphicsFormat, width: int, height: int, rowBytes: int = ...) -> NativeArray_1[int]:...


    # Skipped EncodeToEXR due to it being static, abstract and generic.

    EncodeToEXR : EncodeToEXR_MethodGroup
    class EncodeToEXR_MethodGroup:
        @typing.overload
        def __call__(self, tex: Texture2D) -> Array_1[int]:...
        @typing.overload
        def __call__(self, tex: Texture2D, flags: Texture2D.EXRFlags) -> Array_1[int]:...

    # Skipped EncodeToJPG due to it being static, abstract and generic.

    EncodeToJPG : EncodeToJPG_MethodGroup
    class EncodeToJPG_MethodGroup:
        @typing.overload
        def __call__(self, tex: Texture2D) -> Array_1[int]:...
        @typing.overload
        def __call__(self, tex: Texture2D, quality: int) -> Array_1[int]:...

    # Skipped LoadImage due to it being static, abstract and generic.

    LoadImage : LoadImage_MethodGroup
    class LoadImage_MethodGroup:
        @typing.overload
        def __call__(self, tex: Texture2D, data: Array_1[int]) -> bool:...
        @typing.overload
        def __call__(self, tex: Texture2D, data: Array_1[int], markNonReadable: bool) -> bool:...



class ImageEffectAfterScale(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class ImageEffectAllowedInSceneView(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class ImageEffectOpaque(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class ImageEffectTransformsToLDR(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class ImageEffectUsesCommandBuffer(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class ImagePosition(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    ImageLeft : ImagePosition # 0
    ImageAbove : ImagePosition # 1
    ImageOnly : ImagePosition # 2
    TextOnly : ImagePosition # 3


class IMECompositionMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Auto : IMECompositionMode # 0
    On : IMECompositionMode # 1
    Off : IMECompositionMode # 2


class Input:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def acceleration(cls) -> Vector3: ...
    @classmethod
    @property
    def accelerationEventCount(cls) -> int: ...
    @classmethod
    @property
    def accelerationEvents(cls) -> Array_1[AccelerationEvent]: ...
    @classmethod
    @property
    def anyKey(cls) -> bool: ...
    @classmethod
    @property
    def anyKeyDown(cls) -> bool: ...
    @classmethod
    @property
    def backButtonLeavesApp(cls) -> bool: ...
    @classmethod
    @backButtonLeavesApp.setter
    def backButtonLeavesApp(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def compass(cls) -> Compass: ...
    @classmethod
    @property
    def compensateSensors(cls) -> bool: ...
    @classmethod
    @compensateSensors.setter
    def compensateSensors(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def compositionCursorPos(cls) -> Vector2: ...
    @classmethod
    @compositionCursorPos.setter
    def compositionCursorPos(cls, value: Vector2) -> Vector2: ...
    @classmethod
    @property
    def compositionString(cls) -> str: ...
    @classmethod
    @property
    def deviceOrientation(cls) -> DeviceOrientation: ...
    @classmethod
    @property
    def eatKeyPressOnTextFieldFocus(cls) -> bool: ...
    @classmethod
    @eatKeyPressOnTextFieldFocus.setter
    def eatKeyPressOnTextFieldFocus(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def gyro(cls) -> Gyroscope: ...
    @classmethod
    @property
    def imeCompositionMode(cls) -> IMECompositionMode: ...
    @classmethod
    @imeCompositionMode.setter
    def imeCompositionMode(cls, value: IMECompositionMode) -> IMECompositionMode: ...
    @classmethod
    @property
    def imeIsSelected(cls) -> bool: ...
    @classmethod
    @property
    def inputString(cls) -> str: ...
    @classmethod
    @property
    def isGyroAvailable(cls) -> bool: ...
    @classmethod
    @property
    def location(cls) -> LocationService: ...
    @classmethod
    @property
    def mousePosition(cls) -> Vector3: ...
    @classmethod
    @property
    def mousePresent(cls) -> bool: ...
    @classmethod
    @property
    def mouseScrollDelta(cls) -> Vector2: ...
    @classmethod
    @property
    def multiTouchEnabled(cls) -> bool: ...
    @classmethod
    @multiTouchEnabled.setter
    def multiTouchEnabled(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def penEventCount(cls) -> int: ...
    @classmethod
    @property
    def simulateMouseWithTouches(cls) -> bool: ...
    @classmethod
    @simulateMouseWithTouches.setter
    def simulateMouseWithTouches(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def stylusTouchSupported(cls) -> bool: ...
    @classmethod
    @property
    def touchCount(cls) -> int: ...
    @classmethod
    @property
    def touches(cls) -> Array_1[Touch]: ...
    @classmethod
    @property
    def touchPressureSupported(cls) -> bool: ...
    @classmethod
    @property
    def touchSupported(cls) -> bool: ...
    @staticmethod
    def ClearLastPenContactEvent() -> None: ...
    @staticmethod
    def GetAccelerationEvent(index: int) -> AccelerationEvent: ...
    @staticmethod
    def GetAxis(axisName: str) -> float: ...
    @staticmethod
    def GetAxisRaw(axisName: str) -> float: ...
    @staticmethod
    def GetButton(buttonName: str) -> bool: ...
    @staticmethod
    def GetButtonDown(buttonName: str) -> bool: ...
    @staticmethod
    def GetButtonUp(buttonName: str) -> bool: ...
    @staticmethod
    def GetJoystickNames() -> Array_1[str]: ...
    @staticmethod
    def GetLastPenContactEvent() -> PenData: ...
    @staticmethod
    def GetMouseButton(button: int) -> bool: ...
    @staticmethod
    def GetMouseButtonDown(button: int) -> bool: ...
    @staticmethod
    def GetMouseButtonUp(button: int) -> bool: ...
    @staticmethod
    def GetPenEvent(index: int) -> PenData: ...
    @staticmethod
    def GetTouch(index: int) -> Touch: ...
    @staticmethod
    def IsJoystickPreconfigured(joystickName: str) -> bool: ...
    @staticmethod
    def ResetInputAxes() -> None: ...
    @staticmethod
    def ResetPenEvents() -> None: ...
    # Skipped GetKey due to it being static, abstract and generic.

    GetKey : GetKey_MethodGroup
    class GetKey_MethodGroup:
        @typing.overload
        def __call__(self, key: KeyCode) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped GetKeyDown due to it being static, abstract and generic.

    GetKeyDown : GetKeyDown_MethodGroup
    class GetKeyDown_MethodGroup:
        @typing.overload
        def __call__(self, key: KeyCode) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped GetKeyUp due to it being static, abstract and generic.

    GetKeyUp : GetKeyUp_MethodGroup
    class GetKeyUp_MethodGroup:
        @typing.overload
        def __call__(self, key: KeyCode) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...



class InspectorNameAttribute(PropertyAttribute):
    def __init__(self, displayName: str) -> None: ...
    displayName : str
    @property
    def order(self) -> int: ...
    @order.setter
    def order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class InspectorOrderAttribute(PropertyAttribute):
    def __init__(self, inspectorSort: InspectorSort = ..., sortDirection: InspectorSortDirection = ...) -> None: ...
    @property
    def order(self) -> int: ...
    @order.setter
    def order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class InspectorSort(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    ByName : InspectorSort # 0
    ByValue : InspectorSort # 1


class InspectorSortDirection(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Ascending : InspectorSortDirection # 0
    Descending : InspectorSortDirection # 1


class IntegratedSubsystem_GenericClasses(abc.ABCMeta):
    Generic_IntegratedSubsystem_GenericClasses_IntegratedSubsystem_1_TSubsystemDescriptor = typing.TypeVar('Generic_IntegratedSubsystem_GenericClasses_IntegratedSubsystem_1_TSubsystemDescriptor')
    def __getitem__(self, types : typing.Type[Generic_IntegratedSubsystem_GenericClasses_IntegratedSubsystem_1_TSubsystemDescriptor]) -> typing.Type[IntegratedSubsystem_1[Generic_IntegratedSubsystem_GenericClasses_IntegratedSubsystem_1_TSubsystemDescriptor]]: ...

class IntegratedSubsystem(IntegratedSubsystem_0, metaclass =IntegratedSubsystem_GenericClasses): ...

class IntegratedSubsystem_0(ISubsystem):
    def __init__(self) -> None: ...
    @property
    def running(self) -> bool: ...
    def Destroy(self) -> None: ...
    def Start(self) -> None: ...
    def Stop(self) -> None: ...


IntegratedSubsystem_1_TSubsystemDescriptor = typing.TypeVar('IntegratedSubsystem_1_TSubsystemDescriptor')
class IntegratedSubsystem_1(typing.Generic[IntegratedSubsystem_1_TSubsystemDescriptor], IntegratedSubsystem_0):
    def __init__(self) -> None: ...
    @property
    def running(self) -> bool: ...
    @property
    def subsystemDescriptor(self) -> IntegratedSubsystem_1_TSubsystemDescriptor: ...
    @property
    def SubsystemDescriptor(self) -> IntegratedSubsystem_1_TSubsystemDescriptor: ...


class IntegratedSubsystemDescriptor_GenericClasses(abc.ABCMeta):
    Generic_IntegratedSubsystemDescriptor_GenericClasses_IntegratedSubsystemDescriptor_1_TSubsystem = typing.TypeVar('Generic_IntegratedSubsystemDescriptor_GenericClasses_IntegratedSubsystemDescriptor_1_TSubsystem')
    def __getitem__(self, types : typing.Type[Generic_IntegratedSubsystemDescriptor_GenericClasses_IntegratedSubsystemDescriptor_1_TSubsystem]) -> typing.Type[IntegratedSubsystemDescriptor_1[Generic_IntegratedSubsystemDescriptor_GenericClasses_IntegratedSubsystemDescriptor_1_TSubsystem]]: ...

class IntegratedSubsystemDescriptor(IntegratedSubsystemDescriptor_0, metaclass =IntegratedSubsystemDescriptor_GenericClasses): ...

class IntegratedSubsystemDescriptor_0(abc.ABC):
    @property
    def id(self) -> str: ...


IntegratedSubsystemDescriptor_1_TSubsystem = typing.TypeVar('IntegratedSubsystemDescriptor_1_TSubsystem')
class IntegratedSubsystemDescriptor_1(typing.Generic[IntegratedSubsystemDescriptor_1_TSubsystem], IntegratedSubsystemDescriptor_0):
    def __init__(self) -> None: ...
    @property
    def id(self) -> str: ...
    def Create(self) -> IntegratedSubsystemDescriptor_1_TSubsystem: ...


class iOSActivityIndicatorStyle(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    DontShow : iOSActivityIndicatorStyle # 0
    WhiteLarge : iOSActivityIndicatorStyle # 1
    White : iOSActivityIndicatorStyle # 2
    Gray : iOSActivityIndicatorStyle # 3


class iPhone:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def advertisingIdentifier(cls) -> str: ...
    @classmethod
    @property
    def advertisingTrackingEnabled(cls) -> bool: ...
    @classmethod
    @property
    def generation(cls) -> iPhoneGeneration: ...
    @classmethod
    @property
    def vendorIdentifier(cls) -> str: ...
    @staticmethod
    def ResetNoBackupFlag(path: str) -> None: ...
    @staticmethod
    def SetNoBackupFlag(path: str) -> None: ...


class iPhoneAccelerationEvent:
    @property
    def acceleration(self) -> Vector3: ...
    @property
    def deltaTime(self) -> float: ...
    @property
    def timeDelta(self) -> float: ...


class iPhoneGeneration(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : iPhoneGeneration # 0
    iPhone : iPhoneGeneration # 1
    iPhone3G : iPhoneGeneration # 2
    iPhone3GS : iPhoneGeneration # 3
    iPodTouch1Gen : iPhoneGeneration # 4
    iPodTouch2Gen : iPhoneGeneration # 5
    iPodTouch3Gen : iPhoneGeneration # 6
    iPad1Gen : iPhoneGeneration # 7
    iPhone4 : iPhoneGeneration # 8
    iPodTouch4Gen : iPhoneGeneration # 9
    iPad2Gen : iPhoneGeneration # 10
    iPhone4S : iPhoneGeneration # 11
    iPad3Gen : iPhoneGeneration # 12
    iPhone5 : iPhoneGeneration # 13
    iPodTouch5Gen : iPhoneGeneration # 14
    iPadMini1Gen : iPhoneGeneration # 15
    iPad4Gen : iPhoneGeneration # 16
    iPhone5C : iPhoneGeneration # 17
    iPhone5S : iPhoneGeneration # 18
    iPhoneUnknown : iPhoneGeneration # 19
    iPadUnknown : iPhoneGeneration # 20
    iPodTouchUnknown : iPhoneGeneration # 21


class iPhoneInput:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def acceleration(cls) -> Vector3: ...
    @classmethod
    @property
    def accelerationEventCount(cls) -> int: ...
    @classmethod
    @property
    def accelerationEvents(cls) -> Array_1[iPhoneAccelerationEvent]: ...
    @classmethod
    @property
    def multiTouchEnabled(cls) -> bool: ...
    @classmethod
    @multiTouchEnabled.setter
    def multiTouchEnabled(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def orientation(cls) -> iPhoneOrientation: ...
    @classmethod
    @property
    def touchCount(cls) -> int: ...
    @classmethod
    @property
    def touches(cls) -> Array_1[iPhoneTouch]: ...
    @staticmethod
    def GetAccelerationEvent(index: int) -> iPhoneAccelerationEvent: ...
    @staticmethod
    def GetTouch(index: int) -> iPhoneTouch: ...


class iPhoneKeyboard:
    def __init__(self) -> None: ...
    @property
    def active(self) -> bool: ...
    @active.setter
    def active(self, value: bool) -> bool: ...
    @classmethod
    @property
    def area(cls) -> Rect: ...
    @property
    def done(self) -> bool: ...
    @classmethod
    @property
    def hideInput(cls) -> bool: ...
    @classmethod
    @hideInput.setter
    def hideInput(cls, value: bool) -> bool: ...
    @property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> str: ...
    @classmethod
    @property
    def visible(cls) -> bool: ...


class iPhoneKeyboardType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Default : iPhoneKeyboardType # 0
    ASCIICapable : iPhoneKeyboardType # 1
    NumbersAndPunctuation : iPhoneKeyboardType # 2
    URL : iPhoneKeyboardType # 3
    NumberPad : iPhoneKeyboardType # 4
    PhonePad : iPhoneKeyboardType # 5
    NamePhonePad : iPhoneKeyboardType # 6
    EmailAddress : iPhoneKeyboardType # 7


class iPhoneMovieControlMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Full : iPhoneMovieControlMode # 0
    Minimal : iPhoneMovieControlMode # 1
    CancelOnTouch : iPhoneMovieControlMode # 2
    Hidden : iPhoneMovieControlMode # 3
    VolumeOnly : iPhoneMovieControlMode # 4


class iPhoneMovieScalingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : iPhoneMovieScalingMode # 0
    AspectFit : iPhoneMovieScalingMode # 1
    AspectFill : iPhoneMovieScalingMode # 2
    Fill : iPhoneMovieScalingMode # 3


class iPhoneNetworkReachability(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    NotReachable : iPhoneNetworkReachability # 0
    ReachableViaCarrierDataNetwork : iPhoneNetworkReachability # 1
    ReachableViaWiFiNetwork : iPhoneNetworkReachability # 2


class iPhoneOrientation(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : iPhoneOrientation # 0
    Portrait : iPhoneOrientation # 1
    PortraitUpsideDown : iPhoneOrientation # 2
    LandscapeLeft : iPhoneOrientation # 3
    LandscapeRight : iPhoneOrientation # 4
    FaceUp : iPhoneOrientation # 5
    FaceDown : iPhoneOrientation # 6


class iPhoneScreenOrientation(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : iPhoneScreenOrientation # 0
    Portrait : iPhoneScreenOrientation # 1
    PortraitUpsideDown : iPhoneScreenOrientation # 2
    LandscapeLeft : iPhoneScreenOrientation # 3
    LandscapeRight : iPhoneScreenOrientation # 4
    AutoRotation : iPhoneScreenOrientation # 5
    Landscape : iPhoneScreenOrientation # 6


class iPhoneSettings:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def generation(cls) -> iPhoneGeneration: ...
    @classmethod
    @property
    def internetReachability(cls) -> iPhoneNetworkReachability: ...
    @classmethod
    @property
    def locationServiceEnabledByUser(cls) -> bool: ...
    @classmethod
    @property
    def model(cls) -> str: ...
    @classmethod
    @property
    def name(cls) -> str: ...
    @classmethod
    @property
    def screenCanDarken(cls) -> bool: ...
    @classmethod
    @property
    def screenOrientation(cls) -> iPhoneScreenOrientation: ...
    @classmethod
    @property
    def systemName(cls) -> str: ...
    @classmethod
    @property
    def systemVersion(cls) -> str: ...
    @classmethod
    @property
    def uniqueIdentifier(cls) -> str: ...
    @classmethod
    @property
    def verticalOrientation(cls) -> bool: ...
    @staticmethod
    def StopLocationServiceUpdates() -> None: ...
    # Skipped StartLocationServiceUpdates due to it being static, abstract and generic.

    StartLocationServiceUpdates : StartLocationServiceUpdates_MethodGroup
    class StartLocationServiceUpdates_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, desiredAccuracyInMeters: float) -> None:...
        @typing.overload
        def __call__(self, desiredAccuracyInMeters: float, updateDistanceInMeters: float) -> None:...



class iPhoneTouch:
    @property
    def deltaPosition(self) -> Vector2: ...
    @property
    def deltaTime(self) -> float: ...
    @property
    def fingerId(self) -> int: ...
    @property
    def phase(self) -> iPhoneTouchPhase: ...
    @property
    def position(self) -> Vector2: ...
    @property
    def positionDelta(self) -> Vector2: ...
    @property
    def tapCount(self) -> int: ...
    @property
    def timeDelta(self) -> float: ...


class iPhoneTouchPhase(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Began : iPhoneTouchPhase # 0
    Moved : iPhoneTouchPhase # 1
    Stationary : iPhoneTouchPhase # 2
    Ended : iPhoneTouchPhase # 3
    Canceled : iPhoneTouchPhase # 4


class iPhoneUtils:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def isApplicationGenuine(cls) -> bool: ...
    @classmethod
    @property
    def isApplicationGenuineAvailable(cls) -> bool: ...
    @staticmethod
    def Vibrate() -> None: ...
    # Skipped PlayMovie due to it being static, abstract and generic.

    PlayMovie : PlayMovie_MethodGroup
    class PlayMovie_MethodGroup:
        @typing.overload
        def __call__(self, path: str, bgColor: Color) -> None:...
        @typing.overload
        def __call__(self, path: str, bgColor: Color, controlMode: iPhoneMovieControlMode) -> None:...
        @typing.overload
        def __call__(self, path: str, bgColor: Color, controlMode: iPhoneMovieControlMode, scalingMode: iPhoneMovieScalingMode) -> None:...

    # Skipped PlayMovieURL due to it being static, abstract and generic.

    PlayMovieURL : PlayMovieURL_MethodGroup
    class PlayMovieURL_MethodGroup:
        @typing.overload
        def __call__(self, url: str, bgColor: Color) -> None:...
        @typing.overload
        def __call__(self, url: str, bgColor: Color, controlMode: iPhoneMovieControlMode) -> None:...
        @typing.overload
        def __call__(self, url: str, bgColor: Color, controlMode: iPhoneMovieControlMode, scalingMode: iPhoneMovieScalingMode) -> None:...



class ISerializationCallbackReceiver(typing.Protocol):
    @abc.abstractmethod
    def OnAfterDeserialize(self) -> None: ...
    @abc.abstractmethod
    def OnBeforeSerialize(self) -> None: ...


class ISubsystem(typing.Protocol):
    @property
    def running(self) -> bool: ...
    @abc.abstractmethod
    def Destroy(self) -> None: ...
    @abc.abstractmethod
    def Start(self) -> None: ...
    @abc.abstractmethod
    def Stop(self) -> None: ...


class ISubsystemDescriptor(typing.Protocol):
    @property
    def id(self) -> str: ...
    @abc.abstractmethod
    def Create(self) -> ISubsystem: ...


class JNINativeMethod:
    fnPtr : int
    name : str
    signature : str


class Joint(Component):
    def __init__(self) -> None: ...
    @property
    def anchor(self) -> Vector3: ...
    @anchor.setter
    def anchor(self, value: Vector3) -> Vector3: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoConfigureConnectedAnchor(self) -> bool: ...
    @autoConfigureConnectedAnchor.setter
    def autoConfigureConnectedAnchor(self, value: bool) -> bool: ...
    @property
    def axis(self) -> Vector3: ...
    @axis.setter
    def axis(self, value: Vector3) -> Vector3: ...
    @property
    def breakForce(self) -> float: ...
    @breakForce.setter
    def breakForce(self, value: float) -> float: ...
    @property
    def breakTorque(self) -> float: ...
    @breakTorque.setter
    def breakTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def connectedAnchor(self) -> Vector3: ...
    @connectedAnchor.setter
    def connectedAnchor(self, value: Vector3) -> Vector3: ...
    @property
    def connectedArticulationBody(self) -> ArticulationBody: ...
    @connectedArticulationBody.setter
    def connectedArticulationBody(self, value: ArticulationBody) -> ArticulationBody: ...
    @property
    def connectedBody(self) -> Rigidbody: ...
    @connectedBody.setter
    def connectedBody(self, value: Rigidbody) -> Rigidbody: ...
    @property
    def connectedMassScale(self) -> float: ...
    @connectedMassScale.setter
    def connectedMassScale(self, value: float) -> float: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def currentForce(self) -> Vector3: ...
    @property
    def currentTorque(self) -> Vector3: ...
    @property
    def enableCollision(self) -> bool: ...
    @enableCollision.setter
    def enableCollision(self, value: bool) -> bool: ...
    @property
    def enablePreprocessing(self) -> bool: ...
    @enablePreprocessing.setter
    def enablePreprocessing(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def light(self) -> Component: ...
    @property
    def massScale(self) -> float: ...
    @massScale.setter
    def massScale(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class Joint2D(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def breakAction(self) -> JointBreakAction2D: ...
    @breakAction.setter
    def breakAction(self, value: JointBreakAction2D) -> JointBreakAction2D: ...
    @property
    def breakForce(self) -> float: ...
    @breakForce.setter
    def breakForce(self, value: float) -> float: ...
    @property
    def breakTorque(self) -> float: ...
    @breakTorque.setter
    def breakTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collideConnected(self) -> bool: ...
    @collideConnected.setter
    def collideConnected(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def connectedBody(self) -> Rigidbody2D: ...
    @connectedBody.setter
    def connectedBody(self, value: Rigidbody2D) -> Rigidbody2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enableCollision(self) -> bool: ...
    @enableCollision.setter
    def enableCollision(self, value: bool) -> bool: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def reactionForce(self) -> Vector2: ...
    @property
    def reactionTorque(self) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    def GetReactionForce(self, timeStep: float) -> Vector2: ...
    def GetReactionTorque(self, timeStep: float) -> float: ...


class JointAngleLimits2D:
    @property
    def max(self) -> float: ...
    @max.setter
    def max(self, value: float) -> float: ...
    @property
    def min(self) -> float: ...
    @min.setter
    def min(self, value: float) -> float: ...


class JointBreakAction2D(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Ignore : JointBreakAction2D # 0
    CallbackOnly : JointBreakAction2D # 1
    Disable : JointBreakAction2D # 2
    Destroy : JointBreakAction2D # 3


class JointDrive:
    @property
    def maximumForce(self) -> float: ...
    @maximumForce.setter
    def maximumForce(self, value: float) -> float: ...
    @property
    def mode(self) -> JointDriveMode: ...
    @mode.setter
    def mode(self, value: JointDriveMode) -> JointDriveMode: ...
    @property
    def positionDamper(self) -> float: ...
    @positionDamper.setter
    def positionDamper(self, value: float) -> float: ...
    @property
    def positionSpring(self) -> float: ...
    @positionSpring.setter
    def positionSpring(self, value: float) -> float: ...
    @property
    def useAcceleration(self) -> bool: ...
    @useAcceleration.setter
    def useAcceleration(self, value: bool) -> bool: ...


class JointDriveMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : JointDriveMode # 0
    Position : JointDriveMode # 1
    Velocity : JointDriveMode # 2
    PositionAndVelocity : JointDriveMode # 3


class JointLimits:
    maxBounce : float
    minBounce : float
    @property
    def bounceMinVelocity(self) -> float: ...
    @bounceMinVelocity.setter
    def bounceMinVelocity(self, value: float) -> float: ...
    @property
    def bounciness(self) -> float: ...
    @bounciness.setter
    def bounciness(self, value: float) -> float: ...
    @property
    def contactDistance(self) -> float: ...
    @contactDistance.setter
    def contactDistance(self, value: float) -> float: ...
    @property
    def max(self) -> float: ...
    @max.setter
    def max(self, value: float) -> float: ...
    @property
    def min(self) -> float: ...
    @min.setter
    def min(self, value: float) -> float: ...


class JointLimitState2D(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Inactive : JointLimitState2D # 0
    LowerLimit : JointLimitState2D # 1
    UpperLimit : JointLimitState2D # 2
    EqualLimits : JointLimitState2D # 3


class JointMotor:
    @property
    def force(self) -> float: ...
    @force.setter
    def force(self, value: float) -> float: ...
    @property
    def freeSpin(self) -> bool: ...
    @freeSpin.setter
    def freeSpin(self, value: bool) -> bool: ...
    @property
    def targetVelocity(self) -> float: ...
    @targetVelocity.setter
    def targetVelocity(self, value: float) -> float: ...


class JointMotor2D:
    @property
    def maxMotorTorque(self) -> float: ...
    @maxMotorTorque.setter
    def maxMotorTorque(self, value: float) -> float: ...
    @property
    def motorSpeed(self) -> float: ...
    @motorSpeed.setter
    def motorSpeed(self, value: float) -> float: ...


class JointProjectionMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : JointProjectionMode # 0
    PositionAndRotation : JointProjectionMode # 1
    PositionOnly : JointProjectionMode # 2


class JointSpring:
    damper : float
    spring : float
    targetPosition : float


class JointSuspension2D:
    @property
    def angle(self) -> float: ...
    @angle.setter
    def angle(self, value: float) -> float: ...
    @property
    def dampingRatio(self) -> float: ...
    @dampingRatio.setter
    def dampingRatio(self, value: float) -> float: ...
    @property
    def frequency(self) -> float: ...
    @frequency.setter
    def frequency(self, value: float) -> float: ...


class JointTranslationLimits2D:
    @property
    def max(self) -> float: ...
    @max.setter
    def max(self, value: float) -> float: ...
    @property
    def min(self) -> float: ...
    @min.setter
    def min(self, value: float) -> float: ...


class JsonUtility(abc.ABC):
    @staticmethod
    def FromJsonOverwrite(json: str, objectToOverwrite: typing.Any) -> None: ...
    # Skipped FromJson due to it being static, abstract and generic.

    FromJson : FromJson_MethodGroup
    class FromJson_MethodGroup:
        def __getitem__(self, t:typing.Type[FromJson_1_T1]) -> FromJson_1[FromJson_1_T1]: ...

        FromJson_1_T1 = typing.TypeVar('FromJson_1_T1')
        class FromJson_1(typing.Generic[FromJson_1_T1]):
            FromJson_1_T = JsonUtility.FromJson_MethodGroup.FromJson_1_T1
            def __call__(self, json: str) -> FromJson_1_T:...

        def __call__(self, json: str, type: typing.Type[typing.Any]) -> typing.Any:...

    # Skipped ToJson due to it being static, abstract and generic.

    ToJson : ToJson_MethodGroup
    class ToJson_MethodGroup:
        @typing.overload
        def __call__(self, obj: typing.Any) -> str:...
        @typing.overload
        def __call__(self, obj: typing.Any, prettyPrint: bool) -> str:...



class jvalue:
    b : int
    c : str
    d : float
    f : float
    i : int
    j : int
    l : int
    s : int
    z : bool


class KeyCode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : KeyCode # 0
    Backspace : KeyCode # 8
    Tab : KeyCode # 9
    Clear : KeyCode # 12
    Return : KeyCode # 13
    Pause : KeyCode # 19
    Escape : KeyCode # 27
    Space : KeyCode # 32
    Exclaim : KeyCode # 33
    DoubleQuote : KeyCode # 34
    Hash : KeyCode # 35
    Dollar : KeyCode # 36
    Percent : KeyCode # 37
    Ampersand : KeyCode # 38
    Quote : KeyCode # 39
    LeftParen : KeyCode # 40
    RightParen : KeyCode # 41
    Asterisk : KeyCode # 42
    Plus : KeyCode # 43
    Comma : KeyCode # 44
    Minus : KeyCode # 45
    Period : KeyCode # 46
    Slash : KeyCode # 47
    Alpha0 : KeyCode # 48
    Alpha1 : KeyCode # 49
    Alpha2 : KeyCode # 50
    Alpha3 : KeyCode # 51
    Alpha4 : KeyCode # 52
    Alpha5 : KeyCode # 53
    Alpha6 : KeyCode # 54
    Alpha7 : KeyCode # 55
    Alpha8 : KeyCode # 56
    Alpha9 : KeyCode # 57
    Colon : KeyCode # 58
    Semicolon : KeyCode # 59
    Less : KeyCode # 60
    Equals : KeyCode # 61
    Greater : KeyCode # 62
    Question : KeyCode # 63
    At : KeyCode # 64
    LeftBracket : KeyCode # 91
    Backslash : KeyCode # 92
    RightBracket : KeyCode # 93
    Caret : KeyCode # 94
    Underscore : KeyCode # 95
    BackQuote : KeyCode # 96
    A : KeyCode # 97
    B : KeyCode # 98
    C : KeyCode # 99
    D : KeyCode # 100
    E : KeyCode # 101
    F : KeyCode # 102
    G : KeyCode # 103
    H : KeyCode # 104
    I : KeyCode # 105
    J : KeyCode # 106
    K : KeyCode # 107
    L : KeyCode # 108
    M : KeyCode # 109
    N : KeyCode # 110
    O : KeyCode # 111
    P : KeyCode # 112
    Q : KeyCode # 113
    R : KeyCode # 114
    S : KeyCode # 115
    T : KeyCode # 116
    U : KeyCode # 117
    V : KeyCode # 118
    W : KeyCode # 119
    X : KeyCode # 120
    Y : KeyCode # 121
    Z : KeyCode # 122
    LeftCurlyBracket : KeyCode # 123
    Pipe : KeyCode # 124
    RightCurlyBracket : KeyCode # 125
    Tilde : KeyCode # 126
    Delete : KeyCode # 127
    Keypad0 : KeyCode # 256
    Keypad1 : KeyCode # 257
    Keypad2 : KeyCode # 258
    Keypad3 : KeyCode # 259
    Keypad4 : KeyCode # 260
    Keypad5 : KeyCode # 261
    Keypad6 : KeyCode # 262
    Keypad7 : KeyCode # 263
    Keypad8 : KeyCode # 264
    Keypad9 : KeyCode # 265
    KeypadPeriod : KeyCode # 266
    KeypadDivide : KeyCode # 267
    KeypadMultiply : KeyCode # 268
    KeypadMinus : KeyCode # 269
    KeypadPlus : KeyCode # 270
    KeypadEnter : KeyCode # 271
    KeypadEquals : KeyCode # 272
    UpArrow : KeyCode # 273
    DownArrow : KeyCode # 274
    RightArrow : KeyCode # 275
    LeftArrow : KeyCode # 276
    Insert : KeyCode # 277
    Home : KeyCode # 278
    End : KeyCode # 279
    PageUp : KeyCode # 280
    PageDown : KeyCode # 281
    F1 : KeyCode # 282
    F2 : KeyCode # 283
    F3 : KeyCode # 284
    F4 : KeyCode # 285
    F5 : KeyCode # 286
    F6 : KeyCode # 287
    F7 : KeyCode # 288
    F8 : KeyCode # 289
    F9 : KeyCode # 290
    F10 : KeyCode # 291
    F11 : KeyCode # 292
    F12 : KeyCode # 293
    F13 : KeyCode # 294
    F14 : KeyCode # 295
    F15 : KeyCode # 296
    Numlock : KeyCode # 300
    CapsLock : KeyCode # 301
    ScrollLock : KeyCode # 302
    RightShift : KeyCode # 303
    LeftShift : KeyCode # 304
    RightControl : KeyCode # 305
    LeftControl : KeyCode # 306
    RightAlt : KeyCode # 307
    LeftAlt : KeyCode # 308
    RightApple : KeyCode # 309
    RightMeta : KeyCode # 309
    RightCommand : KeyCode # 309
    LeftApple : KeyCode # 310
    LeftMeta : KeyCode # 310
    LeftCommand : KeyCode # 310
    LeftWindows : KeyCode # 311
    RightWindows : KeyCode # 312
    AltGr : KeyCode # 313
    Help : KeyCode # 315
    Print : KeyCode # 316
    SysReq : KeyCode # 317
    Break : KeyCode # 318
    Menu : KeyCode # 319
    Mouse0 : KeyCode # 323
    Mouse1 : KeyCode # 324
    Mouse2 : KeyCode # 325
    Mouse3 : KeyCode # 326
    Mouse4 : KeyCode # 327
    Mouse5 : KeyCode # 328
    Mouse6 : KeyCode # 329
    JoystickButton0 : KeyCode # 330
    JoystickButton1 : KeyCode # 331
    JoystickButton2 : KeyCode # 332
    JoystickButton3 : KeyCode # 333
    JoystickButton4 : KeyCode # 334
    JoystickButton5 : KeyCode # 335
    JoystickButton6 : KeyCode # 336
    JoystickButton7 : KeyCode # 337
    JoystickButton8 : KeyCode # 338
    JoystickButton9 : KeyCode # 339
    JoystickButton10 : KeyCode # 340
    JoystickButton11 : KeyCode # 341
    JoystickButton12 : KeyCode # 342
    JoystickButton13 : KeyCode # 343
    JoystickButton14 : KeyCode # 344
    JoystickButton15 : KeyCode # 345
    JoystickButton16 : KeyCode # 346
    JoystickButton17 : KeyCode # 347
    JoystickButton18 : KeyCode # 348
    JoystickButton19 : KeyCode # 349
    Joystick1Button0 : KeyCode # 350
    Joystick1Button1 : KeyCode # 351
    Joystick1Button2 : KeyCode # 352
    Joystick1Button3 : KeyCode # 353
    Joystick1Button4 : KeyCode # 354
    Joystick1Button5 : KeyCode # 355
    Joystick1Button6 : KeyCode # 356
    Joystick1Button7 : KeyCode # 357
    Joystick1Button8 : KeyCode # 358
    Joystick1Button9 : KeyCode # 359
    Joystick1Button10 : KeyCode # 360
    Joystick1Button11 : KeyCode # 361
    Joystick1Button12 : KeyCode # 362
    Joystick1Button13 : KeyCode # 363
    Joystick1Button14 : KeyCode # 364
    Joystick1Button15 : KeyCode # 365
    Joystick1Button16 : KeyCode # 366
    Joystick1Button17 : KeyCode # 367
    Joystick1Button18 : KeyCode # 368
    Joystick1Button19 : KeyCode # 369
    Joystick2Button0 : KeyCode # 370
    Joystick2Button1 : KeyCode # 371
    Joystick2Button2 : KeyCode # 372
    Joystick2Button3 : KeyCode # 373
    Joystick2Button4 : KeyCode # 374
    Joystick2Button5 : KeyCode # 375
    Joystick2Button6 : KeyCode # 376
    Joystick2Button7 : KeyCode # 377
    Joystick2Button8 : KeyCode # 378
    Joystick2Button9 : KeyCode # 379
    Joystick2Button10 : KeyCode # 380
    Joystick2Button11 : KeyCode # 381
    Joystick2Button12 : KeyCode # 382
    Joystick2Button13 : KeyCode # 383
    Joystick2Button14 : KeyCode # 384
    Joystick2Button15 : KeyCode # 385
    Joystick2Button16 : KeyCode # 386
    Joystick2Button17 : KeyCode # 387
    Joystick2Button18 : KeyCode # 388
    Joystick2Button19 : KeyCode # 389
    Joystick3Button0 : KeyCode # 390
    Joystick3Button1 : KeyCode # 391
    Joystick3Button2 : KeyCode # 392
    Joystick3Button3 : KeyCode # 393
    Joystick3Button4 : KeyCode # 394
    Joystick3Button5 : KeyCode # 395
    Joystick3Button6 : KeyCode # 396
    Joystick3Button7 : KeyCode # 397
    Joystick3Button8 : KeyCode # 398
    Joystick3Button9 : KeyCode # 399
    Joystick3Button10 : KeyCode # 400
    Joystick3Button11 : KeyCode # 401
    Joystick3Button12 : KeyCode # 402
    Joystick3Button13 : KeyCode # 403
    Joystick3Button14 : KeyCode # 404
    Joystick3Button15 : KeyCode # 405
    Joystick3Button16 : KeyCode # 406
    Joystick3Button17 : KeyCode # 407
    Joystick3Button18 : KeyCode # 408
    Joystick3Button19 : KeyCode # 409
    Joystick4Button0 : KeyCode # 410
    Joystick4Button1 : KeyCode # 411
    Joystick4Button2 : KeyCode # 412
    Joystick4Button3 : KeyCode # 413
    Joystick4Button4 : KeyCode # 414
    Joystick4Button5 : KeyCode # 415
    Joystick4Button6 : KeyCode # 416
    Joystick4Button7 : KeyCode # 417
    Joystick4Button8 : KeyCode # 418
    Joystick4Button9 : KeyCode # 419
    Joystick4Button10 : KeyCode # 420
    Joystick4Button11 : KeyCode # 421
    Joystick4Button12 : KeyCode # 422
    Joystick4Button13 : KeyCode # 423
    Joystick4Button14 : KeyCode # 424
    Joystick4Button15 : KeyCode # 425
    Joystick4Button16 : KeyCode # 426
    Joystick4Button17 : KeyCode # 427
    Joystick4Button18 : KeyCode # 428
    Joystick4Button19 : KeyCode # 429
    Joystick5Button0 : KeyCode # 430
    Joystick5Button1 : KeyCode # 431
    Joystick5Button2 : KeyCode # 432
    Joystick5Button3 : KeyCode # 433
    Joystick5Button4 : KeyCode # 434
    Joystick5Button5 : KeyCode # 435
    Joystick5Button6 : KeyCode # 436
    Joystick5Button7 : KeyCode # 437
    Joystick5Button8 : KeyCode # 438
    Joystick5Button9 : KeyCode # 439
    Joystick5Button10 : KeyCode # 440
    Joystick5Button11 : KeyCode # 441
    Joystick5Button12 : KeyCode # 442
    Joystick5Button13 : KeyCode # 443
    Joystick5Button14 : KeyCode # 444
    Joystick5Button15 : KeyCode # 445
    Joystick5Button16 : KeyCode # 446
    Joystick5Button17 : KeyCode # 447
    Joystick5Button18 : KeyCode # 448
    Joystick5Button19 : KeyCode # 449
    Joystick6Button0 : KeyCode # 450
    Joystick6Button1 : KeyCode # 451
    Joystick6Button2 : KeyCode # 452
    Joystick6Button3 : KeyCode # 453
    Joystick6Button4 : KeyCode # 454
    Joystick6Button5 : KeyCode # 455
    Joystick6Button6 : KeyCode # 456
    Joystick6Button7 : KeyCode # 457
    Joystick6Button8 : KeyCode # 458
    Joystick6Button9 : KeyCode # 459
    Joystick6Button10 : KeyCode # 460
    Joystick6Button11 : KeyCode # 461
    Joystick6Button12 : KeyCode # 462
    Joystick6Button13 : KeyCode # 463
    Joystick6Button14 : KeyCode # 464
    Joystick6Button15 : KeyCode # 465
    Joystick6Button16 : KeyCode # 466
    Joystick6Button17 : KeyCode # 467
    Joystick6Button18 : KeyCode # 468
    Joystick6Button19 : KeyCode # 469
    Joystick7Button0 : KeyCode # 470
    Joystick7Button1 : KeyCode # 471
    Joystick7Button2 : KeyCode # 472
    Joystick7Button3 : KeyCode # 473
    Joystick7Button4 : KeyCode # 474
    Joystick7Button5 : KeyCode # 475
    Joystick7Button6 : KeyCode # 476
    Joystick7Button7 : KeyCode # 477
    Joystick7Button8 : KeyCode # 478
    Joystick7Button9 : KeyCode # 479
    Joystick7Button10 : KeyCode # 480
    Joystick7Button11 : KeyCode # 481
    Joystick7Button12 : KeyCode # 482
    Joystick7Button13 : KeyCode # 483
    Joystick7Button14 : KeyCode # 484
    Joystick7Button15 : KeyCode # 485
    Joystick7Button16 : KeyCode # 486
    Joystick7Button17 : KeyCode # 487
    Joystick7Button18 : KeyCode # 488
    Joystick7Button19 : KeyCode # 489
    Joystick8Button0 : KeyCode # 490
    Joystick8Button1 : KeyCode # 491
    Joystick8Button2 : KeyCode # 492
    Joystick8Button3 : KeyCode # 493
    Joystick8Button4 : KeyCode # 494
    Joystick8Button5 : KeyCode # 495
    Joystick8Button6 : KeyCode # 496
    Joystick8Button7 : KeyCode # 497
    Joystick8Button8 : KeyCode # 498
    Joystick8Button9 : KeyCode # 499
    Joystick8Button10 : KeyCode # 500
    Joystick8Button11 : KeyCode # 501
    Joystick8Button12 : KeyCode # 502
    Joystick8Button13 : KeyCode # 503
    Joystick8Button14 : KeyCode # 504
    Joystick8Button15 : KeyCode # 505
    Joystick8Button16 : KeyCode # 506
    Joystick8Button17 : KeyCode # 507
    Joystick8Button18 : KeyCode # 508
    Joystick8Button19 : KeyCode # 509


class Keyframe:
    @typing.overload
    def __init__(self, time: float, value: float) -> None: ...
    @typing.overload
    def __init__(self, time: float, value: float, inTangent: float, outTangent: float) -> None: ...
    @typing.overload
    def __init__(self, time: float, value: float, inTangent: float, outTangent: float, inWeight: float, outWeight: float) -> None: ...
    @property
    def inTangent(self) -> float: ...
    @inTangent.setter
    def inTangent(self, value: float) -> float: ...
    @property
    def inWeight(self) -> float: ...
    @inWeight.setter
    def inWeight(self, value: float) -> float: ...
    @property
    def outTangent(self) -> float: ...
    @outTangent.setter
    def outTangent(self, value: float) -> float: ...
    @property
    def outWeight(self) -> float: ...
    @outWeight.setter
    def outWeight(self, value: float) -> float: ...
    @property
    def tangentMode(self) -> int: ...
    @tangentMode.setter
    def tangentMode(self, value: int) -> int: ...
    @property
    def time(self) -> float: ...
    @time.setter
    def time(self, value: float) -> float: ...
    @property
    def value(self) -> float: ...
    @value.setter
    def value(self, value: float) -> float: ...
    @property
    def weightedMode(self) -> WeightedMode: ...
    @weightedMode.setter
    def weightedMode(self, value: WeightedMode) -> WeightedMode: ...


class LayerMask:
    @property
    def value(self) -> int: ...
    @value.setter
    def value(self, value: int) -> int: ...
    @staticmethod
    def GetMask(layerNames: Array_1[str]) -> int: ...
    @staticmethod
    def LayerToName(layer: int) -> str: ...
    @staticmethod
    def NameToLayer(layerName: str) -> int: ...
    # Operator not supported op_Implicit(intVal: Int32)
    # Operator not supported op_Implicit(mask: LayerMask)


class LazyLoadReference_GenericClasses(abc.ABCMeta):
    Generic_LazyLoadReference_GenericClasses_LazyLoadReference_1_T = typing.TypeVar('Generic_LazyLoadReference_GenericClasses_LazyLoadReference_1_T')
    def __getitem__(self, types : typing.Type[Generic_LazyLoadReference_GenericClasses_LazyLoadReference_1_T]) -> typing.Type[LazyLoadReference_1[Generic_LazyLoadReference_GenericClasses_LazyLoadReference_1_T]]: ...

LazyLoadReference : LazyLoadReference_GenericClasses

LazyLoadReference_1_T = typing.TypeVar('LazyLoadReference_1_T')
class LazyLoadReference_1(typing.Generic[LazyLoadReference_1_T]):
    @typing.overload
    def __init__(self, asset: LazyLoadReference_1_T) -> None: ...
    @typing.overload
    def __init__(self, instanceID: int) -> None: ...
    @property
    def asset(self) -> LazyLoadReference_1_T: ...
    @asset.setter
    def asset(self, value: LazyLoadReference_1_T) -> LazyLoadReference_1_T: ...
    @property
    def instanceID(self) -> int: ...
    @instanceID.setter
    def instanceID(self, value: int) -> int: ...
    @property
    def isBroken(self) -> bool: ...
    @property
    def isSet(self) -> bool: ...
    # Operator not supported op_Implicit(instanceID: Int32)
    # Operator not supported op_Implicit(asset: T)


class LegDof(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    UpperLegFrontBack : LegDof # 0
    UpperLegInOut : LegDof # 1
    UpperLegRollInOut : LegDof # 2
    LegCloseOpen : LegDof # 3
    LegRollInOut : LegDof # 4
    FootCloseOpen : LegDof # 5
    FootInOut : LegDof # 6
    ToesUpDown : LegDof # 7
    LastLegDof : LegDof # 8


class LensFlare(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def brightness(self) -> float: ...
    @brightness.setter
    def brightness(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def color(self) -> Color: ...
    @color.setter
    def color(self, value: Color) -> Color: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def fadeSpeed(self) -> float: ...
    @fadeSpeed.setter
    def fadeSpeed(self, value: float) -> float: ...
    @property
    def flare(self) -> Flare: ...
    @flare.setter
    def flare(self, value: Flare) -> Flare: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class Light(Behaviour):
    def __init__(self) -> None: ...
    @property
    def alreadyLightmapped(self) -> bool: ...
    @alreadyLightmapped.setter
    def alreadyLightmapped(self, value: bool) -> bool: ...
    @property
    def animation(self) -> Component: ...
    @property
    def areaSize(self) -> Vector2: ...
    @areaSize.setter
    def areaSize(self, value: Vector2) -> Vector2: ...
    @property
    def attenuate(self) -> bool: ...
    @attenuate.setter
    def attenuate(self, value: bool) -> bool: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bakedIndex(self) -> int: ...
    @bakedIndex.setter
    def bakedIndex(self, value: int) -> int: ...
    @property
    def bakingOutput(self) -> LightBakingOutput: ...
    @bakingOutput.setter
    def bakingOutput(self, value: LightBakingOutput) -> LightBakingOutput: ...
    @property
    def bounceIntensity(self) -> float: ...
    @bounceIntensity.setter
    def bounceIntensity(self, value: float) -> float: ...
    @property
    def boundingSphereOverride(self) -> Vector4: ...
    @boundingSphereOverride.setter
    def boundingSphereOverride(self, value: Vector4) -> Vector4: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def color(self) -> Color: ...
    @color.setter
    def color(self, value: Color) -> Color: ...
    @property
    def colorTemperature(self) -> float: ...
    @colorTemperature.setter
    def colorTemperature(self, value: float) -> float: ...
    @property
    def commandBufferCount(self) -> int: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def cookie(self) -> Texture: ...
    @cookie.setter
    def cookie(self, value: Texture) -> Texture: ...
    @property
    def cookieSize(self) -> float: ...
    @cookieSize.setter
    def cookieSize(self, value: float) -> float: ...
    @property
    def cullingMask(self) -> int: ...
    @cullingMask.setter
    def cullingMask(self, value: int) -> int: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def flare(self) -> Flare: ...
    @flare.setter
    def flare(self, value: Flare) -> Flare: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def innerSpotAngle(self) -> float: ...
    @innerSpotAngle.setter
    def innerSpotAngle(self, value: float) -> float: ...
    @property
    def intensity(self) -> float: ...
    @intensity.setter
    def intensity(self, value: float) -> float: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def isBaked(self) -> bool: ...
    @property
    def layerShadowCullDistances(self) -> Array_1[float]: ...
    @layerShadowCullDistances.setter
    def layerShadowCullDistances(self, value: Array_1[float]) -> Array_1[float]: ...
    @property
    def light(self) -> Component: ...
    @property
    def lightmapBakeType(self) -> LightmapBakeType: ...
    @lightmapBakeType.setter
    def lightmapBakeType(self, value: LightmapBakeType) -> LightmapBakeType: ...
    @property
    def lightmappingMode(self) -> LightmappingMode: ...
    @lightmappingMode.setter
    def lightmappingMode(self, value: LightmappingMode) -> LightmappingMode: ...
    @property
    def lightShadowCasterMode(self) -> LightShadowCasterMode: ...
    @lightShadowCasterMode.setter
    def lightShadowCasterMode(self, value: LightShadowCasterMode) -> LightShadowCasterMode: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @classmethod
    @property
    def pixelLightCount(cls) -> int: ...
    @classmethod
    @pixelLightCount.setter
    def pixelLightCount(cls, value: int) -> int: ...
    @property
    def range(self) -> float: ...
    @range.setter
    def range(self, value: float) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def renderingLayerMask(self) -> int: ...
    @renderingLayerMask.setter
    def renderingLayerMask(self, value: int) -> int: ...
    @property
    def renderMode(self) -> LightRenderMode: ...
    @renderMode.setter
    def renderMode(self, value: LightRenderMode) -> LightRenderMode: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def shadowAngle(self) -> float: ...
    @shadowAngle.setter
    def shadowAngle(self, value: float) -> float: ...
    @property
    def shadowBias(self) -> float: ...
    @shadowBias.setter
    def shadowBias(self, value: float) -> float: ...
    @property
    def shadowConstantBias(self) -> float: ...
    @shadowConstantBias.setter
    def shadowConstantBias(self, value: float) -> float: ...
    @property
    def shadowCustomResolution(self) -> int: ...
    @shadowCustomResolution.setter
    def shadowCustomResolution(self, value: int) -> int: ...
    @property
    def shadowMatrixOverride(self) -> Matrix4x4: ...
    @shadowMatrixOverride.setter
    def shadowMatrixOverride(self, value: Matrix4x4) -> Matrix4x4: ...
    @property
    def shadowNearPlane(self) -> float: ...
    @shadowNearPlane.setter
    def shadowNearPlane(self, value: float) -> float: ...
    @property
    def shadowNormalBias(self) -> float: ...
    @shadowNormalBias.setter
    def shadowNormalBias(self, value: float) -> float: ...
    @property
    def shadowObjectSizeBias(self) -> float: ...
    @shadowObjectSizeBias.setter
    def shadowObjectSizeBias(self, value: float) -> float: ...
    @property
    def shadowRadius(self) -> float: ...
    @shadowRadius.setter
    def shadowRadius(self, value: float) -> float: ...
    @property
    def shadowResolution(self) -> LightShadowResolution: ...
    @shadowResolution.setter
    def shadowResolution(self, value: LightShadowResolution) -> LightShadowResolution: ...
    @property
    def shadows(self) -> LightShadows: ...
    @shadows.setter
    def shadows(self, value: LightShadows) -> LightShadows: ...
    @property
    def shadowSoftness(self) -> float: ...
    @shadowSoftness.setter
    def shadowSoftness(self, value: float) -> float: ...
    @property
    def shadowSoftnessFade(self) -> float: ...
    @shadowSoftnessFade.setter
    def shadowSoftnessFade(self, value: float) -> float: ...
    @property
    def shadowStrength(self) -> float: ...
    @shadowStrength.setter
    def shadowStrength(self, value: float) -> float: ...
    @property
    def shape(self) -> LightShape: ...
    @shape.setter
    def shape(self, value: LightShape) -> LightShape: ...
    @property
    def spotAngle(self) -> float: ...
    @spotAngle.setter
    def spotAngle(self, value: float) -> float: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def type(self) -> LightType: ...
    @type.setter
    def type(self, value: LightType) -> LightType: ...
    @property
    def useBoundingSphereOverride(self) -> bool: ...
    @useBoundingSphereOverride.setter
    def useBoundingSphereOverride(self, value: bool) -> bool: ...
    @property
    def useColorTemperature(self) -> bool: ...
    @useColorTemperature.setter
    def useColorTemperature(self, value: bool) -> bool: ...
    @property
    def useShadowMatrixOverride(self) -> bool: ...
    @useShadowMatrixOverride.setter
    def useShadowMatrixOverride(self, value: bool) -> bool: ...
    @property
    def useViewFrustumForShadowCasterCull(self) -> bool: ...
    @useViewFrustumForShadowCasterCull.setter
    def useViewFrustumForShadowCasterCull(self, value: bool) -> bool: ...
    def GetCommandBuffers(self, evt: LightEvent) -> Array_1[CommandBuffer]: ...
    @staticmethod
    def GetLights(type: LightType, layer: int) -> Array_1[Light]: ...
    def RemoveAllCommandBuffers(self) -> None: ...
    def RemoveCommandBuffer(self, evt: LightEvent, buffer: CommandBuffer) -> None: ...
    def RemoveCommandBuffers(self, evt: LightEvent) -> None: ...
    def Reset(self) -> None: ...
    def SetLightDirty(self) -> None: ...
    # Skipped AddCommandBuffer due to it being static, abstract and generic.

    AddCommandBuffer : AddCommandBuffer_MethodGroup
    class AddCommandBuffer_MethodGroup:
        @typing.overload
        def __call__(self, evt: LightEvent, buffer: CommandBuffer) -> None:...
        @typing.overload
        def __call__(self, evt: LightEvent, buffer: CommandBuffer, shadowPassMask: ShadowMapPass) -> None:...

    # Skipped AddCommandBufferAsync due to it being static, abstract and generic.

    AddCommandBufferAsync : AddCommandBufferAsync_MethodGroup
    class AddCommandBufferAsync_MethodGroup:
        @typing.overload
        def __call__(self, evt: LightEvent, buffer: CommandBuffer, queueType: ComputeQueueType) -> None:...
        @typing.overload
        def __call__(self, evt: LightEvent, buffer: CommandBuffer, shadowPassMask: ShadowMapPass, queueType: ComputeQueueType) -> None:...



class LightBakingOutput:
    isBaked : bool
    lightmapBakeType : LightmapBakeType
    mixedLightingMode : MixedLightingMode
    occlusionMaskChannel : int
    probeOcclusionLightIndex : int


class LightingSettings(Object):
    def __init__(self) -> None: ...
    @property
    def albedoBoost(self) -> float: ...
    @albedoBoost.setter
    def albedoBoost(self, value: float) -> float: ...
    @property
    def ao(self) -> bool: ...
    @ao.setter
    def ao(self, value: bool) -> bool: ...
    @property
    def aoExponentDirect(self) -> float: ...
    @aoExponentDirect.setter
    def aoExponentDirect(self, value: float) -> float: ...
    @property
    def aoExponentIndirect(self) -> float: ...
    @aoExponentIndirect.setter
    def aoExponentIndirect(self, value: float) -> float: ...
    @property
    def aoMaxDistance(self) -> float: ...
    @aoMaxDistance.setter
    def aoMaxDistance(self, value: float) -> float: ...
    @property
    def autoGenerate(self) -> bool: ...
    @autoGenerate.setter
    def autoGenerate(self, value: bool) -> bool: ...
    @property
    def bakedGI(self) -> bool: ...
    @bakedGI.setter
    def bakedGI(self, value: bool) -> bool: ...
    @property
    def bounces(self) -> int: ...
    @bounces.setter
    def bounces(self, value: int) -> int: ...
    @property
    def compressLightmaps(self) -> bool: ...
    @compressLightmaps.setter
    def compressLightmaps(self, value: bool) -> bool: ...
    @property
    def denoiserTypeAO(self) -> LightingSettings.DenoiserType: ...
    @denoiserTypeAO.setter
    def denoiserTypeAO(self, value: LightingSettings.DenoiserType) -> LightingSettings.DenoiserType: ...
    @property
    def denoiserTypeDirect(self) -> LightingSettings.DenoiserType: ...
    @denoiserTypeDirect.setter
    def denoiserTypeDirect(self, value: LightingSettings.DenoiserType) -> LightingSettings.DenoiserType: ...
    @property
    def denoiserTypeIndirect(self) -> LightingSettings.DenoiserType: ...
    @denoiserTypeIndirect.setter
    def denoiserTypeIndirect(self, value: LightingSettings.DenoiserType) -> LightingSettings.DenoiserType: ...
    @property
    def directionalityMode(self) -> LightmapsMode: ...
    @directionalityMode.setter
    def directionalityMode(self, value: LightmapsMode) -> LightmapsMode: ...
    @property
    def directSampleCount(self) -> int: ...
    @directSampleCount.setter
    def directSampleCount(self, value: int) -> int: ...
    @property
    def environmentImportanceSampling(self) -> bool: ...
    @environmentImportanceSampling.setter
    def environmentImportanceSampling(self, value: bool) -> bool: ...
    @property
    def environmentSampleCount(self) -> int: ...
    @environmentSampleCount.setter
    def environmentSampleCount(self, value: int) -> int: ...
    @property
    def exportTrainingData(self) -> bool: ...
    @exportTrainingData.setter
    def exportTrainingData(self, value: bool) -> bool: ...
    @property
    def extractAO(self) -> bool: ...
    @extractAO.setter
    def extractAO(self, value: bool) -> bool: ...
    @property
    def filteringAtrousPositionSigmaAO(self) -> float: ...
    @filteringAtrousPositionSigmaAO.setter
    def filteringAtrousPositionSigmaAO(self, value: float) -> float: ...
    @property
    def filteringAtrousPositionSigmaDirect(self) -> float: ...
    @filteringAtrousPositionSigmaDirect.setter
    def filteringAtrousPositionSigmaDirect(self, value: float) -> float: ...
    @property
    def filteringAtrousPositionSigmaIndirect(self) -> float: ...
    @filteringAtrousPositionSigmaIndirect.setter
    def filteringAtrousPositionSigmaIndirect(self, value: float) -> float: ...
    @property
    def filteringGaussianRadiusAO(self) -> float: ...
    @filteringGaussianRadiusAO.setter
    def filteringGaussianRadiusAO(self, value: float) -> float: ...
    @property
    def filteringGaussianRadiusDirect(self) -> float: ...
    @filteringGaussianRadiusDirect.setter
    def filteringGaussianRadiusDirect(self, value: float) -> float: ...
    @property
    def filteringGaussianRadiusIndirect(self) -> float: ...
    @filteringGaussianRadiusIndirect.setter
    def filteringGaussianRadiusIndirect(self, value: float) -> float: ...
    @property
    def filteringGaussRadiusAO(self) -> int: ...
    @filteringGaussRadiusAO.setter
    def filteringGaussRadiusAO(self, value: int) -> int: ...
    @property
    def filteringGaussRadiusDirect(self) -> int: ...
    @filteringGaussRadiusDirect.setter
    def filteringGaussRadiusDirect(self, value: int) -> int: ...
    @property
    def filteringGaussRadiusIndirect(self) -> int: ...
    @filteringGaussRadiusIndirect.setter
    def filteringGaussRadiusIndirect(self, value: int) -> int: ...
    @property
    def filteringMode(self) -> LightingSettings.FilterMode: ...
    @filteringMode.setter
    def filteringMode(self, value: LightingSettings.FilterMode) -> LightingSettings.FilterMode: ...
    @property
    def filterTypeAO(self) -> LightingSettings.FilterType: ...
    @filterTypeAO.setter
    def filterTypeAO(self, value: LightingSettings.FilterType) -> LightingSettings.FilterType: ...
    @property
    def filterTypeDirect(self) -> LightingSettings.FilterType: ...
    @filterTypeDirect.setter
    def filterTypeDirect(self, value: LightingSettings.FilterType) -> LightingSettings.FilterType: ...
    @property
    def filterTypeIndirect(self) -> LightingSettings.FilterType: ...
    @filterTypeIndirect.setter
    def filterTypeIndirect(self, value: LightingSettings.FilterType) -> LightingSettings.FilterType: ...
    @property
    def finalGather(self) -> bool: ...
    @finalGather.setter
    def finalGather(self, value: bool) -> bool: ...
    @property
    def finalGatherFiltering(self) -> bool: ...
    @finalGatherFiltering.setter
    def finalGatherFiltering(self, value: bool) -> bool: ...
    @property
    def finalGatherRayCount(self) -> float: ...
    @finalGatherRayCount.setter
    def finalGatherRayCount(self, value: float) -> float: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def indirectResolution(self) -> float: ...
    @indirectResolution.setter
    def indirectResolution(self, value: float) -> float: ...
    @property
    def indirectSampleCount(self) -> int: ...
    @indirectSampleCount.setter
    def indirectSampleCount(self, value: int) -> int: ...
    @property
    def indirectScale(self) -> float: ...
    @indirectScale.setter
    def indirectScale(self, value: float) -> float: ...
    @property
    def lightmapCompression(self) -> LightmapCompression: ...
    @lightmapCompression.setter
    def lightmapCompression(self, value: LightmapCompression) -> LightmapCompression: ...
    @property
    def lightmapMaxSize(self) -> int: ...
    @lightmapMaxSize.setter
    def lightmapMaxSize(self, value: int) -> int: ...
    @property
    def lightmapPadding(self) -> int: ...
    @lightmapPadding.setter
    def lightmapPadding(self, value: int) -> int: ...
    @property
    def lightmapper(self) -> LightingSettings.Lightmapper: ...
    @lightmapper.setter
    def lightmapper(self, value: LightingSettings.Lightmapper) -> LightingSettings.Lightmapper: ...
    @property
    def lightmapResolution(self) -> float: ...
    @lightmapResolution.setter
    def lightmapResolution(self, value: float) -> float: ...
    @property
    def lightProbeSampleCountMultiplier(self) -> float: ...
    @lightProbeSampleCountMultiplier.setter
    def lightProbeSampleCountMultiplier(self, value: float) -> float: ...
    @property
    def maxBounces(self) -> int: ...
    @maxBounces.setter
    def maxBounces(self, value: int) -> int: ...
    @property
    def minBounces(self) -> int: ...
    @minBounces.setter
    def minBounces(self, value: int) -> int: ...
    @property
    def mixedBakeMode(self) -> MixedLightingMode: ...
    @mixedBakeMode.setter
    def mixedBakeMode(self, value: MixedLightingMode) -> MixedLightingMode: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def prioritizeView(self) -> bool: ...
    @prioritizeView.setter
    def prioritizeView(self, value: bool) -> bool: ...
    @property
    def realtimeEnvironmentLighting(self) -> bool: ...
    @realtimeEnvironmentLighting.setter
    def realtimeEnvironmentLighting(self, value: bool) -> bool: ...
    @property
    def realtimeGI(self) -> bool: ...
    @realtimeGI.setter
    def realtimeGI(self, value: bool) -> bool: ...
    @property
    def respectSceneVisibilityWhenBakingGI(self) -> bool: ...
    @respectSceneVisibilityWhenBakingGI.setter
    def respectSceneVisibilityWhenBakingGI(self, value: bool) -> bool: ...
    @property
    def russianRouletteStartBounce(self) -> int: ...
    @russianRouletteStartBounce.setter
    def russianRouletteStartBounce(self, value: int) -> int: ...
    @property
    def sampling(self) -> LightingSettings.Sampling: ...
    @sampling.setter
    def sampling(self, value: LightingSettings.Sampling) -> LightingSettings.Sampling: ...
    @property
    def trainingDataDestination(self) -> str: ...
    @trainingDataDestination.setter
    def trainingDataDestination(self, value: str) -> str: ...

    class DenoiserType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        None_ : LightingSettings.DenoiserType # 0
        Optix : LightingSettings.DenoiserType # 1
        OpenImage : LightingSettings.DenoiserType # 2
        RadeonPro : LightingSettings.DenoiserType # 3


    class FilterMode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        None_ : LightingSettings.FilterMode # 0
        Auto : LightingSettings.FilterMode # 1
        Advanced : LightingSettings.FilterMode # 2


    class FilterType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Gaussian : LightingSettings.FilterType # 0
        ATrous : LightingSettings.FilterType # 1
        None_ : LightingSettings.FilterType # 2


    class Lightmapper(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Enlighten : LightingSettings.Lightmapper # 0
        ProgressiveCPU : LightingSettings.Lightmapper # 1
        ProgressiveGPU : LightingSettings.Lightmapper # 2


    class Sampling(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Auto : LightingSettings.Sampling # 0
        Fixed : LightingSettings.Sampling # 1



class LightmapBakeType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Mixed : LightmapBakeType # 1
    Baked : LightmapBakeType # 2
    Realtime : LightmapBakeType # 4


class LightmapCompression(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : LightmapCompression # 0
    LowQuality : LightmapCompression # 1
    NormalQuality : LightmapCompression # 2
    HighQuality : LightmapCompression # 3


class LightmapData:
    def __init__(self) -> None: ...
    @property
    def lightmap(self) -> Texture2D: ...
    @lightmap.setter
    def lightmap(self, value: Texture2D) -> Texture2D: ...
    @property
    def lightmapColor(self) -> Texture2D: ...
    @lightmapColor.setter
    def lightmapColor(self, value: Texture2D) -> Texture2D: ...
    @property
    def lightmapDir(self) -> Texture2D: ...
    @lightmapDir.setter
    def lightmapDir(self, value: Texture2D) -> Texture2D: ...
    @property
    def lightmapFar(self) -> Texture2D: ...
    @lightmapFar.setter
    def lightmapFar(self, value: Texture2D) -> Texture2D: ...
    @property
    def lightmapLight(self) -> Texture2D: ...
    @lightmapLight.setter
    def lightmapLight(self, value: Texture2D) -> Texture2D: ...
    @property
    def lightmapNear(self) -> Texture2D: ...
    @lightmapNear.setter
    def lightmapNear(self, value: Texture2D) -> Texture2D: ...
    @property
    def shadowMask(self) -> Texture2D: ...
    @shadowMask.setter
    def shadowMask(self, value: Texture2D) -> Texture2D: ...


class LightmappingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Mixed : LightmappingMode # 1
    Baked : LightmappingMode # 2
    Realtime : LightmappingMode # 4


class LightmapSettings(Object):
    @classmethod
    @property
    def bakedColorSpace(cls) -> ColorSpace: ...
    @classmethod
    @bakedColorSpace.setter
    def bakedColorSpace(cls, value: ColorSpace) -> ColorSpace: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @classmethod
    @property
    def lightmaps(cls) -> Array_1[LightmapData]: ...
    @classmethod
    @lightmaps.setter
    def lightmaps(cls, value: Array_1[LightmapData]) -> Array_1[LightmapData]: ...
    @classmethod
    @property
    def lightmapsMode(cls) -> LightmapsMode: ...
    @classmethod
    @lightmapsMode.setter
    def lightmapsMode(cls, value: LightmapsMode) -> LightmapsMode: ...
    @classmethod
    @property
    def lightmapsModeLegacy(cls) -> LightmapsModeLegacy: ...
    @classmethod
    @lightmapsModeLegacy.setter
    def lightmapsModeLegacy(cls, value: LightmapsModeLegacy) -> LightmapsModeLegacy: ...
    @classmethod
    @property
    def lightProbes(cls) -> LightProbes: ...
    @classmethod
    @lightProbes.setter
    def lightProbes(cls, value: LightProbes) -> LightProbes: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...


class LightmapsMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Single : LightmapsMode # 0
    NonDirectional : LightmapsMode # 0
    CombinedDirectional : LightmapsMode # 1
    Dual : LightmapsMode # 1
    SeparateDirectional : LightmapsMode # 2
    Directional : LightmapsMode # 2


class LightmapsModeLegacy(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Single : LightmapsModeLegacy # 0
    Dual : LightmapsModeLegacy # 1
    Directional : LightmapsModeLegacy # 2


class LightProbeGroup(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def dering(self) -> bool: ...
    @dering.setter
    def dering(self, value: bool) -> bool: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def probePositions(self) -> Array_1[Vector3]: ...
    @probePositions.setter
    def probePositions(self, value: Array_1[Vector3]) -> Array_1[Vector3]: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class LightProbeProxyVolume(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def boundingBoxMode(self) -> LightProbeProxyVolume.BoundingBoxMode: ...
    @boundingBoxMode.setter
    def boundingBoxMode(self, value: LightProbeProxyVolume.BoundingBoxMode) -> LightProbeProxyVolume.BoundingBoxMode: ...
    @property
    def boundsGlobal(self) -> Bounds: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def dataFormat(self) -> LightProbeProxyVolume.DataFormat: ...
    @dataFormat.setter
    def dataFormat(self, value: LightProbeProxyVolume.DataFormat) -> LightProbeProxyVolume.DataFormat: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def gridResolutionX(self) -> int: ...
    @gridResolutionX.setter
    def gridResolutionX(self, value: int) -> int: ...
    @property
    def gridResolutionY(self) -> int: ...
    @gridResolutionY.setter
    def gridResolutionY(self, value: int) -> int: ...
    @property
    def gridResolutionZ(self) -> int: ...
    @gridResolutionZ.setter
    def gridResolutionZ(self, value: int) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @classmethod
    @property
    def isFeatureSupported(cls) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def originCustom(self) -> Vector3: ...
    @originCustom.setter
    def originCustom(self, value: Vector3) -> Vector3: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def probeDensity(self) -> float: ...
    @probeDensity.setter
    def probeDensity(self, value: float) -> float: ...
    @property
    def probePositionMode(self) -> LightProbeProxyVolume.ProbePositionMode: ...
    @probePositionMode.setter
    def probePositionMode(self, value: LightProbeProxyVolume.ProbePositionMode) -> LightProbeProxyVolume.ProbePositionMode: ...
    @property
    def qualityMode(self) -> LightProbeProxyVolume.QualityMode: ...
    @qualityMode.setter
    def qualityMode(self, value: LightProbeProxyVolume.QualityMode) -> LightProbeProxyVolume.QualityMode: ...
    @property
    def refreshMode(self) -> LightProbeProxyVolume.RefreshMode: ...
    @refreshMode.setter
    def refreshMode(self, value: LightProbeProxyVolume.RefreshMode) -> LightProbeProxyVolume.RefreshMode: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def resolutionMode(self) -> LightProbeProxyVolume.ResolutionMode: ...
    @resolutionMode.setter
    def resolutionMode(self, value: LightProbeProxyVolume.ResolutionMode) -> LightProbeProxyVolume.ResolutionMode: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def sizeCustom(self) -> Vector3: ...
    @sizeCustom.setter
    def sizeCustom(self, value: Vector3) -> Vector3: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    def Update(self) -> None: ...

    class BoundingBoxMode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        AutomaticLocal : LightProbeProxyVolume.BoundingBoxMode # 0
        AutomaticWorld : LightProbeProxyVolume.BoundingBoxMode # 1
        Custom : LightProbeProxyVolume.BoundingBoxMode # 2


    class DataFormat(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        HalfFloat : LightProbeProxyVolume.DataFormat # 0
        Float : LightProbeProxyVolume.DataFormat # 1


    class ProbePositionMode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        CellCorner : LightProbeProxyVolume.ProbePositionMode # 0
        CellCenter : LightProbeProxyVolume.ProbePositionMode # 1


    class QualityMode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Low : LightProbeProxyVolume.QualityMode # 0
        Normal : LightProbeProxyVolume.QualityMode # 1


    class RefreshMode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Automatic : LightProbeProxyVolume.RefreshMode # 0
        EveryFrame : LightProbeProxyVolume.RefreshMode # 1
        ViaScripting : LightProbeProxyVolume.RefreshMode # 2


    class ResolutionMode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Automatic : LightProbeProxyVolume.ResolutionMode # 0
        Custom : LightProbeProxyVolume.ResolutionMode # 1



class LightProbes(Object):
    @property
    def bakedProbes(self) -> Array_1[SphericalHarmonicsL2]: ...
    @bakedProbes.setter
    def bakedProbes(self, value: Array_1[SphericalHarmonicsL2]) -> Array_1[SphericalHarmonicsL2]: ...
    @property
    def cellCount(self) -> int: ...
    @property
    def coefficients(self) -> Array_1[float]: ...
    @coefficients.setter
    def coefficients(self, value: Array_1[float]) -> Array_1[float]: ...
    @property
    def count(self) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def positions(self) -> Array_1[Vector3]: ...
    def GetInterpolatedLightProbe(self, position: Vector3, renderer: Renderer, coefficients: Array_1[float]) -> None: ...
    @staticmethod
    def GetInterpolatedProbe(position: Vector3, renderer: Renderer, probe: clr.Reference[SphericalHarmonicsL2]) -> None: ...
    @staticmethod
    def Tetrahedralize() -> None: ...
    @staticmethod
    def TetrahedralizeAsync() -> None: ...
    # Skipped CalculateInterpolatedLightAndOcclusionProbes due to it being static, abstract and generic.

    CalculateInterpolatedLightAndOcclusionProbes : CalculateInterpolatedLightAndOcclusionProbes_MethodGroup
    class CalculateInterpolatedLightAndOcclusionProbes_MethodGroup:
        @typing.overload
        def __call__(self, positions: Array_1[Vector3], lightProbes: Array_1[SphericalHarmonicsL2], occlusionProbes: Array_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, positions: List_1[Vector3], lightProbes: List_1[SphericalHarmonicsL2], occlusionProbes: List_1[Vector4]) -> None:...



class LightProbesQuery(IDisposable):
    def __init__(self, allocator: Allocator) -> None: ...
    @property
    def IsCreated(self) -> bool: ...
    def CalculateInterpolatedLightAndOcclusionProbe(self, position: Vector3, tetrahedronIndex: clr.Reference[int], lightProbe: clr.Reference[SphericalHarmonicsL2], occlusionProbe: clr.Reference[Vector4]) -> None: ...
    def CalculateInterpolatedLightAndOcclusionProbes(self, positions: NativeArray_1[Vector3], tetrahedronIndices: NativeArray_1[int], lightProbes: NativeArray_1[SphericalHarmonicsL2], occlusionProbes: NativeArray_1[Vector4]) -> None: ...
    # Skipped Dispose due to it being static, abstract and generic.

    Dispose : Dispose_MethodGroup
    class Dispose_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, inputDeps: JobHandle) -> JobHandle:...



class LightRenderMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Auto : LightRenderMode # 0
    ForcePixel : LightRenderMode # 1
    ForceVertex : LightRenderMode # 2


class LightShadowCasterMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Default : LightShadowCasterMode # 0
    NonLightmappedOnly : LightShadowCasterMode # 1
    Everything : LightShadowCasterMode # 2


class LightShadows(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : LightShadows # 0
    Hard : LightShadows # 1
    Soft : LightShadows # 2


class LightShape(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Cone : LightShape # 0
    Pyramid : LightShape # 1
    Box : LightShape # 2


class LightType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Spot : LightType # 0
    Directional : LightType # 1
    Point : LightType # 2
    Area : LightType # 3
    Rectangle : LightType # 3
    Disc : LightType # 4


class LineAlignment(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    View : LineAlignment # 0
    Local : LineAlignment # 1
    TransformZ : LineAlignment # 1


class LineRenderer(Renderer):
    def __init__(self) -> None: ...
    @property
    def alignment(self) -> LineAlignment: ...
    @alignment.setter
    def alignment(self, value: LineAlignment) -> LineAlignment: ...
    @property
    def allowOcclusionWhenDynamic(self) -> bool: ...
    @allowOcclusionWhenDynamic.setter
    def allowOcclusionWhenDynamic(self, value: bool) -> bool: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounds(self) -> Bounds: ...
    @bounds.setter
    def bounds(self, value: Bounds) -> Bounds: ...
    @property
    def camera(self) -> Component: ...
    @property
    def castShadows(self) -> bool: ...
    @castShadows.setter
    def castShadows(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def colorGradient(self) -> Gradient: ...
    @colorGradient.setter
    def colorGradient(self, value: Gradient) -> Gradient: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def endColor(self) -> Color: ...
    @endColor.setter
    def endColor(self, value: Color) -> Color: ...
    @property
    def endWidth(self) -> float: ...
    @endWidth.setter
    def endWidth(self, value: float) -> float: ...
    @property
    def forceRenderingOff(self) -> bool: ...
    @forceRenderingOff.setter
    def forceRenderingOff(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def generateLightingData(self) -> bool: ...
    @generateLightingData.setter
    def generateLightingData(self, value: bool) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isPartOfStaticBatch(self) -> bool: ...
    @property
    def isVisible(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def lightmapIndex(self) -> int: ...
    @lightmapIndex.setter
    def lightmapIndex(self, value: int) -> int: ...
    @property
    def lightmapScaleOffset(self) -> Vector4: ...
    @lightmapScaleOffset.setter
    def lightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightmapTilingOffset(self) -> Vector4: ...
    @lightmapTilingOffset.setter
    def lightmapTilingOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightProbeAnchor(self) -> Transform: ...
    @lightProbeAnchor.setter
    def lightProbeAnchor(self, value: Transform) -> Transform: ...
    @property
    def lightProbeProxyVolumeOverride(self) -> GameObject: ...
    @lightProbeProxyVolumeOverride.setter
    def lightProbeProxyVolumeOverride(self, value: GameObject) -> GameObject: ...
    @property
    def lightProbeUsage(self) -> LightProbeUsage: ...
    @lightProbeUsage.setter
    def lightProbeUsage(self, value: LightProbeUsage) -> LightProbeUsage: ...
    @property
    def localBounds(self) -> Bounds: ...
    @localBounds.setter
    def localBounds(self, value: Bounds) -> Bounds: ...
    @property
    def localToWorldMatrix(self) -> Matrix4x4: ...
    @property
    def loop(self) -> bool: ...
    @loop.setter
    def loop(self, value: bool) -> bool: ...
    @property
    def maskInteraction(self) -> SpriteMaskInteraction: ...
    @maskInteraction.setter
    def maskInteraction(self, value: SpriteMaskInteraction) -> SpriteMaskInteraction: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> Material: ...
    @property
    def materials(self) -> Array_1[Material]: ...
    @materials.setter
    def materials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def motionVectorGenerationMode(self) -> MotionVectorGenerationMode: ...
    @motionVectorGenerationMode.setter
    def motionVectorGenerationMode(self, value: MotionVectorGenerationMode) -> MotionVectorGenerationMode: ...
    @property
    def motionVectors(self) -> bool: ...
    @motionVectors.setter
    def motionVectors(self, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def numCapVertices(self) -> int: ...
    @numCapVertices.setter
    def numCapVertices(self, value: int) -> int: ...
    @property
    def numCornerVertices(self) -> int: ...
    @numCornerVertices.setter
    def numCornerVertices(self, value: int) -> int: ...
    @property
    def numPositions(self) -> int: ...
    @numPositions.setter
    def numPositions(self, value: int) -> int: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def positionCount(self) -> int: ...
    @positionCount.setter
    def positionCount(self, value: int) -> int: ...
    @property
    def probeAnchor(self) -> Transform: ...
    @probeAnchor.setter
    def probeAnchor(self, value: Transform) -> Transform: ...
    @property
    def rayTracingMode(self) -> RayTracingMode: ...
    @rayTracingMode.setter
    def rayTracingMode(self, value: RayTracingMode) -> RayTracingMode: ...
    @property
    def realtimeLightmapIndex(self) -> int: ...
    @realtimeLightmapIndex.setter
    def realtimeLightmapIndex(self, value: int) -> int: ...
    @property
    def realtimeLightmapScaleOffset(self) -> Vector4: ...
    @realtimeLightmapScaleOffset.setter
    def realtimeLightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def receiveShadows(self) -> bool: ...
    @receiveShadows.setter
    def receiveShadows(self, value: bool) -> bool: ...
    @property
    def reflectionProbeUsage(self) -> ReflectionProbeUsage: ...
    @reflectionProbeUsage.setter
    def reflectionProbeUsage(self, value: ReflectionProbeUsage) -> ReflectionProbeUsage: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rendererPriority(self) -> int: ...
    @rendererPriority.setter
    def rendererPriority(self, value: int) -> int: ...
    @property
    def renderingLayerMask(self) -> int: ...
    @renderingLayerMask.setter
    def renderingLayerMask(self, value: int) -> int: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def shadowBias(self) -> float: ...
    @shadowBias.setter
    def shadowBias(self, value: float) -> float: ...
    @property
    def shadowCastingMode(self) -> ShadowCastingMode: ...
    @shadowCastingMode.setter
    def shadowCastingMode(self, value: ShadowCastingMode) -> ShadowCastingMode: ...
    @property
    def sharedMaterial(self) -> Material: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: Material) -> Material: ...
    @property
    def sharedMaterials(self) -> Array_1[Material]: ...
    @sharedMaterials.setter
    def sharedMaterials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def sortingLayerID(self) -> int: ...
    @sortingLayerID.setter
    def sortingLayerID(self, value: int) -> int: ...
    @property
    def sortingLayerName(self) -> str: ...
    @sortingLayerName.setter
    def sortingLayerName(self, value: str) -> str: ...
    @property
    def sortingOrder(self) -> int: ...
    @sortingOrder.setter
    def sortingOrder(self, value: int) -> int: ...
    @property
    def startColor(self) -> Color: ...
    @startColor.setter
    def startColor(self, value: Color) -> Color: ...
    @property
    def startWidth(self) -> float: ...
    @startWidth.setter
    def startWidth(self, value: float) -> float: ...
    @property
    def staticShadowCaster(self) -> bool: ...
    @staticShadowCaster.setter
    def staticShadowCaster(self, value: bool) -> bool: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def textureMode(self) -> LineTextureMode: ...
    @textureMode.setter
    def textureMode(self, value: LineTextureMode) -> LineTextureMode: ...
    @property
    def textureScale(self) -> Vector2: ...
    @textureScale.setter
    def textureScale(self, value: Vector2) -> Vector2: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useLightProbes(self) -> bool: ...
    @useLightProbes.setter
    def useLightProbes(self, value: bool) -> bool: ...
    @property
    def useWorldSpace(self) -> bool: ...
    @useWorldSpace.setter
    def useWorldSpace(self, value: bool) -> bool: ...
    @property
    def widthCurve(self) -> AnimationCurve: ...
    @widthCurve.setter
    def widthCurve(self, value: AnimationCurve) -> AnimationCurve: ...
    @property
    def widthMultiplier(self) -> float: ...
    @widthMultiplier.setter
    def widthMultiplier(self, value: float) -> float: ...
    @property
    def worldToLocalMatrix(self) -> Matrix4x4: ...
    def GetPosition(self, index: int) -> Vector3: ...
    def SetColors(self, start: Color, end: Color) -> None: ...
    def SetPosition(self, index: int, position: Vector3) -> None: ...
    def SetVertexCount(self, count: int) -> None: ...
    def SetWidth(self, start: float, end: float) -> None: ...
    def Simplify(self, tolerance: float) -> None: ...
    # Skipped BakeMesh due to it being static, abstract and generic.

    BakeMesh : BakeMesh_MethodGroup
    class BakeMesh_MethodGroup:
        @typing.overload
        def __call__(self, mesh: Mesh, useTransform: bool = ...) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, camera: Camera, useTransform: bool = ...) -> None:...

    # Skipped GetPositions due to it being static, abstract and generic.

    GetPositions : GetPositions_MethodGroup
    class GetPositions_MethodGroup:
        @typing.overload
        def __call__(self, positions: Array_1[Vector3]) -> int:...
        @typing.overload
        def __call__(self, positions: NativeArray_1[Vector3]) -> int:...
        @typing.overload
        def __call__(self, positions: NativeSlice_1[Vector3]) -> int:...

    # Skipped SetPositions due to it being static, abstract and generic.

    SetPositions : SetPositions_MethodGroup
    class SetPositions_MethodGroup:
        @typing.overload
        def __call__(self, positions: Array_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, positions: NativeArray_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, positions: NativeSlice_1[Vector3]) -> None:...



class LineTextureMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Stretch : LineTextureMode # 0
    Tile : LineTextureMode # 1
    DistributePerSegment : LineTextureMode # 2
    RepeatPerSegment : LineTextureMode # 3
    Static : LineTextureMode # 4


class LineUtility:
    def __init__(self) -> None: ...
    # Skipped Simplify due to it being static, abstract and generic.

    Simplify : Simplify_MethodGroup
    class Simplify_MethodGroup:
        @typing.overload
        def __call__(self, points: List_1[Vector3], tolerance: float, pointsToKeep: List_1[int]) -> None:...
        @typing.overload
        def __call__(self, points: List_1[Vector2], tolerance: float, pointsToKeep: List_1[int]) -> None:...
        @typing.overload
        def __call__(self, points: List_1[Vector3], tolerance: float, simplifiedPoints: List_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, points: List_1[Vector2], tolerance: float, simplifiedPoints: List_1[Vector2]) -> None:...



class LocalizationAsset(Object):
    def __init__(self) -> None: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def isEditorAsset(self) -> bool: ...
    @isEditorAsset.setter
    def isEditorAsset(self, value: bool) -> bool: ...
    @property
    def localeIsoCode(self) -> str: ...
    @localeIsoCode.setter
    def localeIsoCode(self, value: str) -> str: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    def GetLocalizedString(self, original: str) -> str: ...
    def SetLocalizedString(self, original: str, localized: str) -> None: ...


class LocationInfo:
    @property
    def altitude(self) -> float: ...
    @property
    def horizontalAccuracy(self) -> float: ...
    @property
    def latitude(self) -> float: ...
    @property
    def longitude(self) -> float: ...
    @property
    def timestamp(self) -> float: ...
    @property
    def verticalAccuracy(self) -> float: ...


class LocationService:
    def __init__(self) -> None: ...
    @property
    def isEnabledByUser(self) -> bool: ...
    @property
    def lastData(self) -> LocationInfo: ...
    @property
    def status(self) -> LocationServiceStatus: ...
    def Stop(self) -> None: ...
    # Skipped Start due to it being static, abstract and generic.

    Start : Start_MethodGroup
    class Start_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, desiredAccuracyInMeters: float) -> None:...
        @typing.overload
        def __call__(self, desiredAccuracyInMeters: float, updateDistanceInMeters: float) -> None:...



class LocationServiceStatus(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Stopped : LocationServiceStatus # 0
    Initializing : LocationServiceStatus # 1
    Running : LocationServiceStatus # 2
    Failed : LocationServiceStatus # 3


class LOD:
    def __init__(self, screenRelativeTransitionHeight: float, renderers: Array_1[Renderer]) -> None: ...
    fadeTransitionWidth : float
    renderers : Array_1[Renderer]
    screenRelativeTransitionHeight : float


class LODFadeMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : LODFadeMode # 0
    CrossFade : LODFadeMode # 1
    SpeedTree : LODFadeMode # 2


class LODGroup(Component):
    def __init__(self) -> None: ...
    @property
    def animateCrossFading(self) -> bool: ...
    @animateCrossFading.setter
    def animateCrossFading(self, value: bool) -> bool: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @classmethod
    @property
    def crossFadeAnimationDuration(cls) -> float: ...
    @classmethod
    @crossFadeAnimationDuration.setter
    def crossFadeAnimationDuration(cls, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def fadeMode(self) -> LODFadeMode: ...
    @fadeMode.setter
    def fadeMode(self, value: LODFadeMode) -> LODFadeMode: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def lastLODBillboard(self) -> bool: ...
    @lastLODBillboard.setter
    def lastLODBillboard(self, value: bool) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def localReferencePoint(self) -> Vector3: ...
    @localReferencePoint.setter
    def localReferencePoint(self, value: Vector3) -> Vector3: ...
    @property
    def lodCount(self) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def size(self) -> float: ...
    @size.setter
    def size(self, value: float) -> float: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    def ForceLOD(self, index: int) -> None: ...
    def GetLODs(self) -> Array_1[LOD]: ...
    def RecalculateBounds(self) -> None: ...
    def SetLODs(self, lods: Array_1[LOD]) -> None: ...
    def SetLODS(self, lods: Array_1[LOD]) -> None: ...


class Logger(ILogger):
    def __init__(self, logHandler: ILogHandler) -> None: ...
    @property
    def filterLogType(self) -> LogType: ...
    @filterLogType.setter
    def filterLogType(self, value: LogType) -> LogType: ...
    @property
    def logEnabled(self) -> bool: ...
    @logEnabled.setter
    def logEnabled(self, value: bool) -> bool: ...
    @property
    def logHandler(self) -> ILogHandler: ...
    @logHandler.setter
    def logHandler(self, value: ILogHandler) -> ILogHandler: ...
    def IsLogTypeAllowed(self, logType: LogType) -> bool: ...
    # Skipped Log due to it being static, abstract and generic.

    Log : Log_MethodGroup
    class Log_MethodGroup:
        @typing.overload
        def __call__(self, message: typing.Any) -> None:...
        @typing.overload
        def __call__(self, logType: LogType, message: typing.Any) -> None:...
        @typing.overload
        def __call__(self, tag: str, message: typing.Any) -> None:...
        @typing.overload
        def __call__(self, logType: LogType, tag: str, message: typing.Any) -> None:...
        @typing.overload
        def __call__(self, logType: LogType, message: typing.Any, context: Object) -> None:...
        @typing.overload
        def __call__(self, tag: str, message: typing.Any, context: Object) -> None:...
        @typing.overload
        def __call__(self, logType: LogType, tag: str, message: typing.Any, context: Object) -> None:...

    # Skipped LogError due to it being static, abstract and generic.

    LogError : LogError_MethodGroup
    class LogError_MethodGroup:
        @typing.overload
        def __call__(self, tag: str, message: typing.Any) -> None:...
        @typing.overload
        def __call__(self, tag: str, message: typing.Any, context: Object) -> None:...

    # Skipped LogException due to it being static, abstract and generic.

    LogException : LogException_MethodGroup
    class LogException_MethodGroup:
        @typing.overload
        def __call__(self, exception: Exception) -> None:...
        @typing.overload
        def __call__(self, exception: Exception, context: Object) -> None:...

    # Skipped LogFormat due to it being static, abstract and generic.

    LogFormat : LogFormat_MethodGroup
    class LogFormat_MethodGroup:
        @typing.overload
        def __call__(self, logType: LogType, format: str, args: Array_1[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, logType: LogType, context: Object, format: str, args: Array_1[typing.Any]) -> None:...

    # Skipped LogWarning due to it being static, abstract and generic.

    LogWarning : LogWarning_MethodGroup
    class LogWarning_MethodGroup:
        @typing.overload
        def __call__(self, tag: str, message: typing.Any) -> None:...
        @typing.overload
        def __call__(self, tag: str, message: typing.Any, context: Object) -> None:...



class LogOption(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : LogOption # 0
    NoStacktrace : LogOption # 1


class LogType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Error : LogType # 0
    Assert : LogType # 1
    Warning : LogType # 2
    Log : LogType # 3
    Exception : LogType # 4


class MasterServer:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def dedicatedServer(cls) -> bool: ...
    @classmethod
    @dedicatedServer.setter
    def dedicatedServer(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def ipAddress(cls) -> str: ...
    @classmethod
    @ipAddress.setter
    def ipAddress(cls, value: str) -> str: ...
    @classmethod
    @property
    def port(cls) -> int: ...
    @classmethod
    @port.setter
    def port(cls, value: int) -> int: ...
    @classmethod
    @property
    def updateRate(cls) -> int: ...
    @classmethod
    @updateRate.setter
    def updateRate(cls, value: int) -> int: ...
    @staticmethod
    def ClearHostList() -> None: ...
    @staticmethod
    def PollHostList() -> Array_1[HostData]: ...
    @staticmethod
    def RequestHostList(gameTypeName: str) -> None: ...
    @staticmethod
    def UnregisterHost() -> None: ...
    # Skipped RegisterHost due to it being static, abstract and generic.

    RegisterHost : RegisterHost_MethodGroup
    class RegisterHost_MethodGroup:
        @typing.overload
        def __call__(self, gameTypeName: str, gameName: str) -> None:...
        @typing.overload
        def __call__(self, gameTypeName: str, gameName: str, comment: str) -> None:...



class MasterServerEvent(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:


class MatchTargetWeightMask:
    def __init__(self, positionXYZWeight: Vector3, rotationWeight: float) -> None: ...
    @property
    def positionXYZWeight(self) -> Vector3: ...
    @positionXYZWeight.setter
    def positionXYZWeight(self, value: Vector3) -> Vector3: ...
    @property
    def rotationWeight(self) -> float: ...
    @rotationWeight.setter
    def rotationWeight(self, value: float) -> float: ...


class Material(Object):
    @typing.overload
    def __init__(self, contents: str) -> None: ...
    @typing.overload
    def __init__(self, shader: Shader) -> None: ...
    @typing.overload
    def __init__(self, source: Material) -> None: ...
    @property
    def color(self) -> Color: ...
    @color.setter
    def color(self, value: Color) -> Color: ...
    @property
    def doubleSidedGI(self) -> bool: ...
    @doubleSidedGI.setter
    def doubleSidedGI(self, value: bool) -> bool: ...
    @property
    def enabledKeywords(self) -> Array_1[LocalKeyword]: ...
    @enabledKeywords.setter
    def enabledKeywords(self, value: Array_1[LocalKeyword]) -> Array_1[LocalKeyword]: ...
    @property
    def enableInstancing(self) -> bool: ...
    @enableInstancing.setter
    def enableInstancing(self, value: bool) -> bool: ...
    @property
    def globalIlluminationFlags(self) -> MaterialGlobalIlluminationFlags: ...
    @globalIlluminationFlags.setter
    def globalIlluminationFlags(self, value: MaterialGlobalIlluminationFlags) -> MaterialGlobalIlluminationFlags: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def isVariant(self) -> bool: ...
    @property
    def mainTexture(self) -> Texture: ...
    @mainTexture.setter
    def mainTexture(self, value: Texture) -> Texture: ...
    @property
    def mainTextureOffset(self) -> Vector2: ...
    @mainTextureOffset.setter
    def mainTextureOffset(self, value: Vector2) -> Vector2: ...
    @property
    def mainTextureScale(self) -> Vector2: ...
    @mainTextureScale.setter
    def mainTextureScale(self, value: Vector2) -> Vector2: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def parent(self) -> Material: ...
    @parent.setter
    def parent(self, value: Material) -> Material: ...
    @property
    def passCount(self) -> int: ...
    @property
    def renderQueue(self) -> int: ...
    @renderQueue.setter
    def renderQueue(self, value: int) -> int: ...
    @property
    def shader(self) -> Shader: ...
    @shader.setter
    def shader(self, value: Shader) -> Shader: ...
    @property
    def shaderKeywords(self) -> Array_1[str]: ...
    @shaderKeywords.setter
    def shaderKeywords(self, value: Array_1[str]) -> Array_1[str]: ...
    def ComputeCRC(self) -> int: ...
    def CopyMatchingPropertiesFromMaterial(self, mat: Material) -> None: ...
    def CopyPropertiesFromMaterial(self, mat: Material) -> None: ...
    @staticmethod
    def Create(scriptContents: str) -> Material: ...
    def FindPass(self, passName: str) -> int: ...
    def GetBuffer(self, name: str) -> GraphicsBufferHandle: ...
    def GetConstantBuffer(self, name: str) -> GraphicsBufferHandle: ...
    def GetPassName(self, pass: int) -> str: ...
    def GetPropertyNames(self, type: MaterialPropertyType) -> Array_1[str]: ...
    def GetShaderPassEnabled(self, passName: str) -> bool: ...
    def IsChildOf(self, ancestor: Material) -> bool: ...
    def Lerp(self, start: Material, end: Material, t: float) -> None: ...
    def RevertAllPropertyOverrides(self) -> None: ...
    def SetKeyword(self, keyword: clr.Reference[LocalKeyword], value: bool) -> None: ...
    def SetOverrideTag(self, tag: str, val: str) -> None: ...
    def SetPass(self, pass: int) -> bool: ...
    def SetShaderPassEnabled(self, passName: str, enabled: bool) -> None: ...
    # Skipped ApplyPropertyOverride due to it being static, abstract and generic.

    ApplyPropertyOverride : ApplyPropertyOverride_MethodGroup
    class ApplyPropertyOverride_MethodGroup:
        @typing.overload
        def __call__(self, destination: Material, nameID: int, recordUndo: bool = ...) -> None:...
        @typing.overload
        def __call__(self, destination: Material, name: str, recordUndo: bool = ...) -> None:...

    # Skipped DisableKeyword due to it being static, abstract and generic.

    DisableKeyword : DisableKeyword_MethodGroup
    class DisableKeyword_MethodGroup:
        @typing.overload
        def __call__(self, keyword: str) -> None:...
        @typing.overload
        def __call__(self, keyword: clr.Reference[LocalKeyword]) -> None:...

    # Skipped EnableKeyword due to it being static, abstract and generic.

    EnableKeyword : EnableKeyword_MethodGroup
    class EnableKeyword_MethodGroup:
        @typing.overload
        def __call__(self, keyword: str) -> None:...
        @typing.overload
        def __call__(self, keyword: clr.Reference[LocalKeyword]) -> None:...

    # Skipped GetColor due to it being static, abstract and generic.

    GetColor : GetColor_MethodGroup
    class GetColor_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Color:...
        @typing.overload
        def __call__(self, name: str) -> Color:...

    # Skipped GetColorArray due to it being static, abstract and generic.

    GetColorArray : GetColorArray_MethodGroup
    class GetColorArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Array_1[Color]:...
        @typing.overload
        def __call__(self, name: str) -> Array_1[Color]:...
        @typing.overload
        def __call__(self, nameID: int, values: List_1[Color]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[Color]) -> None:...

    # Skipped GetFloat due to it being static, abstract and generic.

    GetFloat : GetFloat_MethodGroup
    class GetFloat_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> float:...
        @typing.overload
        def __call__(self, name: str) -> float:...

    # Skipped GetFloatArray due to it being static, abstract and generic.

    GetFloatArray : GetFloatArray_MethodGroup
    class GetFloatArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Array_1[float]:...
        @typing.overload
        def __call__(self, name: str) -> Array_1[float]:...
        @typing.overload
        def __call__(self, nameID: int, values: List_1[float]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[float]) -> None:...

    # Skipped GetInt due to it being static, abstract and generic.

    GetInt : GetInt_MethodGroup
    class GetInt_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> int:...
        @typing.overload
        def __call__(self, name: str) -> int:...

    # Skipped GetInteger due to it being static, abstract and generic.

    GetInteger : GetInteger_MethodGroup
    class GetInteger_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> int:...
        @typing.overload
        def __call__(self, name: str) -> int:...

    # Skipped GetMatrix due to it being static, abstract and generic.

    GetMatrix : GetMatrix_MethodGroup
    class GetMatrix_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Matrix4x4:...
        @typing.overload
        def __call__(self, name: str) -> Matrix4x4:...

    # Skipped GetMatrixArray due to it being static, abstract and generic.

    GetMatrixArray : GetMatrixArray_MethodGroup
    class GetMatrixArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Array_1[Matrix4x4]:...
        @typing.overload
        def __call__(self, name: str) -> Array_1[Matrix4x4]:...
        @typing.overload
        def __call__(self, nameID: int, values: List_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[Matrix4x4]) -> None:...

    # Skipped GetTag due to it being static, abstract and generic.

    GetTag : GetTag_MethodGroup
    class GetTag_MethodGroup:
        @typing.overload
        def __call__(self, tag: str, searchFallbacks: bool) -> str:...
        @typing.overload
        def __call__(self, tag: str, searchFallbacks: bool, defaultValue: str) -> str:...

    # Skipped GetTexture due to it being static, abstract and generic.

    GetTexture : GetTexture_MethodGroup
    class GetTexture_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Texture:...
        @typing.overload
        def __call__(self, name: str) -> Texture:...

    # Skipped GetTextureOffset due to it being static, abstract and generic.

    GetTextureOffset : GetTextureOffset_MethodGroup
    class GetTextureOffset_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Vector2:...
        @typing.overload
        def __call__(self, name: str) -> Vector2:...

    # Skipped GetTexturePropertyNameIDs due to it being static, abstract and generic.

    GetTexturePropertyNameIDs : GetTexturePropertyNameIDs_MethodGroup
    class GetTexturePropertyNameIDs_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[int]:...
        @typing.overload
        def __call__(self, outNames: List_1[int]) -> None:...

    # Skipped GetTexturePropertyNames due to it being static, abstract and generic.

    GetTexturePropertyNames : GetTexturePropertyNames_MethodGroup
    class GetTexturePropertyNames_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[str]:...
        @typing.overload
        def __call__(self, outNames: List_1[str]) -> None:...

    # Skipped GetTextureScale due to it being static, abstract and generic.

    GetTextureScale : GetTextureScale_MethodGroup
    class GetTextureScale_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Vector2:...
        @typing.overload
        def __call__(self, name: str) -> Vector2:...

    # Skipped GetVector due to it being static, abstract and generic.

    GetVector : GetVector_MethodGroup
    class GetVector_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Vector4:...
        @typing.overload
        def __call__(self, name: str) -> Vector4:...

    # Skipped GetVectorArray due to it being static, abstract and generic.

    GetVectorArray : GetVectorArray_MethodGroup
    class GetVectorArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Array_1[Vector4]:...
        @typing.overload
        def __call__(self, name: str) -> Array_1[Vector4]:...
        @typing.overload
        def __call__(self, nameID: int, values: List_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[Vector4]) -> None:...

    # Skipped HasBuffer due to it being static, abstract and generic.

    HasBuffer : HasBuffer_MethodGroup
    class HasBuffer_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasColor due to it being static, abstract and generic.

    HasColor : HasColor_MethodGroup
    class HasColor_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasConstantBuffer due to it being static, abstract and generic.

    HasConstantBuffer : HasConstantBuffer_MethodGroup
    class HasConstantBuffer_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasFloat due to it being static, abstract and generic.

    HasFloat : HasFloat_MethodGroup
    class HasFloat_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasInt due to it being static, abstract and generic.

    HasInt : HasInt_MethodGroup
    class HasInt_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasInteger due to it being static, abstract and generic.

    HasInteger : HasInteger_MethodGroup
    class HasInteger_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasMatrix due to it being static, abstract and generic.

    HasMatrix : HasMatrix_MethodGroup
    class HasMatrix_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasProperty due to it being static, abstract and generic.

    HasProperty : HasProperty_MethodGroup
    class HasProperty_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasTexture due to it being static, abstract and generic.

    HasTexture : HasTexture_MethodGroup
    class HasTexture_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasVector due to it being static, abstract and generic.

    HasVector : HasVector_MethodGroup
    class HasVector_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped IsKeywordEnabled due to it being static, abstract and generic.

    IsKeywordEnabled : IsKeywordEnabled_MethodGroup
    class IsKeywordEnabled_MethodGroup:
        @typing.overload
        def __call__(self, keyword: str) -> bool:...
        @typing.overload
        def __call__(self, keyword: clr.Reference[LocalKeyword]) -> bool:...

    # Skipped IsPropertyLocked due to it being static, abstract and generic.

    IsPropertyLocked : IsPropertyLocked_MethodGroup
    class IsPropertyLocked_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped IsPropertyLockedByAncestor due to it being static, abstract and generic.

    IsPropertyLockedByAncestor : IsPropertyLockedByAncestor_MethodGroup
    class IsPropertyLockedByAncestor_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped IsPropertyOverriden due to it being static, abstract and generic.

    IsPropertyOverriden : IsPropertyOverriden_MethodGroup
    class IsPropertyOverriden_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped RevertPropertyOverride due to it being static, abstract and generic.

    RevertPropertyOverride : RevertPropertyOverride_MethodGroup
    class RevertPropertyOverride_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> None:...
        @typing.overload
        def __call__(self, name: str) -> None:...

    # Skipped SetBuffer due to it being static, abstract and generic.

    SetBuffer : SetBuffer_MethodGroup
    class SetBuffer_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, nameID: int, value: GraphicsBuffer) -> None:...
        @typing.overload
        def __call__(self, name: str, value: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, name: str, value: GraphicsBuffer) -> None:...

    # Skipped SetColor due to it being static, abstract and generic.

    SetColor : SetColor_MethodGroup
    class SetColor_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Color) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Color) -> None:...

    # Skipped SetColorArray due to it being static, abstract and generic.

    SetColorArray : SetColorArray_MethodGroup
    class SetColorArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, values: List_1[Color]) -> None:...
        @typing.overload
        def __call__(self, nameID: int, values: Array_1[Color]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[Color]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: Array_1[Color]) -> None:...

    # Skipped SetConstantBuffer due to it being static, abstract and generic.

    SetConstantBuffer : SetConstantBuffer_MethodGroup
    class SetConstantBuffer_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: ComputeBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, nameID: int, value: GraphicsBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, name: str, value: ComputeBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, name: str, value: GraphicsBuffer, offset: int, size: int) -> None:...

    # Skipped SetFloat due to it being static, abstract and generic.

    SetFloat : SetFloat_MethodGroup
    class SetFloat_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: float) -> None:...
        @typing.overload
        def __call__(self, name: str, value: float) -> None:...

    # Skipped SetFloatArray due to it being static, abstract and generic.

    SetFloatArray : SetFloatArray_MethodGroup
    class SetFloatArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, values: List_1[float]) -> None:...
        @typing.overload
        def __call__(self, nameID: int, values: Array_1[float]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[float]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: Array_1[float]) -> None:...

    # Skipped SetInt due to it being static, abstract and generic.

    SetInt : SetInt_MethodGroup
    class SetInt_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: int) -> None:...
        @typing.overload
        def __call__(self, name: str, value: int) -> None:...

    # Skipped SetInteger due to it being static, abstract and generic.

    SetInteger : SetInteger_MethodGroup
    class SetInteger_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: int) -> None:...
        @typing.overload
        def __call__(self, name: str, value: int) -> None:...

    # Skipped SetMatrix due to it being static, abstract and generic.

    SetMatrix : SetMatrix_MethodGroup
    class SetMatrix_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Matrix4x4) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Matrix4x4) -> None:...

    # Skipped SetMatrixArray due to it being static, abstract and generic.

    SetMatrixArray : SetMatrixArray_MethodGroup
    class SetMatrixArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, values: List_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, nameID: int, values: Array_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: Array_1[Matrix4x4]) -> None:...

    # Skipped SetPropertyLock due to it being static, abstract and generic.

    SetPropertyLock : SetPropertyLock_MethodGroup
    class SetPropertyLock_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: bool) -> None:...
        @typing.overload
        def __call__(self, name: str, value: bool) -> None:...

    # Skipped SetTexture due to it being static, abstract and generic.

    SetTexture : SetTexture_MethodGroup
    class SetTexture_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Texture) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Texture) -> None:...
        @typing.overload
        def __call__(self, nameID: int, value: RenderTexture, element: RenderTextureSubElement) -> None:...
        @typing.overload
        def __call__(self, name: str, value: RenderTexture, element: RenderTextureSubElement) -> None:...

    # Skipped SetTextureOffset due to it being static, abstract and generic.

    SetTextureOffset : SetTextureOffset_MethodGroup
    class SetTextureOffset_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Vector2) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Vector2) -> None:...

    # Skipped SetTextureScale due to it being static, abstract and generic.

    SetTextureScale : SetTextureScale_MethodGroup
    class SetTextureScale_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Vector2) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Vector2) -> None:...

    # Skipped SetVector due to it being static, abstract and generic.

    SetVector : SetVector_MethodGroup
    class SetVector_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Vector4) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Vector4) -> None:...

    # Skipped SetVectorArray due to it being static, abstract and generic.

    SetVectorArray : SetVectorArray_MethodGroup
    class SetVectorArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, values: List_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, nameID: int, values: Array_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: Array_1[Vector4]) -> None:...



class MaterialGlobalIlluminationFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : MaterialGlobalIlluminationFlags # 0
    RealtimeEmissive : MaterialGlobalIlluminationFlags # 1
    BakedEmissive : MaterialGlobalIlluminationFlags # 2
    AnyEmissive : MaterialGlobalIlluminationFlags # 3
    EmissiveIsBlack : MaterialGlobalIlluminationFlags # 4


class MaterialPropertyBlock:
    def __init__(self) -> None: ...
    @property
    def isEmpty(self) -> bool: ...
    def Clear(self) -> None: ...
    # Skipped AddColor due to it being static, abstract and generic.

    AddColor : AddColor_MethodGroup
    class AddColor_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Color) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Color) -> None:...

    # Skipped AddFloat due to it being static, abstract and generic.

    AddFloat : AddFloat_MethodGroup
    class AddFloat_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: float) -> None:...
        @typing.overload
        def __call__(self, name: str, value: float) -> None:...

    # Skipped AddMatrix due to it being static, abstract and generic.

    AddMatrix : AddMatrix_MethodGroup
    class AddMatrix_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Matrix4x4) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Matrix4x4) -> None:...

    # Skipped AddTexture due to it being static, abstract and generic.

    AddTexture : AddTexture_MethodGroup
    class AddTexture_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Texture) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Texture) -> None:...

    # Skipped AddVector due to it being static, abstract and generic.

    AddVector : AddVector_MethodGroup
    class AddVector_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Vector4) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Vector4) -> None:...

    # Skipped CopyProbeOcclusionArrayFrom due to it being static, abstract and generic.

    CopyProbeOcclusionArrayFrom : CopyProbeOcclusionArrayFrom_MethodGroup
    class CopyProbeOcclusionArrayFrom_MethodGroup:
        @typing.overload
        def __call__(self, occlusionProbes: List_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, occlusionProbes: Array_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, occlusionProbes: List_1[Vector4], sourceStart: int, destStart: int, count: int) -> None:...
        @typing.overload
        def __call__(self, occlusionProbes: Array_1[Vector4], sourceStart: int, destStart: int, count: int) -> None:...

    # Skipped CopySHCoefficientArraysFrom due to it being static, abstract and generic.

    CopySHCoefficientArraysFrom : CopySHCoefficientArraysFrom_MethodGroup
    class CopySHCoefficientArraysFrom_MethodGroup:
        @typing.overload
        def __call__(self, lightProbes: List_1[SphericalHarmonicsL2]) -> None:...
        @typing.overload
        def __call__(self, lightProbes: Array_1[SphericalHarmonicsL2]) -> None:...
        @typing.overload
        def __call__(self, lightProbes: List_1[SphericalHarmonicsL2], sourceStart: int, destStart: int, count: int) -> None:...
        @typing.overload
        def __call__(self, lightProbes: Array_1[SphericalHarmonicsL2], sourceStart: int, destStart: int, count: int) -> None:...

    # Skipped GetColor due to it being static, abstract and generic.

    GetColor : GetColor_MethodGroup
    class GetColor_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Color:...
        @typing.overload
        def __call__(self, name: str) -> Color:...

    # Skipped GetFloat due to it being static, abstract and generic.

    GetFloat : GetFloat_MethodGroup
    class GetFloat_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> float:...
        @typing.overload
        def __call__(self, name: str) -> float:...

    # Skipped GetFloatArray due to it being static, abstract and generic.

    GetFloatArray : GetFloatArray_MethodGroup
    class GetFloatArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Array_1[float]:...
        @typing.overload
        def __call__(self, name: str) -> Array_1[float]:...
        @typing.overload
        def __call__(self, nameID: int, values: List_1[float]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[float]) -> None:...

    # Skipped GetInt due to it being static, abstract and generic.

    GetInt : GetInt_MethodGroup
    class GetInt_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> int:...
        @typing.overload
        def __call__(self, name: str) -> int:...

    # Skipped GetInteger due to it being static, abstract and generic.

    GetInteger : GetInteger_MethodGroup
    class GetInteger_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> int:...
        @typing.overload
        def __call__(self, name: str) -> int:...

    # Skipped GetMatrix due to it being static, abstract and generic.

    GetMatrix : GetMatrix_MethodGroup
    class GetMatrix_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Matrix4x4:...
        @typing.overload
        def __call__(self, name: str) -> Matrix4x4:...

    # Skipped GetMatrixArray due to it being static, abstract and generic.

    GetMatrixArray : GetMatrixArray_MethodGroup
    class GetMatrixArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Array_1[Matrix4x4]:...
        @typing.overload
        def __call__(self, name: str) -> Array_1[Matrix4x4]:...
        @typing.overload
        def __call__(self, nameID: int, values: List_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[Matrix4x4]) -> None:...

    # Skipped GetTexture due to it being static, abstract and generic.

    GetTexture : GetTexture_MethodGroup
    class GetTexture_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Texture:...
        @typing.overload
        def __call__(self, name: str) -> Texture:...

    # Skipped GetVector due to it being static, abstract and generic.

    GetVector : GetVector_MethodGroup
    class GetVector_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Vector4:...
        @typing.overload
        def __call__(self, name: str) -> Vector4:...

    # Skipped GetVectorArray due to it being static, abstract and generic.

    GetVectorArray : GetVectorArray_MethodGroup
    class GetVectorArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Array_1[Vector4]:...
        @typing.overload
        def __call__(self, name: str) -> Array_1[Vector4]:...
        @typing.overload
        def __call__(self, nameID: int, values: List_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[Vector4]) -> None:...

    # Skipped HasBuffer due to it being static, abstract and generic.

    HasBuffer : HasBuffer_MethodGroup
    class HasBuffer_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasColor due to it being static, abstract and generic.

    HasColor : HasColor_MethodGroup
    class HasColor_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasConstantBuffer due to it being static, abstract and generic.

    HasConstantBuffer : HasConstantBuffer_MethodGroup
    class HasConstantBuffer_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasFloat due to it being static, abstract and generic.

    HasFloat : HasFloat_MethodGroup
    class HasFloat_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasInt due to it being static, abstract and generic.

    HasInt : HasInt_MethodGroup
    class HasInt_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasInteger due to it being static, abstract and generic.

    HasInteger : HasInteger_MethodGroup
    class HasInteger_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasMatrix due to it being static, abstract and generic.

    HasMatrix : HasMatrix_MethodGroup
    class HasMatrix_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasProperty due to it being static, abstract and generic.

    HasProperty : HasProperty_MethodGroup
    class HasProperty_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasTexture due to it being static, abstract and generic.

    HasTexture : HasTexture_MethodGroup
    class HasTexture_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped HasVector due to it being static, abstract and generic.

    HasVector : HasVector_MethodGroup
    class HasVector_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> bool:...
        @typing.overload
        def __call__(self, name: str) -> bool:...

    # Skipped SetBuffer due to it being static, abstract and generic.

    SetBuffer : SetBuffer_MethodGroup
    class SetBuffer_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, nameID: int, value: GraphicsBuffer) -> None:...
        @typing.overload
        def __call__(self, name: str, value: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, name: str, value: GraphicsBuffer) -> None:...

    # Skipped SetColor due to it being static, abstract and generic.

    SetColor : SetColor_MethodGroup
    class SetColor_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Color) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Color) -> None:...

    # Skipped SetConstantBuffer due to it being static, abstract and generic.

    SetConstantBuffer : SetConstantBuffer_MethodGroup
    class SetConstantBuffer_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: GraphicsBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, nameID: int, value: ComputeBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, name: str, value: GraphicsBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, name: str, value: ComputeBuffer, offset: int, size: int) -> None:...

    # Skipped SetFloat due to it being static, abstract and generic.

    SetFloat : SetFloat_MethodGroup
    class SetFloat_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: float) -> None:...
        @typing.overload
        def __call__(self, name: str, value: float) -> None:...

    # Skipped SetFloatArray due to it being static, abstract and generic.

    SetFloatArray : SetFloatArray_MethodGroup
    class SetFloatArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, values: List_1[float]) -> None:...
        @typing.overload
        def __call__(self, nameID: int, values: Array_1[float]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[float]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: Array_1[float]) -> None:...

    # Skipped SetInt due to it being static, abstract and generic.

    SetInt : SetInt_MethodGroup
    class SetInt_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: int) -> None:...
        @typing.overload
        def __call__(self, name: str, value: int) -> None:...

    # Skipped SetInteger due to it being static, abstract and generic.

    SetInteger : SetInteger_MethodGroup
    class SetInteger_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: int) -> None:...
        @typing.overload
        def __call__(self, name: str, value: int) -> None:...

    # Skipped SetMatrix due to it being static, abstract and generic.

    SetMatrix : SetMatrix_MethodGroup
    class SetMatrix_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Matrix4x4) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Matrix4x4) -> None:...

    # Skipped SetMatrixArray due to it being static, abstract and generic.

    SetMatrixArray : SetMatrixArray_MethodGroup
    class SetMatrixArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, values: List_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, nameID: int, values: Array_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: Array_1[Matrix4x4]) -> None:...

    # Skipped SetTexture due to it being static, abstract and generic.

    SetTexture : SetTexture_MethodGroup
    class SetTexture_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Texture) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Texture) -> None:...
        @typing.overload
        def __call__(self, nameID: int, value: RenderTexture, element: RenderTextureSubElement) -> None:...
        @typing.overload
        def __call__(self, name: str, value: RenderTexture, element: RenderTextureSubElement) -> None:...

    # Skipped SetVector due to it being static, abstract and generic.

    SetVector : SetVector_MethodGroup
    class SetVector_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Vector4) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Vector4) -> None:...

    # Skipped SetVectorArray due to it being static, abstract and generic.

    SetVectorArray : SetVectorArray_MethodGroup
    class SetVectorArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, values: List_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, nameID: int, values: Array_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: Array_1[Vector4]) -> None:...



class MaterialPropertyType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Float : MaterialPropertyType # 0
    Int : MaterialPropertyType # 1
    Vector : MaterialPropertyType # 2
    Matrix : MaterialPropertyType # 3
    Texture : MaterialPropertyType # 4
    ConstantBuffer : MaterialPropertyType # 5
    ComputeBuffer : MaterialPropertyType # 6


class Mathf:
    Deg2Rad : float
    Epsilon : float
    Infinity : float
    NegativeInfinity : float
    PI : float
    Rad2Deg : float
    @staticmethod
    def Acos(f: float) -> float: ...
    @staticmethod
    def Approximately(a: float, b: float) -> bool: ...
    @staticmethod
    def Asin(f: float) -> float: ...
    @staticmethod
    def Atan(f: float) -> float: ...
    @staticmethod
    def Atan2(y: float, x: float) -> float: ...
    @staticmethod
    def Ceil(f: float) -> float: ...
    @staticmethod
    def CeilToInt(f: float) -> int: ...
    @staticmethod
    def Clamp01(value: float) -> float: ...
    @staticmethod
    def ClosestPowerOfTwo(value: int) -> int: ...
    @staticmethod
    def CorrelatedColorTemperatureToRGB(kelvin: float) -> Color: ...
    @staticmethod
    def Cos(f: float) -> float: ...
    @staticmethod
    def DeltaAngle(current: float, target: float) -> float: ...
    @staticmethod
    def Exp(power: float) -> float: ...
    @staticmethod
    def FloatToHalf(val: float) -> int: ...
    @staticmethod
    def Floor(f: float) -> float: ...
    @staticmethod
    def FloorToInt(f: float) -> int: ...
    @staticmethod
    def Gamma(value: float, absmax: float, gamma: float) -> float: ...
    @staticmethod
    def GammaToLinearSpace(value: float) -> float: ...
    @staticmethod
    def HalfToFloat(val: int) -> float: ...
    @staticmethod
    def InverseLerp(a: float, b: float, value: float) -> float: ...
    @staticmethod
    def IsPowerOfTwo(value: int) -> bool: ...
    @staticmethod
    def Lerp(a: float, b: float, t: float) -> float: ...
    @staticmethod
    def LerpAngle(a: float, b: float, t: float) -> float: ...
    @staticmethod
    def LerpUnclamped(a: float, b: float, t: float) -> float: ...
    @staticmethod
    def LinearToGammaSpace(value: float) -> float: ...
    @staticmethod
    def Log10(f: float) -> float: ...
    @staticmethod
    def MoveTowards(current: float, target: float, maxDelta: float) -> float: ...
    @staticmethod
    def MoveTowardsAngle(current: float, target: float, maxDelta: float) -> float: ...
    @staticmethod
    def NextPowerOfTwo(value: int) -> int: ...
    @staticmethod
    def PerlinNoise(x: float, y: float) -> float: ...
    @staticmethod
    def PerlinNoise1D(x: float) -> float: ...
    @staticmethod
    def PingPong(t: float, length: float) -> float: ...
    @staticmethod
    def Pow(f: float, p: float) -> float: ...
    @staticmethod
    def Repeat(t: float, length: float) -> float: ...
    @staticmethod
    def Round(f: float) -> float: ...
    @staticmethod
    def RoundToInt(f: float) -> int: ...
    @staticmethod
    def Sign(f: float) -> float: ...
    @staticmethod
    def Sin(f: float) -> float: ...
    @staticmethod
    def SmoothStep(from_: float, to: float, t: float) -> float: ...
    @staticmethod
    def Sqrt(f: float) -> float: ...
    @staticmethod
    def Tan(f: float) -> float: ...
    # Skipped Abs due to it being static, abstract and generic.

    Abs : Abs_MethodGroup
    class Abs_MethodGroup:
        def __call__(self, f: float) -> float:...
        # Method Abs(value : Int32) was skipped since it collides with above method

    # Skipped Clamp due to it being static, abstract and generic.

    Clamp : Clamp_MethodGroup
    class Clamp_MethodGroup:
        def __call__(self, value: float, min: float, max: float) -> float:...
        # Method Clamp(value : Int32, min : Int32, max : Int32) was skipped since it collides with above method

    # Skipped Log due to it being static, abstract and generic.

    Log : Log_MethodGroup
    class Log_MethodGroup:
        @typing.overload
        def __call__(self, f: float) -> float:...
        @typing.overload
        def __call__(self, f: float, p: float) -> float:...

    # Skipped Max due to it being static, abstract and generic.

    Max : Max_MethodGroup
    class Max_MethodGroup:
        @typing.overload
        def __call__(self, values: Array_1[float]) -> float:...
        # Method Max(values : Int32[]) was skipped since it collides with above method
        @typing.overload
        def __call__(self, a: float, b: float) -> float:...
        # Method Max(a : Int32, b : Int32) was skipped since it collides with above method

    # Skipped Min due to it being static, abstract and generic.

    Min : Min_MethodGroup
    class Min_MethodGroup:
        @typing.overload
        def __call__(self, values: Array_1[float]) -> float:...
        # Method Min(values : Int32[]) was skipped since it collides with above method
        @typing.overload
        def __call__(self, a: float, b: float) -> float:...
        # Method Min(a : Int32, b : Int32) was skipped since it collides with above method

    # Skipped SmoothDamp due to it being static, abstract and generic.

    SmoothDamp : SmoothDamp_MethodGroup
    class SmoothDamp_MethodGroup:
        @typing.overload
        def __call__(self, current: float, target: float, currentVelocity: clr.Reference[float], smoothTime: float) -> float:...
        @typing.overload
        def __call__(self, current: float, target: float, currentVelocity: clr.Reference[float], smoothTime: float, maxSpeed: float) -> float:...
        @typing.overload
        def __call__(self, current: float, target: float, currentVelocity: clr.Reference[float], smoothTime: float, maxSpeed: float, deltaTime: float) -> float:...

    # Skipped SmoothDampAngle due to it being static, abstract and generic.

    SmoothDampAngle : SmoothDampAngle_MethodGroup
    class SmoothDampAngle_MethodGroup:
        @typing.overload
        def __call__(self, current: float, target: float, currentVelocity: clr.Reference[float], smoothTime: float) -> float:...
        @typing.overload
        def __call__(self, current: float, target: float, currentVelocity: clr.Reference[float], smoothTime: float, maxSpeed: float) -> float:...
        @typing.overload
        def __call__(self, current: float, target: float, currentVelocity: clr.Reference[float], smoothTime: float, maxSpeed: float, deltaTime: float) -> float:...



class Matrix4x4(IFormattable, IEquatable_1[Matrix4x4]):
    def __init__(self, column0: Vector4, column1: Vector4, column2: Vector4, column3: Vector4) -> None: ...
    m00 : float
    m01 : float
    m02 : float
    m03 : float
    m10 : float
    m11 : float
    m12 : float
    m13 : float
    m20 : float
    m21 : float
    m22 : float
    m23 : float
    m30 : float
    m31 : float
    m32 : float
    m33 : float
    @property
    def decomposeProjection(self) -> FrustumPlanes: ...
    @property
    def determinant(self) -> float: ...
    @classmethod
    @property
    def identity(cls) -> Matrix4x4: ...
    @property
    def inverse(self) -> Matrix4x4: ...
    @property
    def isIdentity(self) -> bool: ...
    @property
    def Item(self) -> float: ...
    @Item.setter
    def Item(self, value: float) -> float: ...
    @property
    def Item(self) -> float: ...
    @Item.setter
    def Item(self, value: float) -> float: ...
    @property
    def lossyScale(self) -> Vector3: ...
    @property
    def rotation(self) -> Quaternion: ...
    @property
    def transpose(self) -> Matrix4x4: ...
    @classmethod
    @property
    def zero(cls) -> Matrix4x4: ...
    @staticmethod
    def Determinant(m: Matrix4x4) -> float: ...
    def GetColumn(self, index: int) -> Vector4: ...
    def GetHashCode(self) -> int: ...
    def GetPosition(self) -> Vector3: ...
    def GetRow(self, index: int) -> Vector4: ...
    @staticmethod
    def Inverse(m: Matrix4x4) -> Matrix4x4: ...
    @staticmethod
    def Inverse3DAffine(input: Matrix4x4, result: clr.Reference[Matrix4x4]) -> bool: ...
    @staticmethod
    def LookAt(from_: Vector3, to: Vector3, up: Vector3) -> Matrix4x4: ...
    def MultiplyPoint(self, point: Vector3) -> Vector3: ...
    def MultiplyPoint3x4(self, point: Vector3) -> Vector3: ...
    def MultiplyVector(self, vector: Vector3) -> Vector3: ...
    def __eq__(self, lhs: Matrix4x4, rhs: Matrix4x4) -> bool: ...
    def __ne__(self, lhs: Matrix4x4, rhs: Matrix4x4) -> bool: ...
    @typing.overload
    def __mul__(self, lhs: Matrix4x4, rhs: Matrix4x4) -> Matrix4x4: ...
    @typing.overload
    def __mul__(self, lhs: Matrix4x4, vector: Vector4) -> Vector4: ...
    @staticmethod
    def Ortho(left: float, right: float, bottom: float, top: float, zNear: float, zFar: float) -> Matrix4x4: ...
    @staticmethod
    def Perspective(fov: float, aspect: float, zNear: float, zFar: float) -> Matrix4x4: ...
    @staticmethod
    def Rotate(q: Quaternion) -> Matrix4x4: ...
    @staticmethod
    def Scale(vector: Vector3) -> Matrix4x4: ...
    def SetColumn(self, index: int, column: Vector4) -> None: ...
    def SetRow(self, index: int, row: Vector4) -> None: ...
    def SetTRS(self, pos: Vector3, q: Quaternion, s: Vector3) -> None: ...
    def TransformPlane(self, plane: Plane) -> Plane: ...
    @staticmethod
    def Translate(vector: Vector3) -> Matrix4x4: ...
    @staticmethod
    def Transpose(m: Matrix4x4) -> Matrix4x4: ...
    @staticmethod
    def TRS(pos: Vector3, q: Quaternion, s: Vector3) -> Matrix4x4: ...
    def ValidTRS(self) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Matrix4x4) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped Frustum due to it being static, abstract and generic.

    Frustum : Frustum_MethodGroup
    class Frustum_MethodGroup:
        @typing.overload
        def __call__(self, fp: FrustumPlanes) -> Matrix4x4:...
        @typing.overload
        def __call__(self, left: float, right: float, bottom: float, top: float, zNear: float, zFar: float) -> Matrix4x4:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...



class Mesh(Object):
    def __init__(self) -> None: ...
    @property
    def bindposeCount(self) -> int: ...
    @property
    def bindposes(self) -> Array_1[Matrix4x4]: ...
    @bindposes.setter
    def bindposes(self, value: Array_1[Matrix4x4]) -> Array_1[Matrix4x4]: ...
    @property
    def blendShapeCount(self) -> int: ...
    @property
    def boneWeights(self) -> Array_1[BoneWeight]: ...
    @boneWeights.setter
    def boneWeights(self, value: Array_1[BoneWeight]) -> Array_1[BoneWeight]: ...
    @property
    def bounds(self) -> Bounds: ...
    @bounds.setter
    def bounds(self, value: Bounds) -> Bounds: ...
    @property
    def colors(self) -> Array_1[Color]: ...
    @colors.setter
    def colors(self, value: Array_1[Color]) -> Array_1[Color]: ...
    @property
    def colors32(self) -> Array_1[Color32]: ...
    @colors32.setter
    def colors32(self, value: Array_1[Color32]) -> Array_1[Color32]: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def indexBufferTarget(self) -> GraphicsBuffer.Target: ...
    @indexBufferTarget.setter
    def indexBufferTarget(self, value: GraphicsBuffer.Target) -> GraphicsBuffer.Target: ...
    @property
    def indexFormat(self) -> IndexFormat: ...
    @indexFormat.setter
    def indexFormat(self, value: IndexFormat) -> IndexFormat: ...
    @property
    def isReadable(self) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def normals(self) -> Array_1[Vector3]: ...
    @normals.setter
    def normals(self, value: Array_1[Vector3]) -> Array_1[Vector3]: ...
    @property
    def skinWeightBufferLayout(self) -> SkinWeights: ...
    @property
    def subMeshCount(self) -> int: ...
    @subMeshCount.setter
    def subMeshCount(self, value: int) -> int: ...
    @property
    def tangents(self) -> Array_1[Vector4]: ...
    @tangents.setter
    def tangents(self, value: Array_1[Vector4]) -> Array_1[Vector4]: ...
    @property
    def triangles(self) -> Array_1[int]: ...
    @triangles.setter
    def triangles(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def uv(self) -> Array_1[Vector2]: ...
    @uv.setter
    def uv(self, value: Array_1[Vector2]) -> Array_1[Vector2]: ...
    @property
    def uv1(self) -> Array_1[Vector2]: ...
    @uv1.setter
    def uv1(self, value: Array_1[Vector2]) -> Array_1[Vector2]: ...
    @property
    def uv2(self) -> Array_1[Vector2]: ...
    @uv2.setter
    def uv2(self, value: Array_1[Vector2]) -> Array_1[Vector2]: ...
    @property
    def uv3(self) -> Array_1[Vector2]: ...
    @uv3.setter
    def uv3(self, value: Array_1[Vector2]) -> Array_1[Vector2]: ...
    @property
    def uv4(self) -> Array_1[Vector2]: ...
    @uv4.setter
    def uv4(self, value: Array_1[Vector2]) -> Array_1[Vector2]: ...
    @property
    def uv5(self) -> Array_1[Vector2]: ...
    @uv5.setter
    def uv5(self, value: Array_1[Vector2]) -> Array_1[Vector2]: ...
    @property
    def uv6(self) -> Array_1[Vector2]: ...
    @uv6.setter
    def uv6(self, value: Array_1[Vector2]) -> Array_1[Vector2]: ...
    @property
    def uv7(self) -> Array_1[Vector2]: ...
    @uv7.setter
    def uv7(self, value: Array_1[Vector2]) -> Array_1[Vector2]: ...
    @property
    def uv8(self) -> Array_1[Vector2]: ...
    @uv8.setter
    def uv8(self, value: Array_1[Vector2]) -> Array_1[Vector2]: ...
    @property
    def vertexAttributeCount(self) -> int: ...
    @property
    def vertexBufferCount(self) -> int: ...
    @property
    def vertexBufferTarget(self) -> GraphicsBuffer.Target: ...
    @vertexBufferTarget.setter
    def vertexBufferTarget(self, value: GraphicsBuffer.Target) -> GraphicsBuffer.Target: ...
    @property
    def vertexCount(self) -> int: ...
    @property
    def vertices(self) -> Array_1[Vector3]: ...
    @vertices.setter
    def vertices(self, value: Array_1[Vector3]) -> Array_1[Vector3]: ...
    def AddBlendShapeFrame(self, shapeName: str, frameWeight: float, deltaVertices: Array_1[Vector3], deltaNormals: Array_1[Vector3], deltaTangents: Array_1[Vector3]) -> None: ...
    @staticmethod
    def AllocateWritableMeshData(meshCount: int) -> Mesh.MeshDataArray: ...
    def ClearBlendShapes(self) -> None: ...
    def GetAllBoneWeights(self) -> NativeArray_1[BoneWeight1]: ...
    def GetBaseVertex(self, submesh: int) -> int: ...
    def GetBlendShapeBufferRange(self, blendShapeIndex: int) -> BlendShapeBufferRange: ...
    def GetBlendShapeFrameCount(self, shapeIndex: int) -> int: ...
    def GetBlendShapeFrameVertices(self, shapeIndex: int, frameIndex: int, deltaVertices: Array_1[Vector3], deltaNormals: Array_1[Vector3], deltaTangents: Array_1[Vector3]) -> None: ...
    def GetBlendShapeFrameWeight(self, shapeIndex: int, frameIndex: int) -> float: ...
    def GetBlendShapeIndex(self, blendShapeName: str) -> int: ...
    def GetBlendShapeName(self, shapeIndex: int) -> str: ...
    def GetBonesPerVertex(self) -> NativeArray_1[int]: ...
    def GetBoneWeightBuffer(self, layout: SkinWeights) -> GraphicsBuffer: ...
    def GetBoneWeights(self, boneWeights: List_1[BoneWeight]) -> None: ...
    def GetIndexBuffer(self) -> GraphicsBuffer: ...
    def GetIndexCount(self, submesh: int) -> int: ...
    def GetIndexStart(self, submesh: int) -> int: ...
    def GetNativeIndexBufferPtr(self) -> int: ...
    def GetNativeVertexBufferPtr(self, index: int) -> int: ...
    def GetNormals(self, normals: List_1[Vector3]) -> None: ...
    def GetSubMesh(self, index: int) -> SubMeshDescriptor: ...
    def GetTangents(self, tangents: List_1[Vector4]) -> None: ...
    def GetTopology(self, submesh: int) -> MeshTopology: ...
    def GetUVDistributionMetric(self, uvSetIndex: int) -> float: ...
    def GetVertexAttribute(self, index: int) -> VertexAttributeDescriptor: ...
    def GetVertexAttributeDimension(self, attr: VertexAttribute) -> int: ...
    def GetVertexAttributeFormat(self, attr: VertexAttribute) -> VertexAttributeFormat: ...
    def GetVertexAttributeOffset(self, attr: VertexAttribute) -> int: ...
    def GetVertexAttributeStream(self, attr: VertexAttribute) -> int: ...
    def GetVertexBuffer(self, index: int) -> GraphicsBuffer: ...
    def GetVertexBufferStride(self, stream: int) -> int: ...
    def GetVertices(self, vertices: List_1[Vector3]) -> None: ...
    def HasVertexAttribute(self, attr: VertexAttribute) -> bool: ...
    def MarkDynamic(self) -> None: ...
    def MarkModified(self) -> None: ...
    def Optimize(self) -> None: ...
    def OptimizeIndexBuffers(self) -> None: ...
    def OptimizeReorderVertexBuffer(self) -> None: ...
    def RecalculateUVDistributionMetric(self, uvSetIndex: int, uvAreaThreshold: float = ...) -> None: ...
    def RecalculateUVDistributionMetrics(self, uvAreaThreshold: float = ...) -> None: ...
    def SetBoneWeights(self, bonesPerVertex: NativeArray_1[int], weights: NativeArray_1[BoneWeight1]) -> None: ...
    def SetIndexBufferParams(self, indexCount: int, format: IndexFormat) -> None: ...
    def SetSubMesh(self, index: int, desc: SubMeshDescriptor, flags: MeshUpdateFlags = ...) -> None: ...
    def UploadMeshData(self, markNoLongerReadable: bool) -> None: ...
    # Skipped AcquireReadOnlyMeshData due to it being static, abstract and generic.

    AcquireReadOnlyMeshData : AcquireReadOnlyMeshData_MethodGroup
    class AcquireReadOnlyMeshData_MethodGroup:
        @typing.overload
        def __call__(self, meshes: Array_1[Mesh]) -> Mesh.MeshDataArray:...
        @typing.overload
        def __call__(self, meshes: List_1[Mesh]) -> Mesh.MeshDataArray:...
        @typing.overload
        def __call__(self, mesh: Mesh) -> Mesh.MeshDataArray:...

    # Skipped ApplyAndDisposeWritableMeshData due to it being static, abstract and generic.

    ApplyAndDisposeWritableMeshData : ApplyAndDisposeWritableMeshData_MethodGroup
    class ApplyAndDisposeWritableMeshData_MethodGroup:
        @typing.overload
        def __call__(self, data: Mesh.MeshDataArray, meshes: Array_1[Mesh], flags: MeshUpdateFlags = ...) -> None:...
        @typing.overload
        def __call__(self, data: Mesh.MeshDataArray, meshes: List_1[Mesh], flags: MeshUpdateFlags = ...) -> None:...
        @typing.overload
        def __call__(self, data: Mesh.MeshDataArray, mesh: Mesh, flags: MeshUpdateFlags = ...) -> None:...

    # Skipped Clear due to it being static, abstract and generic.

    Clear : Clear_MethodGroup
    class Clear_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, keepVertexLayout: bool) -> None:...

    # Skipped CombineMeshes due to it being static, abstract and generic.

    CombineMeshes : CombineMeshes_MethodGroup
    class CombineMeshes_MethodGroup:
        @typing.overload
        def __call__(self, combine: Array_1[CombineInstance]) -> None:...
        @typing.overload
        def __call__(self, combine: Array_1[CombineInstance], mergeSubMeshes: bool) -> None:...
        @typing.overload
        def __call__(self, combine: Array_1[CombineInstance], mergeSubMeshes: bool, useMatrices: bool) -> None:...
        @typing.overload
        def __call__(self, combine: Array_1[CombineInstance], mergeSubMeshes: bool, useMatrices: bool, hasLightmapData: bool) -> None:...

    # Skipped GetBindposes due to it being static, abstract and generic.

    GetBindposes : GetBindposes_MethodGroup
    class GetBindposes_MethodGroup:
        @typing.overload
        def __call__(self) -> NativeArray_1[Matrix4x4]:...
        @typing.overload
        def __call__(self, bindposes: List_1[Matrix4x4]) -> None:...

    # Skipped GetBlendShapeBuffer due to it being static, abstract and generic.

    GetBlendShapeBuffer : GetBlendShapeBuffer_MethodGroup
    class GetBlendShapeBuffer_MethodGroup:
        @typing.overload
        def __call__(self) -> GraphicsBuffer:...
        @typing.overload
        def __call__(self, layout: BlendShapeBufferLayout) -> GraphicsBuffer:...

    # Skipped GetColors due to it being static, abstract and generic.

    GetColors : GetColors_MethodGroup
    class GetColors_MethodGroup:
        @typing.overload
        def __call__(self, colors: List_1[Color]) -> None:...
        @typing.overload
        def __call__(self, colors: List_1[Color32]) -> None:...

    # Skipped GetIndices due to it being static, abstract and generic.

    GetIndices : GetIndices_MethodGroup
    class GetIndices_MethodGroup:
        @typing.overload
        def __call__(self, submesh: int) -> Array_1[int]:...
        @typing.overload
        def __call__(self, submesh: int, applyBaseVertex: bool) -> Array_1[int]:...
        @typing.overload
        def __call__(self, indices: List_1[int], submesh: int) -> None:...
        @typing.overload
        def __call__(self, indices: List_1[int], submesh: int, applyBaseVertex: bool) -> None:...
        # Method GetIndices(indices : List`1, submesh : Int32, applyBaseVertex : Boolean) was skipped since it collides with above method

    # Skipped GetTriangles due to it being static, abstract and generic.

    GetTriangles : GetTriangles_MethodGroup
    class GetTriangles_MethodGroup:
        @typing.overload
        def __call__(self, submesh: int) -> Array_1[int]:...
        @typing.overload
        def __call__(self, submesh: int, applyBaseVertex: bool) -> Array_1[int]:...
        @typing.overload
        def __call__(self, triangles: List_1[int], submesh: int) -> None:...
        @typing.overload
        def __call__(self, triangles: List_1[int], submesh: int, applyBaseVertex: bool) -> None:...
        # Method GetTriangles(triangles : List`1, submesh : Int32, applyBaseVertex : Boolean) was skipped since it collides with above method

    # Skipped GetUVs due to it being static, abstract and generic.

    GetUVs : GetUVs_MethodGroup
    class GetUVs_MethodGroup:
        @typing.overload
        def __call__(self, channel: int, uvs: List_1[Vector2]) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: List_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: List_1[Vector4]) -> None:...

    # Skipped GetVertexAttributes due to it being static, abstract and generic.

    GetVertexAttributes : GetVertexAttributes_MethodGroup
    class GetVertexAttributes_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[VertexAttributeDescriptor]:...
        @typing.overload
        def __call__(self, attributes: Array_1[VertexAttributeDescriptor]) -> int:...
        @typing.overload
        def __call__(self, attributes: List_1[VertexAttributeDescriptor]) -> int:...

    # Skipped RecalculateBounds due to it being static, abstract and generic.

    RecalculateBounds : RecalculateBounds_MethodGroup
    class RecalculateBounds_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, flags: MeshUpdateFlags) -> None:...

    # Skipped RecalculateNormals due to it being static, abstract and generic.

    RecalculateNormals : RecalculateNormals_MethodGroup
    class RecalculateNormals_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, flags: MeshUpdateFlags) -> None:...

    # Skipped RecalculateTangents due to it being static, abstract and generic.

    RecalculateTangents : RecalculateTangents_MethodGroup
    class RecalculateTangents_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, flags: MeshUpdateFlags) -> None:...

    # Skipped SetColors due to it being static, abstract and generic.

    SetColors : SetColors_MethodGroup
    class SetColors_MethodGroup:
        def __getitem__(self, t:typing.Type[SetColors_1_T1]) -> SetColors_1[SetColors_1_T1]: ...

        SetColors_1_T1 = typing.TypeVar('SetColors_1_T1')
        class SetColors_1(typing.Generic[SetColors_1_T1]):
            SetColors_1_T = Mesh.SetColors_MethodGroup.SetColors_1_T1
            @typing.overload
            def __call__(self, inColors: NativeArray_1[SetColors_1_T]) -> None:...
            @typing.overload
            def __call__(self, inColors: NativeArray_1[SetColors_1_T], start: int, length: int) -> None:...
            @typing.overload
            def __call__(self, inColors: NativeArray_1[SetColors_1_T], start: int, length: int, flags: MeshUpdateFlags) -> None:...

        @typing.overload
        def __call__(self, inColors: List_1[Color]) -> None:...
        @typing.overload
        def __call__(self, inColors: Array_1[Color]) -> None:...
        @typing.overload
        def __call__(self, inColors: List_1[Color32]) -> None:...
        @typing.overload
        def __call__(self, inColors: Array_1[Color32]) -> None:...
        @typing.overload
        def __call__(self, inColors: List_1[Color], start: int, length: int) -> None:...
        @typing.overload
        def __call__(self, inColors: Array_1[Color], start: int, length: int) -> None:...
        @typing.overload
        def __call__(self, inColors: List_1[Color32], start: int, length: int) -> None:...
        @typing.overload
        def __call__(self, inColors: Array_1[Color32], start: int, length: int) -> None:...
        @typing.overload
        def __call__(self, inColors: List_1[Color], start: int, length: int, flags: MeshUpdateFlags) -> None:...
        @typing.overload
        def __call__(self, inColors: Array_1[Color], start: int, length: int, flags: MeshUpdateFlags) -> None:...
        @typing.overload
        def __call__(self, inColors: List_1[Color32], start: int, length: int, flags: MeshUpdateFlags) -> None:...
        @typing.overload
        def __call__(self, inColors: Array_1[Color32], start: int, length: int, flags: MeshUpdateFlags) -> None:...

    # Skipped SetIndexBufferData due to it being static, abstract and generic.

    SetIndexBufferData : SetIndexBufferData_MethodGroup
    class SetIndexBufferData_MethodGroup:
        def __getitem__(self, t:typing.Type[SetIndexBufferData_1_T1]) -> SetIndexBufferData_1[SetIndexBufferData_1_T1]: ...

        SetIndexBufferData_1_T1 = typing.TypeVar('SetIndexBufferData_1_T1')
        class SetIndexBufferData_1(typing.Generic[SetIndexBufferData_1_T1]):
            SetIndexBufferData_1_T = Mesh.SetIndexBufferData_MethodGroup.SetIndexBufferData_1_T1
            @typing.overload
            def __call__(self, data: Array_1[SetIndexBufferData_1_T], dataStart: int, meshBufferStart: int, count: int, flags: MeshUpdateFlags = ...) -> None:...
            @typing.overload
            def __call__(self, data: List_1[SetIndexBufferData_1_T], dataStart: int, meshBufferStart: int, count: int, flags: MeshUpdateFlags = ...) -> None:...
            @typing.overload
            def __call__(self, data: NativeArray_1[SetIndexBufferData_1_T], dataStart: int, meshBufferStart: int, count: int, flags: MeshUpdateFlags = ...) -> None:...


    # Skipped SetIndices due to it being static, abstract and generic.

    SetIndices : SetIndices_MethodGroup
    class SetIndices_MethodGroup:
        def __getitem__(self, t:typing.Type[SetIndices_1_T1]) -> SetIndices_1[SetIndices_1_T1]: ...

        SetIndices_1_T1 = typing.TypeVar('SetIndices_1_T1')
        class SetIndices_1(typing.Generic[SetIndices_1_T1]):
            SetIndices_1_T = Mesh.SetIndices_MethodGroup.SetIndices_1_T1
            @typing.overload
            def __call__(self, indices: NativeArray_1[SetIndices_1_T], topology: MeshTopology, submesh: int, calculateBounds: bool = ..., baseVertex: int = ...) -> None:...
            @typing.overload
            def __call__(self, indices: NativeArray_1[SetIndices_1_T], indicesStart: int, indicesLength: int, topology: MeshTopology, submesh: int, calculateBounds: bool = ..., baseVertex: int = ...) -> None:...

        @typing.overload
        def __call__(self, indices: Array_1[int], topology: MeshTopology, submesh: int) -> None:...
        @typing.overload
        def __call__(self, indices: Array_1[int], topology: MeshTopology, submesh: int, calculateBounds: bool) -> None:...
        @typing.overload
        def __call__(self, indices: Array_1[int], topology: MeshTopology, submesh: int, calculateBounds: bool, baseVertex: int) -> None:...
        # Method SetIndices(indices : UInt16[], topology : MeshTopology, submesh : Int32, calculateBounds : Boolean, baseVertex : Int32) was skipped since it collides with above method
        @typing.overload
        def __call__(self, indices: List_1[int], topology: MeshTopology, submesh: int, calculateBounds: bool = ..., baseVertex: int = ...) -> None:...
        # Method SetIndices(indices : List`1, topology : MeshTopology, submesh : Int32, calculateBounds : Boolean, baseVertex : Int32) was skipped since it collides with above method
        @typing.overload
        def __call__(self, indices: Array_1[int], indicesStart: int, indicesLength: int, topology: MeshTopology, submesh: int, calculateBounds: bool = ..., baseVertex: int = ...) -> None:...
        # Method SetIndices(indices : UInt16[], indicesStart : Int32, indicesLength : Int32, topology : MeshTopology, submesh : Int32, calculateBounds : Boolean, baseVertex : Int32) was skipped since it collides with above method
        @typing.overload
        def __call__(self, indices: List_1[int], indicesStart: int, indicesLength: int, topology: MeshTopology, submesh: int, calculateBounds: bool = ..., baseVertex: int = ...) -> None:...
        # Method SetIndices(indices : List`1, indicesStart : Int32, indicesLength : Int32, topology : MeshTopology, submesh : Int32, calculateBounds : Boolean, baseVertex : Int32) was skipped since it collides with above method

    # Skipped SetNormals due to it being static, abstract and generic.

    SetNormals : SetNormals_MethodGroup
    class SetNormals_MethodGroup:
        def __getitem__(self, t:typing.Type[SetNormals_1_T1]) -> SetNormals_1[SetNormals_1_T1]: ...

        SetNormals_1_T1 = typing.TypeVar('SetNormals_1_T1')
        class SetNormals_1(typing.Generic[SetNormals_1_T1]):
            SetNormals_1_T = Mesh.SetNormals_MethodGroup.SetNormals_1_T1
            @typing.overload
            def __call__(self, inNormals: NativeArray_1[SetNormals_1_T]) -> None:...
            @typing.overload
            def __call__(self, inNormals: NativeArray_1[SetNormals_1_T], start: int, length: int) -> None:...
            @typing.overload
            def __call__(self, inNormals: NativeArray_1[SetNormals_1_T], start: int, length: int, flags: MeshUpdateFlags) -> None:...

        @typing.overload
        def __call__(self, inNormals: List_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, inNormals: Array_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, inNormals: List_1[Vector3], start: int, length: int) -> None:...
        @typing.overload
        def __call__(self, inNormals: Array_1[Vector3], start: int, length: int) -> None:...
        @typing.overload
        def __call__(self, inNormals: List_1[Vector3], start: int, length: int, flags: MeshUpdateFlags) -> None:...
        @typing.overload
        def __call__(self, inNormals: Array_1[Vector3], start: int, length: int, flags: MeshUpdateFlags) -> None:...

    # Skipped SetSubMeshes due to it being static, abstract and generic.

    SetSubMeshes : SetSubMeshes_MethodGroup
    class SetSubMeshes_MethodGroup:
        def __getitem__(self, t:typing.Type[SetSubMeshes_1_T1]) -> SetSubMeshes_1[SetSubMeshes_1_T1]: ...

        SetSubMeshes_1_T1 = typing.TypeVar('SetSubMeshes_1_T1')
        class SetSubMeshes_1(typing.Generic[SetSubMeshes_1_T1]):
            SetSubMeshes_1_T = Mesh.SetSubMeshes_MethodGroup.SetSubMeshes_1_T1
            @typing.overload
            def __call__(self, desc: NativeArray_1[SetSubMeshes_1_T], flags: MeshUpdateFlags = ...) -> None:...
            @typing.overload
            def __call__(self, desc: NativeArray_1[SetSubMeshes_1_T], start: int, count: int, flags: MeshUpdateFlags = ...) -> None:...

        @typing.overload
        def __call__(self, desc: Array_1[SubMeshDescriptor], flags: MeshUpdateFlags = ...) -> None:...
        @typing.overload
        def __call__(self, desc: List_1[SubMeshDescriptor], flags: MeshUpdateFlags = ...) -> None:...
        @typing.overload
        def __call__(self, desc: Array_1[SubMeshDescriptor], start: int, count: int, flags: MeshUpdateFlags = ...) -> None:...
        @typing.overload
        def __call__(self, desc: List_1[SubMeshDescriptor], start: int, count: int, flags: MeshUpdateFlags = ...) -> None:...

    # Skipped SetTangents due to it being static, abstract and generic.

    SetTangents : SetTangents_MethodGroup
    class SetTangents_MethodGroup:
        def __getitem__(self, t:typing.Type[SetTangents_1_T1]) -> SetTangents_1[SetTangents_1_T1]: ...

        SetTangents_1_T1 = typing.TypeVar('SetTangents_1_T1')
        class SetTangents_1(typing.Generic[SetTangents_1_T1]):
            SetTangents_1_T = Mesh.SetTangents_MethodGroup.SetTangents_1_T1
            @typing.overload
            def __call__(self, inTangents: NativeArray_1[SetTangents_1_T]) -> None:...
            @typing.overload
            def __call__(self, inTangents: NativeArray_1[SetTangents_1_T], start: int, length: int) -> None:...
            @typing.overload
            def __call__(self, inTangents: NativeArray_1[SetTangents_1_T], start: int, length: int, flags: MeshUpdateFlags) -> None:...

        @typing.overload
        def __call__(self, inTangents: List_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, inTangents: Array_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, inTangents: List_1[Vector4], start: int, length: int) -> None:...
        @typing.overload
        def __call__(self, inTangents: Array_1[Vector4], start: int, length: int) -> None:...
        @typing.overload
        def __call__(self, inTangents: List_1[Vector4], start: int, length: int, flags: MeshUpdateFlags) -> None:...
        @typing.overload
        def __call__(self, inTangents: Array_1[Vector4], start: int, length: int, flags: MeshUpdateFlags) -> None:...

    # Skipped SetTriangles due to it being static, abstract and generic.

    SetTriangles : SetTriangles_MethodGroup
    class SetTriangles_MethodGroup:
        @typing.overload
        def __call__(self, triangles: Array_1[int], submesh: int) -> None:...
        @typing.overload
        def __call__(self, triangles: List_1[int], submesh: int) -> None:...
        @typing.overload
        def __call__(self, triangles: Array_1[int], submesh: int, calculateBounds: bool) -> None:...
        @typing.overload
        def __call__(self, triangles: List_1[int], submesh: int, calculateBounds: bool) -> None:...
        @typing.overload
        def __call__(self, triangles: Array_1[int], submesh: int, calculateBounds: bool, baseVertex: int) -> None:...
        # Method SetTriangles(triangles : UInt16[], submesh : Int32, calculateBounds : Boolean, baseVertex : Int32) was skipped since it collides with above method
        @typing.overload
        def __call__(self, triangles: List_1[int], submesh: int, calculateBounds: bool, baseVertex: int) -> None:...
        # Method SetTriangles(triangles : List`1, submesh : Int32, calculateBounds : Boolean, baseVertex : Int32) was skipped since it collides with above method
        @typing.overload
        def __call__(self, triangles: Array_1[int], trianglesStart: int, trianglesLength: int, submesh: int, calculateBounds: bool = ..., baseVertex: int = ...) -> None:...
        # Method SetTriangles(triangles : UInt16[], trianglesStart : Int32, trianglesLength : Int32, submesh : Int32, calculateBounds : Boolean, baseVertex : Int32) was skipped since it collides with above method
        @typing.overload
        def __call__(self, triangles: List_1[int], trianglesStart: int, trianglesLength: int, submesh: int, calculateBounds: bool = ..., baseVertex: int = ...) -> None:...
        # Method SetTriangles(triangles : List`1, trianglesStart : Int32, trianglesLength : Int32, submesh : Int32, calculateBounds : Boolean, baseVertex : Int32) was skipped since it collides with above method

    # Skipped SetUVs due to it being static, abstract and generic.

    SetUVs : SetUVs_MethodGroup
    class SetUVs_MethodGroup:
        def __getitem__(self, t:typing.Type[SetUVs_1_T1]) -> SetUVs_1[SetUVs_1_T1]: ...

        SetUVs_1_T1 = typing.TypeVar('SetUVs_1_T1')
        class SetUVs_1(typing.Generic[SetUVs_1_T1]):
            SetUVs_1_T = Mesh.SetUVs_MethodGroup.SetUVs_1_T1
            @typing.overload
            def __call__(self, channel: int, uvs: NativeArray_1[SetUVs_1_T]) -> None:...
            @typing.overload
            def __call__(self, channel: int, uvs: NativeArray_1[SetUVs_1_T], start: int, length: int) -> None:...
            @typing.overload
            def __call__(self, channel: int, uvs: NativeArray_1[SetUVs_1_T], start: int, length: int, flags: MeshUpdateFlags) -> None:...

        @typing.overload
        def __call__(self, channel: int, uvs: List_1[Vector2]) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: List_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: List_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: Array_1[Vector2]) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: Array_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: Array_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: List_1[Vector2], start: int, length: int) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: List_1[Vector3], start: int, length: int) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: List_1[Vector4], start: int, length: int) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: Array_1[Vector2], start: int, length: int) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: Array_1[Vector3], start: int, length: int) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: Array_1[Vector4], start: int, length: int) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: List_1[Vector2], start: int, length: int, flags: MeshUpdateFlags) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: List_1[Vector3], start: int, length: int, flags: MeshUpdateFlags) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: List_1[Vector4], start: int, length: int, flags: MeshUpdateFlags) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: Array_1[Vector2], start: int, length: int, flags: MeshUpdateFlags) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: Array_1[Vector3], start: int, length: int, flags: MeshUpdateFlags) -> None:...
        @typing.overload
        def __call__(self, channel: int, uvs: Array_1[Vector4], start: int, length: int, flags: MeshUpdateFlags) -> None:...

    # Skipped SetVertexBufferData due to it being static, abstract and generic.

    SetVertexBufferData : SetVertexBufferData_MethodGroup
    class SetVertexBufferData_MethodGroup:
        def __getitem__(self, t:typing.Type[SetVertexBufferData_1_T1]) -> SetVertexBufferData_1[SetVertexBufferData_1_T1]: ...

        SetVertexBufferData_1_T1 = typing.TypeVar('SetVertexBufferData_1_T1')
        class SetVertexBufferData_1(typing.Generic[SetVertexBufferData_1_T1]):
            SetVertexBufferData_1_T = Mesh.SetVertexBufferData_MethodGroup.SetVertexBufferData_1_T1
            @typing.overload
            def __call__(self, data: Array_1[SetVertexBufferData_1_T], dataStart: int, meshBufferStart: int, count: int, stream: int = ..., flags: MeshUpdateFlags = ...) -> None:...
            @typing.overload
            def __call__(self, data: List_1[SetVertexBufferData_1_T], dataStart: int, meshBufferStart: int, count: int, stream: int = ..., flags: MeshUpdateFlags = ...) -> None:...
            @typing.overload
            def __call__(self, data: NativeArray_1[SetVertexBufferData_1_T], dataStart: int, meshBufferStart: int, count: int, stream: int = ..., flags: MeshUpdateFlags = ...) -> None:...


    # Skipped SetVertexBufferParams due to it being static, abstract and generic.

    SetVertexBufferParams : SetVertexBufferParams_MethodGroup
    class SetVertexBufferParams_MethodGroup:
        @typing.overload
        def __call__(self, vertexCount: int, attributes: Array_1[VertexAttributeDescriptor]) -> None:...
        @typing.overload
        def __call__(self, vertexCount: int, attributes: NativeArray_1[VertexAttributeDescriptor]) -> None:...

    # Skipped SetVertices due to it being static, abstract and generic.

    SetVertices : SetVertices_MethodGroup
    class SetVertices_MethodGroup:
        def __getitem__(self, t:typing.Type[SetVertices_1_T1]) -> SetVertices_1[SetVertices_1_T1]: ...

        SetVertices_1_T1 = typing.TypeVar('SetVertices_1_T1')
        class SetVertices_1(typing.Generic[SetVertices_1_T1]):
            SetVertices_1_T = Mesh.SetVertices_MethodGroup.SetVertices_1_T1
            @typing.overload
            def __call__(self, inVertices: NativeArray_1[SetVertices_1_T]) -> None:...
            @typing.overload
            def __call__(self, inVertices: NativeArray_1[SetVertices_1_T], start: int, length: int) -> None:...
            @typing.overload
            def __call__(self, inVertices: NativeArray_1[SetVertices_1_T], start: int, length: int, flags: MeshUpdateFlags) -> None:...

        @typing.overload
        def __call__(self, inVertices: List_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, inVertices: Array_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, inVertices: List_1[Vector3], start: int, length: int) -> None:...
        @typing.overload
        def __call__(self, inVertices: Array_1[Vector3], start: int, length: int) -> None:...
        @typing.overload
        def __call__(self, inVertices: List_1[Vector3], start: int, length: int, flags: MeshUpdateFlags) -> None:...
        @typing.overload
        def __call__(self, inVertices: Array_1[Vector3], start: int, length: int, flags: MeshUpdateFlags) -> None:...


    class MeshData:
        @property
        def indexFormat(self) -> IndexFormat: ...
        @property
        def subMeshCount(self) -> int: ...
        @subMeshCount.setter
        def subMeshCount(self, value: int) -> int: ...
        @property
        def vertexBufferCount(self) -> int: ...
        @property
        def vertexCount(self) -> int: ...
        def GetNormals(self, outNormals: NativeArray_1[Vector3]) -> None: ...
        def GetSubMesh(self, index: int) -> SubMeshDescriptor: ...
        def GetTangents(self, outTangents: NativeArray_1[Vector4]) -> None: ...
        def GetVertexAttributeDimension(self, attr: VertexAttribute) -> int: ...
        def GetVertexAttributeFormat(self, attr: VertexAttribute) -> VertexAttributeFormat: ...
        def GetVertexAttributeOffset(self, attr: VertexAttribute) -> int: ...
        def GetVertexAttributeStream(self, attr: VertexAttribute) -> int: ...
        def GetVertexBufferStride(self, stream: int) -> int: ...
        def GetVertices(self, outVertices: NativeArray_1[Vector3]) -> None: ...
        def HasVertexAttribute(self, attr: VertexAttribute) -> bool: ...
        def SetIndexBufferParams(self, indexCount: int, format: IndexFormat) -> None: ...
        def SetSubMesh(self, index: int, desc: SubMeshDescriptor, flags: MeshUpdateFlags = ...) -> None: ...
        # Skipped GetColors due to it being static, abstract and generic.

        GetColors : GetColors_MethodGroup
        class GetColors_MethodGroup:
            @typing.overload
            def __call__(self, outColors: NativeArray_1[Color]) -> None:...
            @typing.overload
            def __call__(self, outColors: NativeArray_1[Color32]) -> None:...

        # Skipped GetIndexData due to it being static, abstract and generic.

        GetIndexData : GetIndexData_MethodGroup
        class GetIndexData_MethodGroup:
            def __getitem__(self, t:typing.Type[GetIndexData_1_T1]) -> GetIndexData_1[GetIndexData_1_T1]: ...

            GetIndexData_1_T1 = typing.TypeVar('GetIndexData_1_T1')
            class GetIndexData_1(typing.Generic[GetIndexData_1_T1]):
                GetIndexData_1_T = Mesh.MeshData.GetIndexData_MethodGroup.GetIndexData_1_T1
                def __call__(self) -> NativeArray_1[GetIndexData_1_T]:...


        # Skipped GetIndices due to it being static, abstract and generic.

        GetIndices : GetIndices_MethodGroup
        class GetIndices_MethodGroup:
            def __call__(self, outIndices: NativeArray_1[int], submesh: int, applyBaseVertex: bool = ...) -> None:...
            # Method GetIndices(outIndices : NativeArray`1, submesh : Int32, applyBaseVertex : Boolean) was skipped since it collides with above method

        # Skipped GetUVs due to it being static, abstract and generic.

        GetUVs : GetUVs_MethodGroup
        class GetUVs_MethodGroup:
            @typing.overload
            def __call__(self, channel: int, outUVs: NativeArray_1[Vector2]) -> None:...
            @typing.overload
            def __call__(self, channel: int, outUVs: NativeArray_1[Vector3]) -> None:...
            @typing.overload
            def __call__(self, channel: int, outUVs: NativeArray_1[Vector4]) -> None:...

        # Skipped GetVertexData due to it being static, abstract and generic.

        GetVertexData : GetVertexData_MethodGroup
        class GetVertexData_MethodGroup:
            def __getitem__(self, t:typing.Type[GetVertexData_1_T1]) -> GetVertexData_1[GetVertexData_1_T1]: ...

            GetVertexData_1_T1 = typing.TypeVar('GetVertexData_1_T1')
            class GetVertexData_1(typing.Generic[GetVertexData_1_T1]):
                GetVertexData_1_T = Mesh.MeshData.GetVertexData_MethodGroup.GetVertexData_1_T1
                def __call__(self, stream: int = ...) -> NativeArray_1[GetVertexData_1_T]:...


        # Skipped SetVertexBufferParams due to it being static, abstract and generic.

        SetVertexBufferParams : SetVertexBufferParams_MethodGroup
        class SetVertexBufferParams_MethodGroup:
            @typing.overload
            def __call__(self, vertexCount: int, attributes: Array_1[VertexAttributeDescriptor]) -> None:...
            @typing.overload
            def __call__(self, vertexCount: int, attributes: NativeArray_1[VertexAttributeDescriptor]) -> None:...



    class MeshDataArray(IDisposable):
        @property
        def Item(self) -> Mesh.MeshData: ...
        @property
        def Length(self) -> int: ...
        def Dispose(self) -> None: ...



class MeshCollider(Collider):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedArticulationBody(self) -> ArticulationBody: ...
    @property
    def attachedRigidbody(self) -> Rigidbody: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def contactOffset(self) -> float: ...
    @contactOffset.setter
    def contactOffset(self, value: float) -> float: ...
    @property
    def convex(self) -> bool: ...
    @convex.setter
    def convex(self, value: bool) -> bool: ...
    @property
    def cookingOptions(self) -> MeshColliderCookingOptions: ...
    @cookingOptions.setter
    def cookingOptions(self, value: MeshColliderCookingOptions) -> MeshColliderCookingOptions: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hasModifiableContacts(self) -> bool: ...
    @hasModifiableContacts.setter
    def hasModifiableContacts(self, value: bool) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def inflateMesh(self) -> bool: ...
    @inflateMesh.setter
    def inflateMesh(self, value: bool) -> bool: ...
    @property
    def isTrigger(self) -> bool: ...
    @isTrigger.setter
    def isTrigger(self, value: bool) -> bool: ...
    @property
    def layerOverridePriority(self) -> int: ...
    @layerOverridePriority.setter
    def layerOverridePriority(self, value: int) -> int: ...
    @property
    def light(self) -> Component: ...
    @property
    def material(self) -> PhysicMaterial: ...
    @material.setter
    def material(self, value: PhysicMaterial) -> PhysicMaterial: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def providesContacts(self) -> bool: ...
    @providesContacts.setter
    def providesContacts(self, value: bool) -> bool: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def sharedMaterial(self) -> PhysicMaterial: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: PhysicMaterial) -> PhysicMaterial: ...
    @property
    def sharedMesh(self) -> Mesh: ...
    @sharedMesh.setter
    def sharedMesh(self, value: Mesh) -> Mesh: ...
    @property
    def skinWidth(self) -> float: ...
    @skinWidth.setter
    def skinWidth(self, value: float) -> float: ...
    @property
    def smoothSphereCollisions(self) -> bool: ...
    @smoothSphereCollisions.setter
    def smoothSphereCollisions(self, value: bool) -> bool: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class MeshColliderCookingOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : MeshColliderCookingOptions # 0
    InflateConvexMesh : MeshColliderCookingOptions # 1
    CookForFasterSimulation : MeshColliderCookingOptions # 2
    EnableMeshCleaning : MeshColliderCookingOptions # 4
    WeldColocatedVertices : MeshColliderCookingOptions # 8
    UseFastMidphase : MeshColliderCookingOptions # 16


class MeshFilter(Component):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def light(self) -> Component: ...
    @property
    def mesh(self) -> Mesh: ...
    @mesh.setter
    def mesh(self, value: Mesh) -> Mesh: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def sharedMesh(self) -> Mesh: ...
    @sharedMesh.setter
    def sharedMesh(self, value: Mesh) -> Mesh: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class MeshRenderer(Renderer):
    def __init__(self) -> None: ...
    @property
    def additionalVertexStreams(self) -> Mesh: ...
    @additionalVertexStreams.setter
    def additionalVertexStreams(self, value: Mesh) -> Mesh: ...
    @property
    def allowOcclusionWhenDynamic(self) -> bool: ...
    @allowOcclusionWhenDynamic.setter
    def allowOcclusionWhenDynamic(self, value: bool) -> bool: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounds(self) -> Bounds: ...
    @bounds.setter
    def bounds(self, value: Bounds) -> Bounds: ...
    @property
    def camera(self) -> Component: ...
    @property
    def castShadows(self) -> bool: ...
    @castShadows.setter
    def castShadows(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def enlightenVertexStream(self) -> Mesh: ...
    @enlightenVertexStream.setter
    def enlightenVertexStream(self, value: Mesh) -> Mesh: ...
    @property
    def forceRenderingOff(self) -> bool: ...
    @forceRenderingOff.setter
    def forceRenderingOff(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isPartOfStaticBatch(self) -> bool: ...
    @property
    def isVisible(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def lightmapIndex(self) -> int: ...
    @lightmapIndex.setter
    def lightmapIndex(self, value: int) -> int: ...
    @property
    def lightmapScaleOffset(self) -> Vector4: ...
    @lightmapScaleOffset.setter
    def lightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightmapTilingOffset(self) -> Vector4: ...
    @lightmapTilingOffset.setter
    def lightmapTilingOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightProbeAnchor(self) -> Transform: ...
    @lightProbeAnchor.setter
    def lightProbeAnchor(self, value: Transform) -> Transform: ...
    @property
    def lightProbeProxyVolumeOverride(self) -> GameObject: ...
    @lightProbeProxyVolumeOverride.setter
    def lightProbeProxyVolumeOverride(self, value: GameObject) -> GameObject: ...
    @property
    def lightProbeUsage(self) -> LightProbeUsage: ...
    @lightProbeUsage.setter
    def lightProbeUsage(self, value: LightProbeUsage) -> LightProbeUsage: ...
    @property
    def localBounds(self) -> Bounds: ...
    @localBounds.setter
    def localBounds(self, value: Bounds) -> Bounds: ...
    @property
    def localToWorldMatrix(self) -> Matrix4x4: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> Material: ...
    @property
    def materials(self) -> Array_1[Material]: ...
    @materials.setter
    def materials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def motionVectorGenerationMode(self) -> MotionVectorGenerationMode: ...
    @motionVectorGenerationMode.setter
    def motionVectorGenerationMode(self, value: MotionVectorGenerationMode) -> MotionVectorGenerationMode: ...
    @property
    def motionVectors(self) -> bool: ...
    @motionVectors.setter
    def motionVectors(self, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def probeAnchor(self) -> Transform: ...
    @probeAnchor.setter
    def probeAnchor(self, value: Transform) -> Transform: ...
    @property
    def rayTracingMode(self) -> RayTracingMode: ...
    @rayTracingMode.setter
    def rayTracingMode(self, value: RayTracingMode) -> RayTracingMode: ...
    @property
    def realtimeLightmapIndex(self) -> int: ...
    @realtimeLightmapIndex.setter
    def realtimeLightmapIndex(self, value: int) -> int: ...
    @property
    def realtimeLightmapScaleOffset(self) -> Vector4: ...
    @realtimeLightmapScaleOffset.setter
    def realtimeLightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def receiveGI(self) -> ReceiveGI: ...
    @receiveGI.setter
    def receiveGI(self, value: ReceiveGI) -> ReceiveGI: ...
    @property
    def receiveShadows(self) -> bool: ...
    @receiveShadows.setter
    def receiveShadows(self, value: bool) -> bool: ...
    @property
    def reflectionProbeUsage(self) -> ReflectionProbeUsage: ...
    @reflectionProbeUsage.setter
    def reflectionProbeUsage(self, value: ReflectionProbeUsage) -> ReflectionProbeUsage: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rendererPriority(self) -> int: ...
    @rendererPriority.setter
    def rendererPriority(self, value: int) -> int: ...
    @property
    def renderingLayerMask(self) -> int: ...
    @renderingLayerMask.setter
    def renderingLayerMask(self, value: int) -> int: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def scaleInLightmap(self) -> float: ...
    @scaleInLightmap.setter
    def scaleInLightmap(self, value: float) -> float: ...
    @property
    def shadowCastingMode(self) -> ShadowCastingMode: ...
    @shadowCastingMode.setter
    def shadowCastingMode(self, value: ShadowCastingMode) -> ShadowCastingMode: ...
    @property
    def sharedMaterial(self) -> Material: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: Material) -> Material: ...
    @property
    def sharedMaterials(self) -> Array_1[Material]: ...
    @sharedMaterials.setter
    def sharedMaterials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def sortingLayerID(self) -> int: ...
    @sortingLayerID.setter
    def sortingLayerID(self, value: int) -> int: ...
    @property
    def sortingLayerName(self) -> str: ...
    @sortingLayerName.setter
    def sortingLayerName(self, value: str) -> str: ...
    @property
    def sortingOrder(self) -> int: ...
    @sortingOrder.setter
    def sortingOrder(self, value: int) -> int: ...
    @property
    def staticShadowCaster(self) -> bool: ...
    @staticShadowCaster.setter
    def staticShadowCaster(self, value: bool) -> bool: ...
    @property
    def stitchLightmapSeams(self) -> bool: ...
    @stitchLightmapSeams.setter
    def stitchLightmapSeams(self, value: bool) -> bool: ...
    @property
    def subMeshStartIndex(self) -> int: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useLightProbes(self) -> bool: ...
    @useLightProbes.setter
    def useLightProbes(self, value: bool) -> bool: ...
    @property
    def worldToLocalMatrix(self) -> Matrix4x4: ...


class MeshTopology(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Triangles : MeshTopology # 0
    Quads : MeshTopology # 2
    Lines : MeshTopology # 3
    LineStrip : MeshTopology # 4
    Points : MeshTopology # 5


class Microphone:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def devices(cls) -> Array_1[str]: ...
    @staticmethod
    def End(deviceName: str) -> None: ...
    @staticmethod
    def GetDeviceCaps(deviceName: str, minFreq: clr.Reference[int], maxFreq: clr.Reference[int]) -> None: ...
    @staticmethod
    def GetPosition(deviceName: str) -> int: ...
    @staticmethod
    def IsRecording(deviceName: str) -> bool: ...
    @staticmethod
    def Start(deviceName: str, loop: bool, lengthSec: int, frequency: int) -> AudioClip: ...


class MinAttribute(PropertyAttribute):
    def __init__(self, min: float) -> None: ...
    min : float
    @property
    def order(self) -> int: ...
    @order.setter
    def order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class MissingComponentException(SystemException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class MissingReferenceException(SystemException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class MixedLightingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    IndirectOnly : MixedLightingMode # 0
    Subtractive : MixedLightingMode # 1
    Shadowmask : MixedLightingMode # 2


class ModifiableContactPair:
    otherPosition : Vector3
    otherRotation : Quaternion
    position : Vector3
    rotation : Quaternion
    @property
    def bodyAngularVelocity(self) -> Vector3: ...
    @property
    def bodyInstanceID(self) -> int: ...
    @property
    def bodyVelocity(self) -> Vector3: ...
    @property
    def colliderInstanceID(self) -> int: ...
    @property
    def contactCount(self) -> int: ...
    @property
    def massProperties(self) -> ModifiableMassProperties: ...
    @massProperties.setter
    def massProperties(self, value: ModifiableMassProperties) -> ModifiableMassProperties: ...
    @property
    def otherBodyAngularVelocity(self) -> Vector3: ...
    @property
    def otherBodyInstanceID(self) -> int: ...
    @property
    def otherBodyVelocity(self) -> Vector3: ...
    @property
    def otherColliderInstanceID(self) -> int: ...
    def GetBounciness(self, i: int) -> float: ...
    def GetDynamicFriction(self, i: int) -> float: ...
    def GetFaceIndex(self, i: int) -> int: ...
    def GetMaxImpulse(self, i: int) -> float: ...
    def GetNormal(self, i: int) -> Vector3: ...
    def GetPoint(self, i: int) -> Vector3: ...
    def GetSeparation(self, i: int) -> float: ...
    def GetStaticFriction(self, i: int) -> float: ...
    def GetTargetVelocity(self, i: int) -> Vector3: ...
    def IgnoreContact(self, i: int) -> None: ...
    def SetBounciness(self, i: int, bounciness: float) -> None: ...
    def SetDynamicFriction(self, i: int, dynamicFriction: float) -> None: ...
    def SetMaxImpulse(self, i: int, value: float) -> None: ...
    def SetNormal(self, i: int, normal: Vector3) -> None: ...
    def SetPoint(self, i: int, v: Vector3) -> None: ...
    def SetSeparation(self, i: int, separation: float) -> None: ...
    def SetStaticFriction(self, i: int, staticFriction: float) -> None: ...
    def SetTargetVelocity(self, i: int, velocity: Vector3) -> None: ...


class ModifiableMassProperties:
    inverseInertiaScale : float
    inverseMassScale : float
    otherInverseInertiaScale : float
    otherInverseMassScale : float


class MonoBehaviour(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def destroyCancellationToken(self) -> CancellationToken: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def runInEditMode(self) -> bool: ...
    @runInEditMode.setter
    def runInEditMode(self, value: bool) -> bool: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useGUILayout(self) -> bool: ...
    @useGUILayout.setter
    def useGUILayout(self, value: bool) -> bool: ...
    def Invoke(self, methodName: str, time: float) -> None: ...
    def InvokeRepeating(self, methodName: str, time: float, repeatRate: float) -> None: ...
    @staticmethod
    def print(message: typing.Any) -> None: ...
    def StartCoroutine_Auto(self, routine: IEnumerator) -> Coroutine: ...
    def StopAllCoroutines(self) -> None: ...
    # Skipped CancelInvoke due to it being static, abstract and generic.

    CancelInvoke : CancelInvoke_MethodGroup
    class CancelInvoke_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, methodName: str) -> None:...

    # Skipped IsInvoking due to it being static, abstract and generic.

    IsInvoking : IsInvoking_MethodGroup
    class IsInvoking_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, methodName: str) -> bool:...

    # Skipped StartCoroutine due to it being static, abstract and generic.

    StartCoroutine : StartCoroutine_MethodGroup
    class StartCoroutine_MethodGroup:
        @typing.overload
        def __call__(self, methodName: str) -> Coroutine:...
        @typing.overload
        def __call__(self, routine: IEnumerator) -> Coroutine:...
        @typing.overload
        def __call__(self, methodName: str, value: typing.Any) -> Coroutine:...

    # Skipped StopCoroutine due to it being static, abstract and generic.

    StopCoroutine : StopCoroutine_MethodGroup
    class StopCoroutine_MethodGroup:
        @typing.overload
        def __call__(self, methodName: str) -> None:...
        @typing.overload
        def __call__(self, routine: Coroutine) -> None:...
        @typing.overload
        def __call__(self, routine: IEnumerator) -> None:...



class Motion(Object):
    @property
    def apparentSpeed(self) -> float: ...
    @property
    def averageAngularSpeed(self) -> float: ...
    @property
    def averageDuration(self) -> float: ...
    @property
    def averageSpeed(self) -> Vector3: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def isAnimatorMotion(self) -> bool: ...
    @property
    def isHumanMotion(self) -> bool: ...
    @property
    def isLooping(self) -> bool: ...
    @property
    def legacy(self) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    def ValidateIfRetargetable(self, val: bool) -> bool: ...


class MotionVectorGenerationMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Camera : MotionVectorGenerationMode # 0
    Object : MotionVectorGenerationMode # 1
    ForceNoMotion : MotionVectorGenerationMode # 2


class MovieTexture(Texture):
    @property
    def anisoLevel(self) -> int: ...
    @anisoLevel.setter
    def anisoLevel(self, value: int) -> int: ...
    @property
    def audioClip(self) -> AudioClip: ...
    @property
    def dimension(self) -> TextureDimension: ...
    @dimension.setter
    def dimension(self, value: TextureDimension) -> TextureDimension: ...
    @property
    def duration(self) -> float: ...
    @property
    def filterMode(self) -> FilterMode: ...
    @filterMode.setter
    def filterMode(self, value: FilterMode) -> FilterMode: ...
    @property
    def graphicsFormat(self) -> GraphicsFormat: ...
    @property
    def height(self) -> int: ...
    @height.setter
    def height(self, value: int) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def imageContentsHash(self) -> Hash128: ...
    @imageContentsHash.setter
    def imageContentsHash(self, value: Hash128) -> Hash128: ...
    @property
    def isDataSRGB(self) -> bool: ...
    @property
    def isPlaying(self) -> bool: ...
    @property
    def isReadable(self) -> bool: ...
    @property
    def isReadyToPlay(self) -> bool: ...
    @property
    def loop(self) -> bool: ...
    @loop.setter
    def loop(self, value: bool) -> bool: ...
    @property
    def mipMapBias(self) -> float: ...
    @mipMapBias.setter
    def mipMapBias(self, value: float) -> float: ...
    @property
    def mipmapCount(self) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def texelSize(self) -> Vector2: ...
    @property
    def updateCount(self) -> int: ...
    @property
    def width(self) -> int: ...
    @width.setter
    def width(self, value: int) -> int: ...
    @property
    def wrapMode(self) -> TextureWrapMode: ...
    @wrapMode.setter
    def wrapMode(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeU(self) -> TextureWrapMode: ...
    @wrapModeU.setter
    def wrapModeU(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeV(self) -> TextureWrapMode: ...
    @wrapModeV.setter
    def wrapModeV(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeW(self) -> TextureWrapMode: ...
    @wrapModeW.setter
    def wrapModeW(self, value: TextureWrapMode) -> TextureWrapMode: ...
    def Pause(self) -> None: ...
    def Play(self) -> None: ...
    def Stop(self) -> None: ...


class MultilineAttribute(PropertyAttribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, lines: int) -> None: ...
    lines : int
    @property
    def order(self) -> int: ...
    @order.setter
    def order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class Network:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def connections(cls) -> Array_1[NetworkPlayer]: ...
    @classmethod
    @property
    def connectionTesterIP(cls) -> str: ...
    @classmethod
    @connectionTesterIP.setter
    def connectionTesterIP(cls, value: str) -> str: ...
    @classmethod
    @property
    def connectionTesterPort(cls) -> int: ...
    @classmethod
    @connectionTesterPort.setter
    def connectionTesterPort(cls, value: int) -> int: ...
    @classmethod
    @property
    def incomingPassword(cls) -> str: ...
    @classmethod
    @incomingPassword.setter
    def incomingPassword(cls, value: str) -> str: ...
    @classmethod
    @property
    def isClient(cls) -> bool: ...
    @classmethod
    @property
    def isMessageQueueRunning(cls) -> bool: ...
    @classmethod
    @isMessageQueueRunning.setter
    def isMessageQueueRunning(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def isServer(cls) -> bool: ...
    @classmethod
    @property
    def logLevel(cls) -> NetworkLogLevel: ...
    @classmethod
    @logLevel.setter
    def logLevel(cls, value: NetworkLogLevel) -> NetworkLogLevel: ...
    @classmethod
    @property
    def maxConnections(cls) -> int: ...
    @classmethod
    @maxConnections.setter
    def maxConnections(cls, value: int) -> int: ...
    @classmethod
    @property
    def minimumAllocatableViewIDs(cls) -> int: ...
    @classmethod
    @minimumAllocatableViewIDs.setter
    def minimumAllocatableViewIDs(cls, value: int) -> int: ...
    @classmethod
    @property
    def natFacilitatorIP(cls) -> str: ...
    @classmethod
    @natFacilitatorIP.setter
    def natFacilitatorIP(cls, value: str) -> str: ...
    @classmethod
    @property
    def natFacilitatorPort(cls) -> int: ...
    @classmethod
    @natFacilitatorPort.setter
    def natFacilitatorPort(cls, value: int) -> int: ...
    @classmethod
    @property
    def peerType(cls) -> NetworkPeerType: ...
    @classmethod
    @property
    def player(cls) -> NetworkPlayer: ...
    @classmethod
    @property
    def proxyIP(cls) -> str: ...
    @classmethod
    @proxyIP.setter
    def proxyIP(cls, value: str) -> str: ...
    @classmethod
    @property
    def proxyPassword(cls) -> str: ...
    @classmethod
    @proxyPassword.setter
    def proxyPassword(cls, value: str) -> str: ...
    @classmethod
    @property
    def proxyPort(cls) -> int: ...
    @classmethod
    @proxyPort.setter
    def proxyPort(cls, value: int) -> int: ...
    @classmethod
    @property
    def sendRate(cls) -> float: ...
    @classmethod
    @sendRate.setter
    def sendRate(cls, value: float) -> float: ...
    @classmethod
    @property
    def time(cls) -> float: ...
    @classmethod
    @property
    def useNat(cls) -> bool: ...
    @classmethod
    @useNat.setter
    def useNat(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def useProxy(cls) -> bool: ...
    @classmethod
    @useProxy.setter
    def useProxy(cls, value: bool) -> bool: ...
    @staticmethod
    def AllocateViewID() -> NetworkViewID: ...
    @staticmethod
    def CloseConnection(target: NetworkPlayer, sendDisconnectionNotification: bool) -> None: ...
    @staticmethod
    def DestroyPlayerObjects(playerID: NetworkPlayer) -> None: ...
    @staticmethod
    def GetAveragePing(player: NetworkPlayer) -> int: ...
    @staticmethod
    def GetLastPing(player: NetworkPlayer) -> int: ...
    @staticmethod
    def HavePublicAddress() -> bool: ...
    @staticmethod
    def InitializeSecurity() -> None: ...
    @staticmethod
    def Instantiate(prefab: Object, position: Vector3, rotation: Quaternion, group: int) -> Object: ...
    @staticmethod
    def RemoveRPCsInGroup(group: int) -> None: ...
    @staticmethod
    def SetLevelPrefix(prefix: int) -> None: ...
    @staticmethod
    def SetReceivingEnabled(player: NetworkPlayer, group: int, enabled: bool) -> None: ...
    # Skipped Connect due to it being static, abstract and generic.

    Connect : Connect_MethodGroup
    class Connect_MethodGroup:
        @typing.overload
        def __call__(self, GUID: str) -> NetworkConnectionError:...
        @typing.overload
        def __call__(self, hostData: HostData) -> NetworkConnectionError:...
        @typing.overload
        def __call__(self, IPs: Array_1[str], remotePort: int) -> NetworkConnectionError:...
        @typing.overload
        def __call__(self, IP: str, remotePort: int) -> NetworkConnectionError:...
        @typing.overload
        def __call__(self, GUID: str, password: str) -> NetworkConnectionError:...
        @typing.overload
        def __call__(self, hostData: HostData, password: str) -> NetworkConnectionError:...
        @typing.overload
        def __call__(self, IPs: Array_1[str], remotePort: int, password: str) -> NetworkConnectionError:...
        @typing.overload
        def __call__(self, IP: str, remotePort: int, password: str) -> NetworkConnectionError:...

    # Skipped Destroy due to it being static, abstract and generic.

    Destroy : Destroy_MethodGroup
    class Destroy_MethodGroup:
        @typing.overload
        def __call__(self, gameObject: GameObject) -> None:...
        @typing.overload
        def __call__(self, viewID: NetworkViewID) -> None:...

    # Skipped Disconnect due to it being static, abstract and generic.

    Disconnect : Disconnect_MethodGroup
    class Disconnect_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, timeout: int) -> None:...

    # Skipped InitializeServer due to it being static, abstract and generic.

    InitializeServer : InitializeServer_MethodGroup
    class InitializeServer_MethodGroup:
        @typing.overload
        def __call__(self, connections: int, listenPort: int) -> NetworkConnectionError:...
        @typing.overload
        def __call__(self, connections: int, listenPort: int, useNat: bool) -> NetworkConnectionError:...

    # Skipped RemoveRPCs due to it being static, abstract and generic.

    RemoveRPCs : RemoveRPCs_MethodGroup
    class RemoveRPCs_MethodGroup:
        @typing.overload
        def __call__(self, playerID: NetworkPlayer) -> None:...
        @typing.overload
        def __call__(self, viewID: NetworkViewID) -> None:...
        @typing.overload
        def __call__(self, playerID: NetworkPlayer, group: int) -> None:...

    # Skipped SetSendingEnabled due to it being static, abstract and generic.

    SetSendingEnabled : SetSendingEnabled_MethodGroup
    class SetSendingEnabled_MethodGroup:
        @typing.overload
        def __call__(self, group: int, enabled: bool) -> None:...
        @typing.overload
        def __call__(self, player: NetworkPlayer, group: int, enabled: bool) -> None:...

    # Skipped TestConnection due to it being static, abstract and generic.

    TestConnection : TestConnection_MethodGroup
    class TestConnection_MethodGroup:
        @typing.overload
        def __call__(self) -> ConnectionTesterStatus:...
        @typing.overload
        def __call__(self, forceTest: bool) -> ConnectionTesterStatus:...

    # Skipped TestConnectionNAT due to it being static, abstract and generic.

    TestConnectionNAT : TestConnectionNAT_MethodGroup
    class TestConnectionNAT_MethodGroup:
        @typing.overload
        def __call__(self) -> ConnectionTesterStatus:...
        @typing.overload
        def __call__(self, forceTest: bool) -> ConnectionTesterStatus:...



class NetworkConnectionError(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:


class NetworkDisconnection(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:


class NetworkLogLevel(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:


class NetworkMessageInfo:
    @property
    def networkView(self) -> NetworkView: ...
    @property
    def sender(self) -> NetworkPlayer: ...
    @property
    def timestamp(self) -> float: ...


class NetworkPeerType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:


class NetworkPlayer:
    def __init__(self, ip: str, port: int) -> None: ...
    @property
    def externalIP(self) -> str: ...
    @property
    def externalPort(self) -> int: ...
    @property
    def guid(self) -> str: ...
    @property
    def ipAddress(self) -> str: ...
    @property
    def port(self) -> int: ...


class NetworkReachability(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    NotReachable : NetworkReachability # 0
    ReachableViaCarrierDataNetwork : NetworkReachability # 1
    ReachableViaLocalAreaNetwork : NetworkReachability # 2


class NetworkStateSynchronization(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:


class NetworkView(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def group(self) -> int: ...
    @group.setter
    def group(self, value: int) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def isMine(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def observed(self) -> Component: ...
    @observed.setter
    def observed(self, value: Component) -> Component: ...
    @property
    def owner(self) -> NetworkPlayer: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def stateSynchronization(self) -> NetworkStateSynchronization: ...
    @stateSynchronization.setter
    def stateSynchronization(self, value: NetworkStateSynchronization) -> NetworkStateSynchronization: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def viewID(self) -> NetworkViewID: ...
    @viewID.setter
    def viewID(self, value: NetworkViewID) -> NetworkViewID: ...
    # Skipped RPC due to it being static, abstract and generic.

    RPC : RPC_MethodGroup
    class RPC_MethodGroup:
        @typing.overload
        def __call__(self, name: str, mode: RPCMode, args: Array_1[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, name: str, target: NetworkPlayer, args: Array_1[typing.Any]) -> None:...



class NetworkViewID:
    @property
    def isMine(self) -> bool: ...
    @property
    def owner(self) -> NetworkPlayer: ...
    @classmethod
    @property
    def unassigned(cls) -> NetworkViewID: ...


class NonReorderableAttribute(PropertyAttribute):
    def __init__(self) -> None: ...
    @property
    def order(self) -> int: ...
    @order.setter
    def order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class NPOTSupport(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : NPOTSupport # 0
    Restricted : NPOTSupport # 1
    Full : NPOTSupport # 2


class Object:
    def __init__(self) -> None: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @staticmethod
    def DontDestroyOnLoad(target: Object) -> None: ...
    def Equals(self, other: typing.Any) -> bool: ...
    @staticmethod
    def FindObjectsOfTypeAll(type: typing.Type[typing.Any]) -> Array_1[Object]: ...
    @staticmethod
    def FindObjectsOfTypeIncludingAssets(type: typing.Type[typing.Any]) -> Array_1[Object]: ...
    @staticmethod
    def FindSceneObjectsOfType(type: typing.Type[typing.Any]) -> Array_1[Object]: ...
    def GetHashCode(self) -> int: ...
    def GetInstanceID(self) -> int: ...
    def __eq__(self, x: Object, y: Object) -> bool: ...
    # Operator not supported op_Implicit(exists: Object)
    def __ne__(self, x: Object, y: Object) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Destroy due to it being static, abstract and generic.

    Destroy : Destroy_MethodGroup
    class Destroy_MethodGroup:
        @typing.overload
        def __call__(self, obj: Object) -> None:...
        @typing.overload
        def __call__(self, obj: Object, t: float) -> None:...

    # Skipped DestroyImmediate due to it being static, abstract and generic.

    DestroyImmediate : DestroyImmediate_MethodGroup
    class DestroyImmediate_MethodGroup:
        @typing.overload
        def __call__(self, obj: Object) -> None:...
        @typing.overload
        def __call__(self, obj: Object, allowDestroyingAssets: bool) -> None:...

    # Skipped DestroyObject due to it being static, abstract and generic.

    DestroyObject : DestroyObject_MethodGroup
    class DestroyObject_MethodGroup:
        @typing.overload
        def __call__(self, obj: Object) -> None:...
        @typing.overload
        def __call__(self, obj: Object, t: float) -> None:...

    # Skipped FindAnyObjectByType due to it being static, abstract and generic.

    FindAnyObjectByType : FindAnyObjectByType_MethodGroup
    class FindAnyObjectByType_MethodGroup:
        def __getitem__(self, t:typing.Type[FindAnyObjectByType_1_T1]) -> FindAnyObjectByType_1[FindAnyObjectByType_1_T1]: ...

        FindAnyObjectByType_1_T1 = typing.TypeVar('FindAnyObjectByType_1_T1')
        class FindAnyObjectByType_1(typing.Generic[FindAnyObjectByType_1_T1]):
            FindAnyObjectByType_1_T = Object.FindAnyObjectByType_MethodGroup.FindAnyObjectByType_1_T1
            @typing.overload
            def __call__(self) -> FindAnyObjectByType_1_T:...
            @typing.overload
            def __call__(self, findObjectsInactive: FindObjectsInactive) -> FindAnyObjectByType_1_T:...

        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> Object:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], findObjectsInactive: FindObjectsInactive) -> Object:...

    # Skipped FindFirstObjectByType due to it being static, abstract and generic.

    FindFirstObjectByType : FindFirstObjectByType_MethodGroup
    class FindFirstObjectByType_MethodGroup:
        def __getitem__(self, t:typing.Type[FindFirstObjectByType_1_T1]) -> FindFirstObjectByType_1[FindFirstObjectByType_1_T1]: ...

        FindFirstObjectByType_1_T1 = typing.TypeVar('FindFirstObjectByType_1_T1')
        class FindFirstObjectByType_1(typing.Generic[FindFirstObjectByType_1_T1]):
            FindFirstObjectByType_1_T = Object.FindFirstObjectByType_MethodGroup.FindFirstObjectByType_1_T1
            @typing.overload
            def __call__(self) -> FindFirstObjectByType_1_T:...
            @typing.overload
            def __call__(self, findObjectsInactive: FindObjectsInactive) -> FindFirstObjectByType_1_T:...

        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> Object:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], findObjectsInactive: FindObjectsInactive) -> Object:...

    # Skipped FindObjectOfType due to it being static, abstract and generic.

    FindObjectOfType : FindObjectOfType_MethodGroup
    class FindObjectOfType_MethodGroup:
        def __getitem__(self, t:typing.Type[FindObjectOfType_1_T1]) -> FindObjectOfType_1[FindObjectOfType_1_T1]: ...

        FindObjectOfType_1_T1 = typing.TypeVar('FindObjectOfType_1_T1')
        class FindObjectOfType_1(typing.Generic[FindObjectOfType_1_T1]):
            FindObjectOfType_1_T = Object.FindObjectOfType_MethodGroup.FindObjectOfType_1_T1
            @typing.overload
            def __call__(self) -> FindObjectOfType_1_T:...
            @typing.overload
            def __call__(self, includeInactive: bool) -> FindObjectOfType_1_T:...

        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> Object:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], includeInactive: bool) -> Object:...

    # Skipped FindObjectsByType due to it being static, abstract and generic.

    FindObjectsByType : FindObjectsByType_MethodGroup
    class FindObjectsByType_MethodGroup:
        def __getitem__(self, t:typing.Type[FindObjectsByType_1_T1]) -> FindObjectsByType_1[FindObjectsByType_1_T1]: ...

        FindObjectsByType_1_T1 = typing.TypeVar('FindObjectsByType_1_T1')
        class FindObjectsByType_1(typing.Generic[FindObjectsByType_1_T1]):
            FindObjectsByType_1_T = Object.FindObjectsByType_MethodGroup.FindObjectsByType_1_T1
            @typing.overload
            def __call__(self, sortMode: FindObjectsSortMode) -> Array_1[FindObjectsByType_1_T]:...
            @typing.overload
            def __call__(self, findObjectsInactive: FindObjectsInactive, sortMode: FindObjectsSortMode) -> Array_1[FindObjectsByType_1_T]:...

        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], sortMode: FindObjectsSortMode) -> Array_1[Object]:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], findObjectsInactive: FindObjectsInactive, sortMode: FindObjectsSortMode) -> Array_1[Object]:...

    # Skipped FindObjectsOfType due to it being static, abstract and generic.

    FindObjectsOfType : FindObjectsOfType_MethodGroup
    class FindObjectsOfType_MethodGroup:
        def __getitem__(self, t:typing.Type[FindObjectsOfType_1_T1]) -> FindObjectsOfType_1[FindObjectsOfType_1_T1]: ...

        FindObjectsOfType_1_T1 = typing.TypeVar('FindObjectsOfType_1_T1')
        class FindObjectsOfType_1(typing.Generic[FindObjectsOfType_1_T1]):
            FindObjectsOfType_1_T = Object.FindObjectsOfType_MethodGroup.FindObjectsOfType_1_T1
            @typing.overload
            def __call__(self) -> Array_1[FindObjectsOfType_1_T]:...
            @typing.overload
            def __call__(self, includeInactive: bool) -> Array_1[FindObjectsOfType_1_T]:...

        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> Array_1[Object]:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], includeInactive: bool) -> Array_1[Object]:...

    # Skipped Instantiate due to it being static, abstract and generic.

    Instantiate : Instantiate_MethodGroup
    class Instantiate_MethodGroup:
        def __getitem__(self, t:typing.Type[Instantiate_1_T1]) -> Instantiate_1[Instantiate_1_T1]: ...

        Instantiate_1_T1 = typing.TypeVar('Instantiate_1_T1')
        class Instantiate_1(typing.Generic[Instantiate_1_T1]):
            Instantiate_1_T = Object.Instantiate_MethodGroup.Instantiate_1_T1
            @typing.overload
            def __call__(self, original: Instantiate_1_T) -> Instantiate_1_T:...
            @typing.overload
            def __call__(self, original: Instantiate_1_T, parent: Transform) -> Instantiate_1_T:...
            @typing.overload
            def __call__(self, original: Instantiate_1_T, parent: Transform, worldPositionStays: bool) -> Instantiate_1_T:...
            @typing.overload
            def __call__(self, original: Instantiate_1_T, position: Vector3, rotation: Quaternion) -> Instantiate_1_T:...
            @typing.overload
            def __call__(self, original: Instantiate_1_T, position: Vector3, rotation: Quaternion, parent: Transform) -> Instantiate_1_T:...

        @typing.overload
        def __call__(self, original: Object) -> Object:...
        @typing.overload
        def __call__(self, original: Object, parent: Transform) -> Object:...
        @typing.overload
        def __call__(self, original: Object, scene: Scene) -> Object:...
        @typing.overload
        def __call__(self, original: Object, parent: Transform, instantiateInWorldSpace: bool) -> Object:...
        @typing.overload
        def __call__(self, original: Object, position: Vector3, rotation: Quaternion) -> Object:...
        @typing.overload
        def __call__(self, original: Object, position: Vector3, rotation: Quaternion, parent: Transform) -> Object:...

    # Skipped InstantiateAsync due to it being static, abstract and generic.

    InstantiateAsync : InstantiateAsync_MethodGroup
    class InstantiateAsync_MethodGroup:
        def __getitem__(self, t:typing.Type[InstantiateAsync_1_T1]) -> InstantiateAsync_1[InstantiateAsync_1_T1]: ...

        InstantiateAsync_1_T1 = typing.TypeVar('InstantiateAsync_1_T1')
        class InstantiateAsync_1(typing.Generic[InstantiateAsync_1_T1]):
            InstantiateAsync_1_T = Object.InstantiateAsync_MethodGroup.InstantiateAsync_1_T1
            @typing.overload
            def __call__(self, original: InstantiateAsync_1_T) -> AsyncInstantiateOperation_1[InstantiateAsync_1_T]:...
            @typing.overload
            def __call__(self, original: InstantiateAsync_1_T, count: int) -> AsyncInstantiateOperation_1[InstantiateAsync_1_T]:...
            @typing.overload
            def __call__(self, original: InstantiateAsync_1_T, parent: Transform) -> AsyncInstantiateOperation_1[InstantiateAsync_1_T]:...
            @typing.overload
            def __call__(self, original: InstantiateAsync_1_T, count: int, parent: Transform) -> AsyncInstantiateOperation_1[InstantiateAsync_1_T]:...
            @typing.overload
            def __call__(self, original: InstantiateAsync_1_T, position: Vector3, rotation: Quaternion) -> AsyncInstantiateOperation_1[InstantiateAsync_1_T]:...
            @typing.overload
            def __call__(self, original: InstantiateAsync_1_T, count: int, positions: ReadOnlySpan_1[Vector3], rotations: ReadOnlySpan_1[Quaternion]) -> AsyncInstantiateOperation_1[InstantiateAsync_1_T]:...
            @typing.overload
            def __call__(self, original: InstantiateAsync_1_T, count: int, position: Vector3, rotation: Quaternion) -> AsyncInstantiateOperation_1[InstantiateAsync_1_T]:...
            @typing.overload
            def __call__(self, original: InstantiateAsync_1_T, parent: Transform, position: Vector3, rotation: Quaternion) -> AsyncInstantiateOperation_1[InstantiateAsync_1_T]:...
            @typing.overload
            def __call__(self, original: InstantiateAsync_1_T, count: int, parent: Transform, positions: ReadOnlySpan_1[Vector3], rotations: ReadOnlySpan_1[Quaternion]) -> AsyncInstantiateOperation_1[InstantiateAsync_1_T]:...
            @typing.overload
            def __call__(self, original: InstantiateAsync_1_T, count: int, parent: Transform, position: Vector3, rotation: Quaternion) -> AsyncInstantiateOperation_1[InstantiateAsync_1_T]:...




class OcclusionArea(Component):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def center(self) -> Vector3: ...
    @center.setter
    def center(self, value: Vector3) -> Vector3: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def size(self) -> Vector3: ...
    @size.setter
    def size(self, value: Vector3) -> Vector3: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class OcclusionPortal(Component):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def open(self) -> bool: ...
    @open.setter
    def open(self, value: bool) -> bool: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class OperatingSystemFamily(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Other : OperatingSystemFamily # 0
    MacOSX : OperatingSystemFamily # 1
    Windows : OperatingSystemFamily # 2
    Linux : OperatingSystemFamily # 3


class OverlapBoxCommand:
    @typing.overload
    def __init__(self, center: Vector3, halfExtents: Vector3, orientation: Quaternion, queryParameters: QueryParameters) -> None: ...
    @typing.overload
    def __init__(self, physicsScene: PhysicsScene, center: Vector3, halfExtents: Vector3, orientation: Quaternion, queryParameters: QueryParameters) -> None: ...
    queryParameters : QueryParameters
    @property
    def center(self) -> Vector3: ...
    @center.setter
    def center(self, value: Vector3) -> Vector3: ...
    @property
    def halfExtents(self) -> Vector3: ...
    @halfExtents.setter
    def halfExtents(self, value: Vector3) -> Vector3: ...
    @property
    def orientation(self) -> Quaternion: ...
    @orientation.setter
    def orientation(self, value: Quaternion) -> Quaternion: ...
    @property
    def physicsScene(self) -> PhysicsScene: ...
    @physicsScene.setter
    def physicsScene(self, value: PhysicsScene) -> PhysicsScene: ...
    @staticmethod
    def ScheduleBatch(commands: NativeArray_1[OverlapBoxCommand], results: NativeArray_1[ColliderHit], minCommandsPerJob: int, maxHits: int, dependsOn: JobHandle = ...) -> JobHandle: ...


class OverlapCapsuleCommand:
    @typing.overload
    def __init__(self, physicsScene: PhysicsScene, point0: Vector3, point1: Vector3, radius: float, queryParameters: QueryParameters) -> None: ...
    @typing.overload
    def __init__(self, point0: Vector3, point1: Vector3, radius: float, queryParameters: QueryParameters) -> None: ...
    queryParameters : QueryParameters
    @property
    def physicsScene(self) -> PhysicsScene: ...
    @physicsScene.setter
    def physicsScene(self, value: PhysicsScene) -> PhysicsScene: ...
    @property
    def point0(self) -> Vector3: ...
    @point0.setter
    def point0(self, value: Vector3) -> Vector3: ...
    @property
    def point1(self) -> Vector3: ...
    @point1.setter
    def point1(self, value: Vector3) -> Vector3: ...
    @property
    def radius(self) -> float: ...
    @radius.setter
    def radius(self, value: float) -> float: ...
    @staticmethod
    def ScheduleBatch(commands: NativeArray_1[OverlapCapsuleCommand], results: NativeArray_1[ColliderHit], minCommandsPerJob: int, maxHits: int, dependsOn: JobHandle = ...) -> JobHandle: ...


class OverlapSphereCommand:
    @typing.overload
    def __init__(self, physicsScene: PhysicsScene, point: Vector3, radius: float, queryParameters: QueryParameters) -> None: ...
    @typing.overload
    def __init__(self, point: Vector3, radius: float, queryParameters: QueryParameters) -> None: ...
    queryParameters : QueryParameters
    @property
    def physicsScene(self) -> PhysicsScene: ...
    @physicsScene.setter
    def physicsScene(self, value: PhysicsScene) -> PhysicsScene: ...
    @property
    def point(self) -> Vector3: ...
    @point.setter
    def point(self, value: Vector3) -> Vector3: ...
    @property
    def radius(self) -> float: ...
    @radius.setter
    def radius(self, value: float) -> float: ...
    @staticmethod
    def ScheduleBatch(commands: NativeArray_1[OverlapSphereCommand], results: NativeArray_1[ColliderHit], minCommandsPerJob: int, maxHits: int, dependsOn: JobHandle = ...) -> JobHandle: ...


class ParticleCollisionEvent:
    @property
    def collider(self) -> Component: ...
    @property
    def colliderComponent(self) -> Component: ...
    @property
    def intersection(self) -> Vector3: ...
    @property
    def normal(self) -> Vector3: ...
    @property
    def velocity(self) -> Vector3: ...


class ParticlePhysicsExtensions(abc.ABC):
    @staticmethod
    def GetSafeCollisionEventSize(ps: ParticleSystem) -> int: ...
    @staticmethod
    def GetSafeTriggerParticlesSize(ps: ParticleSystem, type: ParticleSystemTriggerEventType) -> int: ...
    # Skipped GetCollisionEvents due to it being static, abstract and generic.

    GetCollisionEvents : GetCollisionEvents_MethodGroup
    class GetCollisionEvents_MethodGroup:
        @typing.overload
        def __call__(self, ps: ParticleSystem, go: GameObject, collisionEvents: Array_1[ParticleCollisionEvent]) -> int:...
        @typing.overload
        def __call__(self, ps: ParticleSystem, go: GameObject, collisionEvents: List_1[ParticleCollisionEvent]) -> int:...

    # Skipped GetTriggerParticles due to it being static, abstract and generic.

    GetTriggerParticles : GetTriggerParticles_MethodGroup
    class GetTriggerParticles_MethodGroup:
        @typing.overload
        def __call__(self, ps: ParticleSystem, type: ParticleSystemTriggerEventType, particles: List_1[ParticleSystem.Particle]) -> int:...
        @typing.overload
        def __call__(self, ps: ParticleSystem, type: ParticleSystemTriggerEventType, particles: List_1[ParticleSystem.Particle], colliderData: clr.Reference[ParticleSystem.ColliderData]) -> int:...

    # Skipped SetTriggerParticles due to it being static, abstract and generic.

    SetTriggerParticles : SetTriggerParticles_MethodGroup
    class SetTriggerParticles_MethodGroup:
        @typing.overload
        def __call__(self, ps: ParticleSystem, type: ParticleSystemTriggerEventType, particles: List_1[ParticleSystem.Particle]) -> None:...
        @typing.overload
        def __call__(self, ps: ParticleSystem, type: ParticleSystemTriggerEventType, particles: List_1[ParticleSystem.Particle], offset: int, count: int) -> None:...



class ParticleSystem(Component):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def automaticCullingEnabled(self) -> bool: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def collision(self) -> ParticleSystem.CollisionModule: ...
    @property
    def colorBySpeed(self) -> ParticleSystem.ColorBySpeedModule: ...
    @property
    def colorOverLifetime(self) -> ParticleSystem.ColorOverLifetimeModule: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def customData(self) -> ParticleSystem.CustomDataModule: ...
    @property
    def duration(self) -> float: ...
    @property
    def emission(self) -> ParticleSystem.EmissionModule: ...
    @property
    def emissionRate(self) -> float: ...
    @emissionRate.setter
    def emissionRate(self, value: float) -> float: ...
    @property
    def enableEmission(self) -> bool: ...
    @enableEmission.setter
    def enableEmission(self, value: bool) -> bool: ...
    @property
    def externalForces(self) -> ParticleSystem.ExternalForcesModule: ...
    @property
    def forceOverLifetime(self) -> ParticleSystem.ForceOverLifetimeModule: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def gravityModifier(self) -> float: ...
    @gravityModifier.setter
    def gravityModifier(self, value: float) -> float: ...
    @property
    def has3DParticleRotations(self) -> bool: ...
    @property
    def hasNonUniformParticleSizes(self) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def inheritVelocity(self) -> ParticleSystem.InheritVelocityModule: ...
    @property
    def isEmitting(self) -> bool: ...
    @property
    def isPaused(self) -> bool: ...
    @property
    def isPlaying(self) -> bool: ...
    @property
    def isStopped(self) -> bool: ...
    @property
    def lifetimeByEmitterSpeed(self) -> ParticleSystem.LifetimeByEmitterSpeedModule: ...
    @property
    def light(self) -> Component: ...
    @property
    def lights(self) -> ParticleSystem.LightsModule: ...
    @property
    def limitVelocityOverLifetime(self) -> ParticleSystem.LimitVelocityOverLifetimeModule: ...
    @property
    def loop(self) -> bool: ...
    @loop.setter
    def loop(self, value: bool) -> bool: ...
    @property
    def main(self) -> ParticleSystem.MainModule: ...
    @property
    def maxParticles(self) -> int: ...
    @maxParticles.setter
    def maxParticles(self, value: int) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def noise(self) -> ParticleSystem.NoiseModule: ...
    @property
    def particleCount(self) -> int: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def playbackSpeed(self) -> float: ...
    @playbackSpeed.setter
    def playbackSpeed(self, value: float) -> float: ...
    @property
    def playOnAwake(self) -> bool: ...
    @playOnAwake.setter
    def playOnAwake(self, value: bool) -> bool: ...
    @property
    def proceduralSimulationSupported(self) -> bool: ...
    @property
    def randomSeed(self) -> int: ...
    @randomSeed.setter
    def randomSeed(self, value: int) -> int: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def rotationBySpeed(self) -> ParticleSystem.RotationBySpeedModule: ...
    @property
    def rotationOverLifetime(self) -> ParticleSystem.RotationOverLifetimeModule: ...
    @property
    def safeCollisionEventSize(self) -> int: ...
    @property
    def scalingMode(self) -> ParticleSystemScalingMode: ...
    @scalingMode.setter
    def scalingMode(self, value: ParticleSystemScalingMode) -> ParticleSystemScalingMode: ...
    @property
    def shape(self) -> ParticleSystem.ShapeModule: ...
    @property
    def simulationSpace(self) -> ParticleSystemSimulationSpace: ...
    @simulationSpace.setter
    def simulationSpace(self, value: ParticleSystemSimulationSpace) -> ParticleSystemSimulationSpace: ...
    @property
    def sizeBySpeed(self) -> ParticleSystem.SizeBySpeedModule: ...
    @property
    def sizeOverLifetime(self) -> ParticleSystem.SizeOverLifetimeModule: ...
    @property
    def startColor(self) -> Color: ...
    @startColor.setter
    def startColor(self, value: Color) -> Color: ...
    @property
    def startDelay(self) -> float: ...
    @startDelay.setter
    def startDelay(self, value: float) -> float: ...
    @property
    def startLifetime(self) -> float: ...
    @startLifetime.setter
    def startLifetime(self, value: float) -> float: ...
    @property
    def startRotation(self) -> float: ...
    @startRotation.setter
    def startRotation(self, value: float) -> float: ...
    @property
    def startRotation3D(self) -> Vector3: ...
    @startRotation3D.setter
    def startRotation3D(self, value: Vector3) -> Vector3: ...
    @property
    def startSize(self) -> float: ...
    @startSize.setter
    def startSize(self, value: float) -> float: ...
    @property
    def startSpeed(self) -> float: ...
    @startSpeed.setter
    def startSpeed(self, value: float) -> float: ...
    @property
    def subEmitters(self) -> ParticleSystem.SubEmittersModule: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def textureSheetAnimation(self) -> ParticleSystem.TextureSheetAnimationModule: ...
    @property
    def time(self) -> float: ...
    @time.setter
    def time(self, value: float) -> float: ...
    @property
    def totalTime(self) -> float: ...
    @property
    def trails(self) -> ParticleSystem.TrailModule: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def trigger(self) -> ParticleSystem.TriggerModule: ...
    @property
    def useAutoRandomSeed(self) -> bool: ...
    @useAutoRandomSeed.setter
    def useAutoRandomSeed(self, value: bool) -> bool: ...
    @property
    def velocityOverLifetime(self) -> ParticleSystem.VelocityOverLifetimeModule: ...
    def AllocateAxisOfRotationAttribute(self) -> None: ...
    def AllocateCustomDataAttribute(self, stream: ParticleSystemCustomData) -> None: ...
    def AllocateMeshIndexAttribute(self) -> None: ...
    def GetCustomParticleData(self, customData: List_1[Vector4], streamIndex: ParticleSystemCustomData) -> int: ...
    def GetPlaybackState(self) -> ParticleSystem.PlaybackState: ...
    @staticmethod
    def ResetPreMappedBufferMemory() -> None: ...
    def SetCustomParticleData(self, customData: List_1[Vector4], streamIndex: ParticleSystemCustomData) -> None: ...
    @staticmethod
    def SetMaximumPreMappedBufferCounts(vertexBuffersCount: int, indexBuffersCount: int) -> None: ...
    def SetPlaybackState(self, playbackState: ParticleSystem.PlaybackState) -> None: ...
    def SetTrails(self, trailData: ParticleSystem.Trails) -> None: ...
    # Skipped Clear due to it being static, abstract and generic.

    Clear : Clear_MethodGroup
    class Clear_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, withChildren: bool) -> None:...

    # Skipped Emit due to it being static, abstract and generic.

    Emit : Emit_MethodGroup
    class Emit_MethodGroup:
        @typing.overload
        def __call__(self, count: int) -> None:...
        @typing.overload
        def __call__(self, particle: ParticleSystem.Particle) -> None:...
        @typing.overload
        def __call__(self, emitParams: ParticleSystem.EmitParams, count: int) -> None:...
        @typing.overload
        def __call__(self, position: Vector3, velocity: Vector3, size: float, lifetime: float, color: Color32) -> None:...

    # Skipped GetParticles due to it being static, abstract and generic.

    GetParticles : GetParticles_MethodGroup
    class GetParticles_MethodGroup:
        @typing.overload
        def __call__(self, particles: Array_1[ParticleSystem.Particle]) -> int:...
        @typing.overload
        def __call__(self, particles: NativeArray_1[ParticleSystem.Particle]) -> int:...
        @typing.overload
        def __call__(self, particles: Array_1[ParticleSystem.Particle], size: int) -> int:...
        @typing.overload
        def __call__(self, particles: NativeArray_1[ParticleSystem.Particle], size: int) -> int:...
        @typing.overload
        def __call__(self, particles: Array_1[ParticleSystem.Particle], size: int, offset: int) -> int:...
        @typing.overload
        def __call__(self, particles: NativeArray_1[ParticleSystem.Particle], size: int, offset: int) -> int:...

    # Skipped GetTrails due to it being static, abstract and generic.

    GetTrails : GetTrails_MethodGroup
    class GetTrails_MethodGroup:
        @typing.overload
        def __call__(self) -> ParticleSystem.Trails:...
        @typing.overload
        def __call__(self, trailData: clr.Reference[ParticleSystem.Trails]) -> int:...

    # Skipped IsAlive due to it being static, abstract and generic.

    IsAlive : IsAlive_MethodGroup
    class IsAlive_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, withChildren: bool) -> bool:...

    # Skipped Pause due to it being static, abstract and generic.

    Pause : Pause_MethodGroup
    class Pause_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, withChildren: bool) -> None:...

    # Skipped Play due to it being static, abstract and generic.

    Play : Play_MethodGroup
    class Play_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, withChildren: bool) -> None:...

    # Skipped SetParticles due to it being static, abstract and generic.

    SetParticles : SetParticles_MethodGroup
    class SetParticles_MethodGroup:
        @typing.overload
        def __call__(self, particles: Array_1[ParticleSystem.Particle]) -> None:...
        @typing.overload
        def __call__(self, particles: NativeArray_1[ParticleSystem.Particle]) -> None:...
        @typing.overload
        def __call__(self, particles: Array_1[ParticleSystem.Particle], size: int) -> None:...
        @typing.overload
        def __call__(self, particles: NativeArray_1[ParticleSystem.Particle], size: int) -> None:...
        @typing.overload
        def __call__(self, particles: Array_1[ParticleSystem.Particle], size: int, offset: int) -> None:...
        @typing.overload
        def __call__(self, particles: NativeArray_1[ParticleSystem.Particle], size: int, offset: int) -> None:...

    # Skipped Simulate due to it being static, abstract and generic.

    Simulate : Simulate_MethodGroup
    class Simulate_MethodGroup:
        @typing.overload
        def __call__(self, t: float) -> None:...
        @typing.overload
        def __call__(self, t: float, withChildren: bool) -> None:...
        @typing.overload
        def __call__(self, t: float, withChildren: bool, restart: bool) -> None:...
        @typing.overload
        def __call__(self, t: float, withChildren: bool, restart: bool, fixedTimeStep: bool) -> None:...

    # Skipped Stop due to it being static, abstract and generic.

    Stop : Stop_MethodGroup
    class Stop_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, withChildren: bool) -> None:...
        @typing.overload
        def __call__(self, withChildren: bool, stopBehavior: ParticleSystemStopBehavior) -> None:...

    # Skipped TriggerSubEmitter due to it being static, abstract and generic.

    TriggerSubEmitter : TriggerSubEmitter_MethodGroup
    class TriggerSubEmitter_MethodGroup:
        @typing.overload
        def __call__(self, subEmitterIndex: int) -> None:...
        @typing.overload
        def __call__(self, subEmitterIndex: int, particles: List_1[ParticleSystem.Particle]) -> None:...
        @typing.overload
        def __call__(self, subEmitterIndex: int, particle: clr.Reference[ParticleSystem.Particle]) -> None:...


    class Burst:
        @typing.overload
        def __init__(self, _time: float, _count: int) -> None: ...
        @typing.overload
        def __init__(self, _time: float, _count: ParticleSystem.MinMaxCurve) -> None: ...
        @typing.overload
        def __init__(self, _time: float, _count: ParticleSystem.MinMaxCurve, _cycleCount: int, _repeatInterval: float) -> None: ...
        @typing.overload
        def __init__(self, _time: float, _minCount: int, _maxCount: int) -> None: ...
        @typing.overload
        def __init__(self, _time: float, _minCount: int, _maxCount: int, _cycleCount: int, _repeatInterval: float) -> None: ...
        @property
        def count(self) -> ParticleSystem.MinMaxCurve: ...
        @count.setter
        def count(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def cycleCount(self) -> int: ...
        @cycleCount.setter
        def cycleCount(self, value: int) -> int: ...
        @property
        def maxCount(self) -> int: ...
        @maxCount.setter
        def maxCount(self, value: int) -> int: ...
        @property
        def minCount(self) -> int: ...
        @minCount.setter
        def minCount(self, value: int) -> int: ...
        @property
        def probability(self) -> float: ...
        @probability.setter
        def probability(self, value: float) -> float: ...
        @property
        def repeatInterval(self) -> float: ...
        @repeatInterval.setter
        def repeatInterval(self, value: float) -> float: ...
        @property
        def time(self) -> float: ...
        @time.setter
        def time(self, value: float) -> float: ...


    class ColliderData:
        def GetCollider(self, particleIndex: int, colliderIndex: int) -> Component: ...
        def GetColliderCount(self, particleIndex: int) -> int: ...


    class CollisionEvent:
        @property
        def collider(self) -> Component: ...
        @property
        def intersection(self) -> Vector3: ...
        @property
        def normal(self) -> Vector3: ...
        @property
        def velocity(self) -> Vector3: ...


    class CollisionModule:
        @property
        def bounce(self) -> ParticleSystem.MinMaxCurve: ...
        @bounce.setter
        def bounce(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def bounceMultiplier(self) -> float: ...
        @bounceMultiplier.setter
        def bounceMultiplier(self, value: float) -> float: ...
        @property
        def colliderForce(self) -> float: ...
        @colliderForce.setter
        def colliderForce(self, value: float) -> float: ...
        @property
        def collidesWith(self) -> LayerMask: ...
        @collidesWith.setter
        def collidesWith(self, value: LayerMask) -> LayerMask: ...
        @property
        def dampen(self) -> ParticleSystem.MinMaxCurve: ...
        @dampen.setter
        def dampen(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def dampenMultiplier(self) -> float: ...
        @dampenMultiplier.setter
        def dampenMultiplier(self, value: float) -> float: ...
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def enableDynamicColliders(self) -> bool: ...
        @enableDynamicColliders.setter
        def enableDynamicColliders(self, value: bool) -> bool: ...
        @property
        def enableInteriorCollisions(self) -> bool: ...
        @enableInteriorCollisions.setter
        def enableInteriorCollisions(self, value: bool) -> bool: ...
        @property
        def lifetimeLoss(self) -> ParticleSystem.MinMaxCurve: ...
        @lifetimeLoss.setter
        def lifetimeLoss(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def lifetimeLossMultiplier(self) -> float: ...
        @lifetimeLossMultiplier.setter
        def lifetimeLossMultiplier(self, value: float) -> float: ...
        @property
        def maxCollisionShapes(self) -> int: ...
        @maxCollisionShapes.setter
        def maxCollisionShapes(self, value: int) -> int: ...
        @property
        def maxKillSpeed(self) -> float: ...
        @maxKillSpeed.setter
        def maxKillSpeed(self, value: float) -> float: ...
        @property
        def maxPlaneCount(self) -> int: ...
        @property
        def minKillSpeed(self) -> float: ...
        @minKillSpeed.setter
        def minKillSpeed(self, value: float) -> float: ...
        @property
        def mode(self) -> ParticleSystemCollisionMode: ...
        @mode.setter
        def mode(self, value: ParticleSystemCollisionMode) -> ParticleSystemCollisionMode: ...
        @property
        def multiplyColliderForceByCollisionAngle(self) -> bool: ...
        @multiplyColliderForceByCollisionAngle.setter
        def multiplyColliderForceByCollisionAngle(self, value: bool) -> bool: ...
        @property
        def multiplyColliderForceByParticleSize(self) -> bool: ...
        @multiplyColliderForceByParticleSize.setter
        def multiplyColliderForceByParticleSize(self, value: bool) -> bool: ...
        @property
        def multiplyColliderForceByParticleSpeed(self) -> bool: ...
        @multiplyColliderForceByParticleSpeed.setter
        def multiplyColliderForceByParticleSpeed(self, value: bool) -> bool: ...
        @property
        def planeCount(self) -> int: ...
        @property
        def quality(self) -> ParticleSystemCollisionQuality: ...
        @quality.setter
        def quality(self, value: ParticleSystemCollisionQuality) -> ParticleSystemCollisionQuality: ...
        @property
        def radiusScale(self) -> float: ...
        @radiusScale.setter
        def radiusScale(self, value: float) -> float: ...
        @property
        def sendCollisionMessages(self) -> bool: ...
        @sendCollisionMessages.setter
        def sendCollisionMessages(self, value: bool) -> bool: ...
        @property
        def type(self) -> ParticleSystemCollisionType: ...
        @type.setter
        def type(self, value: ParticleSystemCollisionType) -> ParticleSystemCollisionType: ...
        @property
        def voxelSize(self) -> float: ...
        @voxelSize.setter
        def voxelSize(self, value: float) -> float: ...
        def AddPlane(self, transform: Transform) -> None: ...
        def GetPlane(self, index: int) -> Transform: ...
        def SetPlane(self, index: int, transform: Transform) -> None: ...
        # Skipped RemovePlane due to it being static, abstract and generic.

        RemovePlane : RemovePlane_MethodGroup
        class RemovePlane_MethodGroup:
            @typing.overload
            def __call__(self, index: int) -> None:...
            @typing.overload
            def __call__(self, transform: Transform) -> None:...



    class ColorBySpeedModule:
        @property
        def color(self) -> ParticleSystem.MinMaxGradient: ...
        @color.setter
        def color(self, value: ParticleSystem.MinMaxGradient) -> ParticleSystem.MinMaxGradient: ...
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def range(self) -> Vector2: ...
        @range.setter
        def range(self, value: Vector2) -> Vector2: ...


    class ColorOverLifetimeModule:
        @property
        def color(self) -> ParticleSystem.MinMaxGradient: ...
        @color.setter
        def color(self, value: ParticleSystem.MinMaxGradient) -> ParticleSystem.MinMaxGradient: ...
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...


    class CustomDataModule:
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        def GetColor(self, stream: ParticleSystemCustomData) -> ParticleSystem.MinMaxGradient: ...
        def GetMode(self, stream: ParticleSystemCustomData) -> ParticleSystemCustomDataMode: ...
        def GetVector(self, stream: ParticleSystemCustomData, component: int) -> ParticleSystem.MinMaxCurve: ...
        def GetVectorComponentCount(self, stream: ParticleSystemCustomData) -> int: ...
        def SetColor(self, stream: ParticleSystemCustomData, gradient: ParticleSystem.MinMaxGradient) -> None: ...
        def SetMode(self, stream: ParticleSystemCustomData, mode: ParticleSystemCustomDataMode) -> None: ...
        def SetVector(self, stream: ParticleSystemCustomData, component: int, curve: ParticleSystem.MinMaxCurve) -> None: ...
        def SetVectorComponentCount(self, stream: ParticleSystemCustomData, count: int) -> None: ...


    class EmissionModule:
        @property
        def burstCount(self) -> int: ...
        @burstCount.setter
        def burstCount(self, value: int) -> int: ...
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def rate(self) -> ParticleSystem.MinMaxCurve: ...
        @rate.setter
        def rate(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def rateMultiplier(self) -> float: ...
        @rateMultiplier.setter
        def rateMultiplier(self, value: float) -> float: ...
        @property
        def rateOverDistance(self) -> ParticleSystem.MinMaxCurve: ...
        @rateOverDistance.setter
        def rateOverDistance(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def rateOverDistanceMultiplier(self) -> float: ...
        @rateOverDistanceMultiplier.setter
        def rateOverDistanceMultiplier(self, value: float) -> float: ...
        @property
        def rateOverTime(self) -> ParticleSystem.MinMaxCurve: ...
        @rateOverTime.setter
        def rateOverTime(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def rateOverTimeMultiplier(self) -> float: ...
        @rateOverTimeMultiplier.setter
        def rateOverTimeMultiplier(self, value: float) -> float: ...
        @property
        def type(self) -> ParticleSystemEmissionType: ...
        @type.setter
        def type(self, value: ParticleSystemEmissionType) -> ParticleSystemEmissionType: ...
        def GetBurst(self, index: int) -> ParticleSystem.Burst: ...
        def GetBursts(self, bursts: Array_1[ParticleSystem.Burst]) -> int: ...
        def SetBurst(self, index: int, burst: ParticleSystem.Burst) -> None: ...
        # Skipped SetBursts due to it being static, abstract and generic.

        SetBursts : SetBursts_MethodGroup
        class SetBursts_MethodGroup:
            @typing.overload
            def __call__(self, bursts: Array_1[ParticleSystem.Burst]) -> None:...
            @typing.overload
            def __call__(self, bursts: Array_1[ParticleSystem.Burst], size: int) -> None:...



    class EmitParams:
        @property
        def angularVelocity(self) -> float: ...
        @angularVelocity.setter
        def angularVelocity(self, value: float) -> float: ...
        @property
        def angularVelocity3D(self) -> Vector3: ...
        @angularVelocity3D.setter
        def angularVelocity3D(self, value: Vector3) -> Vector3: ...
        @property
        def applyShapeToPosition(self) -> bool: ...
        @applyShapeToPosition.setter
        def applyShapeToPosition(self, value: bool) -> bool: ...
        @property
        def axisOfRotation(self) -> Vector3: ...
        @axisOfRotation.setter
        def axisOfRotation(self, value: Vector3) -> Vector3: ...
        @property
        def meshIndex(self) -> None: ...
        @meshIndex.setter
        def meshIndex(self, value: int) -> None: ...
        @property
        def particle(self) -> ParticleSystem.Particle: ...
        @particle.setter
        def particle(self, value: ParticleSystem.Particle) -> ParticleSystem.Particle: ...
        @property
        def position(self) -> Vector3: ...
        @position.setter
        def position(self, value: Vector3) -> Vector3: ...
        @property
        def randomSeed(self) -> int: ...
        @randomSeed.setter
        def randomSeed(self, value: int) -> int: ...
        @property
        def rotation(self) -> float: ...
        @rotation.setter
        def rotation(self, value: float) -> float: ...
        @property
        def rotation3D(self) -> Vector3: ...
        @rotation3D.setter
        def rotation3D(self, value: Vector3) -> Vector3: ...
        @property
        def startColor(self) -> Color32: ...
        @startColor.setter
        def startColor(self, value: Color32) -> Color32: ...
        @property
        def startLifetime(self) -> float: ...
        @startLifetime.setter
        def startLifetime(self, value: float) -> float: ...
        @property
        def startSize(self) -> float: ...
        @startSize.setter
        def startSize(self, value: float) -> float: ...
        @property
        def startSize3D(self) -> Vector3: ...
        @startSize3D.setter
        def startSize3D(self, value: Vector3) -> Vector3: ...
        @property
        def velocity(self) -> Vector3: ...
        @velocity.setter
        def velocity(self, value: Vector3) -> Vector3: ...
        def ResetAngularVelocity(self) -> None: ...
        def ResetAxisOfRotation(self) -> None: ...
        def ResetMeshIndex(self) -> None: ...
        def ResetPosition(self) -> None: ...
        def ResetRandomSeed(self) -> None: ...
        def ResetRotation(self) -> None: ...
        def ResetStartColor(self) -> None: ...
        def ResetStartLifetime(self) -> None: ...
        def ResetStartSize(self) -> None: ...
        def ResetVelocity(self) -> None: ...


    class ExternalForcesModule:
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def influenceCount(self) -> int: ...
        @property
        def influenceFilter(self) -> ParticleSystemGameObjectFilter: ...
        @influenceFilter.setter
        def influenceFilter(self, value: ParticleSystemGameObjectFilter) -> ParticleSystemGameObjectFilter: ...
        @property
        def influenceMask(self) -> LayerMask: ...
        @influenceMask.setter
        def influenceMask(self, value: LayerMask) -> LayerMask: ...
        @property
        def multiplier(self) -> float: ...
        @multiplier.setter
        def multiplier(self, value: float) -> float: ...
        @property
        def multiplierCurve(self) -> ParticleSystem.MinMaxCurve: ...
        @multiplierCurve.setter
        def multiplierCurve(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        def AddInfluence(self, field: ParticleSystemForceField) -> None: ...
        def GetInfluence(self, index: int) -> ParticleSystemForceField: ...
        def IsAffectedBy(self, field: ParticleSystemForceField) -> bool: ...
        def RemoveAllInfluences(self) -> None: ...
        def SetInfluence(self, index: int, field: ParticleSystemForceField) -> None: ...
        # Skipped RemoveInfluence due to it being static, abstract and generic.

        RemoveInfluence : RemoveInfluence_MethodGroup
        class RemoveInfluence_MethodGroup:
            @typing.overload
            def __call__(self, index: int) -> None:...
            @typing.overload
            def __call__(self, field: ParticleSystemForceField) -> None:...



    class ForceOverLifetimeModule:
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def randomized(self) -> bool: ...
        @randomized.setter
        def randomized(self, value: bool) -> bool: ...
        @property
        def space(self) -> ParticleSystemSimulationSpace: ...
        @space.setter
        def space(self, value: ParticleSystemSimulationSpace) -> ParticleSystemSimulationSpace: ...
        @property
        def x(self) -> ParticleSystem.MinMaxCurve: ...
        @x.setter
        def x(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def xMultiplier(self) -> float: ...
        @xMultiplier.setter
        def xMultiplier(self, value: float) -> float: ...
        @property
        def y(self) -> ParticleSystem.MinMaxCurve: ...
        @y.setter
        def y(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def yMultiplier(self) -> float: ...
        @yMultiplier.setter
        def yMultiplier(self, value: float) -> float: ...
        @property
        def z(self) -> ParticleSystem.MinMaxCurve: ...
        @z.setter
        def z(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def zMultiplier(self) -> float: ...
        @zMultiplier.setter
        def zMultiplier(self, value: float) -> float: ...


    class InheritVelocityModule:
        @property
        def curve(self) -> ParticleSystem.MinMaxCurve: ...
        @curve.setter
        def curve(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def curveMultiplier(self) -> float: ...
        @curveMultiplier.setter
        def curveMultiplier(self, value: float) -> float: ...
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def mode(self) -> ParticleSystemInheritVelocityMode: ...
        @mode.setter
        def mode(self, value: ParticleSystemInheritVelocityMode) -> ParticleSystemInheritVelocityMode: ...


    class LifetimeByEmitterSpeedModule:
        @property
        def curve(self) -> ParticleSystem.MinMaxCurve: ...
        @curve.setter
        def curve(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def curveMultiplier(self) -> float: ...
        @curveMultiplier.setter
        def curveMultiplier(self, value: float) -> float: ...
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def range(self) -> Vector2: ...
        @range.setter
        def range(self, value: Vector2) -> Vector2: ...


    class LightsModule:
        @property
        def alphaAffectsIntensity(self) -> bool: ...
        @alphaAffectsIntensity.setter
        def alphaAffectsIntensity(self, value: bool) -> bool: ...
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def intensity(self) -> ParticleSystem.MinMaxCurve: ...
        @intensity.setter
        def intensity(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def intensityMultiplier(self) -> float: ...
        @intensityMultiplier.setter
        def intensityMultiplier(self, value: float) -> float: ...
        @property
        def light(self) -> Light: ...
        @light.setter
        def light(self, value: Light) -> Light: ...
        @property
        def maxLights(self) -> int: ...
        @maxLights.setter
        def maxLights(self, value: int) -> int: ...
        @property
        def range(self) -> ParticleSystem.MinMaxCurve: ...
        @range.setter
        def range(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def rangeMultiplier(self) -> float: ...
        @rangeMultiplier.setter
        def rangeMultiplier(self, value: float) -> float: ...
        @property
        def ratio(self) -> float: ...
        @ratio.setter
        def ratio(self, value: float) -> float: ...
        @property
        def sizeAffectsRange(self) -> bool: ...
        @sizeAffectsRange.setter
        def sizeAffectsRange(self, value: bool) -> bool: ...
        @property
        def useParticleColor(self) -> bool: ...
        @useParticleColor.setter
        def useParticleColor(self, value: bool) -> bool: ...
        @property
        def useRandomDistribution(self) -> bool: ...
        @useRandomDistribution.setter
        def useRandomDistribution(self, value: bool) -> bool: ...


    class LimitVelocityOverLifetimeModule:
        @property
        def dampen(self) -> float: ...
        @dampen.setter
        def dampen(self, value: float) -> float: ...
        @property
        def drag(self) -> ParticleSystem.MinMaxCurve: ...
        @drag.setter
        def drag(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def dragMultiplier(self) -> float: ...
        @dragMultiplier.setter
        def dragMultiplier(self, value: float) -> float: ...
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def limit(self) -> ParticleSystem.MinMaxCurve: ...
        @limit.setter
        def limit(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def limitMultiplier(self) -> float: ...
        @limitMultiplier.setter
        def limitMultiplier(self, value: float) -> float: ...
        @property
        def limitX(self) -> ParticleSystem.MinMaxCurve: ...
        @limitX.setter
        def limitX(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def limitXMultiplier(self) -> float: ...
        @limitXMultiplier.setter
        def limitXMultiplier(self, value: float) -> float: ...
        @property
        def limitY(self) -> ParticleSystem.MinMaxCurve: ...
        @limitY.setter
        def limitY(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def limitYMultiplier(self) -> float: ...
        @limitYMultiplier.setter
        def limitYMultiplier(self, value: float) -> float: ...
        @property
        def limitZ(self) -> ParticleSystem.MinMaxCurve: ...
        @limitZ.setter
        def limitZ(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def limitZMultiplier(self) -> float: ...
        @limitZMultiplier.setter
        def limitZMultiplier(self, value: float) -> float: ...
        @property
        def multiplyDragByParticleSize(self) -> bool: ...
        @multiplyDragByParticleSize.setter
        def multiplyDragByParticleSize(self, value: bool) -> bool: ...
        @property
        def multiplyDragByParticleVelocity(self) -> bool: ...
        @multiplyDragByParticleVelocity.setter
        def multiplyDragByParticleVelocity(self, value: bool) -> bool: ...
        @property
        def separateAxes(self) -> bool: ...
        @separateAxes.setter
        def separateAxes(self, value: bool) -> bool: ...
        @property
        def space(self) -> ParticleSystemSimulationSpace: ...
        @space.setter
        def space(self, value: ParticleSystemSimulationSpace) -> ParticleSystemSimulationSpace: ...


    class MainModule:
        @property
        def cullingMode(self) -> ParticleSystemCullingMode: ...
        @cullingMode.setter
        def cullingMode(self, value: ParticleSystemCullingMode) -> ParticleSystemCullingMode: ...
        @property
        def customSimulationSpace(self) -> Transform: ...
        @customSimulationSpace.setter
        def customSimulationSpace(self, value: Transform) -> Transform: ...
        @property
        def duration(self) -> float: ...
        @duration.setter
        def duration(self, value: float) -> float: ...
        @property
        def emitterVelocity(self) -> Vector3: ...
        @emitterVelocity.setter
        def emitterVelocity(self, value: Vector3) -> Vector3: ...
        @property
        def emitterVelocityMode(self) -> ParticleSystemEmitterVelocityMode: ...
        @emitterVelocityMode.setter
        def emitterVelocityMode(self, value: ParticleSystemEmitterVelocityMode) -> ParticleSystemEmitterVelocityMode: ...
        @property
        def flipRotation(self) -> float: ...
        @flipRotation.setter
        def flipRotation(self, value: float) -> float: ...
        @property
        def gravityModifier(self) -> ParticleSystem.MinMaxCurve: ...
        @gravityModifier.setter
        def gravityModifier(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def gravityModifierMultiplier(self) -> float: ...
        @gravityModifierMultiplier.setter
        def gravityModifierMultiplier(self, value: float) -> float: ...
        @property
        def gravitySource(self) -> ParticleSystemGravitySource: ...
        @gravitySource.setter
        def gravitySource(self, value: ParticleSystemGravitySource) -> ParticleSystemGravitySource: ...
        @property
        def loop(self) -> bool: ...
        @loop.setter
        def loop(self, value: bool) -> bool: ...
        @property
        def maxParticles(self) -> int: ...
        @maxParticles.setter
        def maxParticles(self, value: int) -> int: ...
        @property
        def playOnAwake(self) -> bool: ...
        @playOnAwake.setter
        def playOnAwake(self, value: bool) -> bool: ...
        @property
        def prewarm(self) -> bool: ...
        @prewarm.setter
        def prewarm(self, value: bool) -> bool: ...
        @property
        def randomizeRotationDirection(self) -> float: ...
        @randomizeRotationDirection.setter
        def randomizeRotationDirection(self, value: float) -> float: ...
        @property
        def ringBufferLoopRange(self) -> Vector2: ...
        @ringBufferLoopRange.setter
        def ringBufferLoopRange(self, value: Vector2) -> Vector2: ...
        @property
        def ringBufferMode(self) -> ParticleSystemRingBufferMode: ...
        @ringBufferMode.setter
        def ringBufferMode(self, value: ParticleSystemRingBufferMode) -> ParticleSystemRingBufferMode: ...
        @property
        def scalingMode(self) -> ParticleSystemScalingMode: ...
        @scalingMode.setter
        def scalingMode(self, value: ParticleSystemScalingMode) -> ParticleSystemScalingMode: ...
        @property
        def simulationSpace(self) -> ParticleSystemSimulationSpace: ...
        @simulationSpace.setter
        def simulationSpace(self, value: ParticleSystemSimulationSpace) -> ParticleSystemSimulationSpace: ...
        @property
        def simulationSpeed(self) -> float: ...
        @simulationSpeed.setter
        def simulationSpeed(self, value: float) -> float: ...
        @property
        def startColor(self) -> ParticleSystem.MinMaxGradient: ...
        @startColor.setter
        def startColor(self, value: ParticleSystem.MinMaxGradient) -> ParticleSystem.MinMaxGradient: ...
        @property
        def startDelay(self) -> ParticleSystem.MinMaxCurve: ...
        @startDelay.setter
        def startDelay(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def startDelayMultiplier(self) -> float: ...
        @startDelayMultiplier.setter
        def startDelayMultiplier(self, value: float) -> float: ...
        @property
        def startLifetime(self) -> ParticleSystem.MinMaxCurve: ...
        @startLifetime.setter
        def startLifetime(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def startLifetimeMultiplier(self) -> float: ...
        @startLifetimeMultiplier.setter
        def startLifetimeMultiplier(self, value: float) -> float: ...
        @property
        def startRotation(self) -> ParticleSystem.MinMaxCurve: ...
        @startRotation.setter
        def startRotation(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def startRotation3D(self) -> bool: ...
        @startRotation3D.setter
        def startRotation3D(self, value: bool) -> bool: ...
        @property
        def startRotationMultiplier(self) -> float: ...
        @startRotationMultiplier.setter
        def startRotationMultiplier(self, value: float) -> float: ...
        @property
        def startRotationX(self) -> ParticleSystem.MinMaxCurve: ...
        @startRotationX.setter
        def startRotationX(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def startRotationXMultiplier(self) -> float: ...
        @startRotationXMultiplier.setter
        def startRotationXMultiplier(self, value: float) -> float: ...
        @property
        def startRotationY(self) -> ParticleSystem.MinMaxCurve: ...
        @startRotationY.setter
        def startRotationY(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def startRotationYMultiplier(self) -> float: ...
        @startRotationYMultiplier.setter
        def startRotationYMultiplier(self, value: float) -> float: ...
        @property
        def startRotationZ(self) -> ParticleSystem.MinMaxCurve: ...
        @startRotationZ.setter
        def startRotationZ(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def startRotationZMultiplier(self) -> float: ...
        @startRotationZMultiplier.setter
        def startRotationZMultiplier(self, value: float) -> float: ...
        @property
        def startSize(self) -> ParticleSystem.MinMaxCurve: ...
        @startSize.setter
        def startSize(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def startSize3D(self) -> bool: ...
        @startSize3D.setter
        def startSize3D(self, value: bool) -> bool: ...
        @property
        def startSizeMultiplier(self) -> float: ...
        @startSizeMultiplier.setter
        def startSizeMultiplier(self, value: float) -> float: ...
        @property
        def startSizeX(self) -> ParticleSystem.MinMaxCurve: ...
        @startSizeX.setter
        def startSizeX(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def startSizeXMultiplier(self) -> float: ...
        @startSizeXMultiplier.setter
        def startSizeXMultiplier(self, value: float) -> float: ...
        @property
        def startSizeY(self) -> ParticleSystem.MinMaxCurve: ...
        @startSizeY.setter
        def startSizeY(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def startSizeYMultiplier(self) -> float: ...
        @startSizeYMultiplier.setter
        def startSizeYMultiplier(self, value: float) -> float: ...
        @property
        def startSizeZ(self) -> ParticleSystem.MinMaxCurve: ...
        @startSizeZ.setter
        def startSizeZ(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def startSizeZMultiplier(self) -> float: ...
        @startSizeZMultiplier.setter
        def startSizeZMultiplier(self, value: float) -> float: ...
        @property
        def startSpeed(self) -> ParticleSystem.MinMaxCurve: ...
        @startSpeed.setter
        def startSpeed(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def startSpeedMultiplier(self) -> float: ...
        @startSpeedMultiplier.setter
        def startSpeedMultiplier(self, value: float) -> float: ...
        @property
        def stopAction(self) -> ParticleSystemStopAction: ...
        @stopAction.setter
        def stopAction(self, value: ParticleSystemStopAction) -> ParticleSystemStopAction: ...
        @property
        def useUnscaledTime(self) -> bool: ...
        @useUnscaledTime.setter
        def useUnscaledTime(self, value: bool) -> bool: ...


    class MinMaxCurve:
        @typing.overload
        def __init__(self, constant: float) -> None: ...
        @typing.overload
        def __init__(self, min: float, max: float) -> None: ...
        @typing.overload
        def __init__(self, multiplier: float, curve: AnimationCurve) -> None: ...
        @typing.overload
        def __init__(self, multiplier: float, min: AnimationCurve, max: AnimationCurve) -> None: ...
        @property
        def constant(self) -> float: ...
        @constant.setter
        def constant(self, value: float) -> float: ...
        @property
        def constantMax(self) -> float: ...
        @constantMax.setter
        def constantMax(self, value: float) -> float: ...
        @property
        def constantMin(self) -> float: ...
        @constantMin.setter
        def constantMin(self, value: float) -> float: ...
        @property
        def curve(self) -> AnimationCurve: ...
        @curve.setter
        def curve(self, value: AnimationCurve) -> AnimationCurve: ...
        @property
        def curveMax(self) -> AnimationCurve: ...
        @curveMax.setter
        def curveMax(self, value: AnimationCurve) -> AnimationCurve: ...
        @property
        def curveMin(self) -> AnimationCurve: ...
        @curveMin.setter
        def curveMin(self, value: AnimationCurve) -> AnimationCurve: ...
        @property
        def curveMultiplier(self) -> float: ...
        @curveMultiplier.setter
        def curveMultiplier(self, value: float) -> float: ...
        @property
        def curveScalar(self) -> float: ...
        @curveScalar.setter
        def curveScalar(self, value: float) -> float: ...
        @property
        def mode(self) -> ParticleSystemCurveMode: ...
        @mode.setter
        def mode(self, value: ParticleSystemCurveMode) -> ParticleSystemCurveMode: ...
        # Operator not supported op_Implicit(constant: Single)
        # Skipped Evaluate due to it being static, abstract and generic.

        Evaluate : Evaluate_MethodGroup
        class Evaluate_MethodGroup:
            @typing.overload
            def __call__(self, time: float) -> float:...
            @typing.overload
            def __call__(self, time: float, lerpFactor: float) -> float:...



    class MinMaxGradient:
        @typing.overload
        def __init__(self, color: Color) -> None: ...
        @typing.overload
        def __init__(self, gradient: Gradient) -> None: ...
        @typing.overload
        def __init__(self, min: Color, max: Color) -> None: ...
        @typing.overload
        def __init__(self, min: Gradient, max: Gradient) -> None: ...
        @property
        def color(self) -> Color: ...
        @color.setter
        def color(self, value: Color) -> Color: ...
        @property
        def colorMax(self) -> Color: ...
        @colorMax.setter
        def colorMax(self, value: Color) -> Color: ...
        @property
        def colorMin(self) -> Color: ...
        @colorMin.setter
        def colorMin(self, value: Color) -> Color: ...
        @property
        def gradient(self) -> Gradient: ...
        @gradient.setter
        def gradient(self, value: Gradient) -> Gradient: ...
        @property
        def gradientMax(self) -> Gradient: ...
        @gradientMax.setter
        def gradientMax(self, value: Gradient) -> Gradient: ...
        @property
        def gradientMin(self) -> Gradient: ...
        @gradientMin.setter
        def gradientMin(self, value: Gradient) -> Gradient: ...
        @property
        def mode(self) -> ParticleSystemGradientMode: ...
        @mode.setter
        def mode(self, value: ParticleSystemGradientMode) -> ParticleSystemGradientMode: ...
        # Operator not supported op_Implicit(color: Color)
        # Operator not supported op_Implicit(gradient: Gradient)
        # Skipped Evaluate due to it being static, abstract and generic.

        Evaluate : Evaluate_MethodGroup
        class Evaluate_MethodGroup:
            @typing.overload
            def __call__(self, time: float) -> Color:...
            @typing.overload
            def __call__(self, time: float, lerpFactor: float) -> Color:...



    class NoiseModule:
        @property
        def damping(self) -> bool: ...
        @damping.setter
        def damping(self, value: bool) -> bool: ...
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def frequency(self) -> float: ...
        @frequency.setter
        def frequency(self, value: float) -> float: ...
        @property
        def octaveCount(self) -> int: ...
        @octaveCount.setter
        def octaveCount(self, value: int) -> int: ...
        @property
        def octaveMultiplier(self) -> float: ...
        @octaveMultiplier.setter
        def octaveMultiplier(self, value: float) -> float: ...
        @property
        def octaveScale(self) -> float: ...
        @octaveScale.setter
        def octaveScale(self, value: float) -> float: ...
        @property
        def positionAmount(self) -> ParticleSystem.MinMaxCurve: ...
        @positionAmount.setter
        def positionAmount(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def quality(self) -> ParticleSystemNoiseQuality: ...
        @quality.setter
        def quality(self, value: ParticleSystemNoiseQuality) -> ParticleSystemNoiseQuality: ...
        @property
        def remap(self) -> ParticleSystem.MinMaxCurve: ...
        @remap.setter
        def remap(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def remapEnabled(self) -> bool: ...
        @remapEnabled.setter
        def remapEnabled(self, value: bool) -> bool: ...
        @property
        def remapMultiplier(self) -> float: ...
        @remapMultiplier.setter
        def remapMultiplier(self, value: float) -> float: ...
        @property
        def remapX(self) -> ParticleSystem.MinMaxCurve: ...
        @remapX.setter
        def remapX(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def remapXMultiplier(self) -> float: ...
        @remapXMultiplier.setter
        def remapXMultiplier(self, value: float) -> float: ...
        @property
        def remapY(self) -> ParticleSystem.MinMaxCurve: ...
        @remapY.setter
        def remapY(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def remapYMultiplier(self) -> float: ...
        @remapYMultiplier.setter
        def remapYMultiplier(self, value: float) -> float: ...
        @property
        def remapZ(self) -> ParticleSystem.MinMaxCurve: ...
        @remapZ.setter
        def remapZ(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def remapZMultiplier(self) -> float: ...
        @remapZMultiplier.setter
        def remapZMultiplier(self, value: float) -> float: ...
        @property
        def rotationAmount(self) -> ParticleSystem.MinMaxCurve: ...
        @rotationAmount.setter
        def rotationAmount(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def scrollSpeed(self) -> ParticleSystem.MinMaxCurve: ...
        @scrollSpeed.setter
        def scrollSpeed(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def scrollSpeedMultiplier(self) -> float: ...
        @scrollSpeedMultiplier.setter
        def scrollSpeedMultiplier(self, value: float) -> float: ...
        @property
        def separateAxes(self) -> bool: ...
        @separateAxes.setter
        def separateAxes(self, value: bool) -> bool: ...
        @property
        def sizeAmount(self) -> ParticleSystem.MinMaxCurve: ...
        @sizeAmount.setter
        def sizeAmount(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def strength(self) -> ParticleSystem.MinMaxCurve: ...
        @strength.setter
        def strength(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def strengthMultiplier(self) -> float: ...
        @strengthMultiplier.setter
        def strengthMultiplier(self, value: float) -> float: ...
        @property
        def strengthX(self) -> ParticleSystem.MinMaxCurve: ...
        @strengthX.setter
        def strengthX(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def strengthXMultiplier(self) -> float: ...
        @strengthXMultiplier.setter
        def strengthXMultiplier(self, value: float) -> float: ...
        @property
        def strengthY(self) -> ParticleSystem.MinMaxCurve: ...
        @strengthY.setter
        def strengthY(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def strengthYMultiplier(self) -> float: ...
        @strengthYMultiplier.setter
        def strengthYMultiplier(self, value: float) -> float: ...
        @property
        def strengthZ(self) -> ParticleSystem.MinMaxCurve: ...
        @strengthZ.setter
        def strengthZ(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def strengthZMultiplier(self) -> float: ...
        @strengthZMultiplier.setter
        def strengthZMultiplier(self, value: float) -> float: ...


    class Particle:
        @property
        def angularVelocity(self) -> float: ...
        @angularVelocity.setter
        def angularVelocity(self, value: float) -> float: ...
        @property
        def angularVelocity3D(self) -> Vector3: ...
        @angularVelocity3D.setter
        def angularVelocity3D(self, value: Vector3) -> Vector3: ...
        @property
        def animatedVelocity(self) -> Vector3: ...
        @property
        def axisOfRotation(self) -> Vector3: ...
        @axisOfRotation.setter
        def axisOfRotation(self, value: Vector3) -> Vector3: ...
        @property
        def color(self) -> Color32: ...
        @color.setter
        def color(self, value: Color32) -> Color32: ...
        @property
        def lifetime(self) -> float: ...
        @lifetime.setter
        def lifetime(self, value: float) -> float: ...
        @property
        def position(self) -> Vector3: ...
        @position.setter
        def position(self, value: Vector3) -> Vector3: ...
        @property
        def randomSeed(self) -> int: ...
        @randomSeed.setter
        def randomSeed(self, value: int) -> int: ...
        @property
        def randomValue(self) -> float: ...
        @randomValue.setter
        def randomValue(self, value: float) -> float: ...
        @property
        def remainingLifetime(self) -> float: ...
        @remainingLifetime.setter
        def remainingLifetime(self, value: float) -> float: ...
        @property
        def rotation(self) -> float: ...
        @rotation.setter
        def rotation(self, value: float) -> float: ...
        @property
        def rotation3D(self) -> Vector3: ...
        @rotation3D.setter
        def rotation3D(self, value: Vector3) -> Vector3: ...
        @property
        def size(self) -> float: ...
        @size.setter
        def size(self, value: float) -> float: ...
        @property
        def startColor(self) -> Color32: ...
        @startColor.setter
        def startColor(self, value: Color32) -> Color32: ...
        @property
        def startLifetime(self) -> float: ...
        @startLifetime.setter
        def startLifetime(self, value: float) -> float: ...
        @property
        def startSize(self) -> float: ...
        @startSize.setter
        def startSize(self, value: float) -> float: ...
        @property
        def startSize3D(self) -> Vector3: ...
        @startSize3D.setter
        def startSize3D(self, value: Vector3) -> Vector3: ...
        @property
        def totalVelocity(self) -> Vector3: ...
        @property
        def velocity(self) -> Vector3: ...
        @velocity.setter
        def velocity(self, value: Vector3) -> Vector3: ...
        def GetCurrentColor(self, system: ParticleSystem) -> Color32: ...
        def GetCurrentSize(self, system: ParticleSystem) -> float: ...
        def GetCurrentSize3D(self, system: ParticleSystem) -> Vector3: ...
        def GetMeshIndex(self, system: ParticleSystem) -> int: ...
        def SetMeshIndex(self, index: int) -> None: ...


    class PlaybackState:
        pass


    class RotationBySpeedModule:
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def range(self) -> Vector2: ...
        @range.setter
        def range(self, value: Vector2) -> Vector2: ...
        @property
        def separateAxes(self) -> bool: ...
        @separateAxes.setter
        def separateAxes(self, value: bool) -> bool: ...
        @property
        def x(self) -> ParticleSystem.MinMaxCurve: ...
        @x.setter
        def x(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def xMultiplier(self) -> float: ...
        @xMultiplier.setter
        def xMultiplier(self, value: float) -> float: ...
        @property
        def y(self) -> ParticleSystem.MinMaxCurve: ...
        @y.setter
        def y(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def yMultiplier(self) -> float: ...
        @yMultiplier.setter
        def yMultiplier(self, value: float) -> float: ...
        @property
        def z(self) -> ParticleSystem.MinMaxCurve: ...
        @z.setter
        def z(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def zMultiplier(self) -> float: ...
        @zMultiplier.setter
        def zMultiplier(self, value: float) -> float: ...


    class RotationOverLifetimeModule:
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def separateAxes(self) -> bool: ...
        @separateAxes.setter
        def separateAxes(self, value: bool) -> bool: ...
        @property
        def x(self) -> ParticleSystem.MinMaxCurve: ...
        @x.setter
        def x(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def xMultiplier(self) -> float: ...
        @xMultiplier.setter
        def xMultiplier(self, value: float) -> float: ...
        @property
        def y(self) -> ParticleSystem.MinMaxCurve: ...
        @y.setter
        def y(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def yMultiplier(self) -> float: ...
        @yMultiplier.setter
        def yMultiplier(self, value: float) -> float: ...
        @property
        def z(self) -> ParticleSystem.MinMaxCurve: ...
        @z.setter
        def z(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def zMultiplier(self) -> float: ...
        @zMultiplier.setter
        def zMultiplier(self, value: float) -> float: ...


    class ShapeModule:
        @property
        def alignToDirection(self) -> bool: ...
        @alignToDirection.setter
        def alignToDirection(self, value: bool) -> bool: ...
        @property
        def angle(self) -> float: ...
        @angle.setter
        def angle(self, value: float) -> float: ...
        @property
        def arc(self) -> float: ...
        @arc.setter
        def arc(self, value: float) -> float: ...
        @property
        def arcMode(self) -> ParticleSystemShapeMultiModeValue: ...
        @arcMode.setter
        def arcMode(self, value: ParticleSystemShapeMultiModeValue) -> ParticleSystemShapeMultiModeValue: ...
        @property
        def arcSpeed(self) -> ParticleSystem.MinMaxCurve: ...
        @arcSpeed.setter
        def arcSpeed(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def arcSpeedMultiplier(self) -> float: ...
        @arcSpeedMultiplier.setter
        def arcSpeedMultiplier(self, value: float) -> float: ...
        @property
        def arcSpread(self) -> float: ...
        @arcSpread.setter
        def arcSpread(self, value: float) -> float: ...
        @property
        def box(self) -> Vector3: ...
        @box.setter
        def box(self, value: Vector3) -> Vector3: ...
        @property
        def boxThickness(self) -> Vector3: ...
        @boxThickness.setter
        def boxThickness(self, value: Vector3) -> Vector3: ...
        @property
        def donutRadius(self) -> float: ...
        @donutRadius.setter
        def donutRadius(self, value: float) -> float: ...
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def length(self) -> float: ...
        @length.setter
        def length(self, value: float) -> float: ...
        @property
        def mesh(self) -> Mesh: ...
        @mesh.setter
        def mesh(self, value: Mesh) -> Mesh: ...
        @property
        def meshMaterialIndex(self) -> int: ...
        @meshMaterialIndex.setter
        def meshMaterialIndex(self, value: int) -> int: ...
        @property
        def meshRenderer(self) -> MeshRenderer: ...
        @meshRenderer.setter
        def meshRenderer(self, value: MeshRenderer) -> MeshRenderer: ...
        @property
        def meshScale(self) -> float: ...
        @meshScale.setter
        def meshScale(self, value: float) -> float: ...
        @property
        def meshShapeType(self) -> ParticleSystemMeshShapeType: ...
        @meshShapeType.setter
        def meshShapeType(self, value: ParticleSystemMeshShapeType) -> ParticleSystemMeshShapeType: ...
        @property
        def meshSpawnMode(self) -> ParticleSystemShapeMultiModeValue: ...
        @meshSpawnMode.setter
        def meshSpawnMode(self, value: ParticleSystemShapeMultiModeValue) -> ParticleSystemShapeMultiModeValue: ...
        @property
        def meshSpawnSpeed(self) -> ParticleSystem.MinMaxCurve: ...
        @meshSpawnSpeed.setter
        def meshSpawnSpeed(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def meshSpawnSpeedMultiplier(self) -> float: ...
        @meshSpawnSpeedMultiplier.setter
        def meshSpawnSpeedMultiplier(self, value: float) -> float: ...
        @property
        def meshSpawnSpread(self) -> float: ...
        @meshSpawnSpread.setter
        def meshSpawnSpread(self, value: float) -> float: ...
        @property
        def normalOffset(self) -> float: ...
        @normalOffset.setter
        def normalOffset(self, value: float) -> float: ...
        @property
        def position(self) -> Vector3: ...
        @position.setter
        def position(self, value: Vector3) -> Vector3: ...
        @property
        def radius(self) -> float: ...
        @radius.setter
        def radius(self, value: float) -> float: ...
        @property
        def radiusMode(self) -> ParticleSystemShapeMultiModeValue: ...
        @radiusMode.setter
        def radiusMode(self, value: ParticleSystemShapeMultiModeValue) -> ParticleSystemShapeMultiModeValue: ...
        @property
        def radiusSpeed(self) -> ParticleSystem.MinMaxCurve: ...
        @radiusSpeed.setter
        def radiusSpeed(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def radiusSpeedMultiplier(self) -> float: ...
        @radiusSpeedMultiplier.setter
        def radiusSpeedMultiplier(self, value: float) -> float: ...
        @property
        def radiusSpread(self) -> float: ...
        @radiusSpread.setter
        def radiusSpread(self, value: float) -> float: ...
        @property
        def radiusThickness(self) -> float: ...
        @radiusThickness.setter
        def radiusThickness(self, value: float) -> float: ...
        @property
        def randomDirection(self) -> bool: ...
        @randomDirection.setter
        def randomDirection(self, value: bool) -> bool: ...
        @property
        def randomDirectionAmount(self) -> float: ...
        @randomDirectionAmount.setter
        def randomDirectionAmount(self, value: float) -> float: ...
        @property
        def randomPositionAmount(self) -> float: ...
        @randomPositionAmount.setter
        def randomPositionAmount(self, value: float) -> float: ...
        @property
        def rotation(self) -> Vector3: ...
        @rotation.setter
        def rotation(self, value: Vector3) -> Vector3: ...
        @property
        def scale(self) -> Vector3: ...
        @scale.setter
        def scale(self, value: Vector3) -> Vector3: ...
        @property
        def shapeType(self) -> ParticleSystemShapeType: ...
        @shapeType.setter
        def shapeType(self, value: ParticleSystemShapeType) -> ParticleSystemShapeType: ...
        @property
        def skinnedMeshRenderer(self) -> SkinnedMeshRenderer: ...
        @skinnedMeshRenderer.setter
        def skinnedMeshRenderer(self, value: SkinnedMeshRenderer) -> SkinnedMeshRenderer: ...
        @property
        def sphericalDirectionAmount(self) -> float: ...
        @sphericalDirectionAmount.setter
        def sphericalDirectionAmount(self, value: float) -> float: ...
        @property
        def sprite(self) -> Sprite: ...
        @sprite.setter
        def sprite(self, value: Sprite) -> Sprite: ...
        @property
        def spriteRenderer(self) -> SpriteRenderer: ...
        @spriteRenderer.setter
        def spriteRenderer(self, value: SpriteRenderer) -> SpriteRenderer: ...
        @property
        def texture(self) -> Texture2D: ...
        @texture.setter
        def texture(self, value: Texture2D) -> Texture2D: ...
        @property
        def textureAlphaAffectsParticles(self) -> bool: ...
        @textureAlphaAffectsParticles.setter
        def textureAlphaAffectsParticles(self, value: bool) -> bool: ...
        @property
        def textureBilinearFiltering(self) -> bool: ...
        @textureBilinearFiltering.setter
        def textureBilinearFiltering(self, value: bool) -> bool: ...
        @property
        def textureClipChannel(self) -> ParticleSystemShapeTextureChannel: ...
        @textureClipChannel.setter
        def textureClipChannel(self, value: ParticleSystemShapeTextureChannel) -> ParticleSystemShapeTextureChannel: ...
        @property
        def textureClipThreshold(self) -> float: ...
        @textureClipThreshold.setter
        def textureClipThreshold(self, value: float) -> float: ...
        @property
        def textureColorAffectsParticles(self) -> bool: ...
        @textureColorAffectsParticles.setter
        def textureColorAffectsParticles(self, value: bool) -> bool: ...
        @property
        def textureUVChannel(self) -> int: ...
        @textureUVChannel.setter
        def textureUVChannel(self, value: int) -> int: ...
        @property
        def useMeshColors(self) -> bool: ...
        @useMeshColors.setter
        def useMeshColors(self, value: bool) -> bool: ...
        @property
        def useMeshMaterialIndex(self) -> bool: ...
        @useMeshMaterialIndex.setter
        def useMeshMaterialIndex(self, value: bool) -> bool: ...


    class SizeBySpeedModule:
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def range(self) -> Vector2: ...
        @range.setter
        def range(self, value: Vector2) -> Vector2: ...
        @property
        def separateAxes(self) -> bool: ...
        @separateAxes.setter
        def separateAxes(self, value: bool) -> bool: ...
        @property
        def size(self) -> ParticleSystem.MinMaxCurve: ...
        @size.setter
        def size(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def sizeMultiplier(self) -> float: ...
        @sizeMultiplier.setter
        def sizeMultiplier(self, value: float) -> float: ...
        @property
        def x(self) -> ParticleSystem.MinMaxCurve: ...
        @x.setter
        def x(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def xMultiplier(self) -> float: ...
        @xMultiplier.setter
        def xMultiplier(self, value: float) -> float: ...
        @property
        def y(self) -> ParticleSystem.MinMaxCurve: ...
        @y.setter
        def y(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def yMultiplier(self) -> float: ...
        @yMultiplier.setter
        def yMultiplier(self, value: float) -> float: ...
        @property
        def z(self) -> ParticleSystem.MinMaxCurve: ...
        @z.setter
        def z(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def zMultiplier(self) -> float: ...
        @zMultiplier.setter
        def zMultiplier(self, value: float) -> float: ...


    class SizeOverLifetimeModule:
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def separateAxes(self) -> bool: ...
        @separateAxes.setter
        def separateAxes(self, value: bool) -> bool: ...
        @property
        def size(self) -> ParticleSystem.MinMaxCurve: ...
        @size.setter
        def size(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def sizeMultiplier(self) -> float: ...
        @sizeMultiplier.setter
        def sizeMultiplier(self, value: float) -> float: ...
        @property
        def x(self) -> ParticleSystem.MinMaxCurve: ...
        @x.setter
        def x(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def xMultiplier(self) -> float: ...
        @xMultiplier.setter
        def xMultiplier(self, value: float) -> float: ...
        @property
        def y(self) -> ParticleSystem.MinMaxCurve: ...
        @y.setter
        def y(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def yMultiplier(self) -> float: ...
        @yMultiplier.setter
        def yMultiplier(self, value: float) -> float: ...
        @property
        def z(self) -> ParticleSystem.MinMaxCurve: ...
        @z.setter
        def z(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def zMultiplier(self) -> float: ...
        @zMultiplier.setter
        def zMultiplier(self, value: float) -> float: ...


    class SubEmittersModule:
        @property
        def birth0(self) -> ParticleSystem: ...
        @birth0.setter
        def birth0(self, value: ParticleSystem) -> ParticleSystem: ...
        @property
        def birth1(self) -> ParticleSystem: ...
        @birth1.setter
        def birth1(self, value: ParticleSystem) -> ParticleSystem: ...
        @property
        def collision0(self) -> ParticleSystem: ...
        @collision0.setter
        def collision0(self, value: ParticleSystem) -> ParticleSystem: ...
        @property
        def collision1(self) -> ParticleSystem: ...
        @collision1.setter
        def collision1(self, value: ParticleSystem) -> ParticleSystem: ...
        @property
        def death0(self) -> ParticleSystem: ...
        @death0.setter
        def death0(self, value: ParticleSystem) -> ParticleSystem: ...
        @property
        def death1(self) -> ParticleSystem: ...
        @death1.setter
        def death1(self, value: ParticleSystem) -> ParticleSystem: ...
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def subEmittersCount(self) -> int: ...
        def GetSubEmitterEmitProbability(self, index: int) -> float: ...
        def GetSubEmitterProperties(self, index: int) -> ParticleSystemSubEmitterProperties: ...
        def GetSubEmitterSystem(self, index: int) -> ParticleSystem: ...
        def GetSubEmitterType(self, index: int) -> ParticleSystemSubEmitterType: ...
        def SetSubEmitterEmitProbability(self, index: int, emitProbability: float) -> None: ...
        def SetSubEmitterProperties(self, index: int, properties: ParticleSystemSubEmitterProperties) -> None: ...
        def SetSubEmitterSystem(self, index: int, subEmitter: ParticleSystem) -> None: ...
        def SetSubEmitterType(self, index: int, type: ParticleSystemSubEmitterType) -> None: ...
        # Skipped AddSubEmitter due to it being static, abstract and generic.

        AddSubEmitter : AddSubEmitter_MethodGroup
        class AddSubEmitter_MethodGroup:
            @typing.overload
            def __call__(self, subEmitter: ParticleSystem, type: ParticleSystemSubEmitterType, properties: ParticleSystemSubEmitterProperties) -> None:...
            @typing.overload
            def __call__(self, subEmitter: ParticleSystem, type: ParticleSystemSubEmitterType, properties: ParticleSystemSubEmitterProperties, emitProbability: float) -> None:...

        # Skipped RemoveSubEmitter due to it being static, abstract and generic.

        RemoveSubEmitter : RemoveSubEmitter_MethodGroup
        class RemoveSubEmitter_MethodGroup:
            @typing.overload
            def __call__(self, index: int) -> None:...
            @typing.overload
            def __call__(self, subEmitter: ParticleSystem) -> None:...



    class TextureSheetAnimationModule:
        @property
        def animation(self) -> ParticleSystemAnimationType: ...
        @animation.setter
        def animation(self, value: ParticleSystemAnimationType) -> ParticleSystemAnimationType: ...
        @property
        def cycleCount(self) -> int: ...
        @cycleCount.setter
        def cycleCount(self, value: int) -> int: ...
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def flipU(self) -> float: ...
        @flipU.setter
        def flipU(self, value: float) -> float: ...
        @property
        def flipV(self) -> float: ...
        @flipV.setter
        def flipV(self, value: float) -> float: ...
        @property
        def fps(self) -> float: ...
        @fps.setter
        def fps(self, value: float) -> float: ...
        @property
        def frameOverTime(self) -> ParticleSystem.MinMaxCurve: ...
        @frameOverTime.setter
        def frameOverTime(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def frameOverTimeMultiplier(self) -> float: ...
        @frameOverTimeMultiplier.setter
        def frameOverTimeMultiplier(self, value: float) -> float: ...
        @property
        def mode(self) -> ParticleSystemAnimationMode: ...
        @mode.setter
        def mode(self, value: ParticleSystemAnimationMode) -> ParticleSystemAnimationMode: ...
        @property
        def numTilesX(self) -> int: ...
        @numTilesX.setter
        def numTilesX(self, value: int) -> int: ...
        @property
        def numTilesY(self) -> int: ...
        @numTilesY.setter
        def numTilesY(self, value: int) -> int: ...
        @property
        def rowIndex(self) -> int: ...
        @rowIndex.setter
        def rowIndex(self, value: int) -> int: ...
        @property
        def rowMode(self) -> ParticleSystemAnimationRowMode: ...
        @rowMode.setter
        def rowMode(self, value: ParticleSystemAnimationRowMode) -> ParticleSystemAnimationRowMode: ...
        @property
        def speedRange(self) -> Vector2: ...
        @speedRange.setter
        def speedRange(self, value: Vector2) -> Vector2: ...
        @property
        def spriteCount(self) -> int: ...
        @property
        def startFrame(self) -> ParticleSystem.MinMaxCurve: ...
        @startFrame.setter
        def startFrame(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def startFrameMultiplier(self) -> float: ...
        @startFrameMultiplier.setter
        def startFrameMultiplier(self, value: float) -> float: ...
        @property
        def timeMode(self) -> ParticleSystemAnimationTimeMode: ...
        @timeMode.setter
        def timeMode(self, value: ParticleSystemAnimationTimeMode) -> ParticleSystemAnimationTimeMode: ...
        @property
        def useRandomRow(self) -> bool: ...
        @useRandomRow.setter
        def useRandomRow(self, value: bool) -> bool: ...
        @property
        def uvChannelMask(self) -> UVChannelFlags: ...
        @uvChannelMask.setter
        def uvChannelMask(self, value: UVChannelFlags) -> UVChannelFlags: ...
        def AddSprite(self, sprite: Sprite) -> None: ...
        def GetSprite(self, index: int) -> Sprite: ...
        def RemoveSprite(self, index: int) -> None: ...
        def SetSprite(self, index: int, sprite: Sprite) -> None: ...


    class TrailModule:
        @property
        def attachRibbonsToTransform(self) -> bool: ...
        @attachRibbonsToTransform.setter
        def attachRibbonsToTransform(self, value: bool) -> bool: ...
        @property
        def colorOverLifetime(self) -> ParticleSystem.MinMaxGradient: ...
        @colorOverLifetime.setter
        def colorOverLifetime(self, value: ParticleSystem.MinMaxGradient) -> ParticleSystem.MinMaxGradient: ...
        @property
        def colorOverTrail(self) -> ParticleSystem.MinMaxGradient: ...
        @colorOverTrail.setter
        def colorOverTrail(self, value: ParticleSystem.MinMaxGradient) -> ParticleSystem.MinMaxGradient: ...
        @property
        def dieWithParticles(self) -> bool: ...
        @dieWithParticles.setter
        def dieWithParticles(self, value: bool) -> bool: ...
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def generateLightingData(self) -> bool: ...
        @generateLightingData.setter
        def generateLightingData(self, value: bool) -> bool: ...
        @property
        def inheritParticleColor(self) -> bool: ...
        @inheritParticleColor.setter
        def inheritParticleColor(self, value: bool) -> bool: ...
        @property
        def lifetime(self) -> ParticleSystem.MinMaxCurve: ...
        @lifetime.setter
        def lifetime(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def lifetimeMultiplier(self) -> float: ...
        @lifetimeMultiplier.setter
        def lifetimeMultiplier(self, value: float) -> float: ...
        @property
        def minVertexDistance(self) -> float: ...
        @minVertexDistance.setter
        def minVertexDistance(self, value: float) -> float: ...
        @property
        def mode(self) -> ParticleSystemTrailMode: ...
        @mode.setter
        def mode(self, value: ParticleSystemTrailMode) -> ParticleSystemTrailMode: ...
        @property
        def ratio(self) -> float: ...
        @ratio.setter
        def ratio(self, value: float) -> float: ...
        @property
        def ribbonCount(self) -> int: ...
        @ribbonCount.setter
        def ribbonCount(self, value: int) -> int: ...
        @property
        def shadowBias(self) -> float: ...
        @shadowBias.setter
        def shadowBias(self, value: float) -> float: ...
        @property
        def sizeAffectsLifetime(self) -> bool: ...
        @sizeAffectsLifetime.setter
        def sizeAffectsLifetime(self, value: bool) -> bool: ...
        @property
        def sizeAffectsWidth(self) -> bool: ...
        @sizeAffectsWidth.setter
        def sizeAffectsWidth(self, value: bool) -> bool: ...
        @property
        def splitSubEmitterRibbons(self) -> bool: ...
        @splitSubEmitterRibbons.setter
        def splitSubEmitterRibbons(self, value: bool) -> bool: ...
        @property
        def textureMode(self) -> ParticleSystemTrailTextureMode: ...
        @textureMode.setter
        def textureMode(self, value: ParticleSystemTrailTextureMode) -> ParticleSystemTrailTextureMode: ...
        @property
        def textureScale(self) -> Vector2: ...
        @textureScale.setter
        def textureScale(self, value: Vector2) -> Vector2: ...
        @property
        def widthOverTrail(self) -> ParticleSystem.MinMaxCurve: ...
        @widthOverTrail.setter
        def widthOverTrail(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def widthOverTrailMultiplier(self) -> float: ...
        @widthOverTrailMultiplier.setter
        def widthOverTrailMultiplier(self, value: float) -> float: ...
        @property
        def worldSpace(self) -> bool: ...
        @worldSpace.setter
        def worldSpace(self, value: bool) -> bool: ...


    class Trails:
        @property
        def capacity(self) -> int: ...
        @capacity.setter
        def capacity(self, value: int) -> int: ...


    class TriggerModule:
        @property
        def colliderCount(self) -> int: ...
        @property
        def colliderQueryMode(self) -> ParticleSystemColliderQueryMode: ...
        @colliderQueryMode.setter
        def colliderQueryMode(self, value: ParticleSystemColliderQueryMode) -> ParticleSystemColliderQueryMode: ...
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def enter(self) -> ParticleSystemOverlapAction: ...
        @enter.setter
        def enter(self, value: ParticleSystemOverlapAction) -> ParticleSystemOverlapAction: ...
        @property
        def exit(self) -> ParticleSystemOverlapAction: ...
        @exit.setter
        def exit(self, value: ParticleSystemOverlapAction) -> ParticleSystemOverlapAction: ...
        @property
        def inside(self) -> ParticleSystemOverlapAction: ...
        @inside.setter
        def inside(self, value: ParticleSystemOverlapAction) -> ParticleSystemOverlapAction: ...
        @property
        def maxColliderCount(self) -> int: ...
        @property
        def outside(self) -> ParticleSystemOverlapAction: ...
        @outside.setter
        def outside(self, value: ParticleSystemOverlapAction) -> ParticleSystemOverlapAction: ...
        @property
        def radiusScale(self) -> float: ...
        @radiusScale.setter
        def radiusScale(self, value: float) -> float: ...
        def AddCollider(self, collider: Component) -> None: ...
        def GetCollider(self, index: int) -> Component: ...
        def SetCollider(self, index: int, collider: Component) -> None: ...
        # Skipped RemoveCollider due to it being static, abstract and generic.

        RemoveCollider : RemoveCollider_MethodGroup
        class RemoveCollider_MethodGroup:
            @typing.overload
            def __call__(self, index: int) -> None:...
            @typing.overload
            def __call__(self, collider: Component) -> None:...



    class VelocityOverLifetimeModule:
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> bool: ...
        @property
        def orbitalOffsetX(self) -> ParticleSystem.MinMaxCurve: ...
        @orbitalOffsetX.setter
        def orbitalOffsetX(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def orbitalOffsetXMultiplier(self) -> float: ...
        @orbitalOffsetXMultiplier.setter
        def orbitalOffsetXMultiplier(self, value: float) -> float: ...
        @property
        def orbitalOffsetY(self) -> ParticleSystem.MinMaxCurve: ...
        @orbitalOffsetY.setter
        def orbitalOffsetY(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def orbitalOffsetYMultiplier(self) -> float: ...
        @orbitalOffsetYMultiplier.setter
        def orbitalOffsetYMultiplier(self, value: float) -> float: ...
        @property
        def orbitalOffsetZ(self) -> ParticleSystem.MinMaxCurve: ...
        @orbitalOffsetZ.setter
        def orbitalOffsetZ(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def orbitalOffsetZMultiplier(self) -> float: ...
        @orbitalOffsetZMultiplier.setter
        def orbitalOffsetZMultiplier(self, value: float) -> float: ...
        @property
        def orbitalX(self) -> ParticleSystem.MinMaxCurve: ...
        @orbitalX.setter
        def orbitalX(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def orbitalXMultiplier(self) -> float: ...
        @orbitalXMultiplier.setter
        def orbitalXMultiplier(self, value: float) -> float: ...
        @property
        def orbitalY(self) -> ParticleSystem.MinMaxCurve: ...
        @orbitalY.setter
        def orbitalY(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def orbitalYMultiplier(self) -> float: ...
        @orbitalYMultiplier.setter
        def orbitalYMultiplier(self, value: float) -> float: ...
        @property
        def orbitalZ(self) -> ParticleSystem.MinMaxCurve: ...
        @orbitalZ.setter
        def orbitalZ(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def orbitalZMultiplier(self) -> float: ...
        @orbitalZMultiplier.setter
        def orbitalZMultiplier(self, value: float) -> float: ...
        @property
        def radial(self) -> ParticleSystem.MinMaxCurve: ...
        @radial.setter
        def radial(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def radialMultiplier(self) -> float: ...
        @radialMultiplier.setter
        def radialMultiplier(self, value: float) -> float: ...
        @property
        def space(self) -> ParticleSystemSimulationSpace: ...
        @space.setter
        def space(self, value: ParticleSystemSimulationSpace) -> ParticleSystemSimulationSpace: ...
        @property
        def speedModifier(self) -> ParticleSystem.MinMaxCurve: ...
        @speedModifier.setter
        def speedModifier(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def speedModifierMultiplier(self) -> float: ...
        @speedModifierMultiplier.setter
        def speedModifierMultiplier(self, value: float) -> float: ...
        @property
        def x(self) -> ParticleSystem.MinMaxCurve: ...
        @x.setter
        def x(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def xMultiplier(self) -> float: ...
        @xMultiplier.setter
        def xMultiplier(self, value: float) -> float: ...
        @property
        def y(self) -> ParticleSystem.MinMaxCurve: ...
        @y.setter
        def y(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def yMultiplier(self) -> float: ...
        @yMultiplier.setter
        def yMultiplier(self, value: float) -> float: ...
        @property
        def z(self) -> ParticleSystem.MinMaxCurve: ...
        @z.setter
        def z(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
        @property
        def zMultiplier(self) -> float: ...
        @zMultiplier.setter
        def zMultiplier(self, value: float) -> float: ...



class ParticleSystemAnimationMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Grid : ParticleSystemAnimationMode # 0
    Sprites : ParticleSystemAnimationMode # 1


class ParticleSystemAnimationRowMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Custom : ParticleSystemAnimationRowMode # 0
    Random : ParticleSystemAnimationRowMode # 1
    MeshIndex : ParticleSystemAnimationRowMode # 2


class ParticleSystemAnimationTimeMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Lifetime : ParticleSystemAnimationTimeMode # 0
    Speed : ParticleSystemAnimationTimeMode # 1
    FPS : ParticleSystemAnimationTimeMode # 2


class ParticleSystemAnimationType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    WholeSheet : ParticleSystemAnimationType # 0
    SingleRow : ParticleSystemAnimationType # 1


class ParticleSystemBakeMeshOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Default : ParticleSystemBakeMeshOptions # 0
    BakeRotationAndScale : ParticleSystemBakeMeshOptions # 1
    BakePosition : ParticleSystemBakeMeshOptions # 2


class ParticleSystemBakeTextureOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    BakeRotationAndScale : ParticleSystemBakeTextureOptions # 1
    BakePosition : ParticleSystemBakeTextureOptions # 2
    PerVertex : ParticleSystemBakeTextureOptions # 4
    Default : ParticleSystemBakeTextureOptions # 4
    PerParticle : ParticleSystemBakeTextureOptions # 8
    IncludeParticleIndices : ParticleSystemBakeTextureOptions # 16


class ParticleSystemColliderQueryMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Disabled : ParticleSystemColliderQueryMode # 0
    One : ParticleSystemColliderQueryMode # 1
    All : ParticleSystemColliderQueryMode # 2


class ParticleSystemCollisionMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Collision3D : ParticleSystemCollisionMode # 0
    Collision2D : ParticleSystemCollisionMode # 1


class ParticleSystemCollisionQuality(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    High : ParticleSystemCollisionQuality # 0
    Medium : ParticleSystemCollisionQuality # 1
    Low : ParticleSystemCollisionQuality # 2


class ParticleSystemCollisionType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Planes : ParticleSystemCollisionType # 0
    World : ParticleSystemCollisionType # 1


class ParticleSystemCullingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Automatic : ParticleSystemCullingMode # 0
    PauseAndCatchup : ParticleSystemCullingMode # 1
    Pause : ParticleSystemCullingMode # 2
    AlwaysSimulate : ParticleSystemCullingMode # 3


class ParticleSystemCurveMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Constant : ParticleSystemCurveMode # 0
    Curve : ParticleSystemCurveMode # 1
    TwoCurves : ParticleSystemCurveMode # 2
    TwoConstants : ParticleSystemCurveMode # 3


class ParticleSystemCustomData(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Custom1 : ParticleSystemCustomData # 0
    Custom2 : ParticleSystemCustomData # 1


class ParticleSystemCustomDataMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Disabled : ParticleSystemCustomDataMode # 0
    Vector : ParticleSystemCustomDataMode # 1
    Color : ParticleSystemCustomDataMode # 2


class ParticleSystemEmissionType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Time : ParticleSystemEmissionType # 0
    Distance : ParticleSystemEmissionType # 1


class ParticleSystemEmitterVelocityMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Transform : ParticleSystemEmitterVelocityMode # 0
    Rigidbody : ParticleSystemEmitterVelocityMode # 1
    Custom : ParticleSystemEmitterVelocityMode # 2


class ParticleSystemForceField(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def directionX(self) -> ParticleSystem.MinMaxCurve: ...
    @directionX.setter
    def directionX(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
    @property
    def directionY(self) -> ParticleSystem.MinMaxCurve: ...
    @directionY.setter
    def directionY(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
    @property
    def directionZ(self) -> ParticleSystem.MinMaxCurve: ...
    @directionZ.setter
    def directionZ(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
    @property
    def drag(self) -> ParticleSystem.MinMaxCurve: ...
    @drag.setter
    def drag(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def endRange(self) -> float: ...
    @endRange.setter
    def endRange(self, value: float) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def gravity(self) -> ParticleSystem.MinMaxCurve: ...
    @gravity.setter
    def gravity(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
    @property
    def gravityFocus(self) -> float: ...
    @gravityFocus.setter
    def gravityFocus(self, value: float) -> float: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def length(self) -> float: ...
    @length.setter
    def length(self, value: float) -> float: ...
    @property
    def light(self) -> Component: ...
    @property
    def multiplyDragByParticleSize(self) -> bool: ...
    @multiplyDragByParticleSize.setter
    def multiplyDragByParticleSize(self, value: bool) -> bool: ...
    @property
    def multiplyDragByParticleVelocity(self) -> bool: ...
    @multiplyDragByParticleVelocity.setter
    def multiplyDragByParticleVelocity(self, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def rotationAttraction(self) -> ParticleSystem.MinMaxCurve: ...
    @rotationAttraction.setter
    def rotationAttraction(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
    @property
    def rotationRandomness(self) -> Vector2: ...
    @rotationRandomness.setter
    def rotationRandomness(self, value: Vector2) -> Vector2: ...
    @property
    def rotationSpeed(self) -> ParticleSystem.MinMaxCurve: ...
    @rotationSpeed.setter
    def rotationSpeed(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
    @property
    def shape(self) -> ParticleSystemForceFieldShape: ...
    @shape.setter
    def shape(self, value: ParticleSystemForceFieldShape) -> ParticleSystemForceFieldShape: ...
    @property
    def startRange(self) -> float: ...
    @startRange.setter
    def startRange(self, value: float) -> float: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def vectorField(self) -> Texture3D: ...
    @vectorField.setter
    def vectorField(self, value: Texture3D) -> Texture3D: ...
    @property
    def vectorFieldAttraction(self) -> ParticleSystem.MinMaxCurve: ...
    @vectorFieldAttraction.setter
    def vectorFieldAttraction(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
    @property
    def vectorFieldSpeed(self) -> ParticleSystem.MinMaxCurve: ...
    @vectorFieldSpeed.setter
    def vectorFieldSpeed(self, value: ParticleSystem.MinMaxCurve) -> ParticleSystem.MinMaxCurve: ...
    @staticmethod
    def FindAll() -> Array_1[ParticleSystemForceField]: ...


class ParticleSystemForceFieldShape(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Sphere : ParticleSystemForceFieldShape # 0
    Hemisphere : ParticleSystemForceFieldShape # 1
    Cylinder : ParticleSystemForceFieldShape # 2
    Box : ParticleSystemForceFieldShape # 3


class ParticleSystemGameObjectFilter(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    LayerMask : ParticleSystemGameObjectFilter # 0
    List : ParticleSystemGameObjectFilter # 1
    LayerMaskAndList : ParticleSystemGameObjectFilter # 2


class ParticleSystemGradientMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Color : ParticleSystemGradientMode # 0
    Gradient : ParticleSystemGradientMode # 1
    TwoColors : ParticleSystemGradientMode # 2
    TwoGradients : ParticleSystemGradientMode # 3
    RandomColor : ParticleSystemGradientMode # 4


class ParticleSystemGravitySource(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Physics3D : ParticleSystemGravitySource # 0
    Physics2D : ParticleSystemGravitySource # 1


class ParticleSystemInheritVelocityMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Initial : ParticleSystemInheritVelocityMode # 0
    Current : ParticleSystemInheritVelocityMode # 1


class ParticleSystemMeshDistribution(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    UniformRandom : ParticleSystemMeshDistribution # 0
    NonUniformRandom : ParticleSystemMeshDistribution # 1


class ParticleSystemMeshShapeType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Vertex : ParticleSystemMeshShapeType # 0
    Edge : ParticleSystemMeshShapeType # 1
    Triangle : ParticleSystemMeshShapeType # 2


class ParticleSystemNoiseQuality(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Low : ParticleSystemNoiseQuality # 0
    Medium : ParticleSystemNoiseQuality # 1
    High : ParticleSystemNoiseQuality # 2


class ParticleSystemOverlapAction(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Ignore : ParticleSystemOverlapAction # 0
    Kill : ParticleSystemOverlapAction # 1
    Callback : ParticleSystemOverlapAction # 2


class ParticleSystemRenderer(Renderer):
    def __init__(self) -> None: ...
    @property
    def activeTrailVertexStreamsCount(self) -> int: ...
    @property
    def activeVertexStreamsCount(self) -> int: ...
    @property
    def alignment(self) -> ParticleSystemRenderSpace: ...
    @alignment.setter
    def alignment(self, value: ParticleSystemRenderSpace) -> ParticleSystemRenderSpace: ...
    @property
    def allowOcclusionWhenDynamic(self) -> bool: ...
    @allowOcclusionWhenDynamic.setter
    def allowOcclusionWhenDynamic(self, value: bool) -> bool: ...
    @property
    def allowRoll(self) -> bool: ...
    @allowRoll.setter
    def allowRoll(self, value: bool) -> bool: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounds(self) -> Bounds: ...
    @bounds.setter
    def bounds(self, value: Bounds) -> Bounds: ...
    @property
    def camera(self) -> Component: ...
    @property
    def cameraVelocityScale(self) -> float: ...
    @cameraVelocityScale.setter
    def cameraVelocityScale(self, value: float) -> float: ...
    @property
    def castShadows(self) -> bool: ...
    @castShadows.setter
    def castShadows(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def enableGPUInstancing(self) -> bool: ...
    @enableGPUInstancing.setter
    def enableGPUInstancing(self, value: bool) -> bool: ...
    @property
    def flip(self) -> Vector3: ...
    @flip.setter
    def flip(self, value: Vector3) -> Vector3: ...
    @property
    def forceRenderingOff(self) -> bool: ...
    @forceRenderingOff.setter
    def forceRenderingOff(self, value: bool) -> bool: ...
    @property
    def freeformStretching(self) -> bool: ...
    @freeformStretching.setter
    def freeformStretching(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isPartOfStaticBatch(self) -> bool: ...
    @property
    def isVisible(self) -> bool: ...
    @property
    def lengthScale(self) -> float: ...
    @lengthScale.setter
    def lengthScale(self, value: float) -> float: ...
    @property
    def light(self) -> Component: ...
    @property
    def lightmapIndex(self) -> int: ...
    @lightmapIndex.setter
    def lightmapIndex(self, value: int) -> int: ...
    @property
    def lightmapScaleOffset(self) -> Vector4: ...
    @lightmapScaleOffset.setter
    def lightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightmapTilingOffset(self) -> Vector4: ...
    @lightmapTilingOffset.setter
    def lightmapTilingOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightProbeAnchor(self) -> Transform: ...
    @lightProbeAnchor.setter
    def lightProbeAnchor(self, value: Transform) -> Transform: ...
    @property
    def lightProbeProxyVolumeOverride(self) -> GameObject: ...
    @lightProbeProxyVolumeOverride.setter
    def lightProbeProxyVolumeOverride(self, value: GameObject) -> GameObject: ...
    @property
    def lightProbeUsage(self) -> LightProbeUsage: ...
    @lightProbeUsage.setter
    def lightProbeUsage(self, value: LightProbeUsage) -> LightProbeUsage: ...
    @property
    def localBounds(self) -> Bounds: ...
    @localBounds.setter
    def localBounds(self, value: Bounds) -> Bounds: ...
    @property
    def localToWorldMatrix(self) -> Matrix4x4: ...
    @property
    def maskInteraction(self) -> SpriteMaskInteraction: ...
    @maskInteraction.setter
    def maskInteraction(self, value: SpriteMaskInteraction) -> SpriteMaskInteraction: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> Material: ...
    @property
    def materials(self) -> Array_1[Material]: ...
    @materials.setter
    def materials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def maxParticleSize(self) -> float: ...
    @maxParticleSize.setter
    def maxParticleSize(self, value: float) -> float: ...
    @property
    def mesh(self) -> Mesh: ...
    @mesh.setter
    def mesh(self, value: Mesh) -> Mesh: ...
    @property
    def meshCount(self) -> int: ...
    @property
    def meshDistribution(self) -> ParticleSystemMeshDistribution: ...
    @meshDistribution.setter
    def meshDistribution(self, value: ParticleSystemMeshDistribution) -> ParticleSystemMeshDistribution: ...
    @property
    def minParticleSize(self) -> float: ...
    @minParticleSize.setter
    def minParticleSize(self, value: float) -> float: ...
    @property
    def motionVectorGenerationMode(self) -> MotionVectorGenerationMode: ...
    @motionVectorGenerationMode.setter
    def motionVectorGenerationMode(self, value: MotionVectorGenerationMode) -> MotionVectorGenerationMode: ...
    @property
    def motionVectors(self) -> bool: ...
    @motionVectors.setter
    def motionVectors(self, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def normalDirection(self) -> float: ...
    @normalDirection.setter
    def normalDirection(self, value: float) -> float: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def pivot(self) -> Vector3: ...
    @pivot.setter
    def pivot(self, value: Vector3) -> Vector3: ...
    @property
    def probeAnchor(self) -> Transform: ...
    @probeAnchor.setter
    def probeAnchor(self, value: Transform) -> Transform: ...
    @property
    def rayTracingMode(self) -> RayTracingMode: ...
    @rayTracingMode.setter
    def rayTracingMode(self, value: RayTracingMode) -> RayTracingMode: ...
    @property
    def realtimeLightmapIndex(self) -> int: ...
    @realtimeLightmapIndex.setter
    def realtimeLightmapIndex(self, value: int) -> int: ...
    @property
    def realtimeLightmapScaleOffset(self) -> Vector4: ...
    @realtimeLightmapScaleOffset.setter
    def realtimeLightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def receiveShadows(self) -> bool: ...
    @receiveShadows.setter
    def receiveShadows(self, value: bool) -> bool: ...
    @property
    def reflectionProbeUsage(self) -> ReflectionProbeUsage: ...
    @reflectionProbeUsage.setter
    def reflectionProbeUsage(self, value: ReflectionProbeUsage) -> ReflectionProbeUsage: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rendererPriority(self) -> int: ...
    @rendererPriority.setter
    def rendererPriority(self, value: int) -> int: ...
    @property
    def renderingLayerMask(self) -> int: ...
    @renderingLayerMask.setter
    def renderingLayerMask(self, value: int) -> int: ...
    @property
    def renderMode(self) -> ParticleSystemRenderMode: ...
    @renderMode.setter
    def renderMode(self, value: ParticleSystemRenderMode) -> ParticleSystemRenderMode: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def rotateWithStretchDirection(self) -> bool: ...
    @rotateWithStretchDirection.setter
    def rotateWithStretchDirection(self, value: bool) -> bool: ...
    @property
    def shadowBias(self) -> float: ...
    @shadowBias.setter
    def shadowBias(self, value: float) -> float: ...
    @property
    def shadowCastingMode(self) -> ShadowCastingMode: ...
    @shadowCastingMode.setter
    def shadowCastingMode(self, value: ShadowCastingMode) -> ShadowCastingMode: ...
    @property
    def sharedMaterial(self) -> Material: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: Material) -> Material: ...
    @property
    def sharedMaterials(self) -> Array_1[Material]: ...
    @sharedMaterials.setter
    def sharedMaterials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def sortingFudge(self) -> float: ...
    @sortingFudge.setter
    def sortingFudge(self, value: float) -> float: ...
    @property
    def sortingLayerID(self) -> int: ...
    @sortingLayerID.setter
    def sortingLayerID(self, value: int) -> int: ...
    @property
    def sortingLayerName(self) -> str: ...
    @sortingLayerName.setter
    def sortingLayerName(self, value: str) -> str: ...
    @property
    def sortingOrder(self) -> int: ...
    @sortingOrder.setter
    def sortingOrder(self, value: int) -> int: ...
    @property
    def sortMode(self) -> ParticleSystemSortMode: ...
    @sortMode.setter
    def sortMode(self, value: ParticleSystemSortMode) -> ParticleSystemSortMode: ...
    @property
    def staticShadowCaster(self) -> bool: ...
    @staticShadowCaster.setter
    def staticShadowCaster(self, value: bool) -> bool: ...
    @property
    def supportsMeshInstancing(self) -> bool: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def trailMaterial(self) -> Material: ...
    @trailMaterial.setter
    def trailMaterial(self, value: Material) -> Material: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useLightProbes(self) -> bool: ...
    @useLightProbes.setter
    def useLightProbes(self, value: bool) -> bool: ...
    @property
    def velocityScale(self) -> float: ...
    @velocityScale.setter
    def velocityScale(self, value: float) -> float: ...
    @property
    def worldToLocalMatrix(self) -> Matrix4x4: ...
    def AreVertexStreamsEnabled(self, streams: ParticleSystemVertexStreams) -> bool: ...
    def DisableVertexStreams(self, streams: ParticleSystemVertexStreams) -> None: ...
    def EnableVertexStreams(self, streams: ParticleSystemVertexStreams) -> None: ...
    def GetActiveTrailVertexStreams(self, streams: List_1[ParticleSystemVertexStream]) -> None: ...
    def GetActiveVertexStreams(self, streams: List_1[ParticleSystemVertexStream]) -> None: ...
    def GetEnabledVertexStreams(self, streams: ParticleSystemVertexStreams) -> ParticleSystemVertexStreams: ...
    def GetMeshes(self, meshes: Array_1[Mesh]) -> int: ...
    def GetMeshWeightings(self, weightings: Array_1[float]) -> int: ...
    def SetActiveTrailVertexStreams(self, streams: List_1[ParticleSystemVertexStream]) -> None: ...
    def SetActiveVertexStreams(self, streams: List_1[ParticleSystemVertexStream]) -> None: ...
    # Skipped BakeMesh due to it being static, abstract and generic.

    BakeMesh : BakeMesh_MethodGroup
    class BakeMesh_MethodGroup:
        @typing.overload
        def __call__(self, mesh: Mesh, options: ParticleSystemBakeMeshOptions) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, useTransform: bool = ...) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, camera: Camera, options: ParticleSystemBakeMeshOptions) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, camera: Camera, useTransform: bool = ...) -> None:...

    # Skipped BakeTexture due to it being static, abstract and generic.

    BakeTexture : BakeTexture_MethodGroup
    class BakeTexture_MethodGroup:
        @typing.overload
        def __call__(self, verticesTexture: clr.Reference[Texture2D], options: ParticleSystemBakeTextureOptions) -> int:...
        @typing.overload
        def __call__(self, verticesTexture: clr.Reference[Texture2D], camera: Camera, options: ParticleSystemBakeTextureOptions) -> int:...
        @typing.overload
        def __call__(self, verticesTexture: clr.Reference[Texture2D], indicesTexture: clr.Reference[Texture2D], options: ParticleSystemBakeTextureOptions) -> int:...
        @typing.overload
        def __call__(self, verticesTexture: clr.Reference[Texture2D], indicesTexture: clr.Reference[Texture2D], camera: Camera, options: ParticleSystemBakeTextureOptions) -> int:...

    # Skipped BakeTrailsMesh due to it being static, abstract and generic.

    BakeTrailsMesh : BakeTrailsMesh_MethodGroup
    class BakeTrailsMesh_MethodGroup:
        @typing.overload
        def __call__(self, mesh: Mesh, options: ParticleSystemBakeMeshOptions) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, useTransform: bool = ...) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, camera: Camera, options: ParticleSystemBakeMeshOptions) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, camera: Camera, useTransform: bool = ...) -> None:...

    # Skipped BakeTrailsTexture due to it being static, abstract and generic.

    BakeTrailsTexture : BakeTrailsTexture_MethodGroup
    class BakeTrailsTexture_MethodGroup:
        @typing.overload
        def __call__(self, verticesTexture: clr.Reference[Texture2D], indicesTexture: clr.Reference[Texture2D], options: ParticleSystemBakeTextureOptions) -> int:...
        @typing.overload
        def __call__(self, verticesTexture: clr.Reference[Texture2D], indicesTexture: clr.Reference[Texture2D], camera: Camera, options: ParticleSystemBakeTextureOptions) -> int:...

    # Skipped SetMeshes due to it being static, abstract and generic.

    SetMeshes : SetMeshes_MethodGroup
    class SetMeshes_MethodGroup:
        @typing.overload
        def __call__(self, meshes: Array_1[Mesh]) -> None:...
        @typing.overload
        def __call__(self, meshes: Array_1[Mesh], size: int) -> None:...

    # Skipped SetMeshWeightings due to it being static, abstract and generic.

    SetMeshWeightings : SetMeshWeightings_MethodGroup
    class SetMeshWeightings_MethodGroup:
        @typing.overload
        def __call__(self, weightings: Array_1[float]) -> None:...
        @typing.overload
        def __call__(self, weightings: Array_1[float], size: int) -> None:...



class ParticleSystemRenderMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Billboard : ParticleSystemRenderMode # 0
    Stretch : ParticleSystemRenderMode # 1
    HorizontalBillboard : ParticleSystemRenderMode # 2
    VerticalBillboard : ParticleSystemRenderMode # 3
    Mesh : ParticleSystemRenderMode # 4
    None_ : ParticleSystemRenderMode # 5


class ParticleSystemRenderSpace(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    View : ParticleSystemRenderSpace # 0
    World : ParticleSystemRenderSpace # 1
    Local : ParticleSystemRenderSpace # 2
    Facing : ParticleSystemRenderSpace # 3
    Velocity : ParticleSystemRenderSpace # 4


class ParticleSystemRingBufferMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Disabled : ParticleSystemRingBufferMode # 0
    PauseUntilReplaced : ParticleSystemRingBufferMode # 1
    LoopUntilReplaced : ParticleSystemRingBufferMode # 2


class ParticleSystemScalingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Hierarchy : ParticleSystemScalingMode # 0
    Local : ParticleSystemScalingMode # 1
    Shape : ParticleSystemScalingMode # 2


class ParticleSystemShapeMultiModeValue(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Random : ParticleSystemShapeMultiModeValue # 0
    Loop : ParticleSystemShapeMultiModeValue # 1
    PingPong : ParticleSystemShapeMultiModeValue # 2
    BurstSpread : ParticleSystemShapeMultiModeValue # 3


class ParticleSystemShapeTextureChannel(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Red : ParticleSystemShapeTextureChannel # 0
    Green : ParticleSystemShapeTextureChannel # 1
    Blue : ParticleSystemShapeTextureChannel # 2
    Alpha : ParticleSystemShapeTextureChannel # 3


class ParticleSystemShapeType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Sphere : ParticleSystemShapeType # 0
    SphereShell : ParticleSystemShapeType # 1
    Hemisphere : ParticleSystemShapeType # 2
    HemisphereShell : ParticleSystemShapeType # 3
    Cone : ParticleSystemShapeType # 4
    Box : ParticleSystemShapeType # 5
    Mesh : ParticleSystemShapeType # 6
    ConeShell : ParticleSystemShapeType # 7
    ConeVolume : ParticleSystemShapeType # 8
    ConeVolumeShell : ParticleSystemShapeType # 9
    Circle : ParticleSystemShapeType # 10
    CircleEdge : ParticleSystemShapeType # 11
    SingleSidedEdge : ParticleSystemShapeType # 12
    MeshRenderer : ParticleSystemShapeType # 13
    SkinnedMeshRenderer : ParticleSystemShapeType # 14
    BoxShell : ParticleSystemShapeType # 15
    BoxEdge : ParticleSystemShapeType # 16
    Donut : ParticleSystemShapeType # 17
    Rectangle : ParticleSystemShapeType # 18
    Sprite : ParticleSystemShapeType # 19
    SpriteRenderer : ParticleSystemShapeType # 20


class ParticleSystemSimulationSpace(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Local : ParticleSystemSimulationSpace # 0
    World : ParticleSystemSimulationSpace # 1
    Custom : ParticleSystemSimulationSpace # 2


class ParticleSystemSortMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : ParticleSystemSortMode # 0
    Distance : ParticleSystemSortMode # 1
    OldestInFront : ParticleSystemSortMode # 2
    YoungestInFront : ParticleSystemSortMode # 3
    Depth : ParticleSystemSortMode # 4


class ParticleSystemStopAction(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : ParticleSystemStopAction # 0
    Disable : ParticleSystemStopAction # 1
    Destroy : ParticleSystemStopAction # 2
    Callback : ParticleSystemStopAction # 3


class ParticleSystemStopBehavior(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    StopEmittingAndClear : ParticleSystemStopBehavior # 0
    StopEmitting : ParticleSystemStopBehavior # 1


class ParticleSystemSubEmitterProperties(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    InheritNothing : ParticleSystemSubEmitterProperties # 0
    InheritColor : ParticleSystemSubEmitterProperties # 1
    InheritSize : ParticleSystemSubEmitterProperties # 2
    InheritRotation : ParticleSystemSubEmitterProperties # 4
    InheritLifetime : ParticleSystemSubEmitterProperties # 8
    InheritDuration : ParticleSystemSubEmitterProperties # 16
    InheritEverything : ParticleSystemSubEmitterProperties # 31


class ParticleSystemSubEmitterType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Birth : ParticleSystemSubEmitterType # 0
    Collision : ParticleSystemSubEmitterType # 1
    Death : ParticleSystemSubEmitterType # 2
    Trigger : ParticleSystemSubEmitterType # 3
    Manual : ParticleSystemSubEmitterType # 4


class ParticleSystemTrailMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    PerParticle : ParticleSystemTrailMode # 0
    Ribbon : ParticleSystemTrailMode # 1


class ParticleSystemTrailTextureMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Stretch : ParticleSystemTrailTextureMode # 0
    Tile : ParticleSystemTrailTextureMode # 1
    DistributePerSegment : ParticleSystemTrailTextureMode # 2
    RepeatPerSegment : ParticleSystemTrailTextureMode # 3
    Static : ParticleSystemTrailTextureMode # 4


class ParticleSystemTriggerEventType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Inside : ParticleSystemTriggerEventType # 0
    Outside : ParticleSystemTriggerEventType # 1
    Enter : ParticleSystemTriggerEventType # 2
    Exit : ParticleSystemTriggerEventType # 3


class ParticleSystemVertexStream(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Position : ParticleSystemVertexStream # 0
    Normal : ParticleSystemVertexStream # 1
    Tangent : ParticleSystemVertexStream # 2
    Color : ParticleSystemVertexStream # 3
    UV : ParticleSystemVertexStream # 4
    UV2 : ParticleSystemVertexStream # 5
    UV3 : ParticleSystemVertexStream # 6
    UV4 : ParticleSystemVertexStream # 7
    AnimBlend : ParticleSystemVertexStream # 8
    AnimFrame : ParticleSystemVertexStream # 9
    Center : ParticleSystemVertexStream # 10
    VertexID : ParticleSystemVertexStream # 11
    SizeX : ParticleSystemVertexStream # 12
    SizeXY : ParticleSystemVertexStream # 13
    SizeXYZ : ParticleSystemVertexStream # 14
    Rotation : ParticleSystemVertexStream # 15
    Rotation3D : ParticleSystemVertexStream # 16
    RotationSpeed : ParticleSystemVertexStream # 17
    RotationSpeed3D : ParticleSystemVertexStream # 18
    Velocity : ParticleSystemVertexStream # 19
    Speed : ParticleSystemVertexStream # 20
    AgePercent : ParticleSystemVertexStream # 21
    InvStartLifetime : ParticleSystemVertexStream # 22
    StableRandomX : ParticleSystemVertexStream # 23
    StableRandomXY : ParticleSystemVertexStream # 24
    StableRandomXYZ : ParticleSystemVertexStream # 25
    StableRandomXYZW : ParticleSystemVertexStream # 26
    VaryingRandomX : ParticleSystemVertexStream # 27
    VaryingRandomXY : ParticleSystemVertexStream # 28
    VaryingRandomXYZ : ParticleSystemVertexStream # 29
    VaryingRandomXYZW : ParticleSystemVertexStream # 30
    Custom1X : ParticleSystemVertexStream # 31
    Custom1XY : ParticleSystemVertexStream # 32
    Custom1XYZ : ParticleSystemVertexStream # 33
    Custom1XYZW : ParticleSystemVertexStream # 34
    Custom2X : ParticleSystemVertexStream # 35
    Custom2XY : ParticleSystemVertexStream # 36
    Custom2XYZ : ParticleSystemVertexStream # 37
    Custom2XYZW : ParticleSystemVertexStream # 38
    NoiseSumX : ParticleSystemVertexStream # 39
    NoiseSumXY : ParticleSystemVertexStream # 40
    NoiseSumXYZ : ParticleSystemVertexStream # 41
    NoiseImpulseX : ParticleSystemVertexStream # 42
    NoiseImpulseXY : ParticleSystemVertexStream # 43
    NoiseImpulseXYZ : ParticleSystemVertexStream # 44
    MeshIndex : ParticleSystemVertexStream # 45
    ParticleIndex : ParticleSystemVertexStream # 46
    ColorPackedAsTwoFloats : ParticleSystemVertexStream # 47
    MeshAxisOfRotation : ParticleSystemVertexStream # 48
    NextTrailCenter : ParticleSystemVertexStream # 49
    PreviousTrailCenter : ParticleSystemVertexStream # 50
    PercentageAlongTrail : ParticleSystemVertexStream # 51
    TrailWidth : ParticleSystemVertexStream # 52


class ParticleSystemVertexStreams(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : ParticleSystemVertexStreams # 0
    Position : ParticleSystemVertexStreams # 1
    Normal : ParticleSystemVertexStreams # 2
    Tangent : ParticleSystemVertexStreams # 4
    Color : ParticleSystemVertexStreams # 8
    UV : ParticleSystemVertexStreams # 16
    UV2BlendAndFrame : ParticleSystemVertexStreams # 32
    CenterAndVertexID : ParticleSystemVertexStreams # 64
    Size : ParticleSystemVertexStreams # 128
    Rotation : ParticleSystemVertexStreams # 256
    Velocity : ParticleSystemVertexStreams # 512
    Lifetime : ParticleSystemVertexStreams # 1024
    Custom1 : ParticleSystemVertexStreams # 2048
    Custom2 : ParticleSystemVertexStreams # 4096
    Random : ParticleSystemVertexStreams # 8192
    All : ParticleSystemVertexStreams # 2147483647


class PatchExtents:
    @property
    def max(self) -> float: ...
    @max.setter
    def max(self, value: float) -> float: ...
    @property
    def min(self) -> float: ...
    @min.setter
    def min(self, value: float) -> float: ...


class PenData:
    contactType : PenEventType
    deltaPos : Vector2
    penStatus : PenStatus
    position : Vector2
    pressure : float
    tilt : Vector2
    twist : float


class PenEventType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    NoContact : PenEventType # 0
    PenDown : PenEventType # 1
    PenUp : PenEventType # 2


class PenStatus(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : PenStatus # 0
    Contact : PenStatus # 1
    Barrel : PenStatus # 2
    Inverted : PenStatus # 4
    Eraser : PenStatus # 8


class PhysicMaterial(Object):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @property
    def bounceCombine(self) -> PhysicMaterialCombine: ...
    @bounceCombine.setter
    def bounceCombine(self, value: PhysicMaterialCombine) -> PhysicMaterialCombine: ...
    @property
    def bounciness(self) -> float: ...
    @bounciness.setter
    def bounciness(self, value: float) -> float: ...
    @property
    def bouncyness(self) -> float: ...
    @bouncyness.setter
    def bouncyness(self, value: float) -> float: ...
    @property
    def dynamicFriction(self) -> float: ...
    @dynamicFriction.setter
    def dynamicFriction(self, value: float) -> float: ...
    @property
    def dynamicFriction2(self) -> float: ...
    @dynamicFriction2.setter
    def dynamicFriction2(self, value: float) -> float: ...
    @property
    def frictionCombine(self) -> PhysicMaterialCombine: ...
    @frictionCombine.setter
    def frictionCombine(self, value: PhysicMaterialCombine) -> PhysicMaterialCombine: ...
    @property
    def frictionDirection(self) -> Vector3: ...
    @frictionDirection.setter
    def frictionDirection(self, value: Vector3) -> Vector3: ...
    @property
    def frictionDirection2(self) -> Vector3: ...
    @frictionDirection2.setter
    def frictionDirection2(self, value: Vector3) -> Vector3: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def staticFriction(self) -> float: ...
    @staticFriction.setter
    def staticFriction(self, value: float) -> float: ...
    @property
    def staticFriction2(self) -> float: ...
    @staticFriction2.setter
    def staticFriction2(self, value: float) -> float: ...


class PhysicMaterialCombine(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Average : PhysicMaterialCombine # 0
    Multiply : PhysicMaterialCombine # 1
    Minimum : PhysicMaterialCombine # 2
    Maximum : PhysicMaterialCombine # 3


class Physics:
    def __init__(self) -> None: ...
    AllLayers : int
    DefaultRaycastLayers : int
    IgnoreRaycastLayer : int
    kAllLayers : int
    kDefaultRaycastLayers : int
    kIgnoreRaycastLayer : int
    @classmethod
    @property
    def autoSimulation(cls) -> bool: ...
    @classmethod
    @autoSimulation.setter
    def autoSimulation(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def autoSyncTransforms(cls) -> bool: ...
    @classmethod
    @autoSyncTransforms.setter
    def autoSyncTransforms(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def bounceThreshold(cls) -> float: ...
    @classmethod
    @bounceThreshold.setter
    def bounceThreshold(cls, value: float) -> float: ...
    @classmethod
    @property
    def bounceTreshold(cls) -> float: ...
    @classmethod
    @bounceTreshold.setter
    def bounceTreshold(cls, value: float) -> float: ...
    @classmethod
    @property
    def clothGravity(cls) -> Vector3: ...
    @classmethod
    @clothGravity.setter
    def clothGravity(cls, value: Vector3) -> Vector3: ...
    @classmethod
    @property
    def defaultContactOffset(cls) -> float: ...
    @classmethod
    @defaultContactOffset.setter
    def defaultContactOffset(cls, value: float) -> float: ...
    @classmethod
    @property
    def defaultMaxAngularSpeed(cls) -> float: ...
    @classmethod
    @defaultMaxAngularSpeed.setter
    def defaultMaxAngularSpeed(cls, value: float) -> float: ...
    @classmethod
    @property
    def defaultMaxDepenetrationVelocity(cls) -> float: ...
    @classmethod
    @defaultMaxDepenetrationVelocity.setter
    def defaultMaxDepenetrationVelocity(cls, value: float) -> float: ...
    @classmethod
    @property
    def defaultPhysicsScene(cls) -> PhysicsScene: ...
    @classmethod
    @property
    def defaultSolverIterations(cls) -> int: ...
    @classmethod
    @defaultSolverIterations.setter
    def defaultSolverIterations(cls, value: int) -> int: ...
    @classmethod
    @property
    def defaultSolverVelocityIterations(cls) -> int: ...
    @classmethod
    @defaultSolverVelocityIterations.setter
    def defaultSolverVelocityIterations(cls, value: int) -> int: ...
    @classmethod
    @property
    def gravity(cls) -> Vector3: ...
    @classmethod
    @gravity.setter
    def gravity(cls, value: Vector3) -> Vector3: ...
    @classmethod
    @property
    def improvedPatchFriction(cls) -> bool: ...
    @classmethod
    @improvedPatchFriction.setter
    def improvedPatchFriction(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def interCollisionDistance(cls) -> float: ...
    @classmethod
    @interCollisionDistance.setter
    def interCollisionDistance(cls, value: float) -> float: ...
    @classmethod
    @property
    def interCollisionSettingsToggle(cls) -> bool: ...
    @classmethod
    @interCollisionSettingsToggle.setter
    def interCollisionSettingsToggle(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def interCollisionStiffness(cls) -> float: ...
    @classmethod
    @interCollisionStiffness.setter
    def interCollisionStiffness(cls, value: float) -> float: ...
    @classmethod
    @property
    def invokeCollisionCallbacks(cls) -> bool: ...
    @classmethod
    @invokeCollisionCallbacks.setter
    def invokeCollisionCallbacks(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def maxAngularVelocity(cls) -> float: ...
    @classmethod
    @maxAngularVelocity.setter
    def maxAngularVelocity(cls, value: float) -> float: ...
    @classmethod
    @property
    def minPenetrationForPenalty(cls) -> float: ...
    @classmethod
    @minPenetrationForPenalty.setter
    def minPenetrationForPenalty(cls, value: float) -> float: ...
    @classmethod
    @property
    def penetrationPenaltyForce(cls) -> float: ...
    @classmethod
    @penetrationPenaltyForce.setter
    def penetrationPenaltyForce(cls, value: float) -> float: ...
    @classmethod
    @property
    def queriesHitBackfaces(cls) -> bool: ...
    @classmethod
    @queriesHitBackfaces.setter
    def queriesHitBackfaces(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def queriesHitTriggers(cls) -> bool: ...
    @classmethod
    @queriesHitTriggers.setter
    def queriesHitTriggers(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def reuseCollisionCallbacks(cls) -> bool: ...
    @classmethod
    @reuseCollisionCallbacks.setter
    def reuseCollisionCallbacks(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def simulationMode(cls) -> SimulationMode: ...
    @classmethod
    @simulationMode.setter
    def simulationMode(cls, value: SimulationMode) -> SimulationMode: ...
    @classmethod
    @property
    def sleepAngularVelocity(cls) -> float: ...
    @classmethod
    @sleepAngularVelocity.setter
    def sleepAngularVelocity(cls, value: float) -> float: ...
    @classmethod
    @property
    def sleepThreshold(cls) -> float: ...
    @classmethod
    @sleepThreshold.setter
    def sleepThreshold(cls, value: float) -> float: ...
    @classmethod
    @property
    def sleepVelocity(cls) -> float: ...
    @classmethod
    @sleepVelocity.setter
    def sleepVelocity(cls, value: float) -> float: ...
    @classmethod
    @property
    def solverIterationCount(cls) -> int: ...
    @classmethod
    @solverIterationCount.setter
    def solverIterationCount(cls, value: int) -> int: ...
    @classmethod
    @property
    def solverVelocityIterationCount(cls) -> int: ...
    @classmethod
    @solverVelocityIterationCount.setter
    def solverVelocityIterationCount(cls, value: int) -> int: ...
    @staticmethod
    def ClosestPoint(point: Vector3, collider: Collider, position: Vector3, rotation: Quaternion) -> Vector3: ...
    @staticmethod
    def ComputePenetration(colliderA: Collider, positionA: Vector3, rotationA: Quaternion, colliderB: Collider, positionB: Vector3, rotationB: Quaternion, direction: clr.Reference[Vector3], distance: clr.Reference[float]) -> bool: ...
    @staticmethod
    def GetIgnoreCollision(collider1: Collider, collider2: Collider) -> bool: ...
    @staticmethod
    def GetIgnoreLayerCollision(layer1: int, layer2: int) -> bool: ...
    @staticmethod
    def RebuildBroadphaseRegions(worldBounds: Bounds, subdivisions: int) -> None: ...
    @staticmethod
    def Simulate(step: float) -> None: ...
    @staticmethod
    def SyncTransforms() -> None: ...
    # Skipped BakeMesh due to it being static, abstract and generic.

    BakeMesh : BakeMesh_MethodGroup
    class BakeMesh_MethodGroup:
        @typing.overload
        def __call__(self, meshID: int, convex: bool) -> None:...
        @typing.overload
        def __call__(self, meshID: int, convex: bool, cookingOptions: MeshColliderCookingOptions) -> None:...

    # Skipped BoxCast due to it being static, abstract and generic.

    BoxCast : BoxCast_MethodGroup
    class BoxCast_MethodGroup:
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3) -> bool:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion) -> bool:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: clr.Reference[RaycastHit]) -> bool:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: float) -> bool:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: clr.Reference[RaycastHit], orientation: Quaternion) -> bool:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: float, layerMask: int) -> bool:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: clr.Reference[RaycastHit], orientation: Quaternion, maxDistance: float) -> bool:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> bool:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: clr.Reference[RaycastHit], orientation: Quaternion, maxDistance: float, layerMask: int) -> bool:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: clr.Reference[RaycastHit], orientation: Quaternion, maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> bool:...

    # Skipped BoxCastAll due to it being static, abstract and generic.

    BoxCastAll : BoxCastAll_MethodGroup
    class BoxCastAll_MethodGroup:
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: float) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: float, layerMask: int) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> Array_1[RaycastHit]:...

    # Skipped BoxCastNonAlloc due to it being static, abstract and generic.

    BoxCastNonAlloc : BoxCastNonAlloc_MethodGroup
    class BoxCastNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, results: Array_1[RaycastHit]) -> int:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, results: Array_1[RaycastHit], orientation: Quaternion) -> int:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, results: Array_1[RaycastHit], orientation: Quaternion, maxDistance: float) -> int:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, results: Array_1[RaycastHit], orientation: Quaternion, maxDistance: float, layerMask: int) -> int:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, results: Array_1[RaycastHit], orientation: Quaternion, maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> int:...

    # Skipped CapsuleCast due to it being static, abstract and generic.

    CapsuleCast : CapsuleCast_MethodGroup
    class CapsuleCast_MethodGroup:
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3) -> bool:...
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3, maxDistance: float) -> bool:...
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3, hitInfo: clr.Reference[RaycastHit]) -> bool:...
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3, maxDistance: float, layerMask: int) -> bool:...
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3, hitInfo: clr.Reference[RaycastHit], maxDistance: float) -> bool:...
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3, maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> bool:...
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3, hitInfo: clr.Reference[RaycastHit], maxDistance: float, layerMask: int) -> bool:...
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3, hitInfo: clr.Reference[RaycastHit], maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> bool:...

    # Skipped CapsuleCastAll due to it being static, abstract and generic.

    CapsuleCastAll : CapsuleCastAll_MethodGroup
    class CapsuleCastAll_MethodGroup:
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3, maxDistance: float) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3, maxDistance: float, layerMask: int) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3, maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> Array_1[RaycastHit]:...

    # Skipped CapsuleCastNonAlloc due to it being static, abstract and generic.

    CapsuleCastNonAlloc : CapsuleCastNonAlloc_MethodGroup
    class CapsuleCastNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3, results: Array_1[RaycastHit]) -> int:...
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3, results: Array_1[RaycastHit], maxDistance: float) -> int:...
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3, results: Array_1[RaycastHit], maxDistance: float, layerMask: int) -> int:...
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3, results: Array_1[RaycastHit], maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> int:...

    # Skipped CheckBox due to it being static, abstract and generic.

    CheckBox : CheckBox_MethodGroup
    class CheckBox_MethodGroup:
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3) -> bool:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, orientation: Quaternion) -> bool:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, orientation: Quaternion, layerMask: int) -> bool:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, orientation: Quaternion, layermask: int, queryTriggerInteraction: QueryTriggerInteraction) -> bool:...

    # Skipped CheckCapsule due to it being static, abstract and generic.

    CheckCapsule : CheckCapsule_MethodGroup
    class CheckCapsule_MethodGroup:
        @typing.overload
        def __call__(self, start: Vector3, end: Vector3, radius: float) -> bool:...
        @typing.overload
        def __call__(self, start: Vector3, end: Vector3, radius: float, layerMask: int) -> bool:...
        @typing.overload
        def __call__(self, start: Vector3, end: Vector3, radius: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> bool:...

    # Skipped CheckSphere due to it being static, abstract and generic.

    CheckSphere : CheckSphere_MethodGroup
    class CheckSphere_MethodGroup:
        @typing.overload
        def __call__(self, position: Vector3, radius: float) -> bool:...
        @typing.overload
        def __call__(self, position: Vector3, radius: float, layerMask: int) -> bool:...
        @typing.overload
        def __call__(self, position: Vector3, radius: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> bool:...

    # Skipped IgnoreCollision due to it being static, abstract and generic.

    IgnoreCollision : IgnoreCollision_MethodGroup
    class IgnoreCollision_MethodGroup:
        @typing.overload
        def __call__(self, collider1: Collider, collider2: Collider) -> None:...
        @typing.overload
        def __call__(self, collider1: Collider, collider2: Collider, ignore: bool) -> None:...

    # Skipped IgnoreLayerCollision due to it being static, abstract and generic.

    IgnoreLayerCollision : IgnoreLayerCollision_MethodGroup
    class IgnoreLayerCollision_MethodGroup:
        @typing.overload
        def __call__(self, layer1: int, layer2: int) -> None:...
        @typing.overload
        def __call__(self, layer1: int, layer2: int, ignore: bool) -> None:...

    # Skipped Linecast due to it being static, abstract and generic.

    Linecast : Linecast_MethodGroup
    class Linecast_MethodGroup:
        @typing.overload
        def __call__(self, start: Vector3, end: Vector3) -> bool:...
        @typing.overload
        def __call__(self, start: Vector3, end: Vector3, layerMask: int) -> bool:...
        @typing.overload
        def __call__(self, start: Vector3, end: Vector3, hitInfo: clr.Reference[RaycastHit]) -> bool:...
        @typing.overload
        def __call__(self, start: Vector3, end: Vector3, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> bool:...
        @typing.overload
        def __call__(self, start: Vector3, end: Vector3, hitInfo: clr.Reference[RaycastHit], layerMask: int) -> bool:...
        @typing.overload
        def __call__(self, start: Vector3, end: Vector3, hitInfo: clr.Reference[RaycastHit], layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> bool:...

    # Skipped OverlapBox due to it being static, abstract and generic.

    OverlapBox : OverlapBox_MethodGroup
    class OverlapBox_MethodGroup:
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3) -> Array_1[Collider]:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, orientation: Quaternion) -> Array_1[Collider]:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, orientation: Quaternion, layerMask: int) -> Array_1[Collider]:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, orientation: Quaternion, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> Array_1[Collider]:...

    # Skipped OverlapBoxNonAlloc due to it being static, abstract and generic.

    OverlapBoxNonAlloc : OverlapBoxNonAlloc_MethodGroup
    class OverlapBoxNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, results: Array_1[Collider]) -> int:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, results: Array_1[Collider], orientation: Quaternion) -> int:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, results: Array_1[Collider], orientation: Quaternion, mask: int) -> int:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, results: Array_1[Collider], orientation: Quaternion, mask: int, queryTriggerInteraction: QueryTriggerInteraction) -> int:...

    # Skipped OverlapCapsule due to it being static, abstract and generic.

    OverlapCapsule : OverlapCapsule_MethodGroup
    class OverlapCapsule_MethodGroup:
        @typing.overload
        def __call__(self, point0: Vector3, point1: Vector3, radius: float) -> Array_1[Collider]:...
        @typing.overload
        def __call__(self, point0: Vector3, point1: Vector3, radius: float, layerMask: int) -> Array_1[Collider]:...
        @typing.overload
        def __call__(self, point0: Vector3, point1: Vector3, radius: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> Array_1[Collider]:...

    # Skipped OverlapCapsuleNonAlloc due to it being static, abstract and generic.

    OverlapCapsuleNonAlloc : OverlapCapsuleNonAlloc_MethodGroup
    class OverlapCapsuleNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, point0: Vector3, point1: Vector3, radius: float, results: Array_1[Collider]) -> int:...
        @typing.overload
        def __call__(self, point0: Vector3, point1: Vector3, radius: float, results: Array_1[Collider], layerMask: int) -> int:...
        @typing.overload
        def __call__(self, point0: Vector3, point1: Vector3, radius: float, results: Array_1[Collider], layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> int:...

    # Skipped OverlapSphere due to it being static, abstract and generic.

    OverlapSphere : OverlapSphere_MethodGroup
    class OverlapSphere_MethodGroup:
        @typing.overload
        def __call__(self, position: Vector3, radius: float) -> Array_1[Collider]:...
        @typing.overload
        def __call__(self, position: Vector3, radius: float, layerMask: int) -> Array_1[Collider]:...
        @typing.overload
        def __call__(self, position: Vector3, radius: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> Array_1[Collider]:...

    # Skipped OverlapSphereNonAlloc due to it being static, abstract and generic.

    OverlapSphereNonAlloc : OverlapSphereNonAlloc_MethodGroup
    class OverlapSphereNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, position: Vector3, radius: float, results: Array_1[Collider]) -> int:...
        @typing.overload
        def __call__(self, position: Vector3, radius: float, results: Array_1[Collider], layerMask: int) -> int:...
        @typing.overload
        def __call__(self, position: Vector3, radius: float, results: Array_1[Collider], layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> int:...

    # Skipped Raycast due to it being static, abstract and generic.

    Raycast : Raycast_MethodGroup
    class Raycast_MethodGroup:
        @typing.overload
        def __call__(self, ray: Ray) -> bool:...
        @typing.overload
        def __call__(self, ray: Ray, maxDistance: float) -> bool:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3) -> bool:...
        @typing.overload
        def __call__(self, ray: Ray, hitInfo: clr.Reference[RaycastHit]) -> bool:...
        @typing.overload
        def __call__(self, ray: Ray, maxDistance: float, layerMask: int) -> bool:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3, maxDistance: float) -> bool:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3, hitInfo: clr.Reference[RaycastHit]) -> bool:...
        @typing.overload
        def __call__(self, ray: Ray, hitInfo: clr.Reference[RaycastHit], maxDistance: float) -> bool:...
        @typing.overload
        def __call__(self, ray: Ray, maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> bool:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3, maxDistance: float, layerMask: int) -> bool:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3, hitInfo: clr.Reference[RaycastHit], maxDistance: float) -> bool:...
        @typing.overload
        def __call__(self, ray: Ray, hitInfo: clr.Reference[RaycastHit], maxDistance: float, layerMask: int) -> bool:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3, maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> bool:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3, hitInfo: clr.Reference[RaycastHit], maxDistance: float, layerMask: int) -> bool:...
        @typing.overload
        def __call__(self, ray: Ray, hitInfo: clr.Reference[RaycastHit], maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> bool:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3, hitInfo: clr.Reference[RaycastHit], maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> bool:...

    # Skipped RaycastAll due to it being static, abstract and generic.

    RaycastAll : RaycastAll_MethodGroup
    class RaycastAll_MethodGroup:
        @typing.overload
        def __call__(self, ray: Ray) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, ray: Ray, maxDistance: float) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, ray: Ray, maxDistance: float, layerMask: int) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3, maxDistance: float) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, ray: Ray, maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3, maxDistance: float, layerMask: int) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3, maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> Array_1[RaycastHit]:...

    # Skipped RaycastNonAlloc due to it being static, abstract and generic.

    RaycastNonAlloc : RaycastNonAlloc_MethodGroup
    class RaycastNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, ray: Ray, results: Array_1[RaycastHit]) -> int:...
        @typing.overload
        def __call__(self, ray: Ray, results: Array_1[RaycastHit], maxDistance: float) -> int:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3, results: Array_1[RaycastHit]) -> int:...
        @typing.overload
        def __call__(self, ray: Ray, results: Array_1[RaycastHit], maxDistance: float, layerMask: int) -> int:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3, results: Array_1[RaycastHit], maxDistance: float) -> int:...
        @typing.overload
        def __call__(self, ray: Ray, results: Array_1[RaycastHit], maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> int:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3, results: Array_1[RaycastHit], maxDistance: float, layerMask: int) -> int:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3, results: Array_1[RaycastHit], maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> int:...

    # Skipped SphereCast due to it being static, abstract and generic.

    SphereCast : SphereCast_MethodGroup
    class SphereCast_MethodGroup:
        @typing.overload
        def __call__(self, ray: Ray, radius: float) -> bool:...
        @typing.overload
        def __call__(self, ray: Ray, radius: float, maxDistance: float) -> bool:...
        @typing.overload
        def __call__(self, ray: Ray, radius: float, hitInfo: clr.Reference[RaycastHit]) -> bool:...
        @typing.overload
        def __call__(self, ray: Ray, radius: float, maxDistance: float, layerMask: int) -> bool:...
        @typing.overload
        def __call__(self, origin: Vector3, radius: float, direction: Vector3, hitInfo: clr.Reference[RaycastHit]) -> bool:...
        @typing.overload
        def __call__(self, ray: Ray, radius: float, hitInfo: clr.Reference[RaycastHit], maxDistance: float) -> bool:...
        @typing.overload
        def __call__(self, ray: Ray, radius: float, maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> bool:...
        @typing.overload
        def __call__(self, origin: Vector3, radius: float, direction: Vector3, hitInfo: clr.Reference[RaycastHit], maxDistance: float) -> bool:...
        @typing.overload
        def __call__(self, ray: Ray, radius: float, hitInfo: clr.Reference[RaycastHit], maxDistance: float, layerMask: int) -> bool:...
        @typing.overload
        def __call__(self, origin: Vector3, radius: float, direction: Vector3, hitInfo: clr.Reference[RaycastHit], maxDistance: float, layerMask: int) -> bool:...
        @typing.overload
        def __call__(self, ray: Ray, radius: float, hitInfo: clr.Reference[RaycastHit], maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> bool:...
        @typing.overload
        def __call__(self, origin: Vector3, radius: float, direction: Vector3, hitInfo: clr.Reference[RaycastHit], maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> bool:...

    # Skipped SphereCastAll due to it being static, abstract and generic.

    SphereCastAll : SphereCastAll_MethodGroup
    class SphereCastAll_MethodGroup:
        @typing.overload
        def __call__(self, ray: Ray, radius: float) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, ray: Ray, radius: float, maxDistance: float) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, origin: Vector3, radius: float, direction: Vector3) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, ray: Ray, radius: float, maxDistance: float, layerMask: int) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, origin: Vector3, radius: float, direction: Vector3, maxDistance: float) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, ray: Ray, radius: float, maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, origin: Vector3, radius: float, direction: Vector3, maxDistance: float, layerMask: int) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, origin: Vector3, radius: float, direction: Vector3, maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> Array_1[RaycastHit]:...

    # Skipped SphereCastNonAlloc due to it being static, abstract and generic.

    SphereCastNonAlloc : SphereCastNonAlloc_MethodGroup
    class SphereCastNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, ray: Ray, radius: float, results: Array_1[RaycastHit]) -> int:...
        @typing.overload
        def __call__(self, ray: Ray, radius: float, results: Array_1[RaycastHit], maxDistance: float) -> int:...
        @typing.overload
        def __call__(self, origin: Vector3, radius: float, direction: Vector3, results: Array_1[RaycastHit]) -> int:...
        @typing.overload
        def __call__(self, ray: Ray, radius: float, results: Array_1[RaycastHit], maxDistance: float, layerMask: int) -> int:...
        @typing.overload
        def __call__(self, origin: Vector3, radius: float, direction: Vector3, results: Array_1[RaycastHit], maxDistance: float) -> int:...
        @typing.overload
        def __call__(self, ray: Ray, radius: float, results: Array_1[RaycastHit], maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> int:...
        @typing.overload
        def __call__(self, origin: Vector3, radius: float, direction: Vector3, results: Array_1[RaycastHit], maxDistance: float, layerMask: int) -> int:...
        @typing.overload
        def __call__(self, origin: Vector3, radius: float, direction: Vector3, results: Array_1[RaycastHit], maxDistance: float, layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> int:...


    class ContactEventDelegate(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, scene: PhysicsScene, headerArray: NativeArray_1.ReadOnly_1[ContactPairHeader], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, scene: PhysicsScene, headerArray: NativeArray_1.ReadOnly_1[ContactPairHeader]) -> None: ...



class Physics2D:
    def __init__(self) -> None: ...
    AllLayers : int
    DefaultRaycastLayers : int
    IgnoreRaycastLayer : int
    MaxPolygonShapeVertices : int
    @classmethod
    @property
    def alwaysShowColliders(cls) -> bool: ...
    @classmethod
    @alwaysShowColliders.setter
    def alwaysShowColliders(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def angularSleepTolerance(cls) -> float: ...
    @classmethod
    @angularSleepTolerance.setter
    def angularSleepTolerance(cls, value: float) -> float: ...
    @classmethod
    @property
    def autoSimulation(cls) -> bool: ...
    @classmethod
    @autoSimulation.setter
    def autoSimulation(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def autoSyncTransforms(cls) -> bool: ...
    @classmethod
    @autoSyncTransforms.setter
    def autoSyncTransforms(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def baumgarteScale(cls) -> float: ...
    @classmethod
    @baumgarteScale.setter
    def baumgarteScale(cls, value: float) -> float: ...
    @classmethod
    @property
    def baumgarteTOIScale(cls) -> float: ...
    @classmethod
    @baumgarteTOIScale.setter
    def baumgarteTOIScale(cls, value: float) -> float: ...
    @classmethod
    @property
    def callbacksOnDisable(cls) -> bool: ...
    @classmethod
    @callbacksOnDisable.setter
    def callbacksOnDisable(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def changeStopsCallbacks(cls) -> bool: ...
    @classmethod
    @changeStopsCallbacks.setter
    def changeStopsCallbacks(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def colliderAABBColor(cls) -> Color: ...
    @classmethod
    @colliderAABBColor.setter
    def colliderAABBColor(cls, value: Color) -> Color: ...
    @classmethod
    @property
    def colliderAsleepColor(cls) -> Color: ...
    @classmethod
    @colliderAsleepColor.setter
    def colliderAsleepColor(cls, value: Color) -> Color: ...
    @classmethod
    @property
    def colliderAwakeColor(cls) -> Color: ...
    @classmethod
    @colliderAwakeColor.setter
    def colliderAwakeColor(cls, value: Color) -> Color: ...
    @classmethod
    @property
    def colliderContactColor(cls) -> Color: ...
    @classmethod
    @colliderContactColor.setter
    def colliderContactColor(cls, value: Color) -> Color: ...
    @classmethod
    @property
    def contactArrowScale(cls) -> float: ...
    @classmethod
    @contactArrowScale.setter
    def contactArrowScale(cls, value: float) -> float: ...
    @classmethod
    @property
    def defaultContactOffset(cls) -> float: ...
    @classmethod
    @defaultContactOffset.setter
    def defaultContactOffset(cls, value: float) -> float: ...
    @classmethod
    @property
    def defaultPhysicsScene(cls) -> PhysicsScene2D: ...
    @classmethod
    @property
    def deleteStopsCallbacks(cls) -> bool: ...
    @classmethod
    @deleteStopsCallbacks.setter
    def deleteStopsCallbacks(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def gravity(cls) -> Vector2: ...
    @classmethod
    @gravity.setter
    def gravity(cls, value: Vector2) -> Vector2: ...
    @classmethod
    @property
    def jobOptions(cls) -> PhysicsJobOptions2D: ...
    @classmethod
    @jobOptions.setter
    def jobOptions(cls, value: PhysicsJobOptions2D) -> PhysicsJobOptions2D: ...
    @classmethod
    @property
    def linearSleepTolerance(cls) -> float: ...
    @classmethod
    @linearSleepTolerance.setter
    def linearSleepTolerance(cls, value: float) -> float: ...
    @classmethod
    @property
    def maxAngularCorrection(cls) -> float: ...
    @classmethod
    @maxAngularCorrection.setter
    def maxAngularCorrection(cls, value: float) -> float: ...
    @classmethod
    @property
    def maxLinearCorrection(cls) -> float: ...
    @classmethod
    @maxLinearCorrection.setter
    def maxLinearCorrection(cls, value: float) -> float: ...
    @classmethod
    @property
    def maxRotationSpeed(cls) -> float: ...
    @classmethod
    @maxRotationSpeed.setter
    def maxRotationSpeed(cls, value: float) -> float: ...
    @classmethod
    @property
    def maxTranslationSpeed(cls) -> float: ...
    @classmethod
    @maxTranslationSpeed.setter
    def maxTranslationSpeed(cls, value: float) -> float: ...
    @classmethod
    @property
    def minPenetrationForPenalty(cls) -> float: ...
    @classmethod
    @minPenetrationForPenalty.setter
    def minPenetrationForPenalty(cls, value: float) -> float: ...
    @classmethod
    @property
    def positionIterations(cls) -> int: ...
    @classmethod
    @positionIterations.setter
    def positionIterations(cls, value: int) -> int: ...
    @classmethod
    @property
    def queriesHitTriggers(cls) -> bool: ...
    @classmethod
    @queriesHitTriggers.setter
    def queriesHitTriggers(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def queriesStartInColliders(cls) -> bool: ...
    @classmethod
    @queriesStartInColliders.setter
    def queriesStartInColliders(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def raycastsHitTriggers(cls) -> bool: ...
    @classmethod
    @raycastsHitTriggers.setter
    def raycastsHitTriggers(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def raycastsStartInColliders(cls) -> bool: ...
    @classmethod
    @raycastsStartInColliders.setter
    def raycastsStartInColliders(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def reuseCollisionCallbacks(cls) -> bool: ...
    @classmethod
    @reuseCollisionCallbacks.setter
    def reuseCollisionCallbacks(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def showColliderAABB(cls) -> bool: ...
    @classmethod
    @showColliderAABB.setter
    def showColliderAABB(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def showColliderContacts(cls) -> bool: ...
    @classmethod
    @showColliderContacts.setter
    def showColliderContacts(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def showCollidersFilled(cls) -> bool: ...
    @classmethod
    @showCollidersFilled.setter
    def showCollidersFilled(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def showColliderSleep(cls) -> bool: ...
    @classmethod
    @showColliderSleep.setter
    def showColliderSleep(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def simulationMode(cls) -> SimulationMode2D: ...
    @classmethod
    @simulationMode.setter
    def simulationMode(cls, value: SimulationMode2D) -> SimulationMode2D: ...
    @classmethod
    @property
    def timeToSleep(cls) -> float: ...
    @classmethod
    @timeToSleep.setter
    def timeToSleep(cls, value: float) -> float: ...
    @classmethod
    @property
    def velocityIterations(cls) -> int: ...
    @classmethod
    @velocityIterations.setter
    def velocityIterations(cls, value: int) -> int: ...
    @classmethod
    @property
    def velocityThreshold(cls) -> float: ...
    @classmethod
    @velocityThreshold.setter
    def velocityThreshold(cls, value: float) -> float: ...
    @staticmethod
    def Distance(colliderA: Collider2D, colliderB: Collider2D) -> ColliderDistance2D: ...
    @staticmethod
    def GetIgnoreCollision(collider1: Collider2D, collider2: Collider2D) -> bool: ...
    @staticmethod
    def GetIgnoreLayerCollision(layer1: int, layer2: int) -> bool: ...
    @staticmethod
    def GetLayerCollisionMask(layer: int) -> int: ...
    @staticmethod
    def SetLayerCollisionMask(layer: int, layerMask: int) -> None: ...
    @staticmethod
    def Simulate(step: float) -> bool: ...
    @staticmethod
    def SyncTransforms() -> None: ...
    # Skipped BoxCast due to it being static, abstract and generic.

    BoxCast : BoxCast_MethodGroup
    class BoxCast_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, distance: float) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, distance: float, layerMask: int) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, distance: float, layerMask: int, minDepth: float) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D], distance: float) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, contactFilter: ContactFilter2D, results: List_1[RaycastHit2D], distance: float = ...) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, distance: float, layerMask: int, minDepth: float, maxDepth: float) -> RaycastHit2D:...

    # Skipped BoxCastAll due to it being static, abstract and generic.

    BoxCastAll : BoxCastAll_MethodGroup
    class BoxCastAll_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, distance: float) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, distance: float, layerMask: int) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, distance: float, layerMask: int, minDepth: float) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, distance: float, layerMask: int, minDepth: float, maxDepth: float) -> Array_1[RaycastHit2D]:...

    # Skipped BoxCastNonAlloc due to it being static, abstract and generic.

    BoxCastNonAlloc : BoxCastNonAlloc_MethodGroup
    class BoxCastNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, results: Array_1[RaycastHit2D], distance: float) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, results: Array_1[RaycastHit2D], distance: float, layerMask: int) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, results: Array_1[RaycastHit2D], distance: float, layerMask: int, minDepth: float) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, results: Array_1[RaycastHit2D], distance: float, layerMask: int, minDepth: float, maxDepth: float) -> int:...

    # Skipped CapsuleCast due to it being static, abstract and generic.

    CapsuleCast : CapsuleCast_MethodGroup
    class CapsuleCast_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, distance: float) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, distance: float, layerMask: int) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, distance: float, layerMask: int, minDepth: float) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D], distance: float) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, contactFilter: ContactFilter2D, results: List_1[RaycastHit2D], distance: float = ...) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, distance: float, layerMask: int, minDepth: float, maxDepth: float) -> RaycastHit2D:...

    # Skipped CapsuleCastAll due to it being static, abstract and generic.

    CapsuleCastAll : CapsuleCastAll_MethodGroup
    class CapsuleCastAll_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, distance: float) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, distance: float, layerMask: int) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, distance: float, layerMask: int, minDepth: float) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, distance: float, layerMask: int, minDepth: float, maxDepth: float) -> Array_1[RaycastHit2D]:...

    # Skipped CapsuleCastNonAlloc due to it being static, abstract and generic.

    CapsuleCastNonAlloc : CapsuleCastNonAlloc_MethodGroup
    class CapsuleCastNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, results: Array_1[RaycastHit2D], distance: float) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, results: Array_1[RaycastHit2D], distance: float, layerMask: int) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, results: Array_1[RaycastHit2D], distance: float, layerMask: int, minDepth: float) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, results: Array_1[RaycastHit2D], distance: float, layerMask: int, minDepth: float, maxDepth: float) -> int:...

    # Skipped CircleCast due to it being static, abstract and generic.

    CircleCast : CircleCast_MethodGroup
    class CircleCast_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, distance: float) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, distance: float, layerMask: int) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, distance: float, layerMask: int, minDepth: float) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D], distance: float) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, contactFilter: ContactFilter2D, results: List_1[RaycastHit2D], distance: float = ...) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, distance: float, layerMask: int, minDepth: float, maxDepth: float) -> RaycastHit2D:...

    # Skipped CircleCastAll due to it being static, abstract and generic.

    CircleCastAll : CircleCastAll_MethodGroup
    class CircleCastAll_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, distance: float) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, distance: float, layerMask: int) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, distance: float, layerMask: int, minDepth: float) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, distance: float, layerMask: int, minDepth: float, maxDepth: float) -> Array_1[RaycastHit2D]:...

    # Skipped CircleCastNonAlloc due to it being static, abstract and generic.

    CircleCastNonAlloc : CircleCastNonAlloc_MethodGroup
    class CircleCastNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, results: Array_1[RaycastHit2D], distance: float) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, results: Array_1[RaycastHit2D], distance: float, layerMask: int) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, results: Array_1[RaycastHit2D], distance: float, layerMask: int, minDepth: float) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, results: Array_1[RaycastHit2D], distance: float, layerMask: int, minDepth: float, maxDepth: float) -> int:...

    # Skipped ClosestPoint due to it being static, abstract and generic.

    ClosestPoint : ClosestPoint_MethodGroup
    class ClosestPoint_MethodGroup:
        @typing.overload
        def __call__(self, position: Vector2, collider: Collider2D) -> Vector2:...
        @typing.overload
        def __call__(self, position: Vector2, rigidbody: Rigidbody2D) -> Vector2:...

    # Skipped GetContacts due to it being static, abstract and generic.

    GetContacts : GetContacts_MethodGroup
    class GetContacts_MethodGroup:
        @typing.overload
        def __call__(self, collider: Collider2D, colliders: List_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, collider: Collider2D, colliders: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, collider: Collider2D, contacts: List_1[ContactPoint2D]) -> int:...
        @typing.overload
        def __call__(self, collider: Collider2D, contacts: Array_1[ContactPoint2D]) -> int:...
        @typing.overload
        def __call__(self, rigidbody: Rigidbody2D, colliders: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, rigidbody: Rigidbody2D, colliders: List_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, rigidbody: Rigidbody2D, contacts: List_1[ContactPoint2D]) -> int:...
        @typing.overload
        def __call__(self, rigidbody: Rigidbody2D, contacts: Array_1[ContactPoint2D]) -> int:...
        @typing.overload
        def __call__(self, collider: Collider2D, contactFilter: ContactFilter2D, colliders: List_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, collider: Collider2D, contactFilter: ContactFilter2D, colliders: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, collider: Collider2D, contactFilter: ContactFilter2D, contacts: List_1[ContactPoint2D]) -> int:...
        @typing.overload
        def __call__(self, collider: Collider2D, contactFilter: ContactFilter2D, contacts: Array_1[ContactPoint2D]) -> int:...
        @typing.overload
        def __call__(self, rigidbody: Rigidbody2D, contactFilter: ContactFilter2D, colliders: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, rigidbody: Rigidbody2D, contactFilter: ContactFilter2D, colliders: List_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, rigidbody: Rigidbody2D, contactFilter: ContactFilter2D, contacts: Array_1[ContactPoint2D]) -> int:...
        @typing.overload
        def __call__(self, rigidbody: Rigidbody2D, contactFilter: ContactFilter2D, contacts: List_1[ContactPoint2D]) -> int:...
        @typing.overload
        def __call__(self, collider1: Collider2D, collider2: Collider2D, contactFilter: ContactFilter2D, contacts: List_1[ContactPoint2D]) -> int:...
        @typing.overload
        def __call__(self, collider1: Collider2D, collider2: Collider2D, contactFilter: ContactFilter2D, contacts: Array_1[ContactPoint2D]) -> int:...

    # Skipped GetRayIntersection due to it being static, abstract and generic.

    GetRayIntersection : GetRayIntersection_MethodGroup
    class GetRayIntersection_MethodGroup:
        @typing.overload
        def __call__(self, ray: Ray) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, ray: Ray, distance: float) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, ray: Ray, distance: float, layerMask: int) -> RaycastHit2D:...

    # Skipped GetRayIntersectionAll due to it being static, abstract and generic.

    GetRayIntersectionAll : GetRayIntersectionAll_MethodGroup
    class GetRayIntersectionAll_MethodGroup:
        @typing.overload
        def __call__(self, ray: Ray) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, ray: Ray, distance: float) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, ray: Ray, distance: float, layerMask: int) -> Array_1[RaycastHit2D]:...

    # Skipped GetRayIntersectionNonAlloc due to it being static, abstract and generic.

    GetRayIntersectionNonAlloc : GetRayIntersectionNonAlloc_MethodGroup
    class GetRayIntersectionNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, ray: Ray, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, ray: Ray, results: Array_1[RaycastHit2D], distance: float) -> int:...
        @typing.overload
        def __call__(self, ray: Ray, results: Array_1[RaycastHit2D], distance: float, layerMask: int) -> int:...

    # Skipped IgnoreCollision due to it being static, abstract and generic.

    IgnoreCollision : IgnoreCollision_MethodGroup
    class IgnoreCollision_MethodGroup:
        @typing.overload
        def __call__(self, collider1: Collider2D, collider2: Collider2D) -> None:...
        @typing.overload
        def __call__(self, collider1: Collider2D, collider2: Collider2D, ignore: bool) -> None:...

    # Skipped IgnoreLayerCollision due to it being static, abstract and generic.

    IgnoreLayerCollision : IgnoreLayerCollision_MethodGroup
    class IgnoreLayerCollision_MethodGroup:
        @typing.overload
        def __call__(self, layer1: int, layer2: int) -> None:...
        @typing.overload
        def __call__(self, layer1: int, layer2: int, ignore: bool) -> None:...

    # Skipped IsTouching due to it being static, abstract and generic.

    IsTouching : IsTouching_MethodGroup
    class IsTouching_MethodGroup:
        @typing.overload
        def __call__(self, collider1: Collider2D, collider2: Collider2D) -> bool:...
        @typing.overload
        def __call__(self, collider: Collider2D, contactFilter: ContactFilter2D) -> bool:...
        @typing.overload
        def __call__(self, collider1: Collider2D, collider2: Collider2D, contactFilter: ContactFilter2D) -> bool:...

    # Skipped IsTouchingLayers due to it being static, abstract and generic.

    IsTouchingLayers : IsTouchingLayers_MethodGroup
    class IsTouchingLayers_MethodGroup:
        @typing.overload
        def __call__(self, collider: Collider2D) -> bool:...
        @typing.overload
        def __call__(self, collider: Collider2D, layerMask: int) -> bool:...

    # Skipped Linecast due to it being static, abstract and generic.

    Linecast : Linecast_MethodGroup
    class Linecast_MethodGroup:
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2, layerMask: int) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2, layerMask: int, minDepth: float) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2, contactFilter: ContactFilter2D, results: List_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2, layerMask: int, minDepth: float, maxDepth: float) -> RaycastHit2D:...

    # Skipped LinecastAll due to it being static, abstract and generic.

    LinecastAll : LinecastAll_MethodGroup
    class LinecastAll_MethodGroup:
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2, layerMask: int) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2, layerMask: int, minDepth: float) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2, layerMask: int, minDepth: float, maxDepth: float) -> Array_1[RaycastHit2D]:...

    # Skipped LinecastNonAlloc due to it being static, abstract and generic.

    LinecastNonAlloc : LinecastNonAlloc_MethodGroup
    class LinecastNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2, results: Array_1[RaycastHit2D], layerMask: int) -> int:...
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2, results: Array_1[RaycastHit2D], layerMask: int, minDepth: float) -> int:...
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2, results: Array_1[RaycastHit2D], layerMask: int, minDepth: float, maxDepth: float) -> int:...

    # Skipped OverlapArea due to it being static, abstract and generic.

    OverlapArea : OverlapArea_MethodGroup
    class OverlapArea_MethodGroup:
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2) -> Collider2D:...
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2, layerMask: int) -> Collider2D:...
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2, layerMask: int, minDepth: float) -> Collider2D:...
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D, results: List_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2, layerMask: int, minDepth: float, maxDepth: float) -> Collider2D:...

    # Skipped OverlapAreaAll due to it being static, abstract and generic.

    OverlapAreaAll : OverlapAreaAll_MethodGroup
    class OverlapAreaAll_MethodGroup:
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2) -> Array_1[Collider2D]:...
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2, layerMask: int) -> Array_1[Collider2D]:...
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2, layerMask: int, minDepth: float) -> Array_1[Collider2D]:...
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2, layerMask: int, minDepth: float, maxDepth: float) -> Array_1[Collider2D]:...

    # Skipped OverlapAreaNonAlloc due to it being static, abstract and generic.

    OverlapAreaNonAlloc : OverlapAreaNonAlloc_MethodGroup
    class OverlapAreaNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2, results: Array_1[Collider2D], layerMask: int) -> int:...
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2, results: Array_1[Collider2D], layerMask: int, minDepth: float) -> int:...
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2, results: Array_1[Collider2D], layerMask: int, minDepth: float, maxDepth: float) -> int:...

    # Skipped OverlapBox due to it being static, abstract and generic.

    OverlapBox : OverlapBox_MethodGroup
    class OverlapBox_MethodGroup:
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float, layerMask: int) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float, layerMask: int, minDepth: float) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float, contactFilter: ContactFilter2D, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float, contactFilter: ContactFilter2D, results: List_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float, layerMask: int, minDepth: float, maxDepth: float) -> Collider2D:...

    # Skipped OverlapBoxAll due to it being static, abstract and generic.

    OverlapBoxAll : OverlapBoxAll_MethodGroup
    class OverlapBoxAll_MethodGroup:
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float) -> Array_1[Collider2D]:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float, layerMask: int) -> Array_1[Collider2D]:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float, layerMask: int, minDepth: float) -> Array_1[Collider2D]:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float, layerMask: int, minDepth: float, maxDepth: float) -> Array_1[Collider2D]:...

    # Skipped OverlapBoxNonAlloc due to it being static, abstract and generic.

    OverlapBoxNonAlloc : OverlapBoxNonAlloc_MethodGroup
    class OverlapBoxNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float, results: Array_1[Collider2D], layerMask: int) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float, results: Array_1[Collider2D], layerMask: int, minDepth: float) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float, results: Array_1[Collider2D], layerMask: int, minDepth: float, maxDepth: float) -> int:...

    # Skipped OverlapCapsule due to it being static, abstract and generic.

    OverlapCapsule : OverlapCapsule_MethodGroup
    class OverlapCapsule_MethodGroup:
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float, layerMask: int) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float, layerMask: int, minDepth: float) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float, contactFilter: ContactFilter2D, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float, contactFilter: ContactFilter2D, results: List_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float, layerMask: int, minDepth: float, maxDepth: float) -> Collider2D:...

    # Skipped OverlapCapsuleAll due to it being static, abstract and generic.

    OverlapCapsuleAll : OverlapCapsuleAll_MethodGroup
    class OverlapCapsuleAll_MethodGroup:
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float) -> Array_1[Collider2D]:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float, layerMask: int) -> Array_1[Collider2D]:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float, layerMask: int, minDepth: float) -> Array_1[Collider2D]:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float, layerMask: int, minDepth: float, maxDepth: float) -> Array_1[Collider2D]:...

    # Skipped OverlapCapsuleNonAlloc due to it being static, abstract and generic.

    OverlapCapsuleNonAlloc : OverlapCapsuleNonAlloc_MethodGroup
    class OverlapCapsuleNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float, results: Array_1[Collider2D], layerMask: int) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float, results: Array_1[Collider2D], layerMask: int, minDepth: float) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float, results: Array_1[Collider2D], layerMask: int, minDepth: float, maxDepth: float) -> int:...

    # Skipped OverlapCircle due to it being static, abstract and generic.

    OverlapCircle : OverlapCircle_MethodGroup
    class OverlapCircle_MethodGroup:
        @typing.overload
        def __call__(self, point: Vector2, radius: float) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, radius: float, layerMask: int) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, radius: float, layerMask: int, minDepth: float) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, radius: float, contactFilter: ContactFilter2D, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, radius: float, contactFilter: ContactFilter2D, results: List_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, radius: float, layerMask: int, minDepth: float, maxDepth: float) -> Collider2D:...

    # Skipped OverlapCircleAll due to it being static, abstract and generic.

    OverlapCircleAll : OverlapCircleAll_MethodGroup
    class OverlapCircleAll_MethodGroup:
        @typing.overload
        def __call__(self, point: Vector2, radius: float) -> Array_1[Collider2D]:...
        @typing.overload
        def __call__(self, point: Vector2, radius: float, layerMask: int) -> Array_1[Collider2D]:...
        @typing.overload
        def __call__(self, point: Vector2, radius: float, layerMask: int, minDepth: float) -> Array_1[Collider2D]:...
        @typing.overload
        def __call__(self, point: Vector2, radius: float, layerMask: int, minDepth: float, maxDepth: float) -> Array_1[Collider2D]:...

    # Skipped OverlapCircleNonAlloc due to it being static, abstract and generic.

    OverlapCircleNonAlloc : OverlapCircleNonAlloc_MethodGroup
    class OverlapCircleNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, point: Vector2, radius: float, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, radius: float, results: Array_1[Collider2D], layerMask: int) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, radius: float, results: Array_1[Collider2D], layerMask: int, minDepth: float) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, radius: float, results: Array_1[Collider2D], layerMask: int, minDepth: float, maxDepth: float) -> int:...

    # Skipped OverlapCollider due to it being static, abstract and generic.

    OverlapCollider : OverlapCollider_MethodGroup
    class OverlapCollider_MethodGroup:
        @typing.overload
        def __call__(self, collider: Collider2D, contactFilter: ContactFilter2D, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, collider: Collider2D, contactFilter: ContactFilter2D, results: List_1[Collider2D]) -> int:...

    # Skipped OverlapPoint due to it being static, abstract and generic.

    OverlapPoint : OverlapPoint_MethodGroup
    class OverlapPoint_MethodGroup:
        @typing.overload
        def __call__(self, point: Vector2) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, layerMask: int) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, layerMask: int, minDepth: float) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, contactFilter: ContactFilter2D, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, contactFilter: ContactFilter2D, results: List_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, layerMask: int, minDepth: float, maxDepth: float) -> Collider2D:...

    # Skipped OverlapPointAll due to it being static, abstract and generic.

    OverlapPointAll : OverlapPointAll_MethodGroup
    class OverlapPointAll_MethodGroup:
        @typing.overload
        def __call__(self, point: Vector2) -> Array_1[Collider2D]:...
        @typing.overload
        def __call__(self, point: Vector2, layerMask: int) -> Array_1[Collider2D]:...
        @typing.overload
        def __call__(self, point: Vector2, layerMask: int, minDepth: float) -> Array_1[Collider2D]:...
        @typing.overload
        def __call__(self, point: Vector2, layerMask: int, minDepth: float, maxDepth: float) -> Array_1[Collider2D]:...

    # Skipped OverlapPointNonAlloc due to it being static, abstract and generic.

    OverlapPointNonAlloc : OverlapPointNonAlloc_MethodGroup
    class OverlapPointNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, point: Vector2, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, results: Array_1[Collider2D], layerMask: int) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, results: Array_1[Collider2D], layerMask: int, minDepth: float) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, results: Array_1[Collider2D], layerMask: int, minDepth: float, maxDepth: float) -> int:...

    # Skipped Raycast due to it being static, abstract and generic.

    Raycast : Raycast_MethodGroup
    class Raycast_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, distance: float) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, distance: float, layerMask: int) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, distance: float, layerMask: int, minDepth: float) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D], distance: float) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, contactFilter: ContactFilter2D, results: List_1[RaycastHit2D], distance: float = ...) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, distance: float, layerMask: int, minDepth: float, maxDepth: float) -> RaycastHit2D:...

    # Skipped RaycastAll due to it being static, abstract and generic.

    RaycastAll : RaycastAll_MethodGroup
    class RaycastAll_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, distance: float) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, distance: float, layerMask: int) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, distance: float, layerMask: int, minDepth: float) -> Array_1[RaycastHit2D]:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, distance: float, layerMask: int, minDepth: float, maxDepth: float) -> Array_1[RaycastHit2D]:...

    # Skipped RaycastNonAlloc due to it being static, abstract and generic.

    RaycastNonAlloc : RaycastNonAlloc_MethodGroup
    class RaycastNonAlloc_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, results: Array_1[RaycastHit2D], distance: float) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, results: Array_1[RaycastHit2D], distance: float, layerMask: int) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, results: Array_1[RaycastHit2D], distance: float, layerMask: int, minDepth: float) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, results: Array_1[RaycastHit2D], distance: float, layerMask: int, minDepth: float, maxDepth: float) -> int:...



class PhysicsJobOptions2D:
    @property
    def clearBodyForcesPerJob(self) -> int: ...
    @clearBodyForcesPerJob.setter
    def clearBodyForcesPerJob(self, value: int) -> int: ...
    @property
    def clearFlagsPerJob(self) -> int: ...
    @clearFlagsPerJob.setter
    def clearFlagsPerJob(self, value: int) -> int: ...
    @property
    def collideContactsPerJob(self) -> int: ...
    @collideContactsPerJob.setter
    def collideContactsPerJob(self, value: int) -> int: ...
    @property
    def findNearestContactsPerJob(self) -> int: ...
    @findNearestContactsPerJob.setter
    def findNearestContactsPerJob(self, value: int) -> int: ...
    @property
    def interpolationPosesPerJob(self) -> int: ...
    @interpolationPosesPerJob.setter
    def interpolationPosesPerJob(self, value: int) -> int: ...
    @property
    def islandSolverBodiesPerJob(self) -> int: ...
    @islandSolverBodiesPerJob.setter
    def islandSolverBodiesPerJob(self, value: int) -> int: ...
    @property
    def islandSolverBodyCostScale(self) -> int: ...
    @islandSolverBodyCostScale.setter
    def islandSolverBodyCostScale(self, value: int) -> int: ...
    @property
    def islandSolverContactCostScale(self) -> int: ...
    @islandSolverContactCostScale.setter
    def islandSolverContactCostScale(self, value: int) -> int: ...
    @property
    def islandSolverContactsPerJob(self) -> int: ...
    @islandSolverContactsPerJob.setter
    def islandSolverContactsPerJob(self, value: int) -> int: ...
    @property
    def islandSolverCostThreshold(self) -> int: ...
    @islandSolverCostThreshold.setter
    def islandSolverCostThreshold(self, value: int) -> int: ...
    @property
    def islandSolverJointCostScale(self) -> int: ...
    @islandSolverJointCostScale.setter
    def islandSolverJointCostScale(self, value: int) -> int: ...
    @property
    def newContactsPerJob(self) -> int: ...
    @newContactsPerJob.setter
    def newContactsPerJob(self, value: int) -> int: ...
    @property
    def syncContinuousFixturesPerJob(self) -> int: ...
    @syncContinuousFixturesPerJob.setter
    def syncContinuousFixturesPerJob(self, value: int) -> int: ...
    @property
    def syncDiscreteFixturesPerJob(self) -> int: ...
    @syncDiscreteFixturesPerJob.setter
    def syncDiscreteFixturesPerJob(self, value: int) -> int: ...
    @property
    def updateTriggerContactsPerJob(self) -> int: ...
    @updateTriggerContactsPerJob.setter
    def updateTriggerContactsPerJob(self, value: int) -> int: ...
    @property
    def useConsistencySorting(self) -> bool: ...
    @useConsistencySorting.setter
    def useConsistencySorting(self, value: bool) -> bool: ...
    @property
    def useMultithreading(self) -> bool: ...
    @useMultithreading.setter
    def useMultithreading(self, value: bool) -> bool: ...


class PhysicsMaterial2D(Object):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @property
    def bounciness(self) -> float: ...
    @bounciness.setter
    def bounciness(self, value: float) -> float: ...
    @property
    def friction(self) -> float: ...
    @friction.setter
    def friction(self, value: float) -> float: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...


class PhysicsScene(IEquatable_1[PhysicsScene]):
    def GetHashCode(self) -> int: ...
    def InterpolateBodies(self) -> None: ...
    def IsEmpty(self) -> bool: ...
    def IsValid(self) -> bool: ...
    def __eq__(self, lhs: PhysicsScene, rhs: PhysicsScene) -> bool: ...
    def __ne__(self, lhs: PhysicsScene, rhs: PhysicsScene) -> bool: ...
    def OverlapCapsule(self, point0: Vector3, point1: Vector3, radius: float, results: Array_1[Collider], layerMask: int = ..., queryTriggerInteraction: QueryTriggerInteraction = ...) -> int: ...
    def OverlapSphere(self, position: Vector3, radius: float, results: Array_1[Collider], layerMask: int, queryTriggerInteraction: QueryTriggerInteraction) -> int: ...
    def ResetInterpolationPoses(self) -> None: ...
    def Simulate(self, step: float) -> None: ...
    def ToString(self) -> str: ...
    # Skipped BoxCast due to it being static, abstract and generic.

    BoxCast : BoxCast_MethodGroup
    class BoxCast_MethodGroup:
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, results: Array_1[RaycastHit]) -> int:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: clr.Reference[RaycastHit]) -> bool:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, results: Array_1[RaycastHit], orientation: Quaternion, maxDistance: float = ..., layerMask: int = ..., queryTriggerInteraction: QueryTriggerInteraction = ...) -> int:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: clr.Reference[RaycastHit], orientation: Quaternion, maxDistance: float = ..., layerMask: int = ..., queryTriggerInteraction: QueryTriggerInteraction = ...) -> bool:...

    # Skipped CapsuleCast due to it being static, abstract and generic.

    CapsuleCast : CapsuleCast_MethodGroup
    class CapsuleCast_MethodGroup:
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3, results: Array_1[RaycastHit], maxDistance: float = ..., layerMask: int = ..., queryTriggerInteraction: QueryTriggerInteraction = ...) -> int:...
        @typing.overload
        def __call__(self, point1: Vector3, point2: Vector3, radius: float, direction: Vector3, hitInfo: clr.Reference[RaycastHit], maxDistance: float = ..., layerMask: int = ..., queryTriggerInteraction: QueryTriggerInteraction = ...) -> bool:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: PhysicsScene) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped OverlapBox due to it being static, abstract and generic.

    OverlapBox : OverlapBox_MethodGroup
    class OverlapBox_MethodGroup:
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, results: Array_1[Collider]) -> int:...
        @typing.overload
        def __call__(self, center: Vector3, halfExtents: Vector3, results: Array_1[Collider], orientation: Quaternion, layerMask: int = ..., queryTriggerInteraction: QueryTriggerInteraction = ...) -> int:...

    # Skipped Raycast due to it being static, abstract and generic.

    Raycast : Raycast_MethodGroup
    class Raycast_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3, maxDistance: float = ..., layerMask: int = ..., queryTriggerInteraction: QueryTriggerInteraction = ...) -> bool:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3, raycastHits: Array_1[RaycastHit], maxDistance: float = ..., layerMask: int = ..., queryTriggerInteraction: QueryTriggerInteraction = ...) -> int:...
        @typing.overload
        def __call__(self, origin: Vector3, direction: Vector3, hitInfo: clr.Reference[RaycastHit], maxDistance: float = ..., layerMask: int = ..., queryTriggerInteraction: QueryTriggerInteraction = ...) -> bool:...

    # Skipped SphereCast due to it being static, abstract and generic.

    SphereCast : SphereCast_MethodGroup
    class SphereCast_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector3, radius: float, direction: Vector3, results: Array_1[RaycastHit], maxDistance: float = ..., layerMask: int = ..., queryTriggerInteraction: QueryTriggerInteraction = ...) -> int:...
        @typing.overload
        def __call__(self, origin: Vector3, radius: float, direction: Vector3, hitInfo: clr.Reference[RaycastHit], maxDistance: float = ..., layerMask: int = ..., queryTriggerInteraction: QueryTriggerInteraction = ...) -> bool:...



class PhysicsScene2D(IEquatable_1[PhysicsScene2D]):
    def GetHashCode(self) -> int: ...
    def IsEmpty(self) -> bool: ...
    def IsValid(self) -> bool: ...
    def __eq__(self, lhs: PhysicsScene2D, rhs: PhysicsScene2D) -> bool: ...
    def __ne__(self, lhs: PhysicsScene2D, rhs: PhysicsScene2D) -> bool: ...
    def Simulate(self, step: float) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped BoxCast due to it being static, abstract and generic.

    BoxCast : BoxCast_MethodGroup
    class BoxCast_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, distance: float, layerMask: int = ...) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, distance: float, contactFilter: ContactFilter2D) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, distance: float, results: Array_1[RaycastHit2D], layerMask: int = ...) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, distance: float, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, angle: float, direction: Vector2, distance: float, contactFilter: ContactFilter2D, results: List_1[RaycastHit2D]) -> int:...

    # Skipped CapsuleCast due to it being static, abstract and generic.

    CapsuleCast : CapsuleCast_MethodGroup
    class CapsuleCast_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, distance: float, layerMask: int = ...) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, distance: float, contactFilter: ContactFilter2D) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, distance: float, results: Array_1[RaycastHit2D], layerMask: int = ...) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, distance: float, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: float, direction: Vector2, distance: float, contactFilter: ContactFilter2D, results: List_1[RaycastHit2D]) -> int:...

    # Skipped CircleCast due to it being static, abstract and generic.

    CircleCast : CircleCast_MethodGroup
    class CircleCast_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, distance: float, layerMask: int = ...) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, distance: float, contactFilter: ContactFilter2D) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, distance: float, results: Array_1[RaycastHit2D], layerMask: int = ...) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, distance: float, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, radius: float, direction: Vector2, distance: float, contactFilter: ContactFilter2D, results: List_1[RaycastHit2D]) -> int:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: PhysicsScene2D) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped GetRayIntersection due to it being static, abstract and generic.

    GetRayIntersection : GetRayIntersection_MethodGroup
    class GetRayIntersection_MethodGroup:
        @typing.overload
        def __call__(self, ray: Ray, distance: float, layerMask: int = ...) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, ray: Ray, distance: float, results: Array_1[RaycastHit2D], layerMask: int = ...) -> int:...

    # Skipped Linecast due to it being static, abstract and generic.

    Linecast : Linecast_MethodGroup
    class Linecast_MethodGroup:
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2, layerMask: int = ...) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2, contactFilter: ContactFilter2D) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2, results: Array_1[RaycastHit2D], layerMask: int = ...) -> int:...
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, start: Vector2, end: Vector2, contactFilter: ContactFilter2D, results: List_1[RaycastHit2D]) -> int:...

    # Skipped OverlapArea due to it being static, abstract and generic.

    OverlapArea : OverlapArea_MethodGroup
    class OverlapArea_MethodGroup:
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2, layerMask: int = ...) -> Collider2D:...
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D) -> Collider2D:...
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2, results: Array_1[Collider2D], layerMask: int = ...) -> int:...
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D, results: List_1[Collider2D]) -> int:...

    # Skipped OverlapBox due to it being static, abstract and generic.

    OverlapBox : OverlapBox_MethodGroup
    class OverlapBox_MethodGroup:
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float, layerMask: int = ...) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float, contactFilter: ContactFilter2D) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float, results: Array_1[Collider2D], layerMask: int = ...) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float, contactFilter: ContactFilter2D, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, angle: float, contactFilter: ContactFilter2D, results: List_1[Collider2D]) -> int:...

    # Skipped OverlapCapsule due to it being static, abstract and generic.

    OverlapCapsule : OverlapCapsule_MethodGroup
    class OverlapCapsule_MethodGroup:
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float, layerMask: int = ...) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float, contactFilter: ContactFilter2D) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float, results: Array_1[Collider2D], layerMask: int = ...) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float, contactFilter: ContactFilter2D, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: float, contactFilter: ContactFilter2D, results: List_1[Collider2D]) -> int:...

    # Skipped OverlapCircle due to it being static, abstract and generic.

    OverlapCircle : OverlapCircle_MethodGroup
    class OverlapCircle_MethodGroup:
        @typing.overload
        def __call__(self, point: Vector2, radius: float, layerMask: int = ...) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, radius: float, contactFilter: ContactFilter2D) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, radius: float, results: Array_1[Collider2D], layerMask: int = ...) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, radius: float, contactFilter: ContactFilter2D, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, radius: float, contactFilter: ContactFilter2D, results: List_1[Collider2D]) -> int:...

    # Skipped OverlapCollider due to it being static, abstract and generic.

    OverlapCollider : OverlapCollider_MethodGroup
    class OverlapCollider_MethodGroup:
        @typing.overload
        def __call__(self, collider: Collider2D, results: Array_1[Collider2D], layerMask: int = ...) -> int:...
        @typing.overload
        def __call__(self, collider: Collider2D, contactFilter: ContactFilter2D, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, collider: Collider2D, contactFilter: ContactFilter2D, results: List_1[Collider2D]) -> int:...

    # Skipped OverlapPoint due to it being static, abstract and generic.

    OverlapPoint : OverlapPoint_MethodGroup
    class OverlapPoint_MethodGroup:
        @typing.overload
        def __call__(self, point: Vector2, layerMask: int = ...) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, contactFilter: ContactFilter2D) -> Collider2D:...
        @typing.overload
        def __call__(self, point: Vector2, results: Array_1[Collider2D], layerMask: int = ...) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, contactFilter: ContactFilter2D, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, point: Vector2, contactFilter: ContactFilter2D, results: List_1[Collider2D]) -> int:...

    # Skipped Raycast due to it being static, abstract and generic.

    Raycast : Raycast_MethodGroup
    class Raycast_MethodGroup:
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, distance: float, layerMask: int = ...) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, distance: float, contactFilter: ContactFilter2D) -> RaycastHit2D:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, distance: float, results: Array_1[RaycastHit2D], layerMask: int = ...) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, distance: float, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, origin: Vector2, direction: Vector2, distance: float, contactFilter: ContactFilter2D, results: List_1[RaycastHit2D]) -> int:...



class PhysicsSceneExtensions(abc.ABC):
    @staticmethod
    def GetPhysicsScene(scene: Scene) -> PhysicsScene: ...


class PhysicsSceneExtensions2D(abc.ABC):
    @staticmethod
    def GetPhysicsScene2D(scene: Scene) -> PhysicsScene2D: ...


class PhysicsShape2D:
    @property
    def adjacentEnd(self) -> Vector2: ...
    @adjacentEnd.setter
    def adjacentEnd(self, value: Vector2) -> Vector2: ...
    @property
    def adjacentStart(self) -> Vector2: ...
    @adjacentStart.setter
    def adjacentStart(self, value: Vector2) -> Vector2: ...
    @property
    def radius(self) -> float: ...
    @radius.setter
    def radius(self, value: float) -> float: ...
    @property
    def shapeType(self) -> PhysicsShapeType2D: ...
    @shapeType.setter
    def shapeType(self, value: PhysicsShapeType2D) -> PhysicsShapeType2D: ...
    @property
    def useAdjacentEnd(self) -> bool: ...
    @useAdjacentEnd.setter
    def useAdjacentEnd(self, value: bool) -> bool: ...
    @property
    def useAdjacentStart(self) -> bool: ...
    @useAdjacentStart.setter
    def useAdjacentStart(self, value: bool) -> bool: ...
    @property
    def vertexCount(self) -> int: ...
    @vertexCount.setter
    def vertexCount(self, value: int) -> int: ...
    @property
    def vertexStartIndex(self) -> int: ...
    @vertexStartIndex.setter
    def vertexStartIndex(self, value: int) -> int: ...


class PhysicsShapeGroup2D:
    def __init__(self, shapeCapacity: int = ..., vertexCapacity: int = ...) -> None: ...
    @property
    def localToWorldMatrix(self) -> Matrix4x4: ...
    @localToWorldMatrix.setter
    def localToWorldMatrix(self, value: Matrix4x4) -> Matrix4x4: ...
    @property
    def shapeCount(self) -> int: ...
    @property
    def vertexCount(self) -> int: ...
    def Add(self, physicsShapeGroup: PhysicsShapeGroup2D) -> None: ...
    def AddBox(self, center: Vector2, size: Vector2, angle: float = ..., edgeRadius: float = ...) -> int: ...
    def AddCapsule(self, vertex0: Vector2, vertex1: Vector2, radius: float) -> int: ...
    def AddCircle(self, center: Vector2, radius: float) -> int: ...
    def AddPolygon(self, vertices: List_1[Vector2]) -> int: ...
    def Clear(self) -> None: ...
    def DeleteShape(self, shapeIndex: int) -> None: ...
    def GetShape(self, shapeIndex: int) -> PhysicsShape2D: ...
    def GetShapeVertex(self, shapeIndex: int, vertexIndex: int) -> Vector2: ...
    def GetShapeVertices(self, shapeIndex: int, vertices: List_1[Vector2]) -> None: ...
    def SetShapeAdjacentVertices(self, shapeIndex: int, useAdjacentStart: bool, useAdjacentEnd: bool, adjacentStart: Vector2, adjacentEnd: Vector2) -> None: ...
    def SetShapeRadius(self, shapeIndex: int, radius: float) -> None: ...
    def SetShapeVertex(self, shapeIndex: int, vertexIndex: int, vertex: Vector2) -> None: ...
    # Skipped AddEdges due to it being static, abstract and generic.

    AddEdges : AddEdges_MethodGroup
    class AddEdges_MethodGroup:
        @typing.overload
        def __call__(self, vertices: List_1[Vector2], edgeRadius: float = ...) -> int:...
        @typing.overload
        def __call__(self, vertices: List_1[Vector2], useAdjacentStart: bool, useAdjacentEnd: bool, adjacentStart: Vector2, adjacentEnd: Vector2, edgeRadius: float = ...) -> int:...

    # Skipped GetShapeData due to it being static, abstract and generic.

    GetShapeData : GetShapeData_MethodGroup
    class GetShapeData_MethodGroup:
        @typing.overload
        def __call__(self, shapes: List_1[PhysicsShape2D], vertices: List_1[Vector2]) -> None:...
        @typing.overload
        def __call__(self, shapes: NativeArray_1[PhysicsShape2D], vertices: NativeArray_1[Vector2]) -> None:...



class PhysicsShapeType2D(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Circle : PhysicsShapeType2D # 0
    Capsule : PhysicsShapeType2D # 1
    Polygon : PhysicsShapeType2D # 2
    Edges : PhysicsShapeType2D # 3


class PhysicsUpdateBehaviour2D(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class Ping:
    def __init__(self, address: str) -> None: ...
    @property
    def ip(self) -> str: ...
    @property
    def isDone(self) -> bool: ...
    @property
    def time(self) -> int: ...
    def DestroyPing(self) -> None: ...


class Plane(IFormattable):
    @typing.overload
    def __init__(self, a: Vector3, b: Vector3, c: Vector3) -> None: ...
    @typing.overload
    def __init__(self, inNormal: Vector3, d: float) -> None: ...
    @typing.overload
    def __init__(self, inNormal: Vector3, inPoint: Vector3) -> None: ...
    @property
    def distance(self) -> float: ...
    @distance.setter
    def distance(self, value: float) -> float: ...
    @property
    def flipped(self) -> Plane: ...
    @property
    def normal(self) -> Vector3: ...
    @normal.setter
    def normal(self, value: Vector3) -> Vector3: ...
    def ClosestPointOnPlane(self, point: Vector3) -> Vector3: ...
    def Flip(self) -> None: ...
    def GetDistanceToPoint(self, point: Vector3) -> float: ...
    def GetSide(self, point: Vector3) -> bool: ...
    def Raycast(self, ray: Ray, enter: clr.Reference[float]) -> bool: ...
    def SameSide(self, inPt0: Vector3, inPt1: Vector3) -> bool: ...
    def Set3Points(self, a: Vector3, b: Vector3, c: Vector3) -> None: ...
    def SetNormalAndPosition(self, inNormal: Vector3, inPoint: Vector3) -> None: ...
    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...

    # Skipped Translate due to it being static, abstract and generic.

    Translate : Translate_MethodGroup
    class Translate_MethodGroup:
        @typing.overload
        def __call__(self, translation: Vector3) -> None:...
        @typing.overload
        def __call__(self, plane: Plane, translation: Vector3) -> Plane:...



class PlatformEffector2D(Effector2D):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def colliderMask(self) -> int: ...
    @colliderMask.setter
    def colliderMask(self, value: int) -> int: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def oneWay(self) -> bool: ...
    @oneWay.setter
    def oneWay(self, value: bool) -> bool: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def rotationalOffset(self) -> float: ...
    @rotationalOffset.setter
    def rotationalOffset(self, value: float) -> float: ...
    @property
    def sideAngleVariance(self) -> float: ...
    @sideAngleVariance.setter
    def sideAngleVariance(self, value: float) -> float: ...
    @property
    def sideArc(self) -> float: ...
    @sideArc.setter
    def sideArc(self, value: float) -> float: ...
    @property
    def sideBounce(self) -> bool: ...
    @sideBounce.setter
    def sideBounce(self, value: bool) -> bool: ...
    @property
    def sideFriction(self) -> bool: ...
    @sideFriction.setter
    def sideFriction(self, value: bool) -> bool: ...
    @property
    def surfaceArc(self) -> float: ...
    @surfaceArc.setter
    def surfaceArc(self, value: float) -> float: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useColliderMask(self) -> bool: ...
    @useColliderMask.setter
    def useColliderMask(self, value: bool) -> bool: ...
    @property
    def useOneWay(self) -> bool: ...
    @useOneWay.setter
    def useOneWay(self, value: bool) -> bool: ...
    @property
    def useOneWayGrouping(self) -> bool: ...
    @useOneWayGrouping.setter
    def useOneWayGrouping(self, value: bool) -> bool: ...
    @property
    def useSideBounce(self) -> bool: ...
    @useSideBounce.setter
    def useSideBounce(self, value: bool) -> bool: ...
    @property
    def useSideFriction(self) -> bool: ...
    @useSideFriction.setter
    def useSideFriction(self, value: bool) -> bool: ...


class PlayerPrefs:
    def __init__(self) -> None: ...
    @staticmethod
    def DeleteAll() -> None: ...
    @staticmethod
    def DeleteKey(key: str) -> None: ...
    @staticmethod
    def HasKey(key: str) -> bool: ...
    @staticmethod
    def Save() -> None: ...
    @staticmethod
    def SetFloat(key: str, value: float) -> None: ...
    @staticmethod
    def SetInt(key: str, value: int) -> None: ...
    @staticmethod
    def SetString(key: str, value: str) -> None: ...
    # Skipped GetFloat due to it being static, abstract and generic.

    GetFloat : GetFloat_MethodGroup
    class GetFloat_MethodGroup:
        @typing.overload
        def __call__(self, key: str) -> float:...
        @typing.overload
        def __call__(self, key: str, defaultValue: float) -> float:...

    # Skipped GetInt due to it being static, abstract and generic.

    GetInt : GetInt_MethodGroup
    class GetInt_MethodGroup:
        @typing.overload
        def __call__(self, key: str) -> int:...
        @typing.overload
        def __call__(self, key: str, defaultValue: int) -> int:...

    # Skipped GetString due to it being static, abstract and generic.

    GetString : GetString_MethodGroup
    class GetString_MethodGroup:
        @typing.overload
        def __call__(self, key: str) -> str:...
        @typing.overload
        def __call__(self, key: str, defaultValue: str) -> str:...



class PlayerPrefsException(Exception):
    def __init__(self, error: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class PlayMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    StopSameLayer : PlayMode # 0
    StopAll : PlayMode # 4


class PointEffector2D(Effector2D):
    def __init__(self) -> None: ...
    @property
    def angularDrag(self) -> float: ...
    @angularDrag.setter
    def angularDrag(self, value: float) -> float: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def colliderMask(self) -> int: ...
    @colliderMask.setter
    def colliderMask(self, value: int) -> int: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def distanceScale(self) -> float: ...
    @distanceScale.setter
    def distanceScale(self, value: float) -> float: ...
    @property
    def drag(self) -> float: ...
    @drag.setter
    def drag(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def forceMagnitude(self) -> float: ...
    @forceMagnitude.setter
    def forceMagnitude(self, value: float) -> float: ...
    @property
    def forceMode(self) -> EffectorForceMode2D: ...
    @forceMode.setter
    def forceMode(self, value: EffectorForceMode2D) -> EffectorForceMode2D: ...
    @property
    def forceSource(self) -> EffectorSelection2D: ...
    @forceSource.setter
    def forceSource(self, value: EffectorSelection2D) -> EffectorSelection2D: ...
    @property
    def forceTarget(self) -> EffectorSelection2D: ...
    @forceTarget.setter
    def forceTarget(self, value: EffectorSelection2D) -> EffectorSelection2D: ...
    @property
    def forceVariation(self) -> float: ...
    @forceVariation.setter
    def forceVariation(self, value: float) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useColliderMask(self) -> bool: ...
    @useColliderMask.setter
    def useColliderMask(self, value: bool) -> bool: ...


class PointerType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Mouse : PointerType # 0
    Touch : PointerType # 1
    Pen : PointerType # 2


class PolygonCollider2D(Collider2D):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoTiling(self) -> bool: ...
    @autoTiling.setter
    def autoTiling(self, value: bool) -> bool: ...
    @property
    def bounciness(self) -> float: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def callbackLayers(self) -> LayerMask: ...
    @callbackLayers.setter
    def callbackLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def composite(self) -> CompositeCollider2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def contactCaptureLayers(self) -> LayerMask: ...
    @contactCaptureLayers.setter
    def contactCaptureLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def density(self) -> float: ...
    @density.setter
    def density(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def errorState(self) -> ColliderErrorState2D: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def forceReceiveLayers(self) -> LayerMask: ...
    @forceReceiveLayers.setter
    def forceReceiveLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def forceSendLayers(self) -> LayerMask: ...
    @forceSendLayers.setter
    def forceSendLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def friction(self) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def isTrigger(self) -> bool: ...
    @isTrigger.setter
    def isTrigger(self, value: bool) -> bool: ...
    @property
    def layerOverridePriority(self) -> int: ...
    @layerOverridePriority.setter
    def layerOverridePriority(self, value: int) -> int: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def offset(self) -> Vector2: ...
    @offset.setter
    def offset(self, value: Vector2) -> Vector2: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def pathCount(self) -> int: ...
    @pathCount.setter
    def pathCount(self, value: int) -> int: ...
    @property
    def points(self) -> Array_1[Vector2]: ...
    @points.setter
    def points(self, value: Array_1[Vector2]) -> Array_1[Vector2]: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def shapeCount(self) -> int: ...
    @property
    def sharedMaterial(self) -> PhysicsMaterial2D: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: PhysicsMaterial2D) -> PhysicsMaterial2D: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def usedByComposite(self) -> bool: ...
    @usedByComposite.setter
    def usedByComposite(self, value: bool) -> bool: ...
    @property
    def usedByEffector(self) -> bool: ...
    @usedByEffector.setter
    def usedByEffector(self, value: bool) -> bool: ...
    @property
    def useDelaunayMesh(self) -> bool: ...
    @useDelaunayMesh.setter
    def useDelaunayMesh(self, value: bool) -> bool: ...
    def GetTotalPointCount(self) -> int: ...
    # Skipped CreatePrimitive due to it being static, abstract and generic.

    CreatePrimitive : CreatePrimitive_MethodGroup
    class CreatePrimitive_MethodGroup:
        @typing.overload
        def __call__(self, sides: int) -> None:...
        @typing.overload
        def __call__(self, sides: int, scale: Vector2) -> None:...
        @typing.overload
        def __call__(self, sides: int, scale: Vector2, offset: Vector2) -> None:...

    # Skipped GetPath due to it being static, abstract and generic.

    GetPath : GetPath_MethodGroup
    class GetPath_MethodGroup:
        @typing.overload
        def __call__(self, index: int) -> Array_1[Vector2]:...
        @typing.overload
        def __call__(self, index: int, points: List_1[Vector2]) -> int:...

    # Skipped SetPath due to it being static, abstract and generic.

    SetPath : SetPath_MethodGroup
    class SetPath_MethodGroup:
        @typing.overload
        def __call__(self, index: int, points: Array_1[Vector2]) -> None:...
        @typing.overload
        def __call__(self, index: int, points: List_1[Vector2]) -> None:...



class Pose(IEquatable_1[Pose]):
    def __init__(self, position: Vector3, rotation: Quaternion) -> None: ...
    position : Vector3
    rotation : Quaternion
    @property
    def forward(self) -> Vector3: ...
    @classmethod
    @property
    def identity(cls) -> Pose: ...
    @property
    def right(self) -> Vector3: ...
    @property
    def up(self) -> Vector3: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, a: Pose, b: Pose) -> bool: ...
    def __ne__(self, a: Pose, b: Pose) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Pose) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped GetTransformedBy due to it being static, abstract and generic.

    GetTransformedBy : GetTransformedBy_MethodGroup
    class GetTransformedBy_MethodGroup:
        @typing.overload
        def __call__(self, lhs: Transform) -> Pose:...
        @typing.overload
        def __call__(self, lhs: Pose) -> Pose:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...



class PreferBinarySerialization(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class PrimitiveType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Sphere : PrimitiveType # 0
    Capsule : PrimitiveType # 1
    Cylinder : PrimitiveType # 2
    Cube : PrimitiveType # 3
    Plane : PrimitiveType # 4
    Quad : PrimitiveType # 5


class ProceduralCacheSize(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Tiny : ProceduralCacheSize # 0
    Medium : ProceduralCacheSize # 1
    Heavy : ProceduralCacheSize # 2
    NoLimit : ProceduralCacheSize # 3
    None_ : ProceduralCacheSize # 4


class ProceduralLoadingBehavior(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    DoNothing : ProceduralLoadingBehavior # 0
    Generate : ProceduralLoadingBehavior # 1
    BakeAndKeep : ProceduralLoadingBehavior # 2
    BakeAndDiscard : ProceduralLoadingBehavior # 3
    Cache : ProceduralLoadingBehavior # 4
    DoNothingAndCache : ProceduralLoadingBehavior # 5


class ProceduralMaterial(Material):
    @property
    def animationUpdateRate(self) -> int: ...
    @animationUpdateRate.setter
    def animationUpdateRate(self, value: int) -> int: ...
    @property
    def cacheSize(self) -> ProceduralCacheSize: ...
    @cacheSize.setter
    def cacheSize(self, value: ProceduralCacheSize) -> ProceduralCacheSize: ...
    @property
    def color(self) -> Color: ...
    @color.setter
    def color(self, value: Color) -> Color: ...
    @property
    def doubleSidedGI(self) -> bool: ...
    @doubleSidedGI.setter
    def doubleSidedGI(self, value: bool) -> bool: ...
    @property
    def enabledKeywords(self) -> Array_1[LocalKeyword]: ...
    @enabledKeywords.setter
    def enabledKeywords(self, value: Array_1[LocalKeyword]) -> Array_1[LocalKeyword]: ...
    @property
    def enableInstancing(self) -> bool: ...
    @enableInstancing.setter
    def enableInstancing(self, value: bool) -> bool: ...
    @property
    def globalIlluminationFlags(self) -> MaterialGlobalIlluminationFlags: ...
    @globalIlluminationFlags.setter
    def globalIlluminationFlags(self, value: MaterialGlobalIlluminationFlags) -> MaterialGlobalIlluminationFlags: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def isCachedDataAvailable(self) -> bool: ...
    @property
    def isFrozen(self) -> bool: ...
    @property
    def isLoadTimeGenerated(self) -> bool: ...
    @isLoadTimeGenerated.setter
    def isLoadTimeGenerated(self, value: bool) -> bool: ...
    @property
    def isProcessing(self) -> bool: ...
    @property
    def isReadable(self) -> bool: ...
    @isReadable.setter
    def isReadable(self, value: bool) -> bool: ...
    @classmethod
    @property
    def isSupported(cls) -> bool: ...
    @property
    def isVariant(self) -> bool: ...
    @property
    def loadingBehavior(self) -> ProceduralLoadingBehavior: ...
    @property
    def mainTexture(self) -> Texture: ...
    @mainTexture.setter
    def mainTexture(self, value: Texture) -> Texture: ...
    @property
    def mainTextureOffset(self) -> Vector2: ...
    @mainTextureOffset.setter
    def mainTextureOffset(self, value: Vector2) -> Vector2: ...
    @property
    def mainTextureScale(self) -> Vector2: ...
    @mainTextureScale.setter
    def mainTextureScale(self, value: Vector2) -> Vector2: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def parent(self) -> Material: ...
    @parent.setter
    def parent(self, value: Material) -> Material: ...
    @property
    def passCount(self) -> int: ...
    @property
    def preset(self) -> str: ...
    @preset.setter
    def preset(self, value: str) -> str: ...
    @property
    def renderQueue(self) -> int: ...
    @renderQueue.setter
    def renderQueue(self, value: int) -> int: ...
    @property
    def shader(self) -> Shader: ...
    @shader.setter
    def shader(self, value: Shader) -> Shader: ...
    @property
    def shaderKeywords(self) -> Array_1[str]: ...
    @shaderKeywords.setter
    def shaderKeywords(self, value: Array_1[str]) -> Array_1[str]: ...
    @classmethod
    @property
    def substanceProcessorUsage(cls) -> ProceduralProcessorUsage: ...
    @classmethod
    @substanceProcessorUsage.setter
    def substanceProcessorUsage(cls, value: ProceduralProcessorUsage) -> ProceduralProcessorUsage: ...
    def CacheProceduralProperty(self, inputName: str, value: bool) -> None: ...
    def ClearCache(self) -> None: ...
    def FreezeAndReleaseSourceData(self) -> None: ...
    def GetGeneratedTexture(self, textureName: str) -> ProceduralTexture: ...
    def GetGeneratedTextures(self) -> Array_1[Texture]: ...
    def GetProceduralBoolean(self, inputName: str) -> bool: ...
    def GetProceduralColor(self, inputName: str) -> Color: ...
    def GetProceduralEnum(self, inputName: str) -> int: ...
    def GetProceduralFloat(self, inputName: str) -> float: ...
    def GetProceduralPropertyDescriptions(self) -> Array_1[ProceduralPropertyDescription]: ...
    def GetProceduralString(self, inputName: str) -> str: ...
    def GetProceduralTexture(self, inputName: str) -> Texture2D: ...
    def GetProceduralVector(self, inputName: str) -> Vector4: ...
    def HasProceduralProperty(self, inputName: str) -> bool: ...
    def IsProceduralPropertyCached(self, inputName: str) -> bool: ...
    def IsProceduralPropertyVisible(self, inputName: str) -> bool: ...
    def RebuildTextures(self) -> None: ...
    def RebuildTexturesImmediately(self) -> None: ...
    def SetProceduralBoolean(self, inputName: str, value: bool) -> None: ...
    def SetProceduralColor(self, inputName: str, value: Color) -> None: ...
    def SetProceduralEnum(self, inputName: str, value: int) -> None: ...
    def SetProceduralFloat(self, inputName: str, value: float) -> None: ...
    def SetProceduralString(self, inputName: str, value: str) -> None: ...
    def SetProceduralTexture(self, inputName: str, value: Texture2D) -> None: ...
    def SetProceduralVector(self, inputName: str, value: Vector4) -> None: ...
    @staticmethod
    def StopRebuilds() -> None: ...


class ProceduralOutputType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : ProceduralOutputType # 0
    Diffuse : ProceduralOutputType # 1
    Normal : ProceduralOutputType # 2
    Height : ProceduralOutputType # 3
    Emissive : ProceduralOutputType # 4
    Specular : ProceduralOutputType # 5
    Opacity : ProceduralOutputType # 6
    Smoothness : ProceduralOutputType # 7
    AmbientOcclusion : ProceduralOutputType # 8
    DetailMask : ProceduralOutputType # 9
    Metallic : ProceduralOutputType # 10
    Roughness : ProceduralOutputType # 11


class ProceduralProcessorUsage(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unsupported : ProceduralProcessorUsage # 0
    One : ProceduralProcessorUsage # 1
    Half : ProceduralProcessorUsage # 2
    All : ProceduralProcessorUsage # 3


class ProceduralPropertyDescription:
    def __init__(self) -> None: ...
    componentLabels : Array_1[str]
    enumOptions : Array_1[str]
    group : str
    hasRange : bool
    label : str
    maximum : float
    minimum : float
    name : str
    step : float
    type : ProceduralPropertyType


class ProceduralPropertyType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Boolean : ProceduralPropertyType # 0
    Float : ProceduralPropertyType # 1
    Vector2 : ProceduralPropertyType # 2
    Vector3 : ProceduralPropertyType # 3
    Vector4 : ProceduralPropertyType # 4
    Color3 : ProceduralPropertyType # 5
    Color4 : ProceduralPropertyType # 6
    Enum : ProceduralPropertyType # 7
    Texture : ProceduralPropertyType # 8
    String : ProceduralPropertyType # 9


class ProceduralTexture(Texture):
    @property
    def anisoLevel(self) -> int: ...
    @anisoLevel.setter
    def anisoLevel(self, value: int) -> int: ...
    @property
    def dimension(self) -> TextureDimension: ...
    @dimension.setter
    def dimension(self, value: TextureDimension) -> TextureDimension: ...
    @property
    def filterMode(self) -> FilterMode: ...
    @filterMode.setter
    def filterMode(self, value: FilterMode) -> FilterMode: ...
    @property
    def format(self) -> TextureFormat: ...
    @property
    def graphicsFormat(self) -> GraphicsFormat: ...
    @property
    def hasAlpha(self) -> bool: ...
    @property
    def height(self) -> int: ...
    @height.setter
    def height(self, value: int) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def imageContentsHash(self) -> Hash128: ...
    @imageContentsHash.setter
    def imageContentsHash(self, value: Hash128) -> Hash128: ...
    @property
    def isDataSRGB(self) -> bool: ...
    @property
    def isReadable(self) -> bool: ...
    @property
    def mipMapBias(self) -> float: ...
    @mipMapBias.setter
    def mipMapBias(self, value: float) -> float: ...
    @property
    def mipmapCount(self) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def texelSize(self) -> Vector2: ...
    @property
    def updateCount(self) -> int: ...
    @property
    def width(self) -> int: ...
    @width.setter
    def width(self, value: int) -> int: ...
    @property
    def wrapMode(self) -> TextureWrapMode: ...
    @wrapMode.setter
    def wrapMode(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeU(self) -> TextureWrapMode: ...
    @wrapModeU.setter
    def wrapModeU(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeV(self) -> TextureWrapMode: ...
    @wrapModeV.setter
    def wrapModeV(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeW(self) -> TextureWrapMode: ...
    @wrapModeW.setter
    def wrapModeW(self, value: TextureWrapMode) -> TextureWrapMode: ...
    def GetPixels32(self, x: int, y: int, blockWidth: int, blockHeight: int) -> Array_1[Color32]: ...
    def GetProceduralOutputType(self) -> ProceduralOutputType: ...


class Projector(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def aspectRatio(self) -> float: ...
    @aspectRatio.setter
    def aspectRatio(self, value: float) -> float: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def farClipPlane(self) -> float: ...
    @farClipPlane.setter
    def farClipPlane(self, value: float) -> float: ...
    @property
    def fieldOfView(self) -> float: ...
    @fieldOfView.setter
    def fieldOfView(self, value: float) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def ignoreLayers(self) -> int: ...
    @ignoreLayers.setter
    def ignoreLayers(self, value: int) -> int: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def isOrthoGraphic(self) -> bool: ...
    @isOrthoGraphic.setter
    def isOrthoGraphic(self, value: bool) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> Material: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def nearClipPlane(self) -> float: ...
    @nearClipPlane.setter
    def nearClipPlane(self, value: float) -> float: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def orthographic(self) -> bool: ...
    @orthographic.setter
    def orthographic(self, value: bool) -> bool: ...
    @property
    def orthographicSize(self) -> float: ...
    @orthographicSize.setter
    def orthographicSize(self, value: float) -> float: ...
    @property
    def orthoGraphicSize(self) -> float: ...
    @orthoGraphicSize.setter
    def orthoGraphicSize(self, value: float) -> float: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class PropertyAttribute(Attribute):
    @property
    def order(self) -> int: ...
    @order.setter
    def order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class PropertyName(IEquatable_1[PropertyName]):
    @typing.overload
    def __init__(self, id: int) -> None: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, other: PropertyName) -> None: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def IsNullOrEmpty(prop: PropertyName) -> bool: ...
    def __eq__(self, lhs: PropertyName, rhs: PropertyName) -> bool: ...
    # Operator not supported op_Implicit(id: Int32)
    # Operator not supported op_Implicit(name: String)
    def __ne__(self, lhs: PropertyName, rhs: PropertyName) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: PropertyName) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...



class QualityLevel(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Fastest : QualityLevel # 0
    Fast : QualityLevel # 1
    Simple : QualityLevel # 2
    Good : QualityLevel # 3
    Beautiful : QualityLevel # 4
    Fantastic : QualityLevel # 5


class QualitySettings(Object):
    @classmethod
    @property
    def activeColorSpace(cls) -> ColorSpace: ...
    @classmethod
    @property
    def anisotropicFiltering(cls) -> AnisotropicFiltering: ...
    @classmethod
    @anisotropicFiltering.setter
    def anisotropicFiltering(cls, value: AnisotropicFiltering) -> AnisotropicFiltering: ...
    @classmethod
    @property
    def antiAliasing(cls) -> int: ...
    @classmethod
    @antiAliasing.setter
    def antiAliasing(cls, value: int) -> int: ...
    @classmethod
    @property
    def asyncUploadBufferSize(cls) -> int: ...
    @classmethod
    @asyncUploadBufferSize.setter
    def asyncUploadBufferSize(cls, value: int) -> int: ...
    @classmethod
    @property
    def asyncUploadPersistentBuffer(cls) -> bool: ...
    @classmethod
    @asyncUploadPersistentBuffer.setter
    def asyncUploadPersistentBuffer(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def asyncUploadTimeSlice(cls) -> int: ...
    @classmethod
    @asyncUploadTimeSlice.setter
    def asyncUploadTimeSlice(cls, value: int) -> int: ...
    @classmethod
    @property
    def billboardsFaceCameraPosition(cls) -> bool: ...
    @classmethod
    @billboardsFaceCameraPosition.setter
    def billboardsFaceCameraPosition(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def blendWeights(cls) -> BlendWeights: ...
    @classmethod
    @blendWeights.setter
    def blendWeights(cls, value: BlendWeights) -> BlendWeights: ...
    @classmethod
    @property
    def count(cls) -> int: ...
    @classmethod
    @property
    def currentLevel(cls) -> QualityLevel: ...
    @classmethod
    @currentLevel.setter
    def currentLevel(cls, value: QualityLevel) -> QualityLevel: ...
    @classmethod
    @property
    def desiredColorSpace(cls) -> ColorSpace: ...
    @classmethod
    @property
    def enableLODCrossFade(cls) -> bool: ...
    @classmethod
    @enableLODCrossFade.setter
    def enableLODCrossFade(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def globalTextureMipmapLimit(cls) -> int: ...
    @classmethod
    @globalTextureMipmapLimit.setter
    def globalTextureMipmapLimit(cls, value: int) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @classmethod
    @property
    def lodBias(cls) -> float: ...
    @classmethod
    @lodBias.setter
    def lodBias(cls, value: float) -> float: ...
    @classmethod
    @property
    def masterTextureLimit(cls) -> int: ...
    @classmethod
    @masterTextureLimit.setter
    def masterTextureLimit(cls, value: int) -> int: ...
    @classmethod
    @property
    def maximumLODLevel(cls) -> int: ...
    @classmethod
    @maximumLODLevel.setter
    def maximumLODLevel(cls, value: int) -> int: ...
    @classmethod
    @property
    def maxQueuedFrames(cls) -> int: ...
    @classmethod
    @maxQueuedFrames.setter
    def maxQueuedFrames(cls, value: int) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @classmethod
    @property
    def names(cls) -> Array_1[str]: ...
    @classmethod
    @property
    def particleRaycastBudget(cls) -> int: ...
    @classmethod
    @particleRaycastBudget.setter
    def particleRaycastBudget(cls, value: int) -> int: ...
    @classmethod
    @property
    def pixelLightCount(cls) -> int: ...
    @classmethod
    @pixelLightCount.setter
    def pixelLightCount(cls, value: int) -> int: ...
    @classmethod
    @property
    def realtimeGICPUUsage(cls) -> int: ...
    @classmethod
    @realtimeGICPUUsage.setter
    def realtimeGICPUUsage(cls, value: int) -> int: ...
    @classmethod
    @property
    def realtimeReflectionProbes(cls) -> bool: ...
    @classmethod
    @realtimeReflectionProbes.setter
    def realtimeReflectionProbes(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def renderPipeline(cls) -> RenderPipelineAsset: ...
    @classmethod
    @renderPipeline.setter
    def renderPipeline(cls, value: RenderPipelineAsset) -> RenderPipelineAsset: ...
    @classmethod
    @property
    def resolutionScalingFixedDPIFactor(cls) -> float: ...
    @classmethod
    @resolutionScalingFixedDPIFactor.setter
    def resolutionScalingFixedDPIFactor(cls, value: float) -> float: ...
    @classmethod
    @property
    def shadowCascade2Split(cls) -> float: ...
    @classmethod
    @shadowCascade2Split.setter
    def shadowCascade2Split(cls, value: float) -> float: ...
    @classmethod
    @property
    def shadowCascade4Split(cls) -> Vector3: ...
    @classmethod
    @shadowCascade4Split.setter
    def shadowCascade4Split(cls, value: Vector3) -> Vector3: ...
    @classmethod
    @property
    def shadowCascades(cls) -> int: ...
    @classmethod
    @shadowCascades.setter
    def shadowCascades(cls, value: int) -> int: ...
    @classmethod
    @property
    def shadowDistance(cls) -> float: ...
    @classmethod
    @shadowDistance.setter
    def shadowDistance(cls, value: float) -> float: ...
    @classmethod
    @property
    def shadowmaskMode(cls) -> ShadowmaskMode: ...
    @classmethod
    @shadowmaskMode.setter
    def shadowmaskMode(cls, value: ShadowmaskMode) -> ShadowmaskMode: ...
    @classmethod
    @property
    def shadowNearPlaneOffset(cls) -> float: ...
    @classmethod
    @shadowNearPlaneOffset.setter
    def shadowNearPlaneOffset(cls, value: float) -> float: ...
    @classmethod
    @property
    def shadowProjection(cls) -> ShadowProjection: ...
    @classmethod
    @shadowProjection.setter
    def shadowProjection(cls, value: ShadowProjection) -> ShadowProjection: ...
    @classmethod
    @property
    def shadowResolution(cls) -> ShadowResolution: ...
    @classmethod
    @shadowResolution.setter
    def shadowResolution(cls, value: ShadowResolution) -> ShadowResolution: ...
    @classmethod
    @property
    def shadows(cls) -> ShadowQuality: ...
    @classmethod
    @shadows.setter
    def shadows(cls, value: ShadowQuality) -> ShadowQuality: ...
    @classmethod
    @property
    def skinWeights(cls) -> SkinWeights: ...
    @classmethod
    @skinWeights.setter
    def skinWeights(cls, value: SkinWeights) -> SkinWeights: ...
    @classmethod
    @property
    def softParticles(cls) -> bool: ...
    @classmethod
    @softParticles.setter
    def softParticles(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def softVegetation(cls) -> bool: ...
    @classmethod
    @softVegetation.setter
    def softVegetation(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def streamingMipmapsActive(cls) -> bool: ...
    @classmethod
    @streamingMipmapsActive.setter
    def streamingMipmapsActive(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def streamingMipmapsAddAllCameras(cls) -> bool: ...
    @classmethod
    @streamingMipmapsAddAllCameras.setter
    def streamingMipmapsAddAllCameras(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def streamingMipmapsMaxFileIORequests(cls) -> int: ...
    @classmethod
    @streamingMipmapsMaxFileIORequests.setter
    def streamingMipmapsMaxFileIORequests(cls, value: int) -> int: ...
    @classmethod
    @property
    def streamingMipmapsMaxLevelReduction(cls) -> int: ...
    @classmethod
    @streamingMipmapsMaxLevelReduction.setter
    def streamingMipmapsMaxLevelReduction(cls, value: int) -> int: ...
    @classmethod
    @property
    def streamingMipmapsMemoryBudget(cls) -> float: ...
    @classmethod
    @streamingMipmapsMemoryBudget.setter
    def streamingMipmapsMemoryBudget(cls, value: float) -> float: ...
    @classmethod
    @property
    def streamingMipmapsRenderersPerFrame(cls) -> int: ...
    @classmethod
    @streamingMipmapsRenderersPerFrame.setter
    def streamingMipmapsRenderersPerFrame(cls, value: int) -> int: ...
    @classmethod
    @property
    def terrainBasemapDistance(cls) -> float: ...
    @classmethod
    @terrainBasemapDistance.setter
    def terrainBasemapDistance(cls, value: float) -> float: ...
    @classmethod
    @property
    def terrainBillboardStart(cls) -> float: ...
    @classmethod
    @terrainBillboardStart.setter
    def terrainBillboardStart(cls, value: float) -> float: ...
    @classmethod
    @property
    def terrainDetailDensityScale(cls) -> float: ...
    @classmethod
    @terrainDetailDensityScale.setter
    def terrainDetailDensityScale(cls, value: float) -> float: ...
    @classmethod
    @property
    def terrainDetailDistance(cls) -> float: ...
    @classmethod
    @terrainDetailDistance.setter
    def terrainDetailDistance(cls, value: float) -> float: ...
    @classmethod
    @property
    def terrainFadeLength(cls) -> float: ...
    @classmethod
    @terrainFadeLength.setter
    def terrainFadeLength(cls, value: float) -> float: ...
    @classmethod
    @property
    def terrainMaxTrees(cls) -> float: ...
    @classmethod
    @terrainMaxTrees.setter
    def terrainMaxTrees(cls, value: float) -> float: ...
    @classmethod
    @property
    def terrainPixelError(cls) -> float: ...
    @classmethod
    @terrainPixelError.setter
    def terrainPixelError(cls, value: float) -> float: ...
    @classmethod
    @property
    def terrainQualityOverrides(cls) -> TerrainQualityOverrides: ...
    @classmethod
    @terrainQualityOverrides.setter
    def terrainQualityOverrides(cls, value: TerrainQualityOverrides) -> TerrainQualityOverrides: ...
    @classmethod
    @property
    def terrainTreeDistance(cls) -> float: ...
    @classmethod
    @terrainTreeDistance.setter
    def terrainTreeDistance(cls, value: float) -> float: ...
    @classmethod
    @property
    def useLegacyDetailDistribution(cls) -> bool: ...
    @classmethod
    @useLegacyDetailDistribution.setter
    def useLegacyDetailDistribution(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def vSyncCount(cls) -> int: ...
    @classmethod
    @vSyncCount.setter
    def vSyncCount(cls, value: int) -> int: ...
    @staticmethod
    def GetActiveQualityLevelsForPlatform(buildTargetGroupName: str) -> Array_1[int]: ...
    @staticmethod
    def GetActiveQualityLevelsForPlatformCount(buildTargetGroupName: str) -> int: ...
    @staticmethod
    def GetAllRenderPipelineAssetsForPlatform(buildTargetGroupName: str, renderPipelineAssets: clr.Reference[List_1[RenderPipelineAsset]]) -> None: ...
    @staticmethod
    def GetQualityLevel() -> int: ...
    @staticmethod
    def GetQualitySettings() -> Object: ...
    @staticmethod
    def GetRenderPipelineAssetAt(index: int) -> RenderPipelineAsset: ...
    @staticmethod
    def GetTextureMipmapLimitSettings(groupName: str) -> TextureMipmapLimitSettings: ...
    @staticmethod
    def IsPlatformIncluded(buildTargetGroupName: str, index: int) -> bool: ...
    @staticmethod
    def SetLODSettings(lodBias: float, maximumLODLevel: int, setDirty: bool = ...) -> None: ...
    @staticmethod
    def SetTextureMipmapLimitSettings(groupName: str, textureMipmapLimitSettings: TextureMipmapLimitSettings) -> None: ...
    @staticmethod
    def TryExcludePlatformAt(buildTargetGroupName: str, index: int, error: clr.Reference[Exception]) -> bool: ...
    @staticmethod
    def TryIncludePlatformAt(buildTargetGroupName: str, index: int, error: clr.Reference[Exception]) -> bool: ...
    # Skipped DecreaseLevel due to it being static, abstract and generic.

    DecreaseLevel : DecreaseLevel_MethodGroup
    class DecreaseLevel_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, applyExpensiveChanges: bool) -> None:...

    # Skipped ForEach due to it being static, abstract and generic.

    ForEach : ForEach_MethodGroup
    class ForEach_MethodGroup:
        @typing.overload
        def __call__(self, callback: Action_2[int, str]) -> None:...
        @typing.overload
        def __call__(self, callback: Action) -> None:...

    # Skipped GetRenderPipelineAssetsForPlatform due to it being static, abstract and generic.

    GetRenderPipelineAssetsForPlatform : GetRenderPipelineAssetsForPlatform_MethodGroup
    class GetRenderPipelineAssetsForPlatform_MethodGroup:
        def __getitem__(self, t:typing.Type[GetRenderPipelineAssetsForPlatform_1_T1]) -> GetRenderPipelineAssetsForPlatform_1[GetRenderPipelineAssetsForPlatform_1_T1]: ...

        GetRenderPipelineAssetsForPlatform_1_T1 = typing.TypeVar('GetRenderPipelineAssetsForPlatform_1_T1')
        class GetRenderPipelineAssetsForPlatform_1(typing.Generic[GetRenderPipelineAssetsForPlatform_1_T1]):
            GetRenderPipelineAssetsForPlatform_1_T = QualitySettings.GetRenderPipelineAssetsForPlatform_MethodGroup.GetRenderPipelineAssetsForPlatform_1_T1
            def __call__(self, buildTargetGroupName: str, uniqueRenderPipelineAssets: clr.Reference[HashSet_1[GetRenderPipelineAssetsForPlatform_1_T]]) -> None:...


    # Skipped IncreaseLevel due to it being static, abstract and generic.

    IncreaseLevel : IncreaseLevel_MethodGroup
    class IncreaseLevel_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, applyExpensiveChanges: bool) -> None:...

    # Skipped SetQualityLevel due to it being static, abstract and generic.

    SetQualityLevel : SetQualityLevel_MethodGroup
    class SetQualityLevel_MethodGroup:
        @typing.overload
        def __call__(self, index: int) -> None:...
        @typing.overload
        def __call__(self, index: int, applyExpensiveChanges: bool) -> None:...



class Quaternion(IFormattable, IEquatable_1[Quaternion]):
    def __init__(self, x: float, y: float, z: float, w: float) -> None: ...
    kEpsilon : float
    w : float
    x : float
    y : float
    z : float
    @property
    def eulerAngles(self) -> Vector3: ...
    @eulerAngles.setter
    def eulerAngles(self, value: Vector3) -> Vector3: ...
    @classmethod
    @property
    def identity(cls) -> Quaternion: ...
    @property
    def Item(self) -> float: ...
    @Item.setter
    def Item(self, value: float) -> float: ...
    @property
    def normalized(self) -> Quaternion: ...
    @staticmethod
    def Angle(a: Quaternion, b: Quaternion) -> float: ...
    @staticmethod
    def AngleAxis(angle: float, axis: Vector3) -> Quaternion: ...
    @staticmethod
    def AxisAngle(axis: Vector3, angle: float) -> Quaternion: ...
    @staticmethod
    def Dot(a: Quaternion, b: Quaternion) -> float: ...
    @staticmethod
    def FromToRotation(fromDirection: Vector3, toDirection: Vector3) -> Quaternion: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Inverse(rotation: Quaternion) -> Quaternion: ...
    @staticmethod
    def Lerp(a: Quaternion, b: Quaternion, t: float) -> Quaternion: ...
    @staticmethod
    def LerpUnclamped(a: Quaternion, b: Quaternion, t: float) -> Quaternion: ...
    def __eq__(self, lhs: Quaternion, rhs: Quaternion) -> bool: ...
    def __ne__(self, lhs: Quaternion, rhs: Quaternion) -> bool: ...
    @typing.overload
    def __mul__(self, lhs: Quaternion, rhs: Quaternion) -> Quaternion: ...
    @typing.overload
    def __mul__(self, rotation: Quaternion, point: Vector3) -> Vector3: ...
    @staticmethod
    def RotateTowards(from_: Quaternion, to: Quaternion, maxDegreesDelta: float) -> Quaternion: ...
    def Set(self, newX: float, newY: float, newZ: float, newW: float) -> None: ...
    def SetAxisAngle(self, axis: Vector3, angle: float) -> None: ...
    def SetFromToRotation(self, fromDirection: Vector3, toDirection: Vector3) -> None: ...
    @staticmethod
    def Slerp(a: Quaternion, b: Quaternion, t: float) -> Quaternion: ...
    @staticmethod
    def SlerpUnclamped(a: Quaternion, b: Quaternion, t: float) -> Quaternion: ...
    def ToAngleAxis(self, angle: clr.Reference[float], axis: clr.Reference[Vector3]) -> None: ...
    def ToAxisAngle(self, axis: clr.Reference[Vector3], angle: clr.Reference[float]) -> None: ...
    def ToEuler(self) -> Vector3: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Quaternion) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped Euler due to it being static, abstract and generic.

    Euler : Euler_MethodGroup
    class Euler_MethodGroup:
        @typing.overload
        def __call__(self, euler: Vector3) -> Quaternion:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> Quaternion:...

    # Skipped EulerAngles due to it being static, abstract and generic.

    EulerAngles : EulerAngles_MethodGroup
    class EulerAngles_MethodGroup:
        @typing.overload
        def __call__(self, euler: Vector3) -> Quaternion:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> Quaternion:...

    # Skipped EulerRotation due to it being static, abstract and generic.

    EulerRotation : EulerRotation_MethodGroup
    class EulerRotation_MethodGroup:
        @typing.overload
        def __call__(self, euler: Vector3) -> Quaternion:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> Quaternion:...

    # Skipped LookRotation due to it being static, abstract and generic.

    LookRotation : LookRotation_MethodGroup
    class LookRotation_MethodGroup:
        @typing.overload
        def __call__(self, forward: Vector3) -> Quaternion:...
        @typing.overload
        def __call__(self, forward: Vector3, upwards: Vector3) -> Quaternion:...

    # Skipped Normalize due to it being static, abstract and generic.

    Normalize : Normalize_MethodGroup
    class Normalize_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, q: Quaternion) -> Quaternion:...

    # Skipped SetEulerAngles due to it being static, abstract and generic.

    SetEulerAngles : SetEulerAngles_MethodGroup
    class SetEulerAngles_MethodGroup:
        @typing.overload
        def __call__(self, euler: Vector3) -> None:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> None:...

    # Skipped SetEulerRotation due to it being static, abstract and generic.

    SetEulerRotation : SetEulerRotation_MethodGroup
    class SetEulerRotation_MethodGroup:
        @typing.overload
        def __call__(self, euler: Vector3) -> None:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> None:...

    # Skipped SetLookRotation due to it being static, abstract and generic.

    SetLookRotation : SetLookRotation_MethodGroup
    class SetLookRotation_MethodGroup:
        @typing.overload
        def __call__(self, view: Vector3) -> None:...
        @typing.overload
        def __call__(self, view: Vector3, up: Vector3) -> None:...

    # Skipped ToEulerAngles due to it being static, abstract and generic.

    ToEulerAngles : ToEulerAngles_MethodGroup
    class ToEulerAngles_MethodGroup:
        @typing.overload
        def __call__(self) -> Vector3:...
        @typing.overload
        def __call__(self, rotation: Quaternion) -> Vector3:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...



class QueryParameters:
    def __init__(self, layerMask: int = ..., hitMultipleFaces: bool = ..., hitTriggers: QueryTriggerInteraction = ..., hitBackfaces: bool = ...) -> None: ...
    hitBackfaces : bool
    hitMultipleFaces : bool
    hitTriggers : QueryTriggerInteraction
    layerMask : int
    @classmethod
    @property
    def Default(cls) -> QueryParameters: ...


class QueryTriggerInteraction(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    UseGlobal : QueryTriggerInteraction # 0
    Ignore : QueryTriggerInteraction # 1
    Collide : QueryTriggerInteraction # 2


class QueueMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    CompleteOthers : QueueMode # 0
    PlayNow : QueueMode # 2


class Random(abc.ABC):
    @classmethod
    @property
    def insideUnitCircle(cls) -> Vector2: ...
    @classmethod
    @property
    def insideUnitSphere(cls) -> Vector3: ...
    @classmethod
    @property
    def onUnitSphere(cls) -> Vector3: ...
    @classmethod
    @property
    def rotation(cls) -> Quaternion: ...
    @classmethod
    @property
    def rotationUniform(cls) -> Quaternion: ...
    @classmethod
    @property
    def seed(cls) -> int: ...
    @classmethod
    @seed.setter
    def seed(cls, value: int) -> int: ...
    @classmethod
    @property
    def state(cls) -> Random.State: ...
    @classmethod
    @state.setter
    def state(cls, value: Random.State) -> Random.State: ...
    @classmethod
    @property
    def value(cls) -> float: ...
    @staticmethod
    def InitState(seed: int) -> None: ...
    # Skipped ColorHSV due to it being static, abstract and generic.

    ColorHSV : ColorHSV_MethodGroup
    class ColorHSV_MethodGroup:
        @typing.overload
        def __call__(self) -> Color:...
        @typing.overload
        def __call__(self, hueMin: float, hueMax: float) -> Color:...
        @typing.overload
        def __call__(self, hueMin: float, hueMax: float, saturationMin: float, saturationMax: float) -> Color:...
        @typing.overload
        def __call__(self, hueMin: float, hueMax: float, saturationMin: float, saturationMax: float, valueMin: float, valueMax: float) -> Color:...
        @typing.overload
        def __call__(self, hueMin: float, hueMax: float, saturationMin: float, saturationMax: float, valueMin: float, valueMax: float, alphaMin: float, alphaMax: float) -> Color:...

    # Skipped RandomRange due to it being static, abstract and generic.

    RandomRange : RandomRange_MethodGroup
    class RandomRange_MethodGroup:
        def __call__(self, min: float, max: float) -> float:...
        # Method RandomRange(min : Int32, max : Int32) was skipped since it collides with above method

    # Skipped Range due to it being static, abstract and generic.

    Range : Range_MethodGroup
    class Range_MethodGroup:
        def __call__(self, minInclusive: float, maxInclusive: float) -> float:...
        # Method Range(minInclusive : Int32, maxExclusive : Int32) was skipped since it collides with above method


    class State:
        pass



class RangeAttribute(PropertyAttribute):
    def __init__(self, min: float, max: float) -> None: ...
    max : float
    min : float
    @property
    def order(self) -> int: ...
    @order.setter
    def order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class RangeInt:
    def __init__(self, start: int, length: int) -> None: ...
    length : int
    start : int
    @property
    def end(self) -> int: ...


class Ray(IFormattable):
    def __init__(self, origin: Vector3, direction: Vector3) -> None: ...
    @property
    def direction(self) -> Vector3: ...
    @direction.setter
    def direction(self, value: Vector3) -> Vector3: ...
    @property
    def origin(self) -> Vector3: ...
    @origin.setter
    def origin(self, value: Vector3) -> Vector3: ...
    def GetPoint(self, distance: float) -> Vector3: ...
    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...



class Ray2D(IFormattable):
    def __init__(self, origin: Vector2, direction: Vector2) -> None: ...
    @property
    def direction(self) -> Vector2: ...
    @direction.setter
    def direction(self, value: Vector2) -> Vector2: ...
    @property
    def origin(self) -> Vector2: ...
    @origin.setter
    def origin(self, value: Vector2) -> Vector2: ...
    def GetPoint(self, distance: float) -> Vector2: ...
    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...



class RaycastCommand:
    @typing.overload
    def __init__(self, from_: Vector3, direction: Vector3, distance: float = ..., layerMask: int = ..., maxHits: int = ...) -> None: ...
    @typing.overload
    def __init__(self, from_: Vector3, direction: Vector3, queryParameters: QueryParameters, distance: float = ...) -> None: ...
    @typing.overload
    def __init__(self, physicsScene: PhysicsScene, from_: Vector3, direction: Vector3, distance: float = ..., layerMask: int = ..., maxHits: int = ...) -> None: ...
    @typing.overload
    def __init__(self, physicsScene: PhysicsScene, from_: Vector3, direction: Vector3, queryParameters: QueryParameters, distance: float = ...) -> None: ...
    queryParameters : QueryParameters
    @property
    def direction(self) -> Vector3: ...
    @direction.setter
    def direction(self, value: Vector3) -> Vector3: ...
    @property
    def distance(self) -> float: ...
    @distance.setter
    def distance(self, value: float) -> float: ...
    @property
    def from(self) -> Vector3: ...
    @from.setter
    def from(self, value: Vector3) -> Vector3: ...
    @property
    def layerMask(self) -> int: ...
    @layerMask.setter
    def layerMask(self, value: int) -> int: ...
    @property
    def maxHits(self) -> int: ...
    @maxHits.setter
    def maxHits(self, value: int) -> int: ...
    @property
    def physicsScene(self) -> PhysicsScene: ...
    @physicsScene.setter
    def physicsScene(self, value: PhysicsScene) -> PhysicsScene: ...
    # Skipped ScheduleBatch due to it being static, abstract and generic.

    ScheduleBatch : ScheduleBatch_MethodGroup
    class ScheduleBatch_MethodGroup:
        @typing.overload
        def __call__(self, commands: NativeArray_1[RaycastCommand], results: NativeArray_1[RaycastHit], minCommandsPerJob: int, dependsOn: JobHandle = ...) -> JobHandle:...
        @typing.overload
        def __call__(self, commands: NativeArray_1[RaycastCommand], results: NativeArray_1[RaycastHit], minCommandsPerJob: int, maxHits: int, dependsOn: JobHandle = ...) -> JobHandle:...



class RaycastHit:
    @property
    def articulationBody(self) -> ArticulationBody: ...
    @property
    def barycentricCoordinate(self) -> Vector3: ...
    @barycentricCoordinate.setter
    def barycentricCoordinate(self, value: Vector3) -> Vector3: ...
    @property
    def collider(self) -> Collider: ...
    @property
    def colliderInstanceID(self) -> int: ...
    @property
    def distance(self) -> float: ...
    @distance.setter
    def distance(self, value: float) -> float: ...
    @property
    def lightmapCoord(self) -> Vector2: ...
    @property
    def normal(self) -> Vector3: ...
    @normal.setter
    def normal(self, value: Vector3) -> Vector3: ...
    @property
    def point(self) -> Vector3: ...
    @point.setter
    def point(self, value: Vector3) -> Vector3: ...
    @property
    def rigidbody(self) -> Rigidbody: ...
    @property
    def textureCoord(self) -> Vector2: ...
    @property
    def textureCoord1(self) -> Vector2: ...
    @property
    def textureCoord2(self) -> Vector2: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def triangleIndex(self) -> int: ...


class RaycastHit2D:
    @property
    def centroid(self) -> Vector2: ...
    @centroid.setter
    def centroid(self, value: Vector2) -> Vector2: ...
    @property
    def collider(self) -> Collider2D: ...
    @property
    def distance(self) -> float: ...
    @distance.setter
    def distance(self, value: float) -> float: ...
    @property
    def fraction(self) -> float: ...
    @fraction.setter
    def fraction(self, value: float) -> float: ...
    @property
    def normal(self) -> Vector2: ...
    @normal.setter
    def normal(self, value: Vector2) -> Vector2: ...
    @property
    def point(self) -> Vector2: ...
    @point.setter
    def point(self, value: Vector2) -> Vector2: ...
    @property
    def rigidbody(self) -> Rigidbody2D: ...
    @property
    def transform(self) -> Transform: ...
    def CompareTo(self, other: RaycastHit2D) -> int: ...
    # Operator not supported op_Implicit(hit: RaycastHit2D)


class ReceiveGI(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Lightmaps : ReceiveGI # 1
    LightProbes : ReceiveGI # 2


class Rect(IFormattable, IEquatable_1[Rect]):
    @typing.overload
    def __init__(self, position: Vector2, size: Vector2) -> None: ...
    @typing.overload
    def __init__(self, source: Rect) -> None: ...
    @typing.overload
    def __init__(self, x: float, y: float, width: float, height: float) -> None: ...
    @property
    def bottom(self) -> float: ...
    @property
    def center(self) -> Vector2: ...
    @center.setter
    def center(self, value: Vector2) -> Vector2: ...
    @property
    def height(self) -> float: ...
    @height.setter
    def height(self, value: float) -> float: ...
    @property
    def left(self) -> float: ...
    @property
    def max(self) -> Vector2: ...
    @max.setter
    def max(self, value: Vector2) -> Vector2: ...
    @property
    def min(self) -> Vector2: ...
    @min.setter
    def min(self, value: Vector2) -> Vector2: ...
    @property
    def position(self) -> Vector2: ...
    @position.setter
    def position(self, value: Vector2) -> Vector2: ...
    @property
    def right(self) -> float: ...
    @property
    def size(self) -> Vector2: ...
    @size.setter
    def size(self, value: Vector2) -> Vector2: ...
    @property
    def top(self) -> float: ...
    @property
    def width(self) -> float: ...
    @width.setter
    def width(self, value: float) -> float: ...
    @property
    def x(self) -> float: ...
    @x.setter
    def x(self, value: float) -> float: ...
    @property
    def xMax(self) -> float: ...
    @xMax.setter
    def xMax(self, value: float) -> float: ...
    @property
    def xMin(self) -> float: ...
    @xMin.setter
    def xMin(self, value: float) -> float: ...
    @property
    def y(self) -> float: ...
    @y.setter
    def y(self, value: float) -> float: ...
    @property
    def yMax(self) -> float: ...
    @yMax.setter
    def yMax(self, value: float) -> float: ...
    @property
    def yMin(self) -> float: ...
    @yMin.setter
    def yMin(self, value: float) -> float: ...
    @classmethod
    @property
    def zero(cls) -> Rect: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def MinMaxRect(xmin: float, ymin: float, xmax: float, ymax: float) -> Rect: ...
    @staticmethod
    def NormalizedToPoint(rectangle: Rect, normalizedRectCoordinates: Vector2) -> Vector2: ...
    def __eq__(self, lhs: Rect, rhs: Rect) -> bool: ...
    def __ne__(self, lhs: Rect, rhs: Rect) -> bool: ...
    @staticmethod
    def PointToNormalized(rectangle: Rect, point: Vector2) -> Vector2: ...
    def Set(self, x: float, y: float, width: float, height: float) -> None: ...
    # Skipped Contains due to it being static, abstract and generic.

    Contains : Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, point: Vector2) -> bool:...
        @typing.overload
        def __call__(self, point: Vector3) -> bool:...
        @typing.overload
        def __call__(self, point: Vector3, allowInverse: bool) -> bool:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Rect) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped Overlaps due to it being static, abstract and generic.

    Overlaps : Overlaps_MethodGroup
    class Overlaps_MethodGroup:
        @typing.overload
        def __call__(self, other: Rect) -> bool:...
        @typing.overload
        def __call__(self, other: Rect, allowInverse: bool) -> bool:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...



class RectInt(IFormattable, IEquatable_1[RectInt]):
    @typing.overload
    def __init__(self, position: Vector2Int, size: Vector2Int) -> None: ...
    @typing.overload
    def __init__(self, xMin: int, yMin: int, width: int, height: int) -> None: ...
    @property
    def allPositionsWithin(self) -> RectInt.PositionEnumerator: ...
    @property
    def center(self) -> Vector2: ...
    @property
    def height(self) -> int: ...
    @height.setter
    def height(self, value: int) -> int: ...
    @property
    def max(self) -> Vector2Int: ...
    @max.setter
    def max(self, value: Vector2Int) -> Vector2Int: ...
    @property
    def min(self) -> Vector2Int: ...
    @min.setter
    def min(self, value: Vector2Int) -> Vector2Int: ...
    @property
    def position(self) -> Vector2Int: ...
    @position.setter
    def position(self, value: Vector2Int) -> Vector2Int: ...
    @property
    def size(self) -> Vector2Int: ...
    @size.setter
    def size(self, value: Vector2Int) -> Vector2Int: ...
    @property
    def width(self) -> int: ...
    @width.setter
    def width(self, value: int) -> int: ...
    @property
    def x(self) -> int: ...
    @x.setter
    def x(self, value: int) -> int: ...
    @property
    def xMax(self) -> int: ...
    @xMax.setter
    def xMax(self, value: int) -> int: ...
    @property
    def xMin(self) -> int: ...
    @xMin.setter
    def xMin(self, value: int) -> int: ...
    @property
    def y(self) -> int: ...
    @y.setter
    def y(self, value: int) -> int: ...
    @property
    def yMax(self) -> int: ...
    @yMax.setter
    def yMax(self, value: int) -> int: ...
    @property
    def yMin(self) -> int: ...
    @yMin.setter
    def yMin(self, value: int) -> int: ...
    def ClampToBounds(self, bounds: RectInt) -> None: ...
    def Contains(self, position: Vector2Int) -> bool: ...
    def Equals(self, other: RectInt) -> bool: ...
    def Overlaps(self, other: RectInt) -> bool: ...
    def SetMinMax(self, minPosition: Vector2Int, maxPosition: Vector2Int) -> None: ...
    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...


    class PositionEnumerator(IEnumerator_1[Vector2Int]):
        def __init__(self, min: Vector2Int, max: Vector2Int) -> None: ...
        @property
        def Current(self) -> Vector2Int: ...
        def GetEnumerator(self) -> RectInt.PositionEnumerator: ...
        def MoveNext(self) -> bool: ...
        def Reset(self) -> None: ...



class RectOffset(IFormattable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, left: int, right: int, top: int, bottom: int) -> None: ...
    @property
    def bottom(self) -> int: ...
    @bottom.setter
    def bottom(self, value: int) -> int: ...
    @property
    def horizontal(self) -> int: ...
    @property
    def left(self) -> int: ...
    @left.setter
    def left(self, value: int) -> int: ...
    @property
    def right(self) -> int: ...
    @right.setter
    def right(self, value: int) -> int: ...
    @property
    def top(self) -> int: ...
    @top.setter
    def top(self, value: int) -> int: ...
    @property
    def vertical(self) -> int: ...
    def Add(self, rect: Rect) -> Rect: ...
    def Remove(self, rect: Rect) -> Rect: ...
    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...



class RectTransform(Transform):
    def __init__(self) -> None: ...
    @property
    def anchoredPosition(self) -> Vector2: ...
    @anchoredPosition.setter
    def anchoredPosition(self, value: Vector2) -> Vector2: ...
    @property
    def anchoredPosition3D(self) -> Vector3: ...
    @anchoredPosition3D.setter
    def anchoredPosition3D(self, value: Vector3) -> Vector3: ...
    @property
    def anchorMax(self) -> Vector2: ...
    @anchorMax.setter
    def anchorMax(self, value: Vector2) -> Vector2: ...
    @property
    def anchorMin(self) -> Vector2: ...
    @anchorMin.setter
    def anchorMin(self, value: Vector2) -> Vector2: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def childCount(self) -> int: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def drivenByObject(self) -> Object: ...
    @drivenByObject.setter
    def drivenByObject(self, value: Object) -> Object: ...
    @property
    def eulerAngles(self) -> Vector3: ...
    @eulerAngles.setter
    def eulerAngles(self, value: Vector3) -> Vector3: ...
    @property
    def forward(self) -> Vector3: ...
    @forward.setter
    def forward(self, value: Vector3) -> Vector3: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hasChanged(self) -> bool: ...
    @hasChanged.setter
    def hasChanged(self, value: bool) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hierarchyCapacity(self) -> int: ...
    @hierarchyCapacity.setter
    def hierarchyCapacity(self, value: int) -> int: ...
    @property
    def hierarchyCount(self) -> int: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def light(self) -> Component: ...
    @property
    def localEulerAngles(self) -> Vector3: ...
    @localEulerAngles.setter
    def localEulerAngles(self, value: Vector3) -> Vector3: ...
    @property
    def localPosition(self) -> Vector3: ...
    @localPosition.setter
    def localPosition(self, value: Vector3) -> Vector3: ...
    @property
    def localRotation(self) -> Quaternion: ...
    @localRotation.setter
    def localRotation(self, value: Quaternion) -> Quaternion: ...
    @property
    def localScale(self) -> Vector3: ...
    @localScale.setter
    def localScale(self, value: Vector3) -> Vector3: ...
    @property
    def localToWorldMatrix(self) -> Matrix4x4: ...
    @property
    def lossyScale(self) -> Vector3: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def offsetMax(self) -> Vector2: ...
    @offsetMax.setter
    def offsetMax(self, value: Vector2) -> Vector2: ...
    @property
    def offsetMin(self) -> Vector2: ...
    @offsetMin.setter
    def offsetMin(self, value: Vector2) -> Vector2: ...
    @property
    def parent(self) -> Transform: ...
    @parent.setter
    def parent(self, value: Transform) -> Transform: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def pivot(self) -> Vector2: ...
    @pivot.setter
    def pivot(self, value: Vector2) -> Vector2: ...
    @property
    def position(self) -> Vector3: ...
    @position.setter
    def position(self, value: Vector3) -> Vector3: ...
    @property
    def rect(self) -> Rect: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def right(self) -> Vector3: ...
    @right.setter
    def right(self, value: Vector3) -> Vector3: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def root(self) -> Transform: ...
    @property
    def rotation(self) -> Quaternion: ...
    @rotation.setter
    def rotation(self, value: Quaternion) -> Quaternion: ...
    @property
    def sizeDelta(self) -> Vector2: ...
    @sizeDelta.setter
    def sizeDelta(self, value: Vector2) -> Vector2: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def up(self) -> Vector3: ...
    @up.setter
    def up(self, value: Vector3) -> Vector3: ...
    @property
    def worldToLocalMatrix(self) -> Matrix4x4: ...
    def ForceUpdateRectTransforms(self) -> None: ...
    def GetLocalCorners(self, fourCornersArray: Array_1[Vector3]) -> None: ...
    def GetWorldCorners(self, fourCornersArray: Array_1[Vector3]) -> None: ...
    def SetInsetAndSizeFromParentEdge(self, edge: RectTransform.Edge, inset: float, size: float) -> None: ...
    def SetSizeWithCurrentAnchors(self, axis: RectTransform.Axis, size: float) -> None: ...

    class Axis(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Horizontal : RectTransform.Axis # 0
        Vertical : RectTransform.Axis # 1


    class Edge(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Left : RectTransform.Edge # 0
        Right : RectTransform.Edge # 1
        Top : RectTransform.Edge # 2
        Bottom : RectTransform.Edge # 3


    class ReapplyDrivenProperties(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, driven: RectTransform, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, driven: RectTransform) -> None: ...



class RectTransformUtility:
    @staticmethod
    def FlipLayoutAxes(rect: RectTransform, keepPositioning: bool, recursive: bool) -> None: ...
    @staticmethod
    def FlipLayoutOnAxis(rect: RectTransform, axis: int, keepPositioning: bool, recursive: bool) -> None: ...
    @staticmethod
    def PixelAdjustPoint(point: Vector2, elementTransform: Transform, canvas: Canvas) -> Vector2: ...
    @staticmethod
    def PixelAdjustRect(rectTransform: RectTransform, canvas: Canvas) -> Rect: ...
    @staticmethod
    def ScreenPointToLocalPointInRectangle(rect: RectTransform, screenPoint: Vector2, cam: Camera, localPoint: clr.Reference[Vector2]) -> bool: ...
    @staticmethod
    def ScreenPointToRay(cam: Camera, screenPos: Vector2) -> Ray: ...
    @staticmethod
    def ScreenPointToWorldPointInRectangle(rect: RectTransform, screenPoint: Vector2, cam: Camera, worldPoint: clr.Reference[Vector3]) -> bool: ...
    @staticmethod
    def WorldToScreenPoint(cam: Camera, worldPoint: Vector3) -> Vector2: ...
    # Skipped CalculateRelativeRectTransformBounds due to it being static, abstract and generic.

    CalculateRelativeRectTransformBounds : CalculateRelativeRectTransformBounds_MethodGroup
    class CalculateRelativeRectTransformBounds_MethodGroup:
        @typing.overload
        def __call__(self, trans: Transform) -> Bounds:...
        @typing.overload
        def __call__(self, root: Transform, child: Transform) -> Bounds:...

    # Skipped RectangleContainsScreenPoint due to it being static, abstract and generic.

    RectangleContainsScreenPoint : RectangleContainsScreenPoint_MethodGroup
    class RectangleContainsScreenPoint_MethodGroup:
        @typing.overload
        def __call__(self, rect: RectTransform, screenPoint: Vector2) -> bool:...
        @typing.overload
        def __call__(self, rect: RectTransform, screenPoint: Vector2, cam: Camera) -> bool:...
        @typing.overload
        def __call__(self, rect: RectTransform, screenPoint: Vector2, cam: Camera, offset: Vector4) -> bool:...



class ReflectionProbe(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def backgroundColor(self) -> Color: ...
    @backgroundColor.setter
    def backgroundColor(self, value: Color) -> Color: ...
    @property
    def bakedTexture(self) -> Texture: ...
    @bakedTexture.setter
    def bakedTexture(self, value: Texture) -> Texture: ...
    @property
    def blendDistance(self) -> float: ...
    @blendDistance.setter
    def blendDistance(self, value: float) -> float: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def boxProjection(self) -> bool: ...
    @boxProjection.setter
    def boxProjection(self, value: bool) -> bool: ...
    @property
    def camera(self) -> Component: ...
    @property
    def center(self) -> Vector3: ...
    @center.setter
    def center(self, value: Vector3) -> Vector3: ...
    @property
    def clearFlags(self) -> ReflectionProbeClearFlags: ...
    @clearFlags.setter
    def clearFlags(self, value: ReflectionProbeClearFlags) -> ReflectionProbeClearFlags: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def cullingMask(self) -> int: ...
    @cullingMask.setter
    def cullingMask(self, value: int) -> int: ...
    @property
    def customBakedTexture(self) -> Texture: ...
    @customBakedTexture.setter
    def customBakedTexture(self, value: Texture) -> Texture: ...
    @classmethod
    @property
    def defaultTexture(cls) -> Texture: ...
    @classmethod
    @property
    def defaultTextureHDRDecodeValues(cls) -> Vector4: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def farClipPlane(self) -> float: ...
    @farClipPlane.setter
    def farClipPlane(self, value: float) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hdr(self) -> bool: ...
    @hdr.setter
    def hdr(self, value: bool) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def importance(self) -> int: ...
    @importance.setter
    def importance(self, value: int) -> int: ...
    @property
    def intensity(self) -> float: ...
    @intensity.setter
    def intensity(self, value: float) -> float: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @classmethod
    @property
    def maxBakedCubemapResolution(cls) -> int: ...
    @classmethod
    @property
    def minBakedCubemapResolution(cls) -> int: ...
    @property
    def mode(self) -> ReflectionProbeMode: ...
    @mode.setter
    def mode(self, value: ReflectionProbeMode) -> ReflectionProbeMode: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def nearClipPlane(self) -> float: ...
    @nearClipPlane.setter
    def nearClipPlane(self, value: float) -> float: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def realtimeTexture(self) -> RenderTexture: ...
    @realtimeTexture.setter
    def realtimeTexture(self, value: RenderTexture) -> RenderTexture: ...
    @property
    def refreshMode(self) -> ReflectionProbeRefreshMode: ...
    @refreshMode.setter
    def refreshMode(self, value: ReflectionProbeRefreshMode) -> ReflectionProbeRefreshMode: ...
    @property
    def renderDynamicObjects(self) -> bool: ...
    @renderDynamicObjects.setter
    def renderDynamicObjects(self, value: bool) -> bool: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def resolution(self) -> int: ...
    @resolution.setter
    def resolution(self, value: int) -> int: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def shadowDistance(self) -> float: ...
    @shadowDistance.setter
    def shadowDistance(self, value: float) -> float: ...
    @property
    def size(self) -> Vector3: ...
    @size.setter
    def size(self, value: Vector3) -> Vector3: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def texture(self) -> Texture: ...
    @property
    def textureHDRDecodeValues(self) -> Vector4: ...
    @property
    def timeSlicingMode(self) -> ReflectionProbeTimeSlicingMode: ...
    @timeSlicingMode.setter
    def timeSlicingMode(self, value: ReflectionProbeTimeSlicingMode) -> ReflectionProbeTimeSlicingMode: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def type(self) -> ReflectionProbeType: ...
    @type.setter
    def type(self, value: ReflectionProbeType) -> ReflectionProbeType: ...
    @staticmethod
    def BlendCubemap(src: Texture, dst: Texture, blend: float, target: RenderTexture) -> bool: ...
    def IsFinishedRendering(self, renderId: int) -> bool: ...
    def Reset(self) -> None: ...
    @staticmethod
    def UpdateCachedState() -> None: ...
    # Skipped RenderProbe due to it being static, abstract and generic.

    RenderProbe : RenderProbe_MethodGroup
    class RenderProbe_MethodGroup:
        @typing.overload
        def __call__(self) -> int:...
        @typing.overload
        def __call__(self, targetTexture: RenderTexture) -> int:...


    class ReflectionProbeEvent(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        ReflectionProbeAdded : ReflectionProbe.ReflectionProbeEvent # 0
        ReflectionProbeRemoved : ReflectionProbe.ReflectionProbeEvent # 1



class RefreshRate(IComparable_1[RefreshRate], IEquatable_1[RefreshRate]):
    denominator : int
    numerator : int
    @property
    def value(self) -> float: ...
    def CompareTo(self, other: RefreshRate) -> int: ...
    def Equals(self, other: RefreshRate) -> bool: ...
    def ToString(self) -> str: ...


class RelativeJoint2D(Joint2D):
    def __init__(self) -> None: ...
    @property
    def angularOffset(self) -> float: ...
    @angularOffset.setter
    def angularOffset(self, value: float) -> float: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoConfigureOffset(self) -> bool: ...
    @autoConfigureOffset.setter
    def autoConfigureOffset(self, value: bool) -> bool: ...
    @property
    def breakAction(self) -> JointBreakAction2D: ...
    @breakAction.setter
    def breakAction(self, value: JointBreakAction2D) -> JointBreakAction2D: ...
    @property
    def breakForce(self) -> float: ...
    @breakForce.setter
    def breakForce(self, value: float) -> float: ...
    @property
    def breakTorque(self) -> float: ...
    @breakTorque.setter
    def breakTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collideConnected(self) -> bool: ...
    @collideConnected.setter
    def collideConnected(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def connectedBody(self) -> Rigidbody2D: ...
    @connectedBody.setter
    def connectedBody(self, value: Rigidbody2D) -> Rigidbody2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def correctionScale(self) -> float: ...
    @correctionScale.setter
    def correctionScale(self, value: float) -> float: ...
    @property
    def enableCollision(self) -> bool: ...
    @enableCollision.setter
    def enableCollision(self, value: bool) -> bool: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def linearOffset(self) -> Vector2: ...
    @linearOffset.setter
    def linearOffset(self, value: Vector2) -> Vector2: ...
    @property
    def maxForce(self) -> float: ...
    @maxForce.setter
    def maxForce(self, value: float) -> float: ...
    @property
    def maxTorque(self) -> float: ...
    @maxTorque.setter
    def maxTorque(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def reactionForce(self) -> Vector2: ...
    @property
    def reactionTorque(self) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def target(self) -> Vector2: ...
    @property
    def transform(self) -> Transform: ...


class RemoteConfigSettings(IDisposable):
    def __init__(self, configKey: str) -> None: ...
    @staticmethod
    def AddSessionTag(tag: str) -> None: ...
    def Dispose(self) -> None: ...
    def ForceUpdate(self) -> None: ...
    def GetCount(self) -> int: ...
    def GetDictionary(self, key: str = ...) -> IDictionary_2[str, typing.Any]: ...
    def GetKeys(self) -> Array_1[str]: ...
    def HasKey(self, key: str) -> bool: ...
    @staticmethod
    def QueueConfig(name: str, param: typing.Any, ver: int = ..., prefix: str = ...) -> bool: ...
    @staticmethod
    def SendDeviceInfoInConfigRequest() -> bool: ...
    def WasLastUpdatedFromServer(self) -> bool: ...
    # Skipped GetBool due to it being static, abstract and generic.

    GetBool : GetBool_MethodGroup
    class GetBool_MethodGroup:
        @typing.overload
        def __call__(self, key: str) -> bool:...
        @typing.overload
        def __call__(self, key: str, defaultValue: bool) -> bool:...

    # Skipped GetFloat due to it being static, abstract and generic.

    GetFloat : GetFloat_MethodGroup
    class GetFloat_MethodGroup:
        @typing.overload
        def __call__(self, key: str) -> float:...
        @typing.overload
        def __call__(self, key: str, defaultValue: float) -> float:...

    # Skipped GetInt due to it being static, abstract and generic.

    GetInt : GetInt_MethodGroup
    class GetInt_MethodGroup:
        @typing.overload
        def __call__(self, key: str) -> int:...
        @typing.overload
        def __call__(self, key: str, defaultValue: int) -> int:...

    # Skipped GetLong due to it being static, abstract and generic.

    GetLong : GetLong_MethodGroup
    class GetLong_MethodGroup:
        @typing.overload
        def __call__(self, key: str) -> int:...
        @typing.overload
        def __call__(self, key: str, defaultValue: int) -> int:...

    # Skipped GetObject due to it being static, abstract and generic.

    GetObject : GetObject_MethodGroup
    class GetObject_MethodGroup:
        def __getitem__(self, t:typing.Type[GetObject_1_T1]) -> GetObject_1[GetObject_1_T1]: ...

        GetObject_1_T1 = typing.TypeVar('GetObject_1_T1')
        class GetObject_1(typing.Generic[GetObject_1_T1]):
            GetObject_1_T = RemoteConfigSettings.GetObject_MethodGroup.GetObject_1_T1
            def __call__(self, key: str = ...) -> GetObject_1_T:...

        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], key: str = ...) -> typing.Any:...
        @typing.overload
        def __call__(self, key: str, defaultValue: typing.Any) -> typing.Any:...

    # Skipped GetString due to it being static, abstract and generic.

    GetString : GetString_MethodGroup
    class GetString_MethodGroup:
        @typing.overload
        def __call__(self, key: str) -> str:...
        @typing.overload
        def __call__(self, key: str, defaultValue: str) -> str:...



class RemoteSettings(abc.ABC):
    @staticmethod
    def CallOnUpdate() -> None: ...
    @staticmethod
    def ForceUpdate() -> None: ...
    @staticmethod
    def GetCount() -> int: ...
    @staticmethod
    def GetDictionary(key: str = ...) -> IDictionary_2[str, typing.Any]: ...
    @staticmethod
    def GetKeys() -> Array_1[str]: ...
    @staticmethod
    def HasKey(key: str) -> bool: ...
    @staticmethod
    def WasLastUpdatedFromServer() -> bool: ...
    # Skipped GetBool due to it being static, abstract and generic.

    GetBool : GetBool_MethodGroup
    class GetBool_MethodGroup:
        @typing.overload
        def __call__(self, key: str) -> bool:...
        @typing.overload
        def __call__(self, key: str, defaultValue: bool) -> bool:...

    # Skipped GetFloat due to it being static, abstract and generic.

    GetFloat : GetFloat_MethodGroup
    class GetFloat_MethodGroup:
        @typing.overload
        def __call__(self, key: str) -> float:...
        @typing.overload
        def __call__(self, key: str, defaultValue: float) -> float:...

    # Skipped GetInt due to it being static, abstract and generic.

    GetInt : GetInt_MethodGroup
    class GetInt_MethodGroup:
        @typing.overload
        def __call__(self, key: str) -> int:...
        @typing.overload
        def __call__(self, key: str, defaultValue: int) -> int:...

    # Skipped GetLong due to it being static, abstract and generic.

    GetLong : GetLong_MethodGroup
    class GetLong_MethodGroup:
        @typing.overload
        def __call__(self, key: str) -> int:...
        @typing.overload
        def __call__(self, key: str, defaultValue: int) -> int:...

    # Skipped GetObject due to it being static, abstract and generic.

    GetObject : GetObject_MethodGroup
    class GetObject_MethodGroup:
        def __getitem__(self, t:typing.Type[GetObject_1_T1]) -> GetObject_1[GetObject_1_T1]: ...

        GetObject_1_T1 = typing.TypeVar('GetObject_1_T1')
        class GetObject_1(typing.Generic[GetObject_1_T1]):
            GetObject_1_T = RemoteSettings.GetObject_MethodGroup.GetObject_1_T1
            def __call__(self, key: str = ...) -> GetObject_1_T:...

        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], key: str = ...) -> typing.Any:...
        @typing.overload
        def __call__(self, key: str, defaultValue: typing.Any) -> typing.Any:...

    # Skipped GetString due to it being static, abstract and generic.

    GetString : GetString_MethodGroup
    class GetString_MethodGroup:
        @typing.overload
        def __call__(self, key: str) -> str:...
        @typing.overload
        def __call__(self, key: str, defaultValue: str) -> str:...


    class UpdatedEventHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self) -> None: ...



class RenderBuffer:
    def GetNativeRenderBufferPtr(self) -> int: ...


class Renderer(Component):
    def __init__(self) -> None: ...
    @property
    def allowOcclusionWhenDynamic(self) -> bool: ...
    @allowOcclusionWhenDynamic.setter
    def allowOcclusionWhenDynamic(self, value: bool) -> bool: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounds(self) -> Bounds: ...
    @bounds.setter
    def bounds(self, value: Bounds) -> Bounds: ...
    @property
    def camera(self) -> Component: ...
    @property
    def castShadows(self) -> bool: ...
    @castShadows.setter
    def castShadows(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def forceRenderingOff(self) -> bool: ...
    @forceRenderingOff.setter
    def forceRenderingOff(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isPartOfStaticBatch(self) -> bool: ...
    @property
    def isVisible(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def lightmapIndex(self) -> int: ...
    @lightmapIndex.setter
    def lightmapIndex(self, value: int) -> int: ...
    @property
    def lightmapScaleOffset(self) -> Vector4: ...
    @lightmapScaleOffset.setter
    def lightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightmapTilingOffset(self) -> Vector4: ...
    @lightmapTilingOffset.setter
    def lightmapTilingOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightProbeAnchor(self) -> Transform: ...
    @lightProbeAnchor.setter
    def lightProbeAnchor(self, value: Transform) -> Transform: ...
    @property
    def lightProbeProxyVolumeOverride(self) -> GameObject: ...
    @lightProbeProxyVolumeOverride.setter
    def lightProbeProxyVolumeOverride(self, value: GameObject) -> GameObject: ...
    @property
    def lightProbeUsage(self) -> LightProbeUsage: ...
    @lightProbeUsage.setter
    def lightProbeUsage(self, value: LightProbeUsage) -> LightProbeUsage: ...
    @property
    def localBounds(self) -> Bounds: ...
    @localBounds.setter
    def localBounds(self, value: Bounds) -> Bounds: ...
    @property
    def localToWorldMatrix(self) -> Matrix4x4: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> Material: ...
    @property
    def materials(self) -> Array_1[Material]: ...
    @materials.setter
    def materials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def motionVectorGenerationMode(self) -> MotionVectorGenerationMode: ...
    @motionVectorGenerationMode.setter
    def motionVectorGenerationMode(self, value: MotionVectorGenerationMode) -> MotionVectorGenerationMode: ...
    @property
    def motionVectors(self) -> bool: ...
    @motionVectors.setter
    def motionVectors(self, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def probeAnchor(self) -> Transform: ...
    @probeAnchor.setter
    def probeAnchor(self, value: Transform) -> Transform: ...
    @property
    def rayTracingMode(self) -> RayTracingMode: ...
    @rayTracingMode.setter
    def rayTracingMode(self, value: RayTracingMode) -> RayTracingMode: ...
    @property
    def realtimeLightmapIndex(self) -> int: ...
    @realtimeLightmapIndex.setter
    def realtimeLightmapIndex(self, value: int) -> int: ...
    @property
    def realtimeLightmapScaleOffset(self) -> Vector4: ...
    @realtimeLightmapScaleOffset.setter
    def realtimeLightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def receiveShadows(self) -> bool: ...
    @receiveShadows.setter
    def receiveShadows(self, value: bool) -> bool: ...
    @property
    def reflectionProbeUsage(self) -> ReflectionProbeUsage: ...
    @reflectionProbeUsage.setter
    def reflectionProbeUsage(self, value: ReflectionProbeUsage) -> ReflectionProbeUsage: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rendererPriority(self) -> int: ...
    @rendererPriority.setter
    def rendererPriority(self, value: int) -> int: ...
    @property
    def renderingLayerMask(self) -> int: ...
    @renderingLayerMask.setter
    def renderingLayerMask(self, value: int) -> int: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def shadowCastingMode(self) -> ShadowCastingMode: ...
    @shadowCastingMode.setter
    def shadowCastingMode(self, value: ShadowCastingMode) -> ShadowCastingMode: ...
    @property
    def sharedMaterial(self) -> Material: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: Material) -> Material: ...
    @property
    def sharedMaterials(self) -> Array_1[Material]: ...
    @sharedMaterials.setter
    def sharedMaterials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def sortingLayerID(self) -> int: ...
    @sortingLayerID.setter
    def sortingLayerID(self, value: int) -> int: ...
    @property
    def sortingLayerName(self) -> str: ...
    @sortingLayerName.setter
    def sortingLayerName(self, value: str) -> str: ...
    @property
    def sortingOrder(self) -> int: ...
    @sortingOrder.setter
    def sortingOrder(self, value: int) -> int: ...
    @property
    def staticShadowCaster(self) -> bool: ...
    @staticShadowCaster.setter
    def staticShadowCaster(self, value: bool) -> bool: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useLightProbes(self) -> bool: ...
    @useLightProbes.setter
    def useLightProbes(self, value: bool) -> bool: ...
    @property
    def worldToLocalMatrix(self) -> Matrix4x4: ...
    def GetClosestReflectionProbes(self, result: List_1[ReflectionProbeBlendInfo]) -> None: ...
    def GetMaterials(self, m: List_1[Material]) -> None: ...
    def GetSharedMaterials(self, m: List_1[Material]) -> None: ...
    def HasPropertyBlock(self) -> bool: ...
    def ResetBounds(self) -> None: ...
    def ResetLocalBounds(self) -> None: ...
    def SetMaterials(self, materials: List_1[Material]) -> None: ...
    def SetSharedMaterials(self, materials: List_1[Material]) -> None: ...
    # Skipped GetPropertyBlock due to it being static, abstract and generic.

    GetPropertyBlock : GetPropertyBlock_MethodGroup
    class GetPropertyBlock_MethodGroup:
        @typing.overload
        def __call__(self, properties: MaterialPropertyBlock) -> None:...
        @typing.overload
        def __call__(self, properties: MaterialPropertyBlock, materialIndex: int) -> None:...

    # Skipped SetPropertyBlock due to it being static, abstract and generic.

    SetPropertyBlock : SetPropertyBlock_MethodGroup
    class SetPropertyBlock_MethodGroup:
        @typing.overload
        def __call__(self, properties: MaterialPropertyBlock) -> None:...
        @typing.overload
        def __call__(self, properties: MaterialPropertyBlock, materialIndex: int) -> None:...



class RendererExtensions(abc.ABC):
    @staticmethod
    def UpdateGIMaterials(renderer: Renderer) -> None: ...


class RenderingPath(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    VertexLit : RenderingPath # 0
    Forward : RenderingPath # 1
    DeferredLighting : RenderingPath # 2
    DeferredShading : RenderingPath # 3
    UsePlayerSettings : RenderingPath # -1


class RenderMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    ScreenSpaceOverlay : RenderMode # 0
    ScreenSpaceCamera : RenderMode # 1
    WorldSpace : RenderMode # 2


class RenderParams:
    def __init__(self, mat: Material) -> None: ...
    @property
    def camera(self) -> Camera: ...
    @camera.setter
    def camera(self, value: Camera) -> Camera: ...
    @property
    def layer(self) -> int: ...
    @layer.setter
    def layer(self, value: int) -> int: ...
    @property
    def lightProbeProxyVolume(self) -> LightProbeProxyVolume: ...
    @lightProbeProxyVolume.setter
    def lightProbeProxyVolume(self, value: LightProbeProxyVolume) -> LightProbeProxyVolume: ...
    @property
    def lightProbeUsage(self) -> LightProbeUsage: ...
    @lightProbeUsage.setter
    def lightProbeUsage(self, value: LightProbeUsage) -> LightProbeUsage: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> Material: ...
    @property
    def matProps(self) -> MaterialPropertyBlock: ...
    @matProps.setter
    def matProps(self, value: MaterialPropertyBlock) -> MaterialPropertyBlock: ...
    @property
    def motionVectorMode(self) -> MotionVectorGenerationMode: ...
    @motionVectorMode.setter
    def motionVectorMode(self, value: MotionVectorGenerationMode) -> MotionVectorGenerationMode: ...
    @property
    def receiveShadows(self) -> bool: ...
    @receiveShadows.setter
    def receiveShadows(self, value: bool) -> bool: ...
    @property
    def reflectionProbeUsage(self) -> ReflectionProbeUsage: ...
    @reflectionProbeUsage.setter
    def reflectionProbeUsage(self, value: ReflectionProbeUsage) -> ReflectionProbeUsage: ...
    @property
    def rendererPriority(self) -> int: ...
    @rendererPriority.setter
    def rendererPriority(self, value: int) -> int: ...
    @property
    def renderingLayerMask(self) -> int: ...
    @renderingLayerMask.setter
    def renderingLayerMask(self, value: int) -> int: ...
    @property
    def shadowCastingMode(self) -> ShadowCastingMode: ...
    @shadowCastingMode.setter
    def shadowCastingMode(self, value: ShadowCastingMode) -> ShadowCastingMode: ...
    @property
    def worldBounds(self) -> Bounds: ...
    @worldBounds.setter
    def worldBounds(self, value: Bounds) -> Bounds: ...


class RenderSettings(Object):
    @classmethod
    @property
    def ambientEquatorColor(cls) -> Color: ...
    @classmethod
    @ambientEquatorColor.setter
    def ambientEquatorColor(cls, value: Color) -> Color: ...
    @classmethod
    @property
    def ambientGroundColor(cls) -> Color: ...
    @classmethod
    @ambientGroundColor.setter
    def ambientGroundColor(cls, value: Color) -> Color: ...
    @classmethod
    @property
    def ambientIntensity(cls) -> float: ...
    @classmethod
    @ambientIntensity.setter
    def ambientIntensity(cls, value: float) -> float: ...
    @classmethod
    @property
    def ambientLight(cls) -> Color: ...
    @classmethod
    @ambientLight.setter
    def ambientLight(cls, value: Color) -> Color: ...
    @classmethod
    @property
    def ambientMode(cls) -> AmbientMode: ...
    @classmethod
    @ambientMode.setter
    def ambientMode(cls, value: AmbientMode) -> AmbientMode: ...
    @classmethod
    @property
    def ambientProbe(cls) -> SphericalHarmonicsL2: ...
    @classmethod
    @ambientProbe.setter
    def ambientProbe(cls, value: SphericalHarmonicsL2) -> SphericalHarmonicsL2: ...
    @classmethod
    @property
    def ambientSkyboxAmount(cls) -> float: ...
    @classmethod
    @ambientSkyboxAmount.setter
    def ambientSkyboxAmount(cls, value: float) -> float: ...
    @classmethod
    @property
    def ambientSkyColor(cls) -> Color: ...
    @classmethod
    @ambientSkyColor.setter
    def ambientSkyColor(cls, value: Color) -> Color: ...
    @classmethod
    @property
    def customReflection(cls) -> Cubemap: ...
    @classmethod
    @customReflection.setter
    def customReflection(cls, value: Cubemap) -> Cubemap: ...
    @classmethod
    @property
    def customReflectionTexture(cls) -> Texture: ...
    @classmethod
    @customReflectionTexture.setter
    def customReflectionTexture(cls, value: Texture) -> Texture: ...
    @classmethod
    @property
    def defaultReflectionMode(cls) -> DefaultReflectionMode: ...
    @classmethod
    @defaultReflectionMode.setter
    def defaultReflectionMode(cls, value: DefaultReflectionMode) -> DefaultReflectionMode: ...
    @classmethod
    @property
    def defaultReflectionResolution(cls) -> int: ...
    @classmethod
    @defaultReflectionResolution.setter
    def defaultReflectionResolution(cls, value: int) -> int: ...
    @classmethod
    @property
    def flareFadeSpeed(cls) -> float: ...
    @classmethod
    @flareFadeSpeed.setter
    def flareFadeSpeed(cls, value: float) -> float: ...
    @classmethod
    @property
    def flareStrength(cls) -> float: ...
    @classmethod
    @flareStrength.setter
    def flareStrength(cls, value: float) -> float: ...
    @classmethod
    @property
    def fog(cls) -> bool: ...
    @classmethod
    @fog.setter
    def fog(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def fogColor(cls) -> Color: ...
    @classmethod
    @fogColor.setter
    def fogColor(cls, value: Color) -> Color: ...
    @classmethod
    @property
    def fogDensity(cls) -> float: ...
    @classmethod
    @fogDensity.setter
    def fogDensity(cls, value: float) -> float: ...
    @classmethod
    @property
    def fogEndDistance(cls) -> float: ...
    @classmethod
    @fogEndDistance.setter
    def fogEndDistance(cls, value: float) -> float: ...
    @classmethod
    @property
    def fogMode(cls) -> FogMode: ...
    @classmethod
    @fogMode.setter
    def fogMode(cls, value: FogMode) -> FogMode: ...
    @classmethod
    @property
    def fogStartDistance(cls) -> float: ...
    @classmethod
    @fogStartDistance.setter
    def fogStartDistance(cls, value: float) -> float: ...
    @classmethod
    @property
    def haloStrength(cls) -> float: ...
    @classmethod
    @haloStrength.setter
    def haloStrength(cls, value: float) -> float: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @classmethod
    @property
    def reflectionBounces(cls) -> int: ...
    @classmethod
    @reflectionBounces.setter
    def reflectionBounces(cls, value: int) -> int: ...
    @classmethod
    @property
    def reflectionIntensity(cls) -> float: ...
    @classmethod
    @reflectionIntensity.setter
    def reflectionIntensity(cls, value: float) -> float: ...
    @classmethod
    @property
    def skybox(cls) -> Material: ...
    @classmethod
    @skybox.setter
    def skybox(cls, value: Material) -> Material: ...
    @classmethod
    @property
    def subtractiveShadowColor(cls) -> Color: ...
    @classmethod
    @subtractiveShadowColor.setter
    def subtractiveShadowColor(cls, value: Color) -> Color: ...
    @classmethod
    @property
    def sun(cls) -> Light: ...
    @classmethod
    @sun.setter
    def sun(cls, value: Light) -> Light: ...


class RenderTargetSetup:
    @typing.overload
    def __init__(self, color: RenderBuffer, depth: RenderBuffer) -> None: ...
    @typing.overload
    def __init__(self, color: Array_1[RenderBuffer], depth: RenderBuffer) -> None: ...
    @typing.overload
    def __init__(self, color: Array_1[RenderBuffer], depth: RenderBuffer, mip: int, face: CubemapFace) -> None: ...
    @typing.overload
    def __init__(self, color: Array_1[RenderBuffer], depth: RenderBuffer, mip: int, face: CubemapFace, colorLoad: Array_1[RenderBufferLoadAction], colorStore: Array_1[RenderBufferStoreAction], depthLoad: RenderBufferLoadAction, depthStore: RenderBufferStoreAction) -> None: ...
    @typing.overload
    def __init__(self, color: RenderBuffer, depth: RenderBuffer, mipLevel: int) -> None: ...
    @typing.overload
    def __init__(self, color: Array_1[RenderBuffer], depth: RenderBuffer, mipLevel: int) -> None: ...
    @typing.overload
    def __init__(self, color: RenderBuffer, depth: RenderBuffer, mipLevel: int, face: CubemapFace) -> None: ...
    @typing.overload
    def __init__(self, color: RenderBuffer, depth: RenderBuffer, mipLevel: int, face: CubemapFace, depthSlice: int) -> None: ...
    color : Array_1[RenderBuffer]
    colorLoad : Array_1[RenderBufferLoadAction]
    colorStore : Array_1[RenderBufferStoreAction]
    cubemapFace : CubemapFace
    depth : RenderBuffer
    depthLoad : RenderBufferLoadAction
    depthSlice : int
    depthStore : RenderBufferStoreAction
    mipLevel : int


class RenderTexture(Texture):
    @typing.overload
    def __init__(self, desc: RenderTextureDescriptor) -> None: ...
    @typing.overload
    def __init__(self, textureToCopy: RenderTexture) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat, mipCount: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, format: DefaultFormat) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, format: GraphicsFormat) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, format: RenderTextureFormat) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, format: GraphicsFormat, mipCount: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, format: RenderTextureFormat, mipCount: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, format: RenderTextureFormat, readWrite: RenderTextureReadWrite) -> None: ...
    @classmethod
    @property
    def active(cls) -> RenderTexture: ...
    @classmethod
    @active.setter
    def active(cls, value: RenderTexture) -> RenderTexture: ...
    @property
    def anisoLevel(self) -> int: ...
    @anisoLevel.setter
    def anisoLevel(self, value: int) -> int: ...
    @property
    def antiAliasing(self) -> int: ...
    @antiAliasing.setter
    def antiAliasing(self, value: int) -> int: ...
    @property
    def autoGenerateMips(self) -> bool: ...
    @autoGenerateMips.setter
    def autoGenerateMips(self, value: bool) -> bool: ...
    @property
    def bindTextureMS(self) -> bool: ...
    @bindTextureMS.setter
    def bindTextureMS(self, value: bool) -> bool: ...
    @property
    def colorBuffer(self) -> RenderBuffer: ...
    @property
    def depth(self) -> int: ...
    @depth.setter
    def depth(self, value: int) -> int: ...
    @property
    def depthBuffer(self) -> RenderBuffer: ...
    @property
    def depthStencilFormat(self) -> GraphicsFormat: ...
    @depthStencilFormat.setter
    def depthStencilFormat(self, value: GraphicsFormat) -> GraphicsFormat: ...
    @property
    def descriptor(self) -> RenderTextureDescriptor: ...
    @descriptor.setter
    def descriptor(self, value: RenderTextureDescriptor) -> RenderTextureDescriptor: ...
    @property
    def dimension(self) -> TextureDimension: ...
    @dimension.setter
    def dimension(self, value: TextureDimension) -> TextureDimension: ...
    @classmethod
    @property
    def enabled(cls) -> bool: ...
    @classmethod
    @enabled.setter
    def enabled(cls, value: bool) -> bool: ...
    @property
    def enableRandomWrite(self) -> bool: ...
    @enableRandomWrite.setter
    def enableRandomWrite(self, value: bool) -> bool: ...
    @property
    def filterMode(self) -> FilterMode: ...
    @filterMode.setter
    def filterMode(self, value: FilterMode) -> FilterMode: ...
    @property
    def format(self) -> RenderTextureFormat: ...
    @format.setter
    def format(self, value: RenderTextureFormat) -> RenderTextureFormat: ...
    @property
    def generateMips(self) -> bool: ...
    @generateMips.setter
    def generateMips(self, value: bool) -> bool: ...
    @property
    def graphicsFormat(self) -> GraphicsFormat: ...
    @graphicsFormat.setter
    def graphicsFormat(self, value: GraphicsFormat) -> GraphicsFormat: ...
    @property
    def height(self) -> int: ...
    @height.setter
    def height(self, value: int) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def imageContentsHash(self) -> Hash128: ...
    @imageContentsHash.setter
    def imageContentsHash(self, value: Hash128) -> Hash128: ...
    @property
    def isCubemap(self) -> bool: ...
    @isCubemap.setter
    def isCubemap(self, value: bool) -> bool: ...
    @property
    def isDataSRGB(self) -> bool: ...
    @property
    def isPowerOfTwo(self) -> bool: ...
    @isPowerOfTwo.setter
    def isPowerOfTwo(self, value: bool) -> bool: ...
    @property
    def isReadable(self) -> bool: ...
    @property
    def isVolume(self) -> bool: ...
    @isVolume.setter
    def isVolume(self, value: bool) -> bool: ...
    @property
    def memorylessMode(self) -> RenderTextureMemoryless: ...
    @memorylessMode.setter
    def memorylessMode(self, value: RenderTextureMemoryless) -> RenderTextureMemoryless: ...
    @property
    def mipMapBias(self) -> float: ...
    @mipMapBias.setter
    def mipMapBias(self, value: float) -> float: ...
    @property
    def mipmapCount(self) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def sRGB(self) -> bool: ...
    @property
    def stencilFormat(self) -> GraphicsFormat: ...
    @stencilFormat.setter
    def stencilFormat(self, value: GraphicsFormat) -> GraphicsFormat: ...
    @property
    def texelSize(self) -> Vector2: ...
    @property
    def updateCount(self) -> int: ...
    @property
    def useDynamicScale(self) -> bool: ...
    @useDynamicScale.setter
    def useDynamicScale(self, value: bool) -> bool: ...
    @property
    def useMipMap(self) -> bool: ...
    @useMipMap.setter
    def useMipMap(self, value: bool) -> bool: ...
    @property
    def volumeDepth(self) -> int: ...
    @volumeDepth.setter
    def volumeDepth(self, value: int) -> int: ...
    @property
    def vrUsage(self) -> VRTextureUsage: ...
    @vrUsage.setter
    def vrUsage(self, value: VRTextureUsage) -> VRTextureUsage: ...
    @property
    def width(self) -> int: ...
    @width.setter
    def width(self, value: int) -> int: ...
    @property
    def wrapMode(self) -> TextureWrapMode: ...
    @wrapMode.setter
    def wrapMode(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeU(self) -> TextureWrapMode: ...
    @wrapModeU.setter
    def wrapModeU(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeV(self) -> TextureWrapMode: ...
    @wrapModeV.setter
    def wrapModeV(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeW(self) -> TextureWrapMode: ...
    @wrapModeW.setter
    def wrapModeW(self, value: TextureWrapMode) -> TextureWrapMode: ...
    def ConvertToEquirect(self, equirect: RenderTexture, eye: Camera.MonoOrStereoscopicEye = ...) -> None: ...
    def Create(self) -> bool: ...
    def GenerateMips(self) -> None: ...
    def GetNativeDepthBufferPtr(self) -> int: ...
    def GetTexelOffset(self) -> Vector2: ...
    def IsCreated(self) -> bool: ...
    def MarkRestoreExpected(self) -> None: ...
    def Release(self) -> None: ...
    @staticmethod
    def ReleaseTemporary(temp: RenderTexture) -> None: ...
    def SetBorderColor(self, color: Color) -> None: ...
    def SetGlobalShaderProperty(self, propertyName: str) -> None: ...
    @staticmethod
    def SupportsStencil(rt: RenderTexture) -> bool: ...
    # Skipped DiscardContents due to it being static, abstract and generic.

    DiscardContents : DiscardContents_MethodGroup
    class DiscardContents_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, discardColor: bool, discardDepth: bool) -> None:...

    # Skipped GetTemporary due to it being static, abstract and generic.

    GetTemporary : GetTemporary_MethodGroup
    class GetTemporary_MethodGroup:
        @typing.overload
        def __call__(self, desc: RenderTextureDescriptor) -> RenderTexture:...
        @typing.overload
        def __call__(self, width: int, height: int) -> RenderTexture:...
        @typing.overload
        def __call__(self, width: int, height: int, depthBuffer: int) -> RenderTexture:...
        @typing.overload
        def __call__(self, width: int, height: int, depthBuffer: int, format: GraphicsFormat) -> RenderTexture:...
        @typing.overload
        def __call__(self, width: int, height: int, depthBuffer: int, format: RenderTextureFormat) -> RenderTexture:...
        @typing.overload
        def __call__(self, width: int, height: int, depthBuffer: int, format: GraphicsFormat, antiAliasing: int) -> RenderTexture:...
        @typing.overload
        def __call__(self, width: int, height: int, depthBuffer: int, format: RenderTextureFormat, readWrite: RenderTextureReadWrite) -> RenderTexture:...
        @typing.overload
        def __call__(self, width: int, height: int, depthBuffer: int, format: GraphicsFormat, antiAliasing: int, memorylessMode: RenderTextureMemoryless) -> RenderTexture:...
        @typing.overload
        def __call__(self, width: int, height: int, depthBuffer: int, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: int) -> RenderTexture:...
        @typing.overload
        def __call__(self, width: int, height: int, depthBuffer: int, format: GraphicsFormat, antiAliasing: int, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage) -> RenderTexture:...
        @typing.overload
        def __call__(self, width: int, height: int, depthBuffer: int, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: int, memorylessMode: RenderTextureMemoryless) -> RenderTexture:...
        @typing.overload
        def __call__(self, width: int, height: int, depthBuffer: int, format: GraphicsFormat, antiAliasing: int, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage, useDynamicScale: bool) -> RenderTexture:...
        @typing.overload
        def __call__(self, width: int, height: int, depthBuffer: int, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: int, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage) -> RenderTexture:...
        @typing.overload
        def __call__(self, width: int, height: int, depthBuffer: int, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: int, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage, useDynamicScale: bool) -> RenderTexture:...

    # Skipped ResolveAntiAliasedSurface due to it being static, abstract and generic.

    ResolveAntiAliasedSurface : ResolveAntiAliasedSurface_MethodGroup
    class ResolveAntiAliasedSurface_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, target: RenderTexture) -> None:...



class RenderTextureCreationFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    MipMap : RenderTextureCreationFlags # 1
    AutoGenerateMips : RenderTextureCreationFlags # 2
    SRGB : RenderTextureCreationFlags # 4
    EyeTexture : RenderTextureCreationFlags # 8
    EnableRandomWrite : RenderTextureCreationFlags # 16
    CreatedFromScript : RenderTextureCreationFlags # 32
    AllowVerticalFlip : RenderTextureCreationFlags # 128
    NoResolvedColorSurface : RenderTextureCreationFlags # 256
    DynamicallyScalable : RenderTextureCreationFlags # 1024
    BindMS : RenderTextureCreationFlags # 2048


class RenderTextureDescriptor:
    @typing.overload
    def __init__(self, width: int, height: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, colorFormat: RenderTextureFormat) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, colorFormat: RenderTextureFormat, depthBufferBits: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, colorFormat: GraphicsFormat, depthBufferBits: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, colorFormat: RenderTextureFormat, depthBufferBits: int, mipCount: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, colorFormat: GraphicsFormat, depthBufferBits: int, mipCount: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, colorFormat: RenderTextureFormat, depthBufferBits: int, mipCount: int, readWrite: RenderTextureReadWrite) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat, mipCount: int) -> None: ...
    @property
    def autoGenerateMips(self) -> bool: ...
    @autoGenerateMips.setter
    def autoGenerateMips(self, value: bool) -> bool: ...
    @property
    def bindMS(self) -> bool: ...
    @bindMS.setter
    def bindMS(self, value: bool) -> bool: ...
    @property
    def colorFormat(self) -> RenderTextureFormat: ...
    @colorFormat.setter
    def colorFormat(self, value: RenderTextureFormat) -> RenderTextureFormat: ...
    @property
    def depthBufferBits(self) -> int: ...
    @depthBufferBits.setter
    def depthBufferBits(self, value: int) -> int: ...
    @property
    def depthStencilFormat(self) -> GraphicsFormat: ...
    @depthStencilFormat.setter
    def depthStencilFormat(self, value: GraphicsFormat) -> GraphicsFormat: ...
    @property
    def dimension(self) -> TextureDimension: ...
    @dimension.setter
    def dimension(self, value: TextureDimension) -> TextureDimension: ...
    @property
    def enableRandomWrite(self) -> bool: ...
    @enableRandomWrite.setter
    def enableRandomWrite(self, value: bool) -> bool: ...
    @property
    def flags(self) -> RenderTextureCreationFlags: ...
    @property
    def graphicsFormat(self) -> GraphicsFormat: ...
    @graphicsFormat.setter
    def graphicsFormat(self, value: GraphicsFormat) -> GraphicsFormat: ...
    @property
    def height(self) -> int: ...
    @height.setter
    def height(self, value: int) -> int: ...
    @property
    def memoryless(self) -> RenderTextureMemoryless: ...
    @memoryless.setter
    def memoryless(self, value: RenderTextureMemoryless) -> RenderTextureMemoryless: ...
    @property
    def mipCount(self) -> int: ...
    @mipCount.setter
    def mipCount(self, value: int) -> int: ...
    @property
    def msaaSamples(self) -> int: ...
    @msaaSamples.setter
    def msaaSamples(self, value: int) -> int: ...
    @property
    def shadowSamplingMode(self) -> ShadowSamplingMode: ...
    @shadowSamplingMode.setter
    def shadowSamplingMode(self, value: ShadowSamplingMode) -> ShadowSamplingMode: ...
    @property
    def sRGB(self) -> bool: ...
    @sRGB.setter
    def sRGB(self, value: bool) -> bool: ...
    @property
    def stencilFormat(self) -> GraphicsFormat: ...
    @stencilFormat.setter
    def stencilFormat(self, value: GraphicsFormat) -> GraphicsFormat: ...
    @property
    def useDynamicScale(self) -> bool: ...
    @useDynamicScale.setter
    def useDynamicScale(self, value: bool) -> bool: ...
    @property
    def useMipMap(self) -> bool: ...
    @useMipMap.setter
    def useMipMap(self, value: bool) -> bool: ...
    @property
    def volumeDepth(self) -> int: ...
    @volumeDepth.setter
    def volumeDepth(self, value: int) -> int: ...
    @property
    def vrUsage(self) -> VRTextureUsage: ...
    @vrUsage.setter
    def vrUsage(self, value: VRTextureUsage) -> VRTextureUsage: ...
    @property
    def width(self) -> int: ...
    @width.setter
    def width(self, value: int) -> int: ...


class RenderTextureFormat(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    ARGB32 : RenderTextureFormat # 0
    Depth : RenderTextureFormat # 1
    ARGBHalf : RenderTextureFormat # 2
    Shadowmap : RenderTextureFormat # 3
    RGB565 : RenderTextureFormat # 4
    ARGB4444 : RenderTextureFormat # 5
    ARGB1555 : RenderTextureFormat # 6
    Default : RenderTextureFormat # 7
    ARGB2101010 : RenderTextureFormat # 8
    DefaultHDR : RenderTextureFormat # 9
    ARGB64 : RenderTextureFormat # 10
    ARGBFloat : RenderTextureFormat # 11
    RGFloat : RenderTextureFormat # 12
    RGHalf : RenderTextureFormat # 13
    RFloat : RenderTextureFormat # 14
    RHalf : RenderTextureFormat # 15
    R8 : RenderTextureFormat # 16
    ARGBInt : RenderTextureFormat # 17
    RGInt : RenderTextureFormat # 18
    RInt : RenderTextureFormat # 19
    BGRA32 : RenderTextureFormat # 20
    RGB111110Float : RenderTextureFormat # 22
    RG32 : RenderTextureFormat # 23
    RGBAUShort : RenderTextureFormat # 24
    RG16 : RenderTextureFormat # 25
    BGRA10101010_XR : RenderTextureFormat # 26
    BGR101010_XR : RenderTextureFormat # 27
    R16 : RenderTextureFormat # 28


class RenderTextureMemoryless(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : RenderTextureMemoryless # 0
    Color : RenderTextureMemoryless # 1
    Depth : RenderTextureMemoryless # 2
    MSAA : RenderTextureMemoryless # 4


class RenderTextureReadWrite(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Default : RenderTextureReadWrite # 0
    Linear : RenderTextureReadWrite # 1
    sRGB : RenderTextureReadWrite # 2


class RequireComponent(Attribute):
    @typing.overload
    def __init__(self, requiredComponent: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, requiredComponent: typing.Type[typing.Any], requiredComponent2: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, requiredComponent: typing.Type[typing.Any], requiredComponent2: typing.Type[typing.Any], requiredComponent3: typing.Type[typing.Any]) -> None: ...
    m_Type0 : typing.Type[typing.Any]
    m_Type1 : typing.Type[typing.Any]
    m_Type2 : typing.Type[typing.Any]
    @property
    def TypeId(self) -> typing.Any: ...


class Resolution:
    @property
    def height(self) -> int: ...
    @height.setter
    def height(self, value: int) -> int: ...
    @property
    def refreshRate(self) -> int: ...
    @refreshRate.setter
    def refreshRate(self, value: int) -> int: ...
    @property
    def refreshRateRatio(self) -> RefreshRate: ...
    @refreshRateRatio.setter
    def refreshRateRatio(self, value: RefreshRate) -> RefreshRate: ...
    @property
    def width(self) -> int: ...
    @width.setter
    def width(self, value: int) -> int: ...
    def ToString(self) -> str: ...


class ResourceRequest(AsyncOperation):
    def __init__(self) -> None: ...
    @property
    def allowSceneActivation(self) -> bool: ...
    @allowSceneActivation.setter
    def allowSceneActivation(self, value: bool) -> bool: ...
    @property
    def asset(self) -> Object: ...
    @property
    def isDone(self) -> bool: ...
    @property
    def priority(self) -> int: ...
    @priority.setter
    def priority(self, value: int) -> int: ...
    @property
    def progress(self) -> float: ...


class Resources:
    def __init__(self) -> None: ...
    @staticmethod
    def InstanceIDIsValid(instanceId: int) -> bool: ...
    @staticmethod
    def InstanceIDToObject(instanceID: int) -> Object: ...
    @staticmethod
    def InstanceIDToObjectList(instanceIDs: NativeArray_1[int], objects: List_1[Object]) -> None: ...
    @staticmethod
    def UnloadAsset(assetToUnload: Object) -> None: ...
    @staticmethod
    def UnloadUnusedAssets() -> AsyncOperation: ...
    # Skipped FindObjectsOfTypeAll due to it being static, abstract and generic.

    FindObjectsOfTypeAll : FindObjectsOfTypeAll_MethodGroup
    class FindObjectsOfTypeAll_MethodGroup:
        def __getitem__(self, t:typing.Type[FindObjectsOfTypeAll_1_T1]) -> FindObjectsOfTypeAll_1[FindObjectsOfTypeAll_1_T1]: ...

        FindObjectsOfTypeAll_1_T1 = typing.TypeVar('FindObjectsOfTypeAll_1_T1')
        class FindObjectsOfTypeAll_1(typing.Generic[FindObjectsOfTypeAll_1_T1]):
            FindObjectsOfTypeAll_1_T = Resources.FindObjectsOfTypeAll_MethodGroup.FindObjectsOfTypeAll_1_T1
            def __call__(self) -> Array_1[FindObjectsOfTypeAll_1_T]:...

        def __call__(self, type: typing.Type[typing.Any]) -> Array_1[Object]:...

    # Skipped GetBuiltinResource due to it being static, abstract and generic.

    GetBuiltinResource : GetBuiltinResource_MethodGroup
    class GetBuiltinResource_MethodGroup:
        def __getitem__(self, t:typing.Type[GetBuiltinResource_1_T1]) -> GetBuiltinResource_1[GetBuiltinResource_1_T1]: ...

        GetBuiltinResource_1_T1 = typing.TypeVar('GetBuiltinResource_1_T1')
        class GetBuiltinResource_1(typing.Generic[GetBuiltinResource_1_T1]):
            GetBuiltinResource_1_T = Resources.GetBuiltinResource_MethodGroup.GetBuiltinResource_1_T1
            def __call__(self, path: str) -> GetBuiltinResource_1_T:...

        def __call__(self, type: typing.Type[typing.Any], path: str) -> Object:...

    # Skipped InstanceIDsToValidArray due to it being static, abstract and generic.

    InstanceIDsToValidArray : InstanceIDsToValidArray_MethodGroup
    class InstanceIDsToValidArray_MethodGroup:
        @typing.overload
        def __call__(self, instanceIDs: NativeArray_1[int], validArray: NativeArray_1[bool]) -> None:...
        @typing.overload
        def __call__(self, instanceIDs: ReadOnlySpan_1[int], validArray: Span_1[bool]) -> None:...

    # Skipped Load due to it being static, abstract and generic.

    Load : Load_MethodGroup
    class Load_MethodGroup:
        def __getitem__(self, t:typing.Type[Load_1_T1]) -> Load_1[Load_1_T1]: ...

        Load_1_T1 = typing.TypeVar('Load_1_T1')
        class Load_1(typing.Generic[Load_1_T1]):
            Load_1_T = Resources.Load_MethodGroup.Load_1_T1
            def __call__(self, path: str) -> Load_1_T:...

        @typing.overload
        def __call__(self, path: str) -> Object:...
        @typing.overload
        def __call__(self, path: str, systemTypeInstance: typing.Type[typing.Any]) -> Object:...

    # Skipped LoadAll due to it being static, abstract and generic.

    LoadAll : LoadAll_MethodGroup
    class LoadAll_MethodGroup:
        def __getitem__(self, t:typing.Type[LoadAll_1_T1]) -> LoadAll_1[LoadAll_1_T1]: ...

        LoadAll_1_T1 = typing.TypeVar('LoadAll_1_T1')
        class LoadAll_1(typing.Generic[LoadAll_1_T1]):
            LoadAll_1_T = Resources.LoadAll_MethodGroup.LoadAll_1_T1
            def __call__(self, path: str) -> Array_1[LoadAll_1_T]:...

        @typing.overload
        def __call__(self, path: str) -> Array_1[Object]:...
        @typing.overload
        def __call__(self, path: str, systemTypeInstance: typing.Type[typing.Any]) -> Array_1[Object]:...

    # Skipped LoadAssetAtPath due to it being static, abstract and generic.

    LoadAssetAtPath : LoadAssetAtPath_MethodGroup
    class LoadAssetAtPath_MethodGroup:
        def __getitem__(self, t:typing.Type[LoadAssetAtPath_1_T1]) -> LoadAssetAtPath_1[LoadAssetAtPath_1_T1]: ...

        LoadAssetAtPath_1_T1 = typing.TypeVar('LoadAssetAtPath_1_T1')
        class LoadAssetAtPath_1(typing.Generic[LoadAssetAtPath_1_T1]):
            LoadAssetAtPath_1_T = Resources.LoadAssetAtPath_MethodGroup.LoadAssetAtPath_1_T1
            def __call__(self, assetPath: str) -> LoadAssetAtPath_1_T:...

        def __call__(self, assetPath: str, type: typing.Type[typing.Any]) -> Object:...

    # Skipped LoadAsync due to it being static, abstract and generic.

    LoadAsync : LoadAsync_MethodGroup
    class LoadAsync_MethodGroup:
        def __getitem__(self, t:typing.Type[LoadAsync_1_T1]) -> LoadAsync_1[LoadAsync_1_T1]: ...

        LoadAsync_1_T1 = typing.TypeVar('LoadAsync_1_T1')
        class LoadAsync_1(typing.Generic[LoadAsync_1_T1]):
            LoadAsync_1_T = Resources.LoadAsync_MethodGroup.LoadAsync_1_T1
            def __call__(self, path: str) -> ResourceRequest:...

        @typing.overload
        def __call__(self, path: str) -> ResourceRequest:...
        @typing.overload
        def __call__(self, path: str, type: typing.Type[typing.Any]) -> ResourceRequest:...



class ResourcesAPI:
    @classmethod
    @property
    def overrideAPI(cls) -> ResourcesAPI: ...
    @classmethod
    @overrideAPI.setter
    def overrideAPI(cls, value: ResourcesAPI) -> ResourcesAPI: ...


class Rigidbody(Component):
    def __init__(self) -> None: ...
    @property
    def angularDrag(self) -> float: ...
    @angularDrag.setter
    def angularDrag(self, value: float) -> float: ...
    @property
    def angularVelocity(self) -> Vector3: ...
    @angularVelocity.setter
    def angularVelocity(self, value: Vector3) -> Vector3: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def automaticCenterOfMass(self) -> bool: ...
    @automaticCenterOfMass.setter
    def automaticCenterOfMass(self, value: bool) -> bool: ...
    @property
    def automaticInertiaTensor(self) -> bool: ...
    @automaticInertiaTensor.setter
    def automaticInertiaTensor(self, value: bool) -> bool: ...
    @property
    def camera(self) -> Component: ...
    @property
    def centerOfMass(self) -> Vector3: ...
    @centerOfMass.setter
    def centerOfMass(self, value: Vector3) -> Vector3: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def collisionDetectionMode(self) -> CollisionDetectionMode: ...
    @collisionDetectionMode.setter
    def collisionDetectionMode(self, value: CollisionDetectionMode) -> CollisionDetectionMode: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def constraints(self) -> RigidbodyConstraints: ...
    @constraints.setter
    def constraints(self, value: RigidbodyConstraints) -> RigidbodyConstraints: ...
    @property
    def detectCollisions(self) -> bool: ...
    @detectCollisions.setter
    def detectCollisions(self, value: bool) -> bool: ...
    @property
    def drag(self) -> float: ...
    @drag.setter
    def drag(self, value: float) -> float: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def freezeRotation(self) -> bool: ...
    @freezeRotation.setter
    def freezeRotation(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def inertiaTensor(self) -> Vector3: ...
    @inertiaTensor.setter
    def inertiaTensor(self, value: Vector3) -> Vector3: ...
    @property
    def inertiaTensorRotation(self) -> Quaternion: ...
    @inertiaTensorRotation.setter
    def inertiaTensorRotation(self, value: Quaternion) -> Quaternion: ...
    @property
    def interpolation(self) -> RigidbodyInterpolation: ...
    @interpolation.setter
    def interpolation(self, value: RigidbodyInterpolation) -> RigidbodyInterpolation: ...
    @property
    def isKinematic(self) -> bool: ...
    @isKinematic.setter
    def isKinematic(self, value: bool) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def mass(self) -> float: ...
    @mass.setter
    def mass(self, value: float) -> float: ...
    @property
    def maxAngularVelocity(self) -> float: ...
    @maxAngularVelocity.setter
    def maxAngularVelocity(self, value: float) -> float: ...
    @property
    def maxDepenetrationVelocity(self) -> float: ...
    @maxDepenetrationVelocity.setter
    def maxDepenetrationVelocity(self, value: float) -> float: ...
    @property
    def maxLinearVelocity(self) -> float: ...
    @maxLinearVelocity.setter
    def maxLinearVelocity(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def position(self) -> Vector3: ...
    @position.setter
    def position(self, value: Vector3) -> Vector3: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def rotation(self) -> Quaternion: ...
    @rotation.setter
    def rotation(self, value: Quaternion) -> Quaternion: ...
    @property
    def sleepAngularVelocity(self) -> float: ...
    @sleepAngularVelocity.setter
    def sleepAngularVelocity(self, value: float) -> float: ...
    @property
    def sleepThreshold(self) -> float: ...
    @sleepThreshold.setter
    def sleepThreshold(self, value: float) -> float: ...
    @property
    def sleepVelocity(self) -> float: ...
    @sleepVelocity.setter
    def sleepVelocity(self, value: float) -> float: ...
    @property
    def solverIterationCount(self) -> int: ...
    @solverIterationCount.setter
    def solverIterationCount(self, value: int) -> int: ...
    @property
    def solverIterations(self) -> int: ...
    @solverIterations.setter
    def solverIterations(self, value: int) -> int: ...
    @property
    def solverVelocityIterationCount(self) -> int: ...
    @solverVelocityIterationCount.setter
    def solverVelocityIterationCount(self, value: int) -> int: ...
    @property
    def solverVelocityIterations(self) -> int: ...
    @solverVelocityIterations.setter
    def solverVelocityIterations(self, value: int) -> int: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useConeFriction(self) -> bool: ...
    @useConeFriction.setter
    def useConeFriction(self, value: bool) -> bool: ...
    @property
    def useGravity(self) -> bool: ...
    @useGravity.setter
    def useGravity(self, value: bool) -> bool: ...
    @property
    def velocity(self) -> Vector3: ...
    @velocity.setter
    def velocity(self, value: Vector3) -> Vector3: ...
    @property
    def worldCenterOfMass(self) -> Vector3: ...
    def ClosestPointOnBounds(self, position: Vector3) -> Vector3: ...
    def GetPointVelocity(self, worldPoint: Vector3) -> Vector3: ...
    def GetRelativePointVelocity(self, relativePoint: Vector3) -> Vector3: ...
    def IsSleeping(self) -> bool: ...
    def Move(self, position: Vector3, rotation: Quaternion) -> None: ...
    def MovePosition(self, position: Vector3) -> None: ...
    def MoveRotation(self, rot: Quaternion) -> None: ...
    def ResetCenterOfMass(self) -> None: ...
    def ResetInertiaTensor(self) -> None: ...
    def SetDensity(self, density: float) -> None: ...
    def SetMaxAngularVelocity(self, a: float) -> None: ...
    def Sleep(self) -> None: ...
    def WakeUp(self) -> None: ...
    # Skipped AddExplosionForce due to it being static, abstract and generic.

    AddExplosionForce : AddExplosionForce_MethodGroup
    class AddExplosionForce_MethodGroup:
        @typing.overload
        def __call__(self, explosionForce: float, explosionPosition: Vector3, explosionRadius: float) -> None:...
        @typing.overload
        def __call__(self, explosionForce: float, explosionPosition: Vector3, explosionRadius: float, upwardsModifier: float) -> None:...
        @typing.overload
        def __call__(self, explosionForce: float, explosionPosition: Vector3, explosionRadius: float, upwardsModifier: float, mode: ForceMode) -> None:...

    # Skipped AddForce due to it being static, abstract and generic.

    AddForce : AddForce_MethodGroup
    class AddForce_MethodGroup:
        @typing.overload
        def __call__(self, force: Vector3) -> None:...
        @typing.overload
        def __call__(self, force: Vector3, mode: ForceMode) -> None:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> None:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float, mode: ForceMode) -> None:...

    # Skipped AddForceAtPosition due to it being static, abstract and generic.

    AddForceAtPosition : AddForceAtPosition_MethodGroup
    class AddForceAtPosition_MethodGroup:
        @typing.overload
        def __call__(self, force: Vector3, position: Vector3) -> None:...
        @typing.overload
        def __call__(self, force: Vector3, position: Vector3, mode: ForceMode) -> None:...

    # Skipped AddRelativeForce due to it being static, abstract and generic.

    AddRelativeForce : AddRelativeForce_MethodGroup
    class AddRelativeForce_MethodGroup:
        @typing.overload
        def __call__(self, force: Vector3) -> None:...
        @typing.overload
        def __call__(self, force: Vector3, mode: ForceMode) -> None:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> None:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float, mode: ForceMode) -> None:...

    # Skipped AddRelativeTorque due to it being static, abstract and generic.

    AddRelativeTorque : AddRelativeTorque_MethodGroup
    class AddRelativeTorque_MethodGroup:
        @typing.overload
        def __call__(self, torque: Vector3) -> None:...
        @typing.overload
        def __call__(self, torque: Vector3, mode: ForceMode) -> None:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> None:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float, mode: ForceMode) -> None:...

    # Skipped AddTorque due to it being static, abstract and generic.

    AddTorque : AddTorque_MethodGroup
    class AddTorque_MethodGroup:
        @typing.overload
        def __call__(self, torque: Vector3) -> None:...
        @typing.overload
        def __call__(self, torque: Vector3, mode: ForceMode) -> None:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> None:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float, mode: ForceMode) -> None:...

    # Skipped GetAccumulatedForce due to it being static, abstract and generic.

    GetAccumulatedForce : GetAccumulatedForce_MethodGroup
    class GetAccumulatedForce_MethodGroup:
        @typing.overload
        def __call__(self) -> Vector3:...
        @typing.overload
        def __call__(self, step: float) -> Vector3:...

    # Skipped GetAccumulatedTorque due to it being static, abstract and generic.

    GetAccumulatedTorque : GetAccumulatedTorque_MethodGroup
    class GetAccumulatedTorque_MethodGroup:
        @typing.overload
        def __call__(self) -> Vector3:...
        @typing.overload
        def __call__(self, step: float) -> Vector3:...

    # Skipped SweepTest due to it being static, abstract and generic.

    SweepTest : SweepTest_MethodGroup
    class SweepTest_MethodGroup:
        @typing.overload
        def __call__(self, direction: Vector3, hitInfo: clr.Reference[RaycastHit]) -> bool:...
        @typing.overload
        def __call__(self, direction: Vector3, hitInfo: clr.Reference[RaycastHit], maxDistance: float) -> bool:...
        @typing.overload
        def __call__(self, direction: Vector3, hitInfo: clr.Reference[RaycastHit], maxDistance: float, queryTriggerInteraction: QueryTriggerInteraction) -> bool:...

    # Skipped SweepTestAll due to it being static, abstract and generic.

    SweepTestAll : SweepTestAll_MethodGroup
    class SweepTestAll_MethodGroup:
        @typing.overload
        def __call__(self, direction: Vector3) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, direction: Vector3, maxDistance: float) -> Array_1[RaycastHit]:...
        @typing.overload
        def __call__(self, direction: Vector3, maxDistance: float, queryTriggerInteraction: QueryTriggerInteraction) -> Array_1[RaycastHit]:...



class Rigidbody2D(Component):
    def __init__(self) -> None: ...
    @property
    def angularDrag(self) -> float: ...
    @angularDrag.setter
    def angularDrag(self, value: float) -> float: ...
    @property
    def angularVelocity(self) -> float: ...
    @angularVelocity.setter
    def angularVelocity(self, value: float) -> float: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedColliderCount(self) -> int: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bodyType(self) -> RigidbodyType2D: ...
    @bodyType.setter
    def bodyType(self, value: RigidbodyType2D) -> RigidbodyType2D: ...
    @property
    def camera(self) -> Component: ...
    @property
    def centerOfMass(self) -> Vector2: ...
    @centerOfMass.setter
    def centerOfMass(self, value: Vector2) -> Vector2: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def collisionDetectionMode(self) -> CollisionDetectionMode2D: ...
    @collisionDetectionMode.setter
    def collisionDetectionMode(self, value: CollisionDetectionMode2D) -> CollisionDetectionMode2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def constraints(self) -> RigidbodyConstraints2D: ...
    @constraints.setter
    def constraints(self, value: RigidbodyConstraints2D) -> RigidbodyConstraints2D: ...
    @property
    def drag(self) -> float: ...
    @drag.setter
    def drag(self, value: float) -> float: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def fixedAngle(self) -> bool: ...
    @fixedAngle.setter
    def fixedAngle(self, value: bool) -> bool: ...
    @property
    def freezeRotation(self) -> bool: ...
    @freezeRotation.setter
    def freezeRotation(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def gravityScale(self) -> float: ...
    @gravityScale.setter
    def gravityScale(self, value: float) -> float: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def inertia(self) -> float: ...
    @inertia.setter
    def inertia(self, value: float) -> float: ...
    @property
    def interpolation(self) -> RigidbodyInterpolation2D: ...
    @interpolation.setter
    def interpolation(self, value: RigidbodyInterpolation2D) -> RigidbodyInterpolation2D: ...
    @property
    def isKinematic(self) -> bool: ...
    @isKinematic.setter
    def isKinematic(self, value: bool) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def mass(self) -> float: ...
    @mass.setter
    def mass(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def position(self) -> Vector2: ...
    @position.setter
    def position(self, value: Vector2) -> Vector2: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def rotation(self) -> float: ...
    @rotation.setter
    def rotation(self, value: float) -> float: ...
    @property
    def sharedMaterial(self) -> PhysicsMaterial2D: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: PhysicsMaterial2D) -> PhysicsMaterial2D: ...
    @property
    def simulated(self) -> bool: ...
    @simulated.setter
    def simulated(self, value: bool) -> bool: ...
    @property
    def sleepMode(self) -> RigidbodySleepMode2D: ...
    @sleepMode.setter
    def sleepMode(self, value: RigidbodySleepMode2D) -> RigidbodySleepMode2D: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def totalForce(self) -> Vector2: ...
    @totalForce.setter
    def totalForce(self, value: Vector2) -> Vector2: ...
    @property
    def totalTorque(self) -> float: ...
    @totalTorque.setter
    def totalTorque(self, value: float) -> float: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useAutoMass(self) -> bool: ...
    @useAutoMass.setter
    def useAutoMass(self, value: bool) -> bool: ...
    @property
    def useFullKinematicContacts(self) -> bool: ...
    @useFullKinematicContacts.setter
    def useFullKinematicContacts(self, value: bool) -> bool: ...
    @property
    def velocity(self) -> Vector2: ...
    @velocity.setter
    def velocity(self, value: Vector2) -> Vector2: ...
    @property
    def worldCenterOfMass(self) -> Vector2: ...
    def ClosestPoint(self, position: Vector2) -> Vector2: ...
    def Distance(self, collider: Collider2D) -> ColliderDistance2D: ...
    def GetPoint(self, point: Vector2) -> Vector2: ...
    def GetPointVelocity(self, point: Vector2) -> Vector2: ...
    def GetRelativePoint(self, relativePoint: Vector2) -> Vector2: ...
    def GetRelativePointVelocity(self, relativePoint: Vector2) -> Vector2: ...
    def GetRelativeVector(self, relativeVector: Vector2) -> Vector2: ...
    def GetShapes(self, physicsShapeGroup: PhysicsShapeGroup2D) -> int: ...
    def GetVector(self, vector: Vector2) -> Vector2: ...
    def IsAwake(self) -> bool: ...
    def IsSleeping(self) -> bool: ...
    def MovePosition(self, position: Vector2) -> None: ...
    def OverlapPoint(self, point: Vector2) -> bool: ...
    def Sleep(self) -> None: ...
    def WakeUp(self) -> None: ...
    # Skipped AddForce due to it being static, abstract and generic.

    AddForce : AddForce_MethodGroup
    class AddForce_MethodGroup:
        @typing.overload
        def __call__(self, force: Vector2) -> None:...
        @typing.overload
        def __call__(self, force: Vector2, mode: ForceMode2D) -> None:...

    # Skipped AddForceAtPosition due to it being static, abstract and generic.

    AddForceAtPosition : AddForceAtPosition_MethodGroup
    class AddForceAtPosition_MethodGroup:
        @typing.overload
        def __call__(self, force: Vector2, position: Vector2) -> None:...
        @typing.overload
        def __call__(self, force: Vector2, position: Vector2, mode: ForceMode2D) -> None:...

    # Skipped AddRelativeForce due to it being static, abstract and generic.

    AddRelativeForce : AddRelativeForce_MethodGroup
    class AddRelativeForce_MethodGroup:
        @typing.overload
        def __call__(self, relativeForce: Vector2) -> None:...
        @typing.overload
        def __call__(self, relativeForce: Vector2, mode: ForceMode2D) -> None:...

    # Skipped AddTorque due to it being static, abstract and generic.

    AddTorque : AddTorque_MethodGroup
    class AddTorque_MethodGroup:
        @typing.overload
        def __call__(self, torque: float) -> None:...
        @typing.overload
        def __call__(self, torque: float, mode: ForceMode2D) -> None:...

    # Skipped Cast due to it being static, abstract and generic.

    Cast : Cast_MethodGroup
    class Cast_MethodGroup:
        @typing.overload
        def __call__(self, direction: Vector2, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, results: Array_1[RaycastHit2D], distance: float) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, results: List_1[RaycastHit2D], distance: float = ...) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D]) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, contactFilter: ContactFilter2D, results: Array_1[RaycastHit2D], distance: float) -> int:...
        @typing.overload
        def __call__(self, direction: Vector2, contactFilter: ContactFilter2D, results: List_1[RaycastHit2D], distance: float) -> int:...

    # Skipped GetAttachedColliders due to it being static, abstract and generic.

    GetAttachedColliders : GetAttachedColliders_MethodGroup
    class GetAttachedColliders_MethodGroup:
        @typing.overload
        def __call__(self, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, results: List_1[Collider2D]) -> int:...

    # Skipped GetContacts due to it being static, abstract and generic.

    GetContacts : GetContacts_MethodGroup
    class GetContacts_MethodGroup:
        @typing.overload
        def __call__(self, colliders: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, colliders: List_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, contacts: Array_1[ContactPoint2D]) -> int:...
        @typing.overload
        def __call__(self, contacts: List_1[ContactPoint2D]) -> int:...
        @typing.overload
        def __call__(self, contactFilter: ContactFilter2D, colliders: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, contactFilter: ContactFilter2D, colliders: List_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, contactFilter: ContactFilter2D, contacts: Array_1[ContactPoint2D]) -> int:...
        @typing.overload
        def __call__(self, contactFilter: ContactFilter2D, contacts: List_1[ContactPoint2D]) -> int:...

    # Skipped IsTouching due to it being static, abstract and generic.

    IsTouching : IsTouching_MethodGroup
    class IsTouching_MethodGroup:
        @typing.overload
        def __call__(self, collider: Collider2D) -> bool:...
        @typing.overload
        def __call__(self, contactFilter: ContactFilter2D) -> bool:...
        @typing.overload
        def __call__(self, collider: Collider2D, contactFilter: ContactFilter2D) -> bool:...

    # Skipped IsTouchingLayers due to it being static, abstract and generic.

    IsTouchingLayers : IsTouchingLayers_MethodGroup
    class IsTouchingLayers_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, layerMask: int) -> bool:...

    # Skipped MoveRotation due to it being static, abstract and generic.

    MoveRotation : MoveRotation_MethodGroup
    class MoveRotation_MethodGroup:
        @typing.overload
        def __call__(self, angle: float) -> None:...
        @typing.overload
        def __call__(self, rotation: Quaternion) -> None:...

    # Skipped OverlapCollider due to it being static, abstract and generic.

    OverlapCollider : OverlapCollider_MethodGroup
    class OverlapCollider_MethodGroup:
        @typing.overload
        def __call__(self, contactFilter: ContactFilter2D, results: Array_1[Collider2D]) -> int:...
        @typing.overload
        def __call__(self, contactFilter: ContactFilter2D, results: List_1[Collider2D]) -> int:...

    # Skipped SetRotation due to it being static, abstract and generic.

    SetRotation : SetRotation_MethodGroup
    class SetRotation_MethodGroup:
        @typing.overload
        def __call__(self, angle: float) -> None:...
        @typing.overload
        def __call__(self, rotation: Quaternion) -> None:...



class RigidbodyConstraints(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : RigidbodyConstraints # 0
    FreezePositionX : RigidbodyConstraints # 2
    FreezePositionY : RigidbodyConstraints # 4
    FreezePositionZ : RigidbodyConstraints # 8
    FreezePosition : RigidbodyConstraints # 14
    FreezeRotationX : RigidbodyConstraints # 16
    FreezeRotationY : RigidbodyConstraints # 32
    FreezeRotationZ : RigidbodyConstraints # 64
    FreezeRotation : RigidbodyConstraints # 112
    FreezeAll : RigidbodyConstraints # 126


class RigidbodyConstraints2D(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : RigidbodyConstraints2D # 0
    FreezePositionX : RigidbodyConstraints2D # 1
    FreezePositionY : RigidbodyConstraints2D # 2
    FreezePosition : RigidbodyConstraints2D # 3
    FreezeRotation : RigidbodyConstraints2D # 4
    FreezeAll : RigidbodyConstraints2D # 7


class RigidbodyInterpolation(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : RigidbodyInterpolation # 0
    Interpolate : RigidbodyInterpolation # 1
    Extrapolate : RigidbodyInterpolation # 2


class RigidbodyInterpolation2D(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : RigidbodyInterpolation2D # 0
    Interpolate : RigidbodyInterpolation2D # 1
    Extrapolate : RigidbodyInterpolation2D # 2


class RigidbodySleepMode2D(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    NeverSleep : RigidbodySleepMode2D # 0
    StartAwake : RigidbodySleepMode2D # 1
    StartAsleep : RigidbodySleepMode2D # 2


class RigidbodyType2D(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Dynamic : RigidbodyType2D # 0
    Kinematic : RigidbodyType2D # 1
    Static : RigidbodyType2D # 2


class RotationDriveMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    XYAndZ : RotationDriveMode # 0
    Slerp : RotationDriveMode # 1


class RPC(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class RPCMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:


class RuntimeAnimatorController(Object):
    @property
    def animationClips(self) -> Array_1[AnimationClip]: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...


class RuntimeInitializeLoadType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    AfterSceneLoad : RuntimeInitializeLoadType # 0
    BeforeSceneLoad : RuntimeInitializeLoadType # 1
    AfterAssembliesLoaded : RuntimeInitializeLoadType # 2
    BeforeSplashScreen : RuntimeInitializeLoadType # 3
    SubsystemRegistration : RuntimeInitializeLoadType # 4


class RuntimeInitializeOnLoadMethodAttribute(PreserveAttribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, loadType: RuntimeInitializeLoadType) -> None: ...
    @property
    def loadType(self) -> RuntimeInitializeLoadType: ...
    @loadType.setter
    def loadType(self, value: RuntimeInitializeLoadType) -> RuntimeInitializeLoadType: ...
    @property
    def TypeId(self) -> typing.Any: ...


class RuntimePlatform(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    OSXEditor : RuntimePlatform # 0
    OSXPlayer : RuntimePlatform # 1
    WindowsPlayer : RuntimePlatform # 2
    OSXWebPlayer : RuntimePlatform # 3
    OSXDashboardPlayer : RuntimePlatform # 4
    WindowsWebPlayer : RuntimePlatform # 5
    WindowsEditor : RuntimePlatform # 7
    IPhonePlayer : RuntimePlatform # 8
    PS3 : RuntimePlatform # 9
    XBOX360 : RuntimePlatform # 10
    Android : RuntimePlatform # 11
    NaCl : RuntimePlatform # 12
    LinuxPlayer : RuntimePlatform # 13
    FlashPlayer : RuntimePlatform # 15
    LinuxEditor : RuntimePlatform # 16
    WebGLPlayer : RuntimePlatform # 17
    MetroPlayerX86 : RuntimePlatform # 18
    WSAPlayerX86 : RuntimePlatform # 18
    WSAPlayerX64 : RuntimePlatform # 19
    MetroPlayerX64 : RuntimePlatform # 19
    MetroPlayerARM : RuntimePlatform # 20
    WSAPlayerARM : RuntimePlatform # 20
    WP8Player : RuntimePlatform # 21
    BlackBerryPlayer : RuntimePlatform # 22
    BB10Player : RuntimePlatform # 22
    TizenPlayer : RuntimePlatform # 23
    PSP2 : RuntimePlatform # 24
    PS4 : RuntimePlatform # 25
    PSM : RuntimePlatform # 26
    XboxOne : RuntimePlatform # 27
    SamsungTVPlayer : RuntimePlatform # 28
    WiiU : RuntimePlatform # 30
    tvOS : RuntimePlatform # 31
    Switch : RuntimePlatform # 32
    Lumin : RuntimePlatform # 33
    Stadia : RuntimePlatform # 34
    CloudRendering : RuntimePlatform # 35
    GameCoreXboxSeries : RuntimePlatform # 36
    GameCoreXboxOne : RuntimePlatform # 37
    PS5 : RuntimePlatform # 38
    EmbeddedLinuxArm64 : RuntimePlatform # 39
    EmbeddedLinuxArm32 : RuntimePlatform # 40
    EmbeddedLinuxX64 : RuntimePlatform # 41
    EmbeddedLinuxX86 : RuntimePlatform # 42
    LinuxServer : RuntimePlatform # 43
    WindowsServer : RuntimePlatform # 44
    OSXServer : RuntimePlatform # 45
    QNXArm32 : RuntimePlatform # 46
    QNXArm64 : RuntimePlatform # 47
    QNXX64 : RuntimePlatform # 48
    QNXX86 : RuntimePlatform # 49
    VisionOS : RuntimePlatform # 50
    GameCoreScarlett : RuntimePlatform # -1


class ScalableBufferManager(abc.ABC):
    @classmethod
    @property
    def heightScaleFactor(cls) -> float: ...
    @classmethod
    @property
    def widthScaleFactor(cls) -> float: ...
    @staticmethod
    def ResizeBuffers(widthScale: float, heightScale: float) -> None: ...


class ScaleMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    StretchToFill : ScaleMode # 0
    ScaleAndCrop : ScaleMode # 1
    ScaleToFit : ScaleMode # 2


class Screen:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def autorotateToLandscapeLeft(cls) -> bool: ...
    @classmethod
    @autorotateToLandscapeLeft.setter
    def autorotateToLandscapeLeft(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def autorotateToLandscapeRight(cls) -> bool: ...
    @classmethod
    @autorotateToLandscapeRight.setter
    def autorotateToLandscapeRight(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def autorotateToPortrait(cls) -> bool: ...
    @classmethod
    @autorotateToPortrait.setter
    def autorotateToPortrait(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def autorotateToPortraitUpsideDown(cls) -> bool: ...
    @classmethod
    @autorotateToPortraitUpsideDown.setter
    def autorotateToPortraitUpsideDown(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def brightness(cls) -> float: ...
    @classmethod
    @brightness.setter
    def brightness(cls, value: float) -> float: ...
    @classmethod
    @property
    def currentResolution(cls) -> Resolution: ...
    @classmethod
    @property
    def cutouts(cls) -> Array_1[Rect]: ...
    @classmethod
    @property
    def dpi(cls) -> float: ...
    @classmethod
    @property
    def fullScreen(cls) -> bool: ...
    @classmethod
    @fullScreen.setter
    def fullScreen(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def fullScreenMode(cls) -> FullScreenMode: ...
    @classmethod
    @fullScreenMode.setter
    def fullScreenMode(cls, value: FullScreenMode) -> FullScreenMode: ...
    @classmethod
    @property
    def GetResolution(cls) -> Array_1[Resolution]: ...
    @classmethod
    @property
    def height(cls) -> int: ...
    @classmethod
    @property
    def lockCursor(cls) -> bool: ...
    @classmethod
    @lockCursor.setter
    def lockCursor(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def mainWindowDisplayInfo(cls) -> DisplayInfo: ...
    @classmethod
    @property
    def mainWindowPosition(cls) -> Vector2Int: ...
    @classmethod
    @property
    def orientation(cls) -> ScreenOrientation: ...
    @classmethod
    @orientation.setter
    def orientation(cls, value: ScreenOrientation) -> ScreenOrientation: ...
    @classmethod
    @property
    def resolutions(cls) -> Array_1[Resolution]: ...
    @classmethod
    @property
    def safeArea(cls) -> Rect: ...
    @classmethod
    @property
    def showCursor(cls) -> bool: ...
    @classmethod
    @showCursor.setter
    def showCursor(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def sleepTimeout(cls) -> int: ...
    @classmethod
    @sleepTimeout.setter
    def sleepTimeout(cls, value: int) -> int: ...
    @classmethod
    @property
    def width(cls) -> int: ...
    @staticmethod
    def GetDisplayLayout(displayLayout: List_1[DisplayInfo]) -> None: ...
    @staticmethod
    def MoveMainWindowTo(display: clr.Reference[DisplayInfo], position: Vector2Int) -> AsyncOperation: ...
    # Skipped SetResolution due to it being static, abstract and generic.

    SetResolution : SetResolution_MethodGroup
    class SetResolution_MethodGroup:
        @typing.overload
        def __call__(self, width: int, height: int, fullscreenMode: FullScreenMode) -> None:...
        @typing.overload
        def __call__(self, width: int, height: int, fullscreen: bool) -> None:...
        @typing.overload
        def __call__(self, width: int, height: int, fullscreenMode: FullScreenMode, preferredRefreshRate: int) -> None:...
        @typing.overload
        def __call__(self, width: int, height: int, fullscreenMode: FullScreenMode, preferredRefreshRate: RefreshRate) -> None:...
        @typing.overload
        def __call__(self, width: int, height: int, fullscreen: bool, preferredRefreshRate: int) -> None:...



class ScreenCapture(abc.ABC):
    @staticmethod
    def CaptureScreenshotIntoRenderTexture(renderTexture: RenderTexture) -> None: ...
    # Skipped CaptureScreenshot due to it being static, abstract and generic.

    CaptureScreenshot : CaptureScreenshot_MethodGroup
    class CaptureScreenshot_MethodGroup:
        @typing.overload
        def __call__(self, filename: str) -> None:...
        @typing.overload
        def __call__(self, filename: str, superSize: int) -> None:...
        @typing.overload
        def __call__(self, filename: str, stereoCaptureMode: ScreenCapture.StereoScreenCaptureMode) -> None:...

    # Skipped CaptureScreenshotAsTexture due to it being static, abstract and generic.

    CaptureScreenshotAsTexture : CaptureScreenshotAsTexture_MethodGroup
    class CaptureScreenshotAsTexture_MethodGroup:
        @typing.overload
        def __call__(self) -> Texture2D:...
        @typing.overload
        def __call__(self, superSize: int) -> Texture2D:...
        @typing.overload
        def __call__(self, stereoCaptureMode: ScreenCapture.StereoScreenCaptureMode) -> Texture2D:...


    class StereoScreenCaptureMode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        LeftEye : ScreenCapture.StereoScreenCaptureMode # 1
        RightEye : ScreenCapture.StereoScreenCaptureMode # 2
        BothEyes : ScreenCapture.StereoScreenCaptureMode # 3



class ScreenOrientation(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : ScreenOrientation # 0
    Portrait : ScreenOrientation # 1
    PortraitUpsideDown : ScreenOrientation # 2
    LandscapeLeft : ScreenOrientation # 3
    Landscape : ScreenOrientation # 3
    LandscapeRight : ScreenOrientation # 4
    AutoRotation : ScreenOrientation # 5


class ScriptableObject(Object):
    def __init__(self) -> None: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    def SetDirty(self) -> None: ...
    # Skipped CreateInstance due to it being static, abstract and generic.

    CreateInstance : CreateInstance_MethodGroup
    class CreateInstance_MethodGroup:
        def __getitem__(self, t:typing.Type[CreateInstance_1_T1]) -> CreateInstance_1[CreateInstance_1_T1]: ...

        CreateInstance_1_T1 = typing.TypeVar('CreateInstance_1_T1')
        class CreateInstance_1(typing.Generic[CreateInstance_1_T1]):
            CreateInstance_1_T = ScriptableObject.CreateInstance_MethodGroup.CreateInstance_1_T1
            def __call__(self) -> CreateInstance_1_T:...

        @typing.overload
        def __call__(self, className: str) -> ScriptableObject:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> ScriptableObject:...



class SecondarySpriteTexture:
    name : str
    texture : Texture2D


class Security:
    def __init__(self) -> None: ...
    # Skipped LoadAndVerifyAssembly due to it being static, abstract and generic.

    LoadAndVerifyAssembly : LoadAndVerifyAssembly_MethodGroup
    class LoadAndVerifyAssembly_MethodGroup:
        @typing.overload
        def __call__(self, assemblyData: Array_1[int]) -> Assembly:...
        @typing.overload
        def __call__(self, assemblyData: Array_1[int], authorizationKey: str) -> Assembly:...

    # Skipped PrefetchSocketPolicy due to it being static, abstract and generic.

    PrefetchSocketPolicy : PrefetchSocketPolicy_MethodGroup
    class PrefetchSocketPolicy_MethodGroup:
        @typing.overload
        def __call__(self, ip: str, atPort: int) -> bool:...
        @typing.overload
        def __call__(self, ip: str, atPort: int, timeout: int) -> bool:...



class SelectionBaseAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class SendMessageOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    RequireReceiver : SendMessageOptions # 0
    DontRequireReceiver : SendMessageOptions # 1


class SerializeField(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class SerializeReference(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class Shader(Object):
    @classmethod
    @property
    def enabledGlobalKeywords(cls) -> Array_1[GlobalKeyword]: ...
    @classmethod
    @property
    def globalKeywords(cls) -> Array_1[GlobalKeyword]: ...
    @classmethod
    @property
    def globalMaximumLOD(cls) -> int: ...
    @classmethod
    @globalMaximumLOD.setter
    def globalMaximumLOD(cls, value: int) -> int: ...
    @classmethod
    @property
    def globalRenderPipeline(cls) -> str: ...
    @classmethod
    @globalRenderPipeline.setter
    def globalRenderPipeline(cls, value: str) -> str: ...
    @classmethod
    @property
    def globalShaderHardwareTier(cls) -> ShaderHardwareTier: ...
    @classmethod
    @globalShaderHardwareTier.setter
    def globalShaderHardwareTier(cls, value: ShaderHardwareTier) -> ShaderHardwareTier: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def isSupported(self) -> bool: ...
    @property
    def keywordSpace(self) -> LocalKeywordSpace: ...
    @classmethod
    @property
    def maximumChunksOverride(cls) -> int: ...
    @classmethod
    @maximumChunksOverride.setter
    def maximumChunksOverride(cls, value: int) -> int: ...
    @property
    def maximumLOD(self) -> int: ...
    @maximumLOD.setter
    def maximumLOD(self, value: int) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def passCount(self) -> int: ...
    @property
    def renderQueue(self) -> int: ...
    @property
    def subshaderCount(self) -> int: ...
    @staticmethod
    def Find(name: str) -> Shader: ...
    def FindPropertyIndex(self, propertyName: str) -> int: ...
    def FindSubshaderTagValue(self, subshaderIndex: int, tagName: ShaderTagId) -> ShaderTagId: ...
    def FindTextureStack(self, propertyIndex: int, stackName: clr.Reference[str], layerIndex: clr.Reference[int]) -> bool: ...
    def GetDependency(self, name: str) -> Shader: ...
    def GetPassCountInSubshader(self, subshaderIndex: int) -> int: ...
    def GetPropertyAttributes(self, propertyIndex: int) -> Array_1[str]: ...
    def GetPropertyCount(self) -> int: ...
    def GetPropertyDefaultFloatValue(self, propertyIndex: int) -> float: ...
    def GetPropertyDefaultIntValue(self, propertyIndex: int) -> int: ...
    def GetPropertyDefaultVectorValue(self, propertyIndex: int) -> Vector4: ...
    def GetPropertyDescription(self, propertyIndex: int) -> str: ...
    def GetPropertyFlags(self, propertyIndex: int) -> ShaderPropertyFlags: ...
    def GetPropertyName(self, propertyIndex: int) -> str: ...
    def GetPropertyNameId(self, propertyIndex: int) -> int: ...
    def GetPropertyRangeLimits(self, propertyIndex: int) -> Vector2: ...
    def GetPropertyTextureDefaultName(self, propertyIndex: int) -> str: ...
    def GetPropertyTextureDimension(self, propertyIndex: int) -> TextureDimension: ...
    def GetPropertyType(self, propertyIndex: int) -> ShaderPropertyType: ...
    @staticmethod
    def PropertyToID(name: str) -> int: ...
    @staticmethod
    def SetGlobalTexGenMode(propertyName: str, mode: TexGenMode) -> None: ...
    @staticmethod
    def SetGlobalTextureMatrixName(propertyName: str, matrixName: str) -> None: ...
    @staticmethod
    def SetKeyword(keyword: clr.Reference[GlobalKeyword], value: bool) -> None: ...
    @staticmethod
    def WarmupAllShaders() -> None: ...
    # Skipped DisableKeyword due to it being static, abstract and generic.

    DisableKeyword : DisableKeyword_MethodGroup
    class DisableKeyword_MethodGroup:
        @typing.overload
        def __call__(self, keyword: str) -> None:...
        @typing.overload
        def __call__(self, keyword: clr.Reference[GlobalKeyword]) -> None:...

    # Skipped EnableKeyword due to it being static, abstract and generic.

    EnableKeyword : EnableKeyword_MethodGroup
    class EnableKeyword_MethodGroup:
        @typing.overload
        def __call__(self, keyword: str) -> None:...
        @typing.overload
        def __call__(self, keyword: clr.Reference[GlobalKeyword]) -> None:...

    # Skipped FindPassTagValue due to it being static, abstract and generic.

    FindPassTagValue : FindPassTagValue_MethodGroup
    class FindPassTagValue_MethodGroup:
        @typing.overload
        def __call__(self, passIndex: int, tagName: ShaderTagId) -> ShaderTagId:...
        @typing.overload
        def __call__(self, subshaderIndex: int, passIndex: int, tagName: ShaderTagId) -> ShaderTagId:...

    # Skipped GetGlobalColor due to it being static, abstract and generic.

    GetGlobalColor : GetGlobalColor_MethodGroup
    class GetGlobalColor_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Color:...
        @typing.overload
        def __call__(self, name: str) -> Color:...

    # Skipped GetGlobalFloat due to it being static, abstract and generic.

    GetGlobalFloat : GetGlobalFloat_MethodGroup
    class GetGlobalFloat_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> float:...
        @typing.overload
        def __call__(self, name: str) -> float:...

    # Skipped GetGlobalFloatArray due to it being static, abstract and generic.

    GetGlobalFloatArray : GetGlobalFloatArray_MethodGroup
    class GetGlobalFloatArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Array_1[float]:...
        @typing.overload
        def __call__(self, name: str) -> Array_1[float]:...
        @typing.overload
        def __call__(self, nameID: int, values: List_1[float]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[float]) -> None:...

    # Skipped GetGlobalInt due to it being static, abstract and generic.

    GetGlobalInt : GetGlobalInt_MethodGroup
    class GetGlobalInt_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> int:...
        @typing.overload
        def __call__(self, name: str) -> int:...

    # Skipped GetGlobalInteger due to it being static, abstract and generic.

    GetGlobalInteger : GetGlobalInteger_MethodGroup
    class GetGlobalInteger_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> int:...
        @typing.overload
        def __call__(self, name: str) -> int:...

    # Skipped GetGlobalMatrix due to it being static, abstract and generic.

    GetGlobalMatrix : GetGlobalMatrix_MethodGroup
    class GetGlobalMatrix_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Matrix4x4:...
        @typing.overload
        def __call__(self, name: str) -> Matrix4x4:...

    # Skipped GetGlobalMatrixArray due to it being static, abstract and generic.

    GetGlobalMatrixArray : GetGlobalMatrixArray_MethodGroup
    class GetGlobalMatrixArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Array_1[Matrix4x4]:...
        @typing.overload
        def __call__(self, name: str) -> Array_1[Matrix4x4]:...
        @typing.overload
        def __call__(self, nameID: int, values: List_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[Matrix4x4]) -> None:...

    # Skipped GetGlobalTexture due to it being static, abstract and generic.

    GetGlobalTexture : GetGlobalTexture_MethodGroup
    class GetGlobalTexture_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Texture:...
        @typing.overload
        def __call__(self, name: str) -> Texture:...

    # Skipped GetGlobalVector due to it being static, abstract and generic.

    GetGlobalVector : GetGlobalVector_MethodGroup
    class GetGlobalVector_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Vector4:...
        @typing.overload
        def __call__(self, name: str) -> Vector4:...

    # Skipped GetGlobalVectorArray due to it being static, abstract and generic.

    GetGlobalVectorArray : GetGlobalVectorArray_MethodGroup
    class GetGlobalVectorArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int) -> Array_1[Vector4]:...
        @typing.overload
        def __call__(self, name: str) -> Array_1[Vector4]:...
        @typing.overload
        def __call__(self, nameID: int, values: List_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[Vector4]) -> None:...

    # Skipped IsKeywordEnabled due to it being static, abstract and generic.

    IsKeywordEnabled : IsKeywordEnabled_MethodGroup
    class IsKeywordEnabled_MethodGroup:
        @typing.overload
        def __call__(self, keyword: str) -> bool:...
        @typing.overload
        def __call__(self, keyword: clr.Reference[GlobalKeyword]) -> bool:...

    # Skipped SetGlobalBuffer due to it being static, abstract and generic.

    SetGlobalBuffer : SetGlobalBuffer_MethodGroup
    class SetGlobalBuffer_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, nameID: int, value: GraphicsBuffer) -> None:...
        @typing.overload
        def __call__(self, name: str, value: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, name: str, value: GraphicsBuffer) -> None:...

    # Skipped SetGlobalColor due to it being static, abstract and generic.

    SetGlobalColor : SetGlobalColor_MethodGroup
    class SetGlobalColor_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Color) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Color) -> None:...

    # Skipped SetGlobalConstantBuffer due to it being static, abstract and generic.

    SetGlobalConstantBuffer : SetGlobalConstantBuffer_MethodGroup
    class SetGlobalConstantBuffer_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: ComputeBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, nameID: int, value: GraphicsBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, name: str, value: ComputeBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, name: str, value: GraphicsBuffer, offset: int, size: int) -> None:...

    # Skipped SetGlobalFloat due to it being static, abstract and generic.

    SetGlobalFloat : SetGlobalFloat_MethodGroup
    class SetGlobalFloat_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: float) -> None:...
        @typing.overload
        def __call__(self, name: str, value: float) -> None:...

    # Skipped SetGlobalFloatArray due to it being static, abstract and generic.

    SetGlobalFloatArray : SetGlobalFloatArray_MethodGroup
    class SetGlobalFloatArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, values: List_1[float]) -> None:...
        @typing.overload
        def __call__(self, nameID: int, values: Array_1[float]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[float]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: Array_1[float]) -> None:...

    # Skipped SetGlobalInt due to it being static, abstract and generic.

    SetGlobalInt : SetGlobalInt_MethodGroup
    class SetGlobalInt_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: int) -> None:...
        @typing.overload
        def __call__(self, name: str, value: int) -> None:...

    # Skipped SetGlobalInteger due to it being static, abstract and generic.

    SetGlobalInteger : SetGlobalInteger_MethodGroup
    class SetGlobalInteger_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: int) -> None:...
        @typing.overload
        def __call__(self, name: str, value: int) -> None:...

    # Skipped SetGlobalMatrix due to it being static, abstract and generic.

    SetGlobalMatrix : SetGlobalMatrix_MethodGroup
    class SetGlobalMatrix_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Matrix4x4) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Matrix4x4) -> None:...

    # Skipped SetGlobalMatrixArray due to it being static, abstract and generic.

    SetGlobalMatrixArray : SetGlobalMatrixArray_MethodGroup
    class SetGlobalMatrixArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, values: List_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, nameID: int, values: Array_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: Array_1[Matrix4x4]) -> None:...

    # Skipped SetGlobalTexture due to it being static, abstract and generic.

    SetGlobalTexture : SetGlobalTexture_MethodGroup
    class SetGlobalTexture_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Texture) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Texture) -> None:...
        @typing.overload
        def __call__(self, nameID: int, value: RenderTexture, element: RenderTextureSubElement) -> None:...
        @typing.overload
        def __call__(self, name: str, value: RenderTexture, element: RenderTextureSubElement) -> None:...

    # Skipped SetGlobalVector due to it being static, abstract and generic.

    SetGlobalVector : SetGlobalVector_MethodGroup
    class SetGlobalVector_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Vector4) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Vector4) -> None:...

    # Skipped SetGlobalVectorArray due to it being static, abstract and generic.

    SetGlobalVectorArray : SetGlobalVectorArray_MethodGroup
    class SetGlobalVectorArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, values: List_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, nameID: int, values: Array_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: List_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, name: str, values: Array_1[Vector4]) -> None:...



class ShaderVariantCollection(Object):
    def __init__(self) -> None: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def isWarmedUp(self) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def shaderCount(self) -> int: ...
    @property
    def variantCount(self) -> int: ...
    @property
    def warmedUpVariantCount(self) -> int: ...
    def Add(self, variant: ShaderVariantCollection.ShaderVariant) -> bool: ...
    def Clear(self) -> None: ...
    def Contains(self, variant: ShaderVariantCollection.ShaderVariant) -> bool: ...
    def Remove(self, variant: ShaderVariantCollection.ShaderVariant) -> bool: ...
    def WarmUp(self) -> None: ...
    def WarmUpProgressively(self, variantCount: int) -> bool: ...

    class ShaderVariant:
        def __init__(self, shader: Shader, passType: PassType, keywords: Array_1[str]) -> None: ...
        keywords : Array_1[str]
        passType : PassType
        shader : Shader



class ShadowmaskMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Shadowmask : ShadowmaskMode # 0
    DistanceShadowmask : ShadowmaskMode # 1


class ShadowObjectsFilter(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    AllObjects : ShadowObjectsFilter # 0
    DynamicOnly : ShadowObjectsFilter # 1
    StaticOnly : ShadowObjectsFilter # 2


class ShadowProjection(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    CloseFit : ShadowProjection # 0
    StableFit : ShadowProjection # 1


class ShadowQuality(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Disable : ShadowQuality # 0
    HardOnly : ShadowQuality # 1
    All : ShadowQuality # 2


class ShadowResolution(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Low : ShadowResolution # 0
    Medium : ShadowResolution # 1
    High : ShadowResolution # 2
    VeryHigh : ShadowResolution # 3


class SharedBetweenAnimatorsAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class SimulationMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    FixedUpdate : SimulationMode # 0
    Update : SimulationMode # 1
    Script : SimulationMode # 2


class SimulationMode2D(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    FixedUpdate : SimulationMode2D # 0
    Update : SimulationMode2D # 1
    Script : SimulationMode2D # 2


class SkeletonBone:
    name : str
    position : Vector3
    rotation : Quaternion
    scale : Vector3
    @property
    def transformModified(self) -> int: ...
    @transformModified.setter
    def transformModified(self, value: int) -> int: ...


class SkinnedMeshRenderer(Renderer):
    def __init__(self) -> None: ...
    @property
    def allowOcclusionWhenDynamic(self) -> bool: ...
    @allowOcclusionWhenDynamic.setter
    def allowOcclusionWhenDynamic(self, value: bool) -> bool: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bones(self) -> Array_1[Transform]: ...
    @bones.setter
    def bones(self, value: Array_1[Transform]) -> Array_1[Transform]: ...
    @property
    def bounds(self) -> Bounds: ...
    @bounds.setter
    def bounds(self, value: Bounds) -> Bounds: ...
    @property
    def camera(self) -> Component: ...
    @property
    def castShadows(self) -> bool: ...
    @castShadows.setter
    def castShadows(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def forceMatrixRecalculationPerRender(self) -> bool: ...
    @forceMatrixRecalculationPerRender.setter
    def forceMatrixRecalculationPerRender(self, value: bool) -> bool: ...
    @property
    def forceRenderingOff(self) -> bool: ...
    @forceRenderingOff.setter
    def forceRenderingOff(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isPartOfStaticBatch(self) -> bool: ...
    @property
    def isVisible(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def lightmapIndex(self) -> int: ...
    @lightmapIndex.setter
    def lightmapIndex(self, value: int) -> int: ...
    @property
    def lightmapScaleOffset(self) -> Vector4: ...
    @lightmapScaleOffset.setter
    def lightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightmapTilingOffset(self) -> Vector4: ...
    @lightmapTilingOffset.setter
    def lightmapTilingOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightProbeAnchor(self) -> Transform: ...
    @lightProbeAnchor.setter
    def lightProbeAnchor(self, value: Transform) -> Transform: ...
    @property
    def lightProbeProxyVolumeOverride(self) -> GameObject: ...
    @lightProbeProxyVolumeOverride.setter
    def lightProbeProxyVolumeOverride(self, value: GameObject) -> GameObject: ...
    @property
    def lightProbeUsage(self) -> LightProbeUsage: ...
    @lightProbeUsage.setter
    def lightProbeUsage(self, value: LightProbeUsage) -> LightProbeUsage: ...
    @property
    def localBounds(self) -> Bounds: ...
    @localBounds.setter
    def localBounds(self, value: Bounds) -> Bounds: ...
    @property
    def localToWorldMatrix(self) -> Matrix4x4: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> Material: ...
    @property
    def materials(self) -> Array_1[Material]: ...
    @materials.setter
    def materials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def motionVectorGenerationMode(self) -> MotionVectorGenerationMode: ...
    @motionVectorGenerationMode.setter
    def motionVectorGenerationMode(self, value: MotionVectorGenerationMode) -> MotionVectorGenerationMode: ...
    @property
    def motionVectors(self) -> bool: ...
    @motionVectors.setter
    def motionVectors(self, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def probeAnchor(self) -> Transform: ...
    @probeAnchor.setter
    def probeAnchor(self, value: Transform) -> Transform: ...
    @property
    def quality(self) -> SkinQuality: ...
    @quality.setter
    def quality(self, value: SkinQuality) -> SkinQuality: ...
    @property
    def rayTracingMode(self) -> RayTracingMode: ...
    @rayTracingMode.setter
    def rayTracingMode(self, value: RayTracingMode) -> RayTracingMode: ...
    @property
    def realtimeLightmapIndex(self) -> int: ...
    @realtimeLightmapIndex.setter
    def realtimeLightmapIndex(self, value: int) -> int: ...
    @property
    def realtimeLightmapScaleOffset(self) -> Vector4: ...
    @realtimeLightmapScaleOffset.setter
    def realtimeLightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def receiveShadows(self) -> bool: ...
    @receiveShadows.setter
    def receiveShadows(self, value: bool) -> bool: ...
    @property
    def reflectionProbeUsage(self) -> ReflectionProbeUsage: ...
    @reflectionProbeUsage.setter
    def reflectionProbeUsage(self, value: ReflectionProbeUsage) -> ReflectionProbeUsage: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rendererPriority(self) -> int: ...
    @rendererPriority.setter
    def rendererPriority(self, value: int) -> int: ...
    @property
    def renderingLayerMask(self) -> int: ...
    @renderingLayerMask.setter
    def renderingLayerMask(self, value: int) -> int: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def rootBone(self) -> Transform: ...
    @rootBone.setter
    def rootBone(self, value: Transform) -> Transform: ...
    @property
    def shadowCastingMode(self) -> ShadowCastingMode: ...
    @shadowCastingMode.setter
    def shadowCastingMode(self, value: ShadowCastingMode) -> ShadowCastingMode: ...
    @property
    def sharedMaterial(self) -> Material: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: Material) -> Material: ...
    @property
    def sharedMaterials(self) -> Array_1[Material]: ...
    @sharedMaterials.setter
    def sharedMaterials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def sharedMesh(self) -> Mesh: ...
    @sharedMesh.setter
    def sharedMesh(self, value: Mesh) -> Mesh: ...
    @property
    def skinnedMotionVectors(self) -> bool: ...
    @skinnedMotionVectors.setter
    def skinnedMotionVectors(self, value: bool) -> bool: ...
    @property
    def sortingLayerID(self) -> int: ...
    @sortingLayerID.setter
    def sortingLayerID(self, value: int) -> int: ...
    @property
    def sortingLayerName(self) -> str: ...
    @sortingLayerName.setter
    def sortingLayerName(self, value: str) -> str: ...
    @property
    def sortingOrder(self) -> int: ...
    @sortingOrder.setter
    def sortingOrder(self, value: int) -> int: ...
    @property
    def staticShadowCaster(self) -> bool: ...
    @staticShadowCaster.setter
    def staticShadowCaster(self, value: bool) -> bool: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def updateWhenOffscreen(self) -> bool: ...
    @updateWhenOffscreen.setter
    def updateWhenOffscreen(self, value: bool) -> bool: ...
    @property
    def useLightProbes(self) -> bool: ...
    @useLightProbes.setter
    def useLightProbes(self, value: bool) -> bool: ...
    @property
    def vertexBufferTarget(self) -> GraphicsBuffer.Target: ...
    @vertexBufferTarget.setter
    def vertexBufferTarget(self, value: GraphicsBuffer.Target) -> GraphicsBuffer.Target: ...
    @property
    def worldToLocalMatrix(self) -> Matrix4x4: ...
    def GetBlendShapeWeight(self, index: int) -> float: ...
    def GetPreviousVertexBuffer(self) -> GraphicsBuffer: ...
    def GetVertexBuffer(self) -> GraphicsBuffer: ...
    def SetBlendShapeWeight(self, index: int, value: float) -> None: ...
    # Skipped BakeMesh due to it being static, abstract and generic.

    BakeMesh : BakeMesh_MethodGroup
    class BakeMesh_MethodGroup:
        @typing.overload
        def __call__(self, mesh: Mesh) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, useScale: bool) -> None:...



class SkinQuality(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Auto : SkinQuality # 0
    Bone1 : SkinQuality # 1
    Bone2 : SkinQuality # 2
    Bone4 : SkinQuality # 4


class SkinWeights(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : SkinWeights # 0
    OneBone : SkinWeights # 1
    TwoBones : SkinWeights # 2
    FourBones : SkinWeights # 4
    Unlimited : SkinWeights # 255


class Skybox(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> Material: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class SleepTimeout:
    def __init__(self) -> None: ...
    NeverSleep : int
    SystemSetting : int


class SliderJoint2D(AnchoredJoint2D):
    def __init__(self) -> None: ...
    @property
    def anchor(self) -> Vector2: ...
    @anchor.setter
    def anchor(self, value: Vector2) -> Vector2: ...
    @property
    def angle(self) -> float: ...
    @angle.setter
    def angle(self, value: float) -> float: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoConfigureAngle(self) -> bool: ...
    @autoConfigureAngle.setter
    def autoConfigureAngle(self, value: bool) -> bool: ...
    @property
    def autoConfigureConnectedAnchor(self) -> bool: ...
    @autoConfigureConnectedAnchor.setter
    def autoConfigureConnectedAnchor(self, value: bool) -> bool: ...
    @property
    def breakAction(self) -> JointBreakAction2D: ...
    @breakAction.setter
    def breakAction(self, value: JointBreakAction2D) -> JointBreakAction2D: ...
    @property
    def breakForce(self) -> float: ...
    @breakForce.setter
    def breakForce(self, value: float) -> float: ...
    @property
    def breakTorque(self) -> float: ...
    @breakTorque.setter
    def breakTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collideConnected(self) -> bool: ...
    @collideConnected.setter
    def collideConnected(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def connectedAnchor(self) -> Vector2: ...
    @connectedAnchor.setter
    def connectedAnchor(self, value: Vector2) -> Vector2: ...
    @property
    def connectedBody(self) -> Rigidbody2D: ...
    @connectedBody.setter
    def connectedBody(self, value: Rigidbody2D) -> Rigidbody2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enableCollision(self) -> bool: ...
    @enableCollision.setter
    def enableCollision(self, value: bool) -> bool: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def jointSpeed(self) -> float: ...
    @property
    def jointTranslation(self) -> float: ...
    @property
    def light(self) -> Component: ...
    @property
    def limits(self) -> JointTranslationLimits2D: ...
    @limits.setter
    def limits(self, value: JointTranslationLimits2D) -> JointTranslationLimits2D: ...
    @property
    def limitState(self) -> JointLimitState2D: ...
    @property
    def motor(self) -> JointMotor2D: ...
    @motor.setter
    def motor(self, value: JointMotor2D) -> JointMotor2D: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def reactionForce(self) -> Vector2: ...
    @property
    def reactionTorque(self) -> float: ...
    @property
    def referenceAngle(self) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useLimits(self) -> bool: ...
    @useLimits.setter
    def useLimits(self, value: bool) -> bool: ...
    @property
    def useMotor(self) -> bool: ...
    @useMotor.setter
    def useMotor(self, value: bool) -> bool: ...
    def GetMotorForce(self, timeStep: float) -> float: ...


class SnapAxis(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : SnapAxis # 0
    X : SnapAxis # 1
    Y : SnapAxis # 2
    Z : SnapAxis # 4
    All : SnapAxis # 7


class Snapping(abc.ABC):
    # Skipped Snap due to it being static, abstract and generic.

    Snap : Snap_MethodGroup
    class Snap_MethodGroup:
        @typing.overload
        def __call__(self, val: float, snap: float) -> float:...
        @typing.overload
        def __call__(self, val: Vector2, snap: Vector2) -> Vector2:...
        @typing.overload
        def __call__(self, val: Vector3, snap: Vector3, axis: SnapAxis = ...) -> Vector3:...



class Social(abc.ABC):
    @classmethod
    @property
    def Active(cls) -> ISocialPlatform: ...
    @classmethod
    @Active.setter
    def Active(cls, value: ISocialPlatform) -> ISocialPlatform: ...
    @classmethod
    @property
    def localUser(cls) -> ILocalUser: ...
    @staticmethod
    def CreateAchievement() -> IAchievement: ...
    @staticmethod
    def CreateLeaderboard() -> ILeaderboard: ...
    @staticmethod
    def LoadAchievementDescriptions(callback: Action_1[Array_1[IAchievementDescription]]) -> None: ...
    @staticmethod
    def LoadAchievements(callback: Action_1[Array_1[IAchievement]]) -> None: ...
    @staticmethod
    def LoadScores(leaderboardID: str, callback: Action_1[Array_1[IScore]]) -> None: ...
    @staticmethod
    def LoadUsers(userIDs: Array_1[str], callback: Action_1[Array_1[IUserProfile]]) -> None: ...
    @staticmethod
    def ReportProgress(achievementID: str, progress: float, callback: Action_1[bool]) -> None: ...
    @staticmethod
    def ReportScore(score: int, board: str, callback: Action_1[bool]) -> None: ...
    @staticmethod
    def ShowAchievementsUI() -> None: ...
    @staticmethod
    def ShowLeaderboardUI() -> None: ...


class SoftJointLimit:
    @property
    def bounciness(self) -> float: ...
    @bounciness.setter
    def bounciness(self, value: float) -> float: ...
    @property
    def bouncyness(self) -> float: ...
    @bouncyness.setter
    def bouncyness(self, value: float) -> float: ...
    @property
    def contactDistance(self) -> float: ...
    @contactDistance.setter
    def contactDistance(self, value: float) -> float: ...
    @property
    def damper(self) -> float: ...
    @damper.setter
    def damper(self, value: float) -> float: ...
    @property
    def limit(self) -> float: ...
    @limit.setter
    def limit(self, value: float) -> float: ...
    @property
    def spring(self) -> float: ...
    @spring.setter
    def spring(self, value: float) -> float: ...


class SoftJointLimitSpring:
    @property
    def damper(self) -> float: ...
    @damper.setter
    def damper(self, value: float) -> float: ...
    @property
    def spring(self) -> float: ...
    @spring.setter
    def spring(self, value: float) -> float: ...


class SortingLayer:
    onLayerAdded : SortingLayer.LayerCallback
    onLayerRemoved : SortingLayer.LayerCallback
    @property
    def id(self) -> int: ...
    @classmethod
    @property
    def layers(cls) -> Array_1[SortingLayer]: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    @staticmethod
    def GetLayerValueFromID(id: int) -> int: ...
    @staticmethod
    def GetLayerValueFromName(name: str) -> int: ...
    @staticmethod
    def IDToName(id: int) -> str: ...
    @staticmethod
    def IsValid(id: int) -> bool: ...
    @staticmethod
    def NameToID(name: str) -> int: ...

    class LayerCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, layer: SortingLayer, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, layer: SortingLayer) -> None: ...



class Space(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    World : Space # 0
    Self : Space # 1


class SpaceAttribute(PropertyAttribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, height: float) -> None: ...
    height : float
    @property
    def order(self) -> int: ...
    @order.setter
    def order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class SparseTexture(Texture):
    @typing.overload
    def __init__(self, width: int, height: int, format: DefaultFormat, mipCount: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, format: GraphicsFormat, mipCount: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, textureFormat: TextureFormat, mipCount: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, textureFormat: TextureFormat, mipCount: int, linear: bool) -> None: ...
    @property
    def anisoLevel(self) -> int: ...
    @anisoLevel.setter
    def anisoLevel(self, value: int) -> int: ...
    @property
    def dimension(self) -> TextureDimension: ...
    @dimension.setter
    def dimension(self, value: TextureDimension) -> TextureDimension: ...
    @property
    def filterMode(self) -> FilterMode: ...
    @filterMode.setter
    def filterMode(self, value: FilterMode) -> FilterMode: ...
    @property
    def graphicsFormat(self) -> GraphicsFormat: ...
    @property
    def height(self) -> int: ...
    @height.setter
    def height(self, value: int) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def imageContentsHash(self) -> Hash128: ...
    @imageContentsHash.setter
    def imageContentsHash(self, value: Hash128) -> Hash128: ...
    @property
    def isCreated(self) -> bool: ...
    @property
    def isDataSRGB(self) -> bool: ...
    @property
    def isReadable(self) -> bool: ...
    @property
    def mipMapBias(self) -> float: ...
    @mipMapBias.setter
    def mipMapBias(self, value: float) -> float: ...
    @property
    def mipmapCount(self) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def texelSize(self) -> Vector2: ...
    @property
    def tileHeight(self) -> int: ...
    @property
    def tileWidth(self) -> int: ...
    @property
    def updateCount(self) -> int: ...
    @property
    def width(self) -> int: ...
    @width.setter
    def width(self, value: int) -> int: ...
    @property
    def wrapMode(self) -> TextureWrapMode: ...
    @wrapMode.setter
    def wrapMode(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeU(self) -> TextureWrapMode: ...
    @wrapModeU.setter
    def wrapModeU(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeV(self) -> TextureWrapMode: ...
    @wrapModeV.setter
    def wrapModeV(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeW(self) -> TextureWrapMode: ...
    @wrapModeW.setter
    def wrapModeW(self, value: TextureWrapMode) -> TextureWrapMode: ...
    def UnloadTile(self, tileX: int, tileY: int, miplevel: int) -> None: ...
    def UpdateTile(self, tileX: int, tileY: int, miplevel: int, data: Array_1[Color32]) -> None: ...
    def UpdateTileRaw(self, tileX: int, tileY: int, miplevel: int, data: Array_1[int]) -> None: ...


class SpherecastCommand:
    @typing.overload
    def __init__(self, origin: Vector3, radius: float, direction: Vector3, distance: float = ..., layerMask: int = ...) -> None: ...
    @typing.overload
    def __init__(self, origin: Vector3, radius: float, direction: Vector3, queryParameters: QueryParameters, distance: float = ...) -> None: ...
    @typing.overload
    def __init__(self, physicsScene: PhysicsScene, origin: Vector3, radius: float, direction: Vector3, distance: float = ..., layerMask: int = ...) -> None: ...
    @typing.overload
    def __init__(self, physicsScene: PhysicsScene, origin: Vector3, radius: float, direction: Vector3, queryParameters: QueryParameters, distance: float = ...) -> None: ...
    queryParameters : QueryParameters
    @property
    def direction(self) -> Vector3: ...
    @direction.setter
    def direction(self, value: Vector3) -> Vector3: ...
    @property
    def distance(self) -> float: ...
    @distance.setter
    def distance(self, value: float) -> float: ...
    @property
    def layerMask(self) -> int: ...
    @layerMask.setter
    def layerMask(self, value: int) -> int: ...
    @property
    def origin(self) -> Vector3: ...
    @origin.setter
    def origin(self, value: Vector3) -> Vector3: ...
    @property
    def physicsScene(self) -> PhysicsScene: ...
    @physicsScene.setter
    def physicsScene(self, value: PhysicsScene) -> PhysicsScene: ...
    @property
    def radius(self) -> float: ...
    @radius.setter
    def radius(self, value: float) -> float: ...
    # Skipped ScheduleBatch due to it being static, abstract and generic.

    ScheduleBatch : ScheduleBatch_MethodGroup
    class ScheduleBatch_MethodGroup:
        @typing.overload
        def __call__(self, commands: NativeArray_1[SpherecastCommand], results: NativeArray_1[RaycastHit], minCommandsPerJob: int, dependsOn: JobHandle = ...) -> JobHandle:...
        @typing.overload
        def __call__(self, commands: NativeArray_1[SpherecastCommand], results: NativeArray_1[RaycastHit], minCommandsPerJob: int, maxHits: int, dependsOn: JobHandle = ...) -> JobHandle:...



class SphereCollider(Collider):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedArticulationBody(self) -> ArticulationBody: ...
    @property
    def attachedRigidbody(self) -> Rigidbody: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def camera(self) -> Component: ...
    @property
    def center(self) -> Vector3: ...
    @center.setter
    def center(self, value: Vector3) -> Vector3: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def contactOffset(self) -> float: ...
    @contactOffset.setter
    def contactOffset(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hasModifiableContacts(self) -> bool: ...
    @hasModifiableContacts.setter
    def hasModifiableContacts(self, value: bool) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def isTrigger(self) -> bool: ...
    @isTrigger.setter
    def isTrigger(self, value: bool) -> bool: ...
    @property
    def layerOverridePriority(self) -> int: ...
    @layerOverridePriority.setter
    def layerOverridePriority(self, value: int) -> int: ...
    @property
    def light(self) -> Component: ...
    @property
    def material(self) -> PhysicMaterial: ...
    @material.setter
    def material(self, value: PhysicMaterial) -> PhysicMaterial: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def providesContacts(self) -> bool: ...
    @providesContacts.setter
    def providesContacts(self, value: bool) -> bool: ...
    @property
    def radius(self) -> float: ...
    @radius.setter
    def radius(self, value: float) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def sharedMaterial(self) -> PhysicMaterial: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: PhysicMaterial) -> PhysicMaterial: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class SplatPrototype:
    def __init__(self) -> None: ...
    @property
    def metallic(self) -> float: ...
    @metallic.setter
    def metallic(self, value: float) -> float: ...
    @property
    def normalMap(self) -> Texture2D: ...
    @normalMap.setter
    def normalMap(self, value: Texture2D) -> Texture2D: ...
    @property
    def smoothness(self) -> float: ...
    @smoothness.setter
    def smoothness(self, value: float) -> float: ...
    @property
    def specular(self) -> Color: ...
    @specular.setter
    def specular(self, value: Color) -> Color: ...
    @property
    def texture(self) -> Texture2D: ...
    @texture.setter
    def texture(self, value: Texture2D) -> Texture2D: ...
    @property
    def tileOffset(self) -> Vector2: ...
    @tileOffset.setter
    def tileOffset(self, value: Vector2) -> Vector2: ...
    @property
    def tileSize(self) -> Vector2: ...
    @tileSize.setter
    def tileSize(self, value: Vector2) -> Vector2: ...


class SpringJoint(Joint):
    def __init__(self) -> None: ...
    @property
    def anchor(self) -> Vector3: ...
    @anchor.setter
    def anchor(self, value: Vector3) -> Vector3: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoConfigureConnectedAnchor(self) -> bool: ...
    @autoConfigureConnectedAnchor.setter
    def autoConfigureConnectedAnchor(self, value: bool) -> bool: ...
    @property
    def axis(self) -> Vector3: ...
    @axis.setter
    def axis(self, value: Vector3) -> Vector3: ...
    @property
    def breakForce(self) -> float: ...
    @breakForce.setter
    def breakForce(self, value: float) -> float: ...
    @property
    def breakTorque(self) -> float: ...
    @breakTorque.setter
    def breakTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def connectedAnchor(self) -> Vector3: ...
    @connectedAnchor.setter
    def connectedAnchor(self, value: Vector3) -> Vector3: ...
    @property
    def connectedArticulationBody(self) -> ArticulationBody: ...
    @connectedArticulationBody.setter
    def connectedArticulationBody(self, value: ArticulationBody) -> ArticulationBody: ...
    @property
    def connectedBody(self) -> Rigidbody: ...
    @connectedBody.setter
    def connectedBody(self, value: Rigidbody) -> Rigidbody: ...
    @property
    def connectedMassScale(self) -> float: ...
    @connectedMassScale.setter
    def connectedMassScale(self, value: float) -> float: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def currentForce(self) -> Vector3: ...
    @property
    def currentTorque(self) -> Vector3: ...
    @property
    def damper(self) -> float: ...
    @damper.setter
    def damper(self, value: float) -> float: ...
    @property
    def enableCollision(self) -> bool: ...
    @enableCollision.setter
    def enableCollision(self, value: bool) -> bool: ...
    @property
    def enablePreprocessing(self) -> bool: ...
    @enablePreprocessing.setter
    def enablePreprocessing(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def light(self) -> Component: ...
    @property
    def massScale(self) -> float: ...
    @massScale.setter
    def massScale(self, value: float) -> float: ...
    @property
    def maxDistance(self) -> float: ...
    @maxDistance.setter
    def maxDistance(self, value: float) -> float: ...
    @property
    def minDistance(self) -> float: ...
    @minDistance.setter
    def minDistance(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def spring(self) -> float: ...
    @spring.setter
    def spring(self, value: float) -> float: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def tolerance(self) -> float: ...
    @tolerance.setter
    def tolerance(self, value: float) -> float: ...
    @property
    def transform(self) -> Transform: ...


class SpringJoint2D(AnchoredJoint2D):
    def __init__(self) -> None: ...
    @property
    def anchor(self) -> Vector2: ...
    @anchor.setter
    def anchor(self, value: Vector2) -> Vector2: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoConfigureConnectedAnchor(self) -> bool: ...
    @autoConfigureConnectedAnchor.setter
    def autoConfigureConnectedAnchor(self, value: bool) -> bool: ...
    @property
    def autoConfigureDistance(self) -> bool: ...
    @autoConfigureDistance.setter
    def autoConfigureDistance(self, value: bool) -> bool: ...
    @property
    def breakAction(self) -> JointBreakAction2D: ...
    @breakAction.setter
    def breakAction(self, value: JointBreakAction2D) -> JointBreakAction2D: ...
    @property
    def breakForce(self) -> float: ...
    @breakForce.setter
    def breakForce(self, value: float) -> float: ...
    @property
    def breakTorque(self) -> float: ...
    @breakTorque.setter
    def breakTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collideConnected(self) -> bool: ...
    @collideConnected.setter
    def collideConnected(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def connectedAnchor(self) -> Vector2: ...
    @connectedAnchor.setter
    def connectedAnchor(self, value: Vector2) -> Vector2: ...
    @property
    def connectedBody(self) -> Rigidbody2D: ...
    @connectedBody.setter
    def connectedBody(self, value: Rigidbody2D) -> Rigidbody2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def dampingRatio(self) -> float: ...
    @dampingRatio.setter
    def dampingRatio(self, value: float) -> float: ...
    @property
    def distance(self) -> float: ...
    @distance.setter
    def distance(self, value: float) -> float: ...
    @property
    def enableCollision(self) -> bool: ...
    @enableCollision.setter
    def enableCollision(self, value: bool) -> bool: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def frequency(self) -> float: ...
    @frequency.setter
    def frequency(self, value: float) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def reactionForce(self) -> Vector2: ...
    @property
    def reactionTorque(self) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class Sprite(Object):
    @property
    def associatedAlphaSplitTexture(self) -> Texture2D: ...
    @property
    def border(self) -> Vector4: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def packed(self) -> bool: ...
    @property
    def packingMode(self) -> SpritePackingMode: ...
    @property
    def packingRotation(self) -> SpritePackingRotation: ...
    @property
    def pivot(self) -> Vector2: ...
    @property
    def pixelsPerUnit(self) -> float: ...
    @property
    def rect(self) -> Rect: ...
    @property
    def spriteAtlasTextureScale(self) -> float: ...
    @property
    def texture(self) -> Texture2D: ...
    @property
    def textureRect(self) -> Rect: ...
    @property
    def textureRectOffset(self) -> Vector2: ...
    @property
    def triangles(self) -> Array_1[int]: ...
    @property
    def uv(self) -> Array_1[Vector2]: ...
    @property
    def vertices(self) -> Array_1[Vector2]: ...
    def GetPhysicsShape(self, shapeIdx: int, physicsShape: List_1[Vector2]) -> int: ...
    def GetPhysicsShapeCount(self) -> int: ...
    def GetPhysicsShapePointCount(self, shapeIdx: int) -> int: ...
    def GetSecondaryTextureCount(self) -> int: ...
    def GetSecondaryTextures(self, secondaryTexture: Array_1[SecondarySpriteTexture]) -> int: ...
    def OverrideGeometry(self, vertices: Array_1[Vector2], triangles: Array_1[int]) -> None: ...
    def OverridePhysicsShape(self, physicsShapes: IList_1[Array_1[Vector2]]) -> None: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self, texture: Texture2D, rect: Rect, pivot: Vector2) -> Sprite:...
        @typing.overload
        def __call__(self, texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: float) -> Sprite:...
        @typing.overload
        def __call__(self, texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: float, extrude: int) -> Sprite:...
        @typing.overload
        def __call__(self, texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: float, extrude: int, meshType: SpriteMeshType) -> Sprite:...
        @typing.overload
        def __call__(self, texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: float, extrude: int, meshType: SpriteMeshType, border: Vector4) -> Sprite:...
        @typing.overload
        def __call__(self, texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: float, extrude: int, meshType: SpriteMeshType, border: Vector4, generateFallbackPhysicsShape: bool) -> Sprite:...
        @typing.overload
        def __call__(self, texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: float, extrude: int, meshType: SpriteMeshType, border: Vector4, generateFallbackPhysicsShape: bool, secondaryTextures: Array_1[SecondarySpriteTexture]) -> Sprite:...



class SpriteAlignment(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Center : SpriteAlignment # 0
    TopLeft : SpriteAlignment # 1
    TopCenter : SpriteAlignment # 2
    TopRight : SpriteAlignment # 3
    LeftCenter : SpriteAlignment # 4
    RightCenter : SpriteAlignment # 5
    BottomLeft : SpriteAlignment # 6
    BottomCenter : SpriteAlignment # 7
    BottomRight : SpriteAlignment # 8
    Custom : SpriteAlignment # 9


class SpriteDrawMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Simple : SpriteDrawMode # 0
    Sliced : SpriteDrawMode # 1
    Tiled : SpriteDrawMode # 2


class SpriteMask(Renderer):
    def __init__(self) -> None: ...
    @property
    def allowOcclusionWhenDynamic(self) -> bool: ...
    @allowOcclusionWhenDynamic.setter
    def allowOcclusionWhenDynamic(self, value: bool) -> bool: ...
    @property
    def alphaCutoff(self) -> float: ...
    @alphaCutoff.setter
    def alphaCutoff(self, value: float) -> float: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def backSortingLayerID(self) -> int: ...
    @backSortingLayerID.setter
    def backSortingLayerID(self, value: int) -> int: ...
    @property
    def backSortingOrder(self) -> int: ...
    @backSortingOrder.setter
    def backSortingOrder(self, value: int) -> int: ...
    @property
    def bounds(self) -> Bounds: ...
    @bounds.setter
    def bounds(self, value: Bounds) -> Bounds: ...
    @property
    def camera(self) -> Component: ...
    @property
    def castShadows(self) -> bool: ...
    @castShadows.setter
    def castShadows(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def forceRenderingOff(self) -> bool: ...
    @forceRenderingOff.setter
    def forceRenderingOff(self, value: bool) -> bool: ...
    @property
    def frontSortingLayerID(self) -> int: ...
    @frontSortingLayerID.setter
    def frontSortingLayerID(self, value: int) -> int: ...
    @property
    def frontSortingOrder(self) -> int: ...
    @frontSortingOrder.setter
    def frontSortingOrder(self, value: int) -> int: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isCustomRangeActive(self) -> bool: ...
    @isCustomRangeActive.setter
    def isCustomRangeActive(self, value: bool) -> bool: ...
    @property
    def isPartOfStaticBatch(self) -> bool: ...
    @property
    def isVisible(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def lightmapIndex(self) -> int: ...
    @lightmapIndex.setter
    def lightmapIndex(self, value: int) -> int: ...
    @property
    def lightmapScaleOffset(self) -> Vector4: ...
    @lightmapScaleOffset.setter
    def lightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightmapTilingOffset(self) -> Vector4: ...
    @lightmapTilingOffset.setter
    def lightmapTilingOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightProbeAnchor(self) -> Transform: ...
    @lightProbeAnchor.setter
    def lightProbeAnchor(self, value: Transform) -> Transform: ...
    @property
    def lightProbeProxyVolumeOverride(self) -> GameObject: ...
    @lightProbeProxyVolumeOverride.setter
    def lightProbeProxyVolumeOverride(self, value: GameObject) -> GameObject: ...
    @property
    def lightProbeUsage(self) -> LightProbeUsage: ...
    @lightProbeUsage.setter
    def lightProbeUsage(self, value: LightProbeUsage) -> LightProbeUsage: ...
    @property
    def localBounds(self) -> Bounds: ...
    @localBounds.setter
    def localBounds(self, value: Bounds) -> Bounds: ...
    @property
    def localToWorldMatrix(self) -> Matrix4x4: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> Material: ...
    @property
    def materials(self) -> Array_1[Material]: ...
    @materials.setter
    def materials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def motionVectorGenerationMode(self) -> MotionVectorGenerationMode: ...
    @motionVectorGenerationMode.setter
    def motionVectorGenerationMode(self, value: MotionVectorGenerationMode) -> MotionVectorGenerationMode: ...
    @property
    def motionVectors(self) -> bool: ...
    @motionVectors.setter
    def motionVectors(self, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def probeAnchor(self) -> Transform: ...
    @probeAnchor.setter
    def probeAnchor(self, value: Transform) -> Transform: ...
    @property
    def rayTracingMode(self) -> RayTracingMode: ...
    @rayTracingMode.setter
    def rayTracingMode(self, value: RayTracingMode) -> RayTracingMode: ...
    @property
    def realtimeLightmapIndex(self) -> int: ...
    @realtimeLightmapIndex.setter
    def realtimeLightmapIndex(self, value: int) -> int: ...
    @property
    def realtimeLightmapScaleOffset(self) -> Vector4: ...
    @realtimeLightmapScaleOffset.setter
    def realtimeLightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def receiveShadows(self) -> bool: ...
    @receiveShadows.setter
    def receiveShadows(self, value: bool) -> bool: ...
    @property
    def reflectionProbeUsage(self) -> ReflectionProbeUsage: ...
    @reflectionProbeUsage.setter
    def reflectionProbeUsage(self, value: ReflectionProbeUsage) -> ReflectionProbeUsage: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rendererPriority(self) -> int: ...
    @rendererPriority.setter
    def rendererPriority(self, value: int) -> int: ...
    @property
    def renderingLayerMask(self) -> int: ...
    @renderingLayerMask.setter
    def renderingLayerMask(self, value: int) -> int: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def shadowCastingMode(self) -> ShadowCastingMode: ...
    @shadowCastingMode.setter
    def shadowCastingMode(self, value: ShadowCastingMode) -> ShadowCastingMode: ...
    @property
    def sharedMaterial(self) -> Material: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: Material) -> Material: ...
    @property
    def sharedMaterials(self) -> Array_1[Material]: ...
    @sharedMaterials.setter
    def sharedMaterials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def sortingLayerID(self) -> int: ...
    @sortingLayerID.setter
    def sortingLayerID(self, value: int) -> int: ...
    @property
    def sortingLayerName(self) -> str: ...
    @sortingLayerName.setter
    def sortingLayerName(self, value: str) -> str: ...
    @property
    def sortingOrder(self) -> int: ...
    @sortingOrder.setter
    def sortingOrder(self, value: int) -> int: ...
    @property
    def sprite(self) -> Sprite: ...
    @sprite.setter
    def sprite(self, value: Sprite) -> Sprite: ...
    @property
    def spriteSortPoint(self) -> SpriteSortPoint: ...
    @spriteSortPoint.setter
    def spriteSortPoint(self, value: SpriteSortPoint) -> SpriteSortPoint: ...
    @property
    def staticShadowCaster(self) -> bool: ...
    @staticShadowCaster.setter
    def staticShadowCaster(self, value: bool) -> bool: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useLightProbes(self) -> bool: ...
    @useLightProbes.setter
    def useLightProbes(self, value: bool) -> bool: ...
    @property
    def worldToLocalMatrix(self) -> Matrix4x4: ...


class SpriteMaskInteraction(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : SpriteMaskInteraction # 0
    VisibleInsideMask : SpriteMaskInteraction # 1
    VisibleOutsideMask : SpriteMaskInteraction # 2


class SpriteMaskUtility(abc.ABC):
    @staticmethod
    def HasSpriteMaskInScene() -> bool: ...


class SpriteMeshType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    FullRect : SpriteMeshType # 0
    Tight : SpriteMeshType # 1


class SpritePackingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Tight : SpritePackingMode # 0
    Rectangle : SpritePackingMode # 1


class SpritePackingRotation(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : SpritePackingRotation # 0
    FlipHorizontal : SpritePackingRotation # 1
    FlipVertical : SpritePackingRotation # 2
    Rotate180 : SpritePackingRotation # 3
    Any : SpritePackingRotation # 15


class SpriteRenderer(Renderer):
    def __init__(self) -> None: ...
    @property
    def adaptiveModeThreshold(self) -> float: ...
    @adaptiveModeThreshold.setter
    def adaptiveModeThreshold(self, value: float) -> float: ...
    @property
    def allowOcclusionWhenDynamic(self) -> bool: ...
    @allowOcclusionWhenDynamic.setter
    def allowOcclusionWhenDynamic(self, value: bool) -> bool: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounds(self) -> Bounds: ...
    @bounds.setter
    def bounds(self, value: Bounds) -> Bounds: ...
    @property
    def camera(self) -> Component: ...
    @property
    def castShadows(self) -> bool: ...
    @castShadows.setter
    def castShadows(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def color(self) -> Color: ...
    @color.setter
    def color(self, value: Color) -> Color: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def drawMode(self) -> SpriteDrawMode: ...
    @drawMode.setter
    def drawMode(self, value: SpriteDrawMode) -> SpriteDrawMode: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def flipX(self) -> bool: ...
    @flipX.setter
    def flipX(self, value: bool) -> bool: ...
    @property
    def flipY(self) -> bool: ...
    @flipY.setter
    def flipY(self, value: bool) -> bool: ...
    @property
    def forceRenderingOff(self) -> bool: ...
    @forceRenderingOff.setter
    def forceRenderingOff(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isPartOfStaticBatch(self) -> bool: ...
    @property
    def isVisible(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def lightmapIndex(self) -> int: ...
    @lightmapIndex.setter
    def lightmapIndex(self, value: int) -> int: ...
    @property
    def lightmapScaleOffset(self) -> Vector4: ...
    @lightmapScaleOffset.setter
    def lightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightmapTilingOffset(self) -> Vector4: ...
    @lightmapTilingOffset.setter
    def lightmapTilingOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightProbeAnchor(self) -> Transform: ...
    @lightProbeAnchor.setter
    def lightProbeAnchor(self, value: Transform) -> Transform: ...
    @property
    def lightProbeProxyVolumeOverride(self) -> GameObject: ...
    @lightProbeProxyVolumeOverride.setter
    def lightProbeProxyVolumeOverride(self, value: GameObject) -> GameObject: ...
    @property
    def lightProbeUsage(self) -> LightProbeUsage: ...
    @lightProbeUsage.setter
    def lightProbeUsage(self, value: LightProbeUsage) -> LightProbeUsage: ...
    @property
    def localBounds(self) -> Bounds: ...
    @localBounds.setter
    def localBounds(self, value: Bounds) -> Bounds: ...
    @property
    def localToWorldMatrix(self) -> Matrix4x4: ...
    @property
    def maskInteraction(self) -> SpriteMaskInteraction: ...
    @maskInteraction.setter
    def maskInteraction(self, value: SpriteMaskInteraction) -> SpriteMaskInteraction: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> Material: ...
    @property
    def materials(self) -> Array_1[Material]: ...
    @materials.setter
    def materials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def motionVectorGenerationMode(self) -> MotionVectorGenerationMode: ...
    @motionVectorGenerationMode.setter
    def motionVectorGenerationMode(self, value: MotionVectorGenerationMode) -> MotionVectorGenerationMode: ...
    @property
    def motionVectors(self) -> bool: ...
    @motionVectors.setter
    def motionVectors(self, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def probeAnchor(self) -> Transform: ...
    @probeAnchor.setter
    def probeAnchor(self, value: Transform) -> Transform: ...
    @property
    def rayTracingMode(self) -> RayTracingMode: ...
    @rayTracingMode.setter
    def rayTracingMode(self, value: RayTracingMode) -> RayTracingMode: ...
    @property
    def realtimeLightmapIndex(self) -> int: ...
    @realtimeLightmapIndex.setter
    def realtimeLightmapIndex(self, value: int) -> int: ...
    @property
    def realtimeLightmapScaleOffset(self) -> Vector4: ...
    @realtimeLightmapScaleOffset.setter
    def realtimeLightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def receiveShadows(self) -> bool: ...
    @receiveShadows.setter
    def receiveShadows(self, value: bool) -> bool: ...
    @property
    def reflectionProbeUsage(self) -> ReflectionProbeUsage: ...
    @reflectionProbeUsage.setter
    def reflectionProbeUsage(self, value: ReflectionProbeUsage) -> ReflectionProbeUsage: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rendererPriority(self) -> int: ...
    @rendererPriority.setter
    def rendererPriority(self, value: int) -> int: ...
    @property
    def renderingLayerMask(self) -> int: ...
    @renderingLayerMask.setter
    def renderingLayerMask(self, value: int) -> int: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def shadowCastingMode(self) -> ShadowCastingMode: ...
    @shadowCastingMode.setter
    def shadowCastingMode(self, value: ShadowCastingMode) -> ShadowCastingMode: ...
    @property
    def sharedMaterial(self) -> Material: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: Material) -> Material: ...
    @property
    def sharedMaterials(self) -> Array_1[Material]: ...
    @sharedMaterials.setter
    def sharedMaterials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def size(self) -> Vector2: ...
    @size.setter
    def size(self, value: Vector2) -> Vector2: ...
    @property
    def sortingLayerID(self) -> int: ...
    @sortingLayerID.setter
    def sortingLayerID(self, value: int) -> int: ...
    @property
    def sortingLayerName(self) -> str: ...
    @sortingLayerName.setter
    def sortingLayerName(self, value: str) -> str: ...
    @property
    def sortingOrder(self) -> int: ...
    @sortingOrder.setter
    def sortingOrder(self, value: int) -> int: ...
    @property
    def sprite(self) -> Sprite: ...
    @sprite.setter
    def sprite(self, value: Sprite) -> Sprite: ...
    @property
    def spriteSortPoint(self) -> SpriteSortPoint: ...
    @spriteSortPoint.setter
    def spriteSortPoint(self, value: SpriteSortPoint) -> SpriteSortPoint: ...
    @property
    def staticShadowCaster(self) -> bool: ...
    @staticShadowCaster.setter
    def staticShadowCaster(self, value: bool) -> bool: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def tileMode(self) -> SpriteTileMode: ...
    @tileMode.setter
    def tileMode(self, value: SpriteTileMode) -> SpriteTileMode: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useLightProbes(self) -> bool: ...
    @useLightProbes.setter
    def useLightProbes(self, value: bool) -> bool: ...
    @property
    def worldToLocalMatrix(self) -> Matrix4x4: ...
    def RegisterSpriteChangeCallback(self, callback: UnityAction_1[SpriteRenderer]) -> None: ...
    def UnregisterSpriteChangeCallback(self, callback: UnityAction_1[SpriteRenderer]) -> None: ...


class SpriteSortPoint(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Center : SpriteSortPoint # 0
    Pivot : SpriteSortPoint # 1


class SpriteTileMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Continuous : SpriteTileMode # 0
    Adaptive : SpriteTileMode # 1


class StackTraceLogType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : StackTraceLogType # 0
    ScriptOnly : StackTraceLogType # 1
    Full : StackTraceLogType # 2


class StackTraceUtility(abc.ABC):
    @staticmethod
    def ExtractStackTrace() -> str: ...
    @staticmethod
    def ExtractStringFromException(exception: typing.Any) -> str: ...


class StandaloneRenderResize(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Enabled : StandaloneRenderResize # 0
    Disabled : StandaloneRenderResize # 1


class StateMachineBehaviour(ScriptableObject, abc.ABC):
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    # Skipped OnStateEnter due to it being static, abstract and generic.

    OnStateEnter : OnStateEnter_MethodGroup
    class OnStateEnter_MethodGroup:
        @typing.overload
        def __call__(self, animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: int) -> None:...
        @typing.overload
        def __call__(self, animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: int, controller: AnimatorControllerPlayable) -> None:...

    # Skipped OnStateExit due to it being static, abstract and generic.

    OnStateExit : OnStateExit_MethodGroup
    class OnStateExit_MethodGroup:
        @typing.overload
        def __call__(self, animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: int) -> None:...
        @typing.overload
        def __call__(self, animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: int, controller: AnimatorControllerPlayable) -> None:...

    # Skipped OnStateIK due to it being static, abstract and generic.

    OnStateIK : OnStateIK_MethodGroup
    class OnStateIK_MethodGroup:
        @typing.overload
        def __call__(self, animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: int) -> None:...
        @typing.overload
        def __call__(self, animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: int, controller: AnimatorControllerPlayable) -> None:...

    # Skipped OnStateMachineEnter due to it being static, abstract and generic.

    OnStateMachineEnter : OnStateMachineEnter_MethodGroup
    class OnStateMachineEnter_MethodGroup:
        @typing.overload
        def __call__(self, animator: Animator, stateMachinePathHash: int) -> None:...
        @typing.overload
        def __call__(self, animator: Animator, stateMachinePathHash: int, controller: AnimatorControllerPlayable) -> None:...

    # Skipped OnStateMachineExit due to it being static, abstract and generic.

    OnStateMachineExit : OnStateMachineExit_MethodGroup
    class OnStateMachineExit_MethodGroup:
        @typing.overload
        def __call__(self, animator: Animator, stateMachinePathHash: int) -> None:...
        @typing.overload
        def __call__(self, animator: Animator, stateMachinePathHash: int, controller: AnimatorControllerPlayable) -> None:...

    # Skipped OnStateMove due to it being static, abstract and generic.

    OnStateMove : OnStateMove_MethodGroup
    class OnStateMove_MethodGroup:
        @typing.overload
        def __call__(self, animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: int) -> None:...
        @typing.overload
        def __call__(self, animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: int, controller: AnimatorControllerPlayable) -> None:...

    # Skipped OnStateUpdate due to it being static, abstract and generic.

    OnStateUpdate : OnStateUpdate_MethodGroup
    class OnStateUpdate_MethodGroup:
        @typing.overload
        def __call__(self, animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: int) -> None:...
        @typing.overload
        def __call__(self, animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: int, controller: AnimatorControllerPlayable) -> None:...



class StaticBatchingUtility:
    def __init__(self) -> None: ...
    # Skipped Combine due to it being static, abstract and generic.

    Combine : Combine_MethodGroup
    class Combine_MethodGroup:
        @typing.overload
        def __call__(self, staticBatchRoot: GameObject) -> None:...
        @typing.overload
        def __call__(self, gos: Array_1[GameObject], staticBatchRoot: GameObject) -> None:...



class StereoTargetEyeMask(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : StereoTargetEyeMask # 0
    Left : StereoTargetEyeMask # 1
    Right : StereoTargetEyeMask # 2
    Both : StereoTargetEyeMask # 3


class StreamingController(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def streamingMipmapBias(self) -> float: ...
    @streamingMipmapBias.setter
    def streamingMipmapBias(self, value: float) -> float: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    def CancelPreloading(self) -> None: ...
    def IsPreloading(self) -> bool: ...
    def SetPreloading(self, timeoutSeconds: float = ..., activateCameraOnTimeout: bool = ..., disableCameraCuttingFrom: Camera = ...) -> None: ...


class Subsystem_GenericClasses(abc.ABCMeta):
    Generic_Subsystem_GenericClasses_Subsystem_1_TSubsystemDescriptor = typing.TypeVar('Generic_Subsystem_GenericClasses_Subsystem_1_TSubsystemDescriptor')
    def __getitem__(self, types : typing.Type[Generic_Subsystem_GenericClasses_Subsystem_1_TSubsystemDescriptor]) -> typing.Type[Subsystem_1[Generic_Subsystem_GenericClasses_Subsystem_1_TSubsystemDescriptor]]: ...

class Subsystem(Subsystem_0, metaclass =Subsystem_GenericClasses): ...

class Subsystem_0(ISubsystem, abc.ABC):
    @property
    def running(self) -> bool: ...
    def Destroy(self) -> None: ...
    @abc.abstractmethod
    def Start(self) -> None: ...
    @abc.abstractmethod
    def Stop(self) -> None: ...


Subsystem_1_TSubsystemDescriptor = typing.TypeVar('Subsystem_1_TSubsystemDescriptor')
class Subsystem_1(typing.Generic[Subsystem_1_TSubsystemDescriptor], Subsystem_0):
    @property
    def running(self) -> bool: ...
    @property
    def SubsystemDescriptor(self) -> Subsystem_1_TSubsystemDescriptor: ...


class SubsystemDescriptor_GenericClasses(abc.ABCMeta):
    Generic_SubsystemDescriptor_GenericClasses_SubsystemDescriptor_1_TSubsystem = typing.TypeVar('Generic_SubsystemDescriptor_GenericClasses_SubsystemDescriptor_1_TSubsystem')
    def __getitem__(self, types : typing.Type[Generic_SubsystemDescriptor_GenericClasses_SubsystemDescriptor_1_TSubsystem]) -> typing.Type[SubsystemDescriptor_1[Generic_SubsystemDescriptor_GenericClasses_SubsystemDescriptor_1_TSubsystem]]: ...

class SubsystemDescriptor(SubsystemDescriptor_0, metaclass =SubsystemDescriptor_GenericClasses): ...

class SubsystemDescriptor_0(ISubsystemDescriptor, abc.ABC):
    @property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> str: ...
    @property
    def subsystemImplementationType(self) -> typing.Type[typing.Any]: ...
    @subsystemImplementationType.setter
    def subsystemImplementationType(self, value: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...


SubsystemDescriptor_1_TSubsystem = typing.TypeVar('SubsystemDescriptor_1_TSubsystem')
class SubsystemDescriptor_1(typing.Generic[SubsystemDescriptor_1_TSubsystem], SubsystemDescriptor_0):
    def __init__(self) -> None: ...
    @property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> str: ...
    @property
    def subsystemImplementationType(self) -> typing.Type[typing.Any]: ...
    @subsystemImplementationType.setter
    def subsystemImplementationType(self, value: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    def Create(self) -> SubsystemDescriptor_1_TSubsystem: ...


class SubsystemManager(abc.ABC):
    @staticmethod
    def GetAllSubsystemDescriptors(descriptors: List_1[ISubsystemDescriptor]) -> None: ...
    # Skipped GetInstances due to it being static, abstract and generic.

    GetInstances : GetInstances_MethodGroup
    class GetInstances_MethodGroup:
        def __getitem__(self, t:typing.Type[GetInstances_1_T1]) -> GetInstances_1[GetInstances_1_T1]: ...

        GetInstances_1_T1 = typing.TypeVar('GetInstances_1_T1')
        class GetInstances_1(typing.Generic[GetInstances_1_T1]):
            GetInstances_1_T = SubsystemManager.GetInstances_MethodGroup.GetInstances_1_T1
            def __call__(self, subsystems: List_1[GetInstances_1_T]) -> None:...


    # Skipped GetSubsystemDescriptors due to it being static, abstract and generic.

    GetSubsystemDescriptors : GetSubsystemDescriptors_MethodGroup
    class GetSubsystemDescriptors_MethodGroup:
        def __getitem__(self, t:typing.Type[GetSubsystemDescriptors_1_T1]) -> GetSubsystemDescriptors_1[GetSubsystemDescriptors_1_T1]: ...

        GetSubsystemDescriptors_1_T1 = typing.TypeVar('GetSubsystemDescriptors_1_T1')
        class GetSubsystemDescriptors_1(typing.Generic[GetSubsystemDescriptors_1_T1]):
            GetSubsystemDescriptors_1_T = SubsystemManager.GetSubsystemDescriptors_MethodGroup.GetSubsystemDescriptors_1_T1
            def __call__(self, descriptors: List_1[GetSubsystemDescriptors_1_T]) -> None:...


    # Skipped GetSubsystems due to it being static, abstract and generic.

    GetSubsystems : GetSubsystems_MethodGroup
    class GetSubsystems_MethodGroup:
        def __getitem__(self, t:typing.Type[GetSubsystems_1_T1]) -> GetSubsystems_1[GetSubsystems_1_T1]: ...

        GetSubsystems_1_T1 = typing.TypeVar('GetSubsystems_1_T1')
        class GetSubsystems_1(typing.Generic[GetSubsystems_1_T1]):
            GetSubsystems_1_T = SubsystemManager.GetSubsystems_MethodGroup.GetSubsystems_1_T1
            def __call__(self, subsystems: List_1[GetSubsystems_1_T]) -> None:...




class SurfaceEffector2D(Effector2D):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def colliderMask(self) -> int: ...
    @colliderMask.setter
    def colliderMask(self, value: int) -> int: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def forceScale(self) -> float: ...
    @forceScale.setter
    def forceScale(self, value: float) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def speed(self) -> float: ...
    @speed.setter
    def speed(self, value: float) -> float: ...
    @property
    def speedVariation(self) -> float: ...
    @speedVariation.setter
    def speedVariation(self, value: float) -> float: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useBounce(self) -> bool: ...
    @useBounce.setter
    def useBounce(self, value: bool) -> bool: ...
    @property
    def useColliderMask(self) -> bool: ...
    @useColliderMask.setter
    def useColliderMask(self, value: bool) -> bool: ...
    @property
    def useContactForce(self) -> bool: ...
    @useContactForce.setter
    def useContactForce(self, value: bool) -> bool: ...
    @property
    def useFriction(self) -> bool: ...
    @useFriction.setter
    def useFriction(self, value: bool) -> bool: ...


class SystemInfo:
    def __init__(self) -> None: ...
    unsupportedIdentifier : str
    @classmethod
    @property
    def batteryLevel(cls) -> float: ...
    @classmethod
    @property
    def batteryStatus(cls) -> BatteryStatus: ...
    @classmethod
    @property
    def computeSubGroupSize(cls) -> int: ...
    @classmethod
    @property
    def constantBufferOffsetAlignment(cls) -> int: ...
    @classmethod
    @property
    def copyTextureSupport(cls) -> CopyTextureSupport: ...
    @classmethod
    @property
    def deviceModel(cls) -> str: ...
    @classmethod
    @property
    def deviceName(cls) -> str: ...
    @classmethod
    @property
    def deviceType(cls) -> DeviceType: ...
    @classmethod
    @property
    def deviceUniqueIdentifier(cls) -> str: ...
    @classmethod
    @property
    def foveatedRenderingCaps(cls) -> FoveatedRenderingCaps: ...
    @classmethod
    @property
    def graphicsDeviceID(cls) -> int: ...
    @classmethod
    @property
    def graphicsDeviceName(cls) -> str: ...
    @classmethod
    @property
    def graphicsDeviceType(cls) -> GraphicsDeviceType: ...
    @classmethod
    @property
    def graphicsDeviceVendor(cls) -> str: ...
    @classmethod
    @property
    def graphicsDeviceVendorID(cls) -> int: ...
    @classmethod
    @property
    def graphicsDeviceVersion(cls) -> str: ...
    @classmethod
    @property
    def graphicsMemorySize(cls) -> int: ...
    @classmethod
    @property
    def graphicsMultiThreaded(cls) -> bool: ...
    @classmethod
    @property
    def graphicsPixelFillrate(cls) -> int: ...
    @classmethod
    @property
    def graphicsShaderLevel(cls) -> int: ...
    @classmethod
    @property
    def graphicsUVStartsAtTop(cls) -> bool: ...
    @classmethod
    @property
    def hasDynamicUniformArrayIndexingInFragmentShaders(cls) -> bool: ...
    @classmethod
    @property
    def hasHiddenSurfaceRemovalOnGPU(cls) -> bool: ...
    @classmethod
    @property
    def hasMipMaxLevel(cls) -> bool: ...
    @classmethod
    @property
    def hdrDisplaySupportFlags(cls) -> HDRDisplaySupportFlags: ...
    @classmethod
    @property
    def maxComputeBufferInputsCompute(cls) -> int: ...
    @classmethod
    @property
    def maxComputeBufferInputsDomain(cls) -> int: ...
    @classmethod
    @property
    def maxComputeBufferInputsFragment(cls) -> int: ...
    @classmethod
    @property
    def maxComputeBufferInputsGeometry(cls) -> int: ...
    @classmethod
    @property
    def maxComputeBufferInputsHull(cls) -> int: ...
    @classmethod
    @property
    def maxComputeBufferInputsVertex(cls) -> int: ...
    @classmethod
    @property
    def maxComputeWorkGroupSize(cls) -> int: ...
    @classmethod
    @property
    def maxComputeWorkGroupSizeX(cls) -> int: ...
    @classmethod
    @property
    def maxComputeWorkGroupSizeY(cls) -> int: ...
    @classmethod
    @property
    def maxComputeWorkGroupSizeZ(cls) -> int: ...
    @classmethod
    @property
    def maxConstantBufferSize(cls) -> int: ...
    @classmethod
    @property
    def maxCubemapSize(cls) -> int: ...
    @classmethod
    @property
    def maxGraphicsBufferSize(cls) -> int: ...
    @classmethod
    @property
    def maxTexture3DSize(cls) -> int: ...
    @classmethod
    @property
    def maxTextureArraySlices(cls) -> int: ...
    @classmethod
    @property
    def maxTextureSize(cls) -> int: ...
    @classmethod
    @property
    def minConstantBufferOffsetAlignment(cls) -> bool: ...
    @classmethod
    @property
    def npotSupport(cls) -> NPOTSupport: ...
    @classmethod
    @property
    def operatingSystem(cls) -> str: ...
    @classmethod
    @property
    def operatingSystemFamily(cls) -> OperatingSystemFamily: ...
    @classmethod
    @property
    def processorCount(cls) -> int: ...
    @classmethod
    @property
    def processorFrequency(cls) -> int: ...
    @classmethod
    @property
    def processorType(cls) -> str: ...
    @classmethod
    @property
    def renderingThreadingMode(cls) -> RenderingThreadingMode: ...
    @classmethod
    @property
    def supportedRandomWriteTargetCount(cls) -> int: ...
    @classmethod
    @property
    def supportedRenderTargetCount(cls) -> int: ...
    @classmethod
    @property
    def supports2DArrayTextures(cls) -> bool: ...
    @classmethod
    @property
    def supports32bitsIndexBuffer(cls) -> bool: ...
    @classmethod
    @property
    def supports3DRenderTextures(cls) -> bool: ...
    @classmethod
    @property
    def supports3DTextures(cls) -> bool: ...
    @classmethod
    @property
    def supportsAccelerometer(cls) -> bool: ...
    @classmethod
    @property
    def supportsAsyncCompute(cls) -> bool: ...
    @classmethod
    @property
    def supportsAsyncGPUReadback(cls) -> bool: ...
    @classmethod
    @property
    def supportsAudio(cls) -> bool: ...
    @classmethod
    @property
    def supportsCompressed3DTextures(cls) -> bool: ...
    @classmethod
    @property
    def supportsComputeShaders(cls) -> bool: ...
    @classmethod
    @property
    def supportsConservativeRaster(cls) -> bool: ...
    @classmethod
    @property
    def supportsCubemapArrayTextures(cls) -> bool: ...
    @classmethod
    @property
    def supportsGeometryShaders(cls) -> bool: ...
    @classmethod
    @property
    def supportsGPUFence(cls) -> bool: ...
    @classmethod
    @property
    def supportsGpuRecorder(cls) -> bool: ...
    @classmethod
    @property
    def supportsGraphicsFence(cls) -> bool: ...
    @classmethod
    @property
    def supportsGyroscope(cls) -> bool: ...
    @classmethod
    @property
    def supportsHardwareQuadTopology(cls) -> bool: ...
    @classmethod
    @property
    def supportsImageEffects(cls) -> bool: ...
    @classmethod
    @property
    def supportsIndirectArgumentsBuffer(cls) -> bool: ...
    @classmethod
    @property
    def supportsInstancing(cls) -> bool: ...
    @classmethod
    @property
    def supportsLocationService(cls) -> bool: ...
    @classmethod
    @property
    def supportsMipStreaming(cls) -> bool: ...
    @classmethod
    @property
    def supportsMotionVectors(cls) -> bool: ...
    @classmethod
    @property
    def supportsMultisampleAutoResolve(cls) -> bool: ...
    @classmethod
    @property
    def supportsMultisampled2DArrayTextures(cls) -> bool: ...
    @classmethod
    @property
    def supportsMultisampledTextures(cls) -> int: ...
    @classmethod
    @property
    def supportsMultisampleResolveDepth(cls) -> bool: ...
    @classmethod
    @property
    def supportsMultisampleResolveStencil(cls) -> bool: ...
    @classmethod
    @property
    def supportsMultiview(cls) -> bool: ...
    @classmethod
    @property
    def supportsRawShadowDepthSampling(cls) -> bool: ...
    @classmethod
    @property
    def supportsRayTracing(cls) -> bool: ...
    @classmethod
    @property
    def supportsRenderTargetArrayIndexFromVertexShader(cls) -> bool: ...
    @classmethod
    @property
    def supportsRenderTextures(cls) -> bool: ...
    @classmethod
    @property
    def supportsRenderToCubemap(cls) -> bool: ...
    @classmethod
    @property
    def supportsSeparatedRenderTargetsBlend(cls) -> bool: ...
    @classmethod
    @property
    def supportsSetConstantBuffer(cls) -> bool: ...
    @classmethod
    @property
    def supportsShadows(cls) -> bool: ...
    @classmethod
    @property
    def supportsSparseTextures(cls) -> bool: ...
    @classmethod
    @property
    def supportsStencil(cls) -> int: ...
    @classmethod
    @property
    def supportsStoreAndResolveAction(cls) -> bool: ...
    @classmethod
    @property
    def supportsTessellationShaders(cls) -> bool: ...
    @classmethod
    @property
    def supportsTextureWrapMirrorOnce(cls) -> int: ...
    @classmethod
    @property
    def supportsVertexPrograms(cls) -> bool: ...
    @classmethod
    @property
    def supportsVibration(cls) -> bool: ...
    @classmethod
    @property
    def systemMemorySize(cls) -> int: ...
    @classmethod
    @property
    def usesLoadStoreActions(cls) -> bool: ...
    @classmethod
    @property
    def usesReversedZBuffer(cls) -> bool: ...
    @staticmethod
    def GetCompatibleFormat(format: GraphicsFormat, usage: FormatUsage) -> GraphicsFormat: ...
    @staticmethod
    def GetGraphicsFormat(format: DefaultFormat) -> GraphicsFormat: ...
    @staticmethod
    def GetRenderTextureSupportedMSAASampleCount(desc: RenderTextureDescriptor) -> int: ...
    @staticmethod
    def IsFormatSupported(format: GraphicsFormat, usage: FormatUsage) -> bool: ...
    @staticmethod
    def SupportsBlendingOnRenderTextureFormat(format: RenderTextureFormat) -> bool: ...
    @staticmethod
    def SupportsRandomWriteOnRenderTextureFormat(format: RenderTextureFormat) -> bool: ...
    @staticmethod
    def SupportsRenderTextureFormat(format: RenderTextureFormat) -> bool: ...
    @staticmethod
    def SupportsTextureFormat(format: TextureFormat) -> bool: ...
    @staticmethod
    def SupportsVertexAttributeFormat(format: VertexAttributeFormat, dimension: int) -> bool: ...


class SystemLanguage(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Afrikaans : SystemLanguage # 0
    Arabic : SystemLanguage # 1
    Basque : SystemLanguage # 2
    Belarusian : SystemLanguage # 3
    Bulgarian : SystemLanguage # 4
    Catalan : SystemLanguage # 5
    Chinese : SystemLanguage # 6
    Czech : SystemLanguage # 7
    Danish : SystemLanguage # 8
    Dutch : SystemLanguage # 9
    English : SystemLanguage # 10
    Estonian : SystemLanguage # 11
    Faroese : SystemLanguage # 12
    Finnish : SystemLanguage # 13
    French : SystemLanguage # 14
    German : SystemLanguage # 15
    Greek : SystemLanguage # 16
    Hebrew : SystemLanguage # 17
    Hugarian : SystemLanguage # 18
    Hungarian : SystemLanguage # 18
    Icelandic : SystemLanguage # 19
    Indonesian : SystemLanguage # 20
    Italian : SystemLanguage # 21
    Japanese : SystemLanguage # 22
    Korean : SystemLanguage # 23
    Latvian : SystemLanguage # 24
    Lithuanian : SystemLanguage # 25
    Norwegian : SystemLanguage # 26
    Polish : SystemLanguage # 27
    Portuguese : SystemLanguage # 28
    Romanian : SystemLanguage # 29
    Russian : SystemLanguage # 30
    SerboCroatian : SystemLanguage # 31
    Slovak : SystemLanguage # 32
    Slovenian : SystemLanguage # 33
    Spanish : SystemLanguage # 34
    Swedish : SystemLanguage # 35
    Thai : SystemLanguage # 36
    Turkish : SystemLanguage # 37
    Ukrainian : SystemLanguage # 38
    Vietnamese : SystemLanguage # 39
    ChineseSimplified : SystemLanguage # 40
    ChineseTraditional : SystemLanguage # 41
    Hindi : SystemLanguage # 42
    Unknown : SystemLanguage # 43


class TargetJoint2D(Joint2D):
    def __init__(self) -> None: ...
    @property
    def anchor(self) -> Vector2: ...
    @anchor.setter
    def anchor(self, value: Vector2) -> Vector2: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoConfigureTarget(self) -> bool: ...
    @autoConfigureTarget.setter
    def autoConfigureTarget(self, value: bool) -> bool: ...
    @property
    def breakAction(self) -> JointBreakAction2D: ...
    @breakAction.setter
    def breakAction(self, value: JointBreakAction2D) -> JointBreakAction2D: ...
    @property
    def breakForce(self) -> float: ...
    @breakForce.setter
    def breakForce(self, value: float) -> float: ...
    @property
    def breakTorque(self) -> float: ...
    @breakTorque.setter
    def breakTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collideConnected(self) -> bool: ...
    @collideConnected.setter
    def collideConnected(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def connectedBody(self) -> Rigidbody2D: ...
    @connectedBody.setter
    def connectedBody(self, value: Rigidbody2D) -> Rigidbody2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def dampingRatio(self) -> float: ...
    @dampingRatio.setter
    def dampingRatio(self, value: float) -> float: ...
    @property
    def enableCollision(self) -> bool: ...
    @enableCollision.setter
    def enableCollision(self, value: bool) -> bool: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def frequency(self) -> float: ...
    @frequency.setter
    def frequency(self, value: float) -> float: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def maxForce(self) -> float: ...
    @maxForce.setter
    def maxForce(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def reactionForce(self) -> Vector2: ...
    @property
    def reactionTorque(self) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def target(self) -> Vector2: ...
    @target.setter
    def target(self, value: Vector2) -> Vector2: ...
    @property
    def transform(self) -> Transform: ...


class Terrain(Behaviour):
    def __init__(self) -> None: ...
    @classmethod
    @property
    def activeTerrain(cls) -> Terrain: ...
    @classmethod
    @property
    def activeTerrains(cls) -> Array_1[Terrain]: ...
    @property
    def allowAutoConnect(self) -> bool: ...
    @allowAutoConnect.setter
    def allowAutoConnect(self, value: bool) -> bool: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bakeLightProbesForTrees(self) -> bool: ...
    @bakeLightProbesForTrees.setter
    def bakeLightProbesForTrees(self, value: bool) -> bool: ...
    @property
    def basemapDistance(self) -> float: ...
    @basemapDistance.setter
    def basemapDistance(self, value: float) -> float: ...
    @property
    def bottomNeighbor(self) -> Terrain: ...
    @property
    def camera(self) -> Component: ...
    @property
    def castShadows(self) -> bool: ...
    @castShadows.setter
    def castShadows(self, value: bool) -> bool: ...
    @property
    def collectDetailPatches(self) -> bool: ...
    @collectDetailPatches.setter
    def collectDetailPatches(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @classmethod
    @property
    def compressedHolesFormat(cls) -> GraphicsFormat: ...
    @classmethod
    @property
    def compressedHolesTextureFormat(cls) -> TextureFormat: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def deringLightProbesForTrees(self) -> bool: ...
    @deringLightProbesForTrees.setter
    def deringLightProbesForTrees(self, value: bool) -> bool: ...
    @property
    def detailObjectDensity(self) -> float: ...
    @detailObjectDensity.setter
    def detailObjectDensity(self, value: float) -> float: ...
    @property
    def detailObjectDistance(self) -> float: ...
    @detailObjectDistance.setter
    def detailObjectDistance(self, value: float) -> float: ...
    @property
    def drawHeightmap(self) -> bool: ...
    @drawHeightmap.setter
    def drawHeightmap(self, value: bool) -> bool: ...
    @property
    def drawInstanced(self) -> bool: ...
    @drawInstanced.setter
    def drawInstanced(self, value: bool) -> bool: ...
    @property
    def drawTreesAndFoliage(self) -> bool: ...
    @drawTreesAndFoliage.setter
    def drawTreesAndFoliage(self, value: bool) -> bool: ...
    @property
    def editorRenderFlags(self) -> TerrainRenderFlags: ...
    @editorRenderFlags.setter
    def editorRenderFlags(self, value: TerrainRenderFlags) -> TerrainRenderFlags: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def enableHeightmapRayTracing(self) -> bool: ...
    @enableHeightmapRayTracing.setter
    def enableHeightmapRayTracing(self, value: bool) -> bool: ...
    @property
    def freeUnusedRenderingResources(self) -> bool: ...
    @freeUnusedRenderingResources.setter
    def freeUnusedRenderingResources(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def groupingID(self) -> int: ...
    @groupingID.setter
    def groupingID(self, value: int) -> int: ...
    @classmethod
    @property
    def heightmapFormat(cls) -> GraphicsFormat: ...
    @property
    def heightmapMaximumLOD(self) -> int: ...
    @heightmapMaximumLOD.setter
    def heightmapMaximumLOD(self, value: int) -> int: ...
    @property
    def heightmapPixelError(self) -> float: ...
    @heightmapPixelError.setter
    def heightmapPixelError(self, value: float) -> float: ...
    @classmethod
    @property
    def heightmapRenderTextureFormat(cls) -> RenderTextureFormat: ...
    @classmethod
    @property
    def heightmapTextureFormat(cls) -> TextureFormat: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @classmethod
    @property
    def holesFormat(cls) -> GraphicsFormat: ...
    @classmethod
    @property
    def holesRenderTextureFormat(cls) -> RenderTextureFormat: ...
    @property
    def ignoreQualitySettings(self) -> bool: ...
    @ignoreQualitySettings.setter
    def ignoreQualitySettings(self, value: bool) -> bool: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def keepUnusedRenderingResources(self) -> bool: ...
    @keepUnusedRenderingResources.setter
    def keepUnusedRenderingResources(self, value: bool) -> bool: ...
    @property
    def leftNeighbor(self) -> Terrain: ...
    @property
    def legacyShininess(self) -> float: ...
    @legacyShininess.setter
    def legacyShininess(self, value: float) -> float: ...
    @property
    def legacySpecular(self) -> Color: ...
    @legacySpecular.setter
    def legacySpecular(self, value: Color) -> Color: ...
    @property
    def light(self) -> Component: ...
    @property
    def lightmapIndex(self) -> int: ...
    @lightmapIndex.setter
    def lightmapIndex(self, value: int) -> int: ...
    @property
    def lightmapScaleOffset(self) -> Vector4: ...
    @lightmapScaleOffset.setter
    def lightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def materialTemplate(self) -> Material: ...
    @materialTemplate.setter
    def materialTemplate(self, value: Material) -> Material: ...
    @property
    def materialType(self) -> Terrain.MaterialType: ...
    @materialType.setter
    def materialType(self, value: Terrain.MaterialType) -> Terrain.MaterialType: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @classmethod
    @property
    def normalmapFormat(cls) -> GraphicsFormat: ...
    @classmethod
    @property
    def normalmapRenderTextureFormat(cls) -> RenderTextureFormat: ...
    @property
    def normalmapTexture(self) -> RenderTexture: ...
    @classmethod
    @property
    def normalmapTextureFormat(cls) -> TextureFormat: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def patchBoundsMultiplier(self) -> Vector3: ...
    @patchBoundsMultiplier.setter
    def patchBoundsMultiplier(self, value: Vector3) -> Vector3: ...
    @property
    def preserveTreePrototypeLayers(self) -> bool: ...
    @preserveTreePrototypeLayers.setter
    def preserveTreePrototypeLayers(self, value: bool) -> bool: ...
    @property
    def realtimeLightmapIndex(self) -> int: ...
    @realtimeLightmapIndex.setter
    def realtimeLightmapIndex(self, value: int) -> int: ...
    @property
    def realtimeLightmapScaleOffset(self) -> Vector4: ...
    @realtimeLightmapScaleOffset.setter
    def realtimeLightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def reflectionProbeUsage(self) -> ReflectionProbeUsage: ...
    @reflectionProbeUsage.setter
    def reflectionProbeUsage(self, value: ReflectionProbeUsage) -> ReflectionProbeUsage: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def renderingLayerMask(self) -> int: ...
    @renderingLayerMask.setter
    def renderingLayerMask(self, value: int) -> int: ...
    @property
    def rightNeighbor(self) -> Terrain: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def shadowCastingMode(self) -> ShadowCastingMode: ...
    @shadowCastingMode.setter
    def shadowCastingMode(self, value: ShadowCastingMode) -> ShadowCastingMode: ...
    @property
    def splatmapDistance(self) -> float: ...
    @splatmapDistance.setter
    def splatmapDistance(self, value: float) -> float: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def terrainData(self) -> TerrainData: ...
    @terrainData.setter
    def terrainData(self, value: TerrainData) -> TerrainData: ...
    @property
    def topNeighbor(self) -> Terrain: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def treeBillboardDistance(self) -> float: ...
    @treeBillboardDistance.setter
    def treeBillboardDistance(self, value: float) -> float: ...
    @property
    def treeCrossFadeLength(self) -> float: ...
    @treeCrossFadeLength.setter
    def treeCrossFadeLength(self, value: float) -> float: ...
    @property
    def treeDistance(self) -> float: ...
    @treeDistance.setter
    def treeDistance(self, value: float) -> float: ...
    @property
    def treeLODBiasMultiplier(self) -> float: ...
    @treeLODBiasMultiplier.setter
    def treeLODBiasMultiplier(self, value: float) -> float: ...
    @property
    def treeMaximumFullLODCount(self) -> int: ...
    @treeMaximumFullLODCount.setter
    def treeMaximumFullLODCount(self, value: int) -> int: ...
    @property
    def treeMotionVectorModeOverride(self) -> TreeMotionVectorModeOverride: ...
    @treeMotionVectorModeOverride.setter
    def treeMotionVectorModeOverride(self, value: TreeMotionVectorModeOverride) -> TreeMotionVectorModeOverride: ...
    def AddTreeInstance(self, instance: TreeInstance) -> None: ...
    def ApplyDelayedHeightmapModification(self) -> None: ...
    @staticmethod
    def CreateTerrainGameObject(assignTerrain: TerrainData) -> GameObject: ...
    def Flush(self) -> None: ...
    @staticmethod
    def GetActiveTerrains(terrainList: List_1[Terrain]) -> None: ...
    def GetClosestReflectionProbes(self, result: List_1[ReflectionProbeBlendInfo]) -> None: ...
    def GetKeepUnusedCameraRenderingResources(self, cameraInstanceID: int) -> bool: ...
    def GetPosition(self) -> Vector3: ...
    def GetSplatMaterialPropertyBlock(self, dest: MaterialPropertyBlock) -> None: ...
    def SampleHeight(self, worldPosition: Vector3) -> float: ...
    @staticmethod
    def SetConnectivityDirty() -> None: ...
    def SetKeepUnusedCameraRenderingResources(self, cameraInstanceID: int, keepUnused: bool) -> None: ...
    def SetNeighbors(self, left: Terrain, top: Terrain, right: Terrain, bottom: Terrain) -> None: ...
    def SetSplatMaterialPropertyBlock(self, properties: MaterialPropertyBlock) -> None: ...

    class MaterialType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        BuiltInStandard : Terrain.MaterialType # 0
        BuiltInLegacyDiffuse : Terrain.MaterialType # 1
        BuiltInLegacySpecular : Terrain.MaterialType # 2
        Custom : Terrain.MaterialType # 3



class TerrainCallbacks(abc.ABC):

    class HeightmapChangedCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, terrain: Terrain, heightRegion: RectInt, synched: bool, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, terrain: Terrain, heightRegion: RectInt, synched: bool) -> None: ...


    class TextureChangedCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, terrain: Terrain, textureName: str, texelRegion: RectInt, synched: bool, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, terrain: Terrain, textureName: str, texelRegion: RectInt, synched: bool) -> None: ...



class TerrainChangedFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Heightmap : TerrainChangedFlags # 1
    TreeInstances : TerrainChangedFlags # 2
    DelayedHeightmapUpdate : TerrainChangedFlags # 4
    FlushEverythingImmediately : TerrainChangedFlags # 8
    RemoveDirtyDetailsImmediately : TerrainChangedFlags # 16
    HeightmapResolution : TerrainChangedFlags # 32
    Holes : TerrainChangedFlags # 64
    DelayedHolesUpdate : TerrainChangedFlags # 128
    WillBeDestroyed : TerrainChangedFlags # 256


class TerrainCollider(Collider):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedArticulationBody(self) -> ArticulationBody: ...
    @property
    def attachedRigidbody(self) -> Rigidbody: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def contactOffset(self) -> float: ...
    @contactOffset.setter
    def contactOffset(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hasModifiableContacts(self) -> bool: ...
    @hasModifiableContacts.setter
    def hasModifiableContacts(self, value: bool) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def isTrigger(self) -> bool: ...
    @isTrigger.setter
    def isTrigger(self, value: bool) -> bool: ...
    @property
    def layerOverridePriority(self) -> int: ...
    @layerOverridePriority.setter
    def layerOverridePriority(self, value: int) -> int: ...
    @property
    def light(self) -> Component: ...
    @property
    def material(self) -> PhysicMaterial: ...
    @material.setter
    def material(self, value: PhysicMaterial) -> PhysicMaterial: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def providesContacts(self) -> bool: ...
    @providesContacts.setter
    def providesContacts(self, value: bool) -> bool: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def sharedMaterial(self) -> PhysicMaterial: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: PhysicMaterial) -> PhysicMaterial: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def terrainData(self) -> TerrainData: ...
    @terrainData.setter
    def terrainData(self, value: TerrainData) -> TerrainData: ...
    @property
    def transform(self) -> Transform: ...


class TerrainData(Object):
    def __init__(self) -> None: ...
    @property
    def alphamapHeight(self) -> int: ...
    @property
    def alphamapLayers(self) -> int: ...
    @property
    def alphamapResolution(self) -> int: ...
    @alphamapResolution.setter
    def alphamapResolution(self, value: int) -> int: ...
    @property
    def alphamapTextureCount(self) -> int: ...
    @classmethod
    @property
    def AlphamapTextureName(cls) -> str: ...
    @property
    def alphamapTextures(self) -> Array_1[Texture2D]: ...
    @property
    def alphamapWidth(self) -> int: ...
    @property
    def baseMapResolution(self) -> int: ...
    @baseMapResolution.setter
    def baseMapResolution(self, value: int) -> int: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def detailHeight(self) -> int: ...
    @property
    def detailPatchCount(self) -> int: ...
    @property
    def detailPrototypes(self) -> Array_1[DetailPrototype]: ...
    @detailPrototypes.setter
    def detailPrototypes(self, value: Array_1[DetailPrototype]) -> Array_1[DetailPrototype]: ...
    @property
    def detailResolution(self) -> int: ...
    @property
    def detailResolutionPerPatch(self) -> int: ...
    @property
    def detailScatterMode(self) -> DetailScatterMode: ...
    @property
    def detailWidth(self) -> int: ...
    @property
    def enableHolesTextureCompression(self) -> bool: ...
    @enableHolesTextureCompression.setter
    def enableHolesTextureCompression(self, value: bool) -> bool: ...
    @property
    def heightmapHeight(self) -> int: ...
    @property
    def heightmapResolution(self) -> int: ...
    @heightmapResolution.setter
    def heightmapResolution(self, value: int) -> int: ...
    @property
    def heightmapScale(self) -> Vector3: ...
    @property
    def heightmapTexture(self) -> RenderTexture: ...
    @property
    def heightmapWidth(self) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def holesResolution(self) -> int: ...
    @property
    def holesTexture(self) -> Texture: ...
    @classmethod
    @property
    def HolesTextureName(cls) -> str: ...
    @property
    def maxDetailScatterPerRes(self) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def size(self) -> Vector3: ...
    @size.setter
    def size(self, value: Vector3) -> Vector3: ...
    @property
    def splatPrototypes(self) -> Array_1[SplatPrototype]: ...
    @splatPrototypes.setter
    def splatPrototypes(self, value: Array_1[SplatPrototype]) -> Array_1[SplatPrototype]: ...
    @property
    def terrainLayers(self) -> Array_1[TerrainLayer]: ...
    @terrainLayers.setter
    def terrainLayers(self, value: Array_1[TerrainLayer]) -> Array_1[TerrainLayer]: ...
    @property
    def thickness(self) -> float: ...
    @thickness.setter
    def thickness(self, value: float) -> float: ...
    @property
    def treeInstanceCount(self) -> int: ...
    @property
    def treeInstances(self) -> Array_1[TreeInstance]: ...
    @treeInstances.setter
    def treeInstances(self, value: Array_1[TreeInstance]) -> Array_1[TreeInstance]: ...
    @property
    def treePrototypes(self) -> Array_1[TreePrototype]: ...
    @treePrototypes.setter
    def treePrototypes(self, value: Array_1[TreePrototype]) -> Array_1[TreePrototype]: ...
    @property
    def wavingGrassAmount(self) -> float: ...
    @wavingGrassAmount.setter
    def wavingGrassAmount(self, value: float) -> float: ...
    @property
    def wavingGrassSpeed(self) -> float: ...
    @wavingGrassSpeed.setter
    def wavingGrassSpeed(self, value: float) -> float: ...
    @property
    def wavingGrassStrength(self) -> float: ...
    @wavingGrassStrength.setter
    def wavingGrassStrength(self, value: float) -> float: ...
    @property
    def wavingGrassTint(self) -> Color: ...
    @wavingGrassTint.setter
    def wavingGrassTint(self, value: Color) -> Color: ...
    def ComputeDetailCoverage(self, detailPrototypeIndex: int) -> float: ...
    def ComputeDetailInstanceTransforms(self, patchX: int, patchY: int, layer: int, density: float, bounds: clr.Reference[Bounds]) -> Array_1[DetailInstanceTransform]: ...
    def CopyActiveRenderTextureToHeightmap(self, sourceRect: RectInt, dest: Vector2Int, syncControl: TerrainHeightmapSyncControl) -> None: ...
    def CopyActiveRenderTextureToTexture(self, textureName: str, textureIndex: int, sourceRect: RectInt, dest: Vector2Int, allowDelayedCPUSync: bool) -> None: ...
    def DirtyHeightmapRegion(self, region: RectInt, syncControl: TerrainHeightmapSyncControl) -> None: ...
    def DirtyTextureRegion(self, textureName: str, region: RectInt, allowDelayedCPUSync: bool) -> None: ...
    def GetAlphamaps(self, x: int, y: int, width: int, height: int) -> Array_1[float]: ...
    def GetAlphamapTexture(self, index: int) -> Texture2D: ...
    def GetClampedDetailPatches(self, density: float) -> Array_1[Vector2Int]: ...
    def GetHeight(self, x: int, y: int) -> float: ...
    def GetHeights(self, xBase: int, yBase: int, width: int, height: int) -> Array_1[float]: ...
    def GetHoles(self, xBase: int, yBase: int, width: int, height: int) -> Array_1[bool]: ...
    def GetInterpolatedHeight(self, x: float, y: float) -> float: ...
    def GetInterpolatedNormal(self, x: float, y: float) -> Vector3: ...
    def GetMaximumHeightError(self) -> Array_1[float]: ...
    def GetPatchMinMaxHeights(self) -> Array_1[PatchExtents]: ...
    def GetSteepness(self, x: float, y: float) -> float: ...
    def GetTreeInstance(self, index: int) -> TreeInstance: ...
    def IsHole(self, x: int, y: int) -> bool: ...
    def OverrideMaximumHeightError(self, maxError: Array_1[float]) -> None: ...
    def OverrideMinMaxPatchHeights(self, minMaxHeights: Array_1[PatchExtents]) -> None: ...
    def RefreshPrototypes(self) -> None: ...
    def RemoveDetailPrototype(self, index: int) -> None: ...
    def SetAlphamaps(self, x: int, y: int, map: Array_1[float]) -> None: ...
    def SetBaseMapDirty(self) -> None: ...
    def SetDetailResolution(self, detailResolution: int, resolutionPerPatch: int) -> None: ...
    def SetDetailScatterMode(self, scatterMode: DetailScatterMode) -> None: ...
    def SetHeights(self, xBase: int, yBase: int, heights: Array_1[float]) -> None: ...
    def SetHeightsDelayLOD(self, xBase: int, yBase: int, heights: Array_1[float]) -> None: ...
    def SetHoles(self, xBase: int, yBase: int, holes: Array_1[bool]) -> None: ...
    def SetHolesDelayLOD(self, xBase: int, yBase: int, holes: Array_1[bool]) -> None: ...
    def SetTerrainLayersRegisterUndo(self, terrainLayers: Array_1[TerrainLayer], undoName: str) -> None: ...
    def SetTreeInstance(self, index: int, instance: TreeInstance) -> None: ...
    def SetTreeInstances(self, instances: Array_1[TreeInstance], snapToHeightmap: bool) -> None: ...
    def SyncHeightmap(self) -> None: ...
    def SyncTexture(self, textureName: str) -> None: ...
    def UpdateDirtyRegion(self, x: int, y: int, width: int, height: int, syncHeightmapTextureImmediately: bool) -> None: ...
    # Skipped GetDetailLayer due to it being static, abstract and generic.

    GetDetailLayer : GetDetailLayer_MethodGroup
    class GetDetailLayer_MethodGroup:
        @typing.overload
        def __call__(self, positionBase: Vector2Int, size: Vector2Int, layer: int) -> Array_1[int]:...
        @typing.overload
        def __call__(self, xBase: int, yBase: int, width: int, height: int, layer: int) -> Array_1[int]:...

    # Skipped GetInterpolatedHeights due to it being static, abstract and generic.

    GetInterpolatedHeights : GetInterpolatedHeights_MethodGroup
    class GetInterpolatedHeights_MethodGroup:
        @typing.overload
        def __call__(self, xBase: float, yBase: float, xCount: int, yCount: int, xInterval: float, yInterval: float) -> Array_1[float]:...
        @typing.overload
        def __call__(self, results: Array_1[float], resultXOffset: int, resultYOffset: int, xBase: float, yBase: float, xCount: int, yCount: int, xInterval: float, yInterval: float) -> None:...

    # Skipped GetSupportedLayers due to it being static, abstract and generic.

    GetSupportedLayers : GetSupportedLayers_MethodGroup
    class GetSupportedLayers_MethodGroup:
        @typing.overload
        def __call__(self, positionBase: Vector2Int, size: Vector2Int) -> Array_1[int]:...
        @typing.overload
        def __call__(self, xBase: int, yBase: int, totalWidth: int, totalHeight: int) -> Array_1[int]:...

    # Skipped SetDetailLayer due to it being static, abstract and generic.

    SetDetailLayer : SetDetailLayer_MethodGroup
    class SetDetailLayer_MethodGroup:
        @typing.overload
        def __call__(self, basePosition: Vector2Int, layer: int, details: Array_1[int]) -> None:...
        @typing.overload
        def __call__(self, xBase: int, yBase: int, layer: int, details: Array_1[int]) -> None:...



class TerrainExtensions(abc.ABC):
    # Skipped UpdateGIMaterials due to it being static, abstract and generic.

    UpdateGIMaterials : UpdateGIMaterials_MethodGroup
    class UpdateGIMaterials_MethodGroup:
        @typing.overload
        def __call__(self, terrain: Terrain) -> None:...
        @typing.overload
        def __call__(self, terrain: Terrain, x: int, y: int, width: int, height: int) -> None:...



class TerrainHeightmapSyncControl(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : TerrainHeightmapSyncControl # 0
    HeightOnly : TerrainHeightmapSyncControl # 1
    HeightAndLod : TerrainHeightmapSyncControl # 2


class TerrainLayer(Object):
    def __init__(self) -> None: ...
    @property
    def diffuseRemapMax(self) -> Vector4: ...
    @diffuseRemapMax.setter
    def diffuseRemapMax(self, value: Vector4) -> Vector4: ...
    @property
    def diffuseRemapMin(self) -> Vector4: ...
    @diffuseRemapMin.setter
    def diffuseRemapMin(self, value: Vector4) -> Vector4: ...
    @property
    def diffuseTexture(self) -> Texture2D: ...
    @diffuseTexture.setter
    def diffuseTexture(self, value: Texture2D) -> Texture2D: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def maskMapRemapMax(self) -> Vector4: ...
    @maskMapRemapMax.setter
    def maskMapRemapMax(self, value: Vector4) -> Vector4: ...
    @property
    def maskMapRemapMin(self) -> Vector4: ...
    @maskMapRemapMin.setter
    def maskMapRemapMin(self, value: Vector4) -> Vector4: ...
    @property
    def maskMapTexture(self) -> Texture2D: ...
    @maskMapTexture.setter
    def maskMapTexture(self, value: Texture2D) -> Texture2D: ...
    @property
    def metallic(self) -> float: ...
    @metallic.setter
    def metallic(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def normalMapTexture(self) -> Texture2D: ...
    @normalMapTexture.setter
    def normalMapTexture(self, value: Texture2D) -> Texture2D: ...
    @property
    def normalScale(self) -> float: ...
    @normalScale.setter
    def normalScale(self, value: float) -> float: ...
    @property
    def smoothness(self) -> float: ...
    @smoothness.setter
    def smoothness(self, value: float) -> float: ...
    @property
    def specular(self) -> Color: ...
    @specular.setter
    def specular(self, value: Color) -> Color: ...
    @property
    def tileOffset(self) -> Vector2: ...
    @tileOffset.setter
    def tileOffset(self, value: Vector2) -> Vector2: ...
    @property
    def tileSize(self) -> Vector2: ...
    @tileSize.setter
    def tileSize(self, value: Vector2) -> Vector2: ...


class TerrainQualityOverrides(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : TerrainQualityOverrides # 0
    PixelError : TerrainQualityOverrides # 1
    BasemapDistance : TerrainQualityOverrides # 2
    DetailDensity : TerrainQualityOverrides # 4
    DetailDistance : TerrainQualityOverrides # 8
    TreeDistance : TerrainQualityOverrides # 16
    BillboardStart : TerrainQualityOverrides # 32
    FadeLength : TerrainQualityOverrides # 64
    MaxTrees : TerrainQualityOverrides # 128


class TerrainRenderFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Heightmap : TerrainRenderFlags # 1
    heightmap : TerrainRenderFlags # 1
    trees : TerrainRenderFlags # 2
    Trees : TerrainRenderFlags # 2
    details : TerrainRenderFlags # 4
    Details : TerrainRenderFlags # 4
    all : TerrainRenderFlags # 7
    All : TerrainRenderFlags # 7


class TexGenMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : TexGenMode # 0
    SphereMap : TexGenMode # 1
    Object : TexGenMode # 2
    EyeLinear : TexGenMode # 3
    CubeReflect : TexGenMode # 4
    CubeNormal : TexGenMode # 5


class TextAlignment(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Left : TextAlignment # 0
    Center : TextAlignment # 1
    Right : TextAlignment # 2


class TextAnchor(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    UpperLeft : TextAnchor # 0
    UpperCenter : TextAnchor # 1
    UpperRight : TextAnchor # 2
    MiddleLeft : TextAnchor # 3
    MiddleCenter : TextAnchor # 4
    MiddleRight : TextAnchor # 5
    LowerLeft : TextAnchor # 6
    LowerCenter : TextAnchor # 7
    LowerRight : TextAnchor # 8


class TextAreaAttribute(PropertyAttribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, minLines: int, maxLines: int) -> None: ...
    maxLines : int
    minLines : int
    @property
    def order(self) -> int: ...
    @order.setter
    def order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class TextAsset(Object):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, text: str) -> None: ...
    @property
    def bytes(self) -> Array_1[int]: ...
    @property
    def dataSize(self) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def text(self) -> str: ...
    def ToString(self) -> str: ...
    # Skipped GetData due to it being static, abstract and generic.

    GetData : GetData_MethodGroup
    class GetData_MethodGroup:
        def __getitem__(self, t:typing.Type[GetData_1_T1]) -> GetData_1[GetData_1_T1]: ...

        GetData_1_T1 = typing.TypeVar('GetData_1_T1')
        class GetData_1(typing.Generic[GetData_1_T1]):
            GetData_1_T = TextAsset.GetData_MethodGroup.GetData_1_T1
            def __call__(self) -> NativeArray_1[GetData_1_T]:...




class TextClipping(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Overflow : TextClipping # 0
    Clip : TextClipping # 1


class TextEditor:
    def __init__(self) -> None: ...
    controlID : int
    graphicalCursorPos : Vector2
    graphicalSelectCursorPos : Vector2
    hasHorizontalCursorPos : bool
    isPasswordField : bool
    keyboardOnScreen : TouchScreenKeyboard
    multiline : bool
    scrollOffset : Vector2
    style : GUIStyle
    @property
    def altCursorPosition(self) -> int: ...
    @altCursorPosition.setter
    def altCursorPosition(self, value: int) -> int: ...
    @property
    def content(self) -> GUIContent: ...
    @content.setter
    def content(self, value: GUIContent) -> GUIContent: ...
    @property
    def cursorIndex(self) -> int: ...
    @cursorIndex.setter
    def cursorIndex(self, value: int) -> int: ...
    @property
    def doubleClickSnapping(self) -> TextEditor.DblClickSnapping: ...
    @doubleClickSnapping.setter
    def doubleClickSnapping(self, value: TextEditor.DblClickSnapping) -> TextEditor.DblClickSnapping: ...
    @property
    def hasSelection(self) -> bool: ...
    @property
    def position(self) -> Rect: ...
    @position.setter
    def position(self, value: Rect) -> Rect: ...
    @property
    def SelectedText(self) -> str: ...
    @property
    def selectIndex(self) -> int: ...
    @selectIndex.setter
    def selectIndex(self, value: int) -> int: ...
    @property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> str: ...
    def Backspace(self) -> bool: ...
    def CanPaste(self) -> bool: ...
    def Copy(self) -> None: ...
    def Cut(self) -> bool: ...
    def DblClickSnap(self, snapping: TextEditor.DblClickSnapping) -> None: ...
    def Delete(self) -> bool: ...
    def DeleteLineBack(self) -> bool: ...
    def DeleteSelection(self) -> bool: ...
    def DeleteWordBack(self) -> bool: ...
    def DeleteWordForward(self) -> bool: ...
    def DetectFocusChange(self) -> None: ...
    def DrawCursor(self, newText: str) -> None: ...
    def ExpandSelectGraphicalLineEnd(self) -> None: ...
    def ExpandSelectGraphicalLineStart(self) -> None: ...
    def FindStartOfNextWord(self, p: int) -> int: ...
    def HandleKeyEvent(self, e: Event) -> bool: ...
    def Insert(self, c: str) -> None: ...
    def IsOverSelection(self, cursorPosition: Vector2) -> bool: ...
    def MouseDragSelectsWholeWords(self, on: bool) -> None: ...
    def MoveAltCursorToPosition(self, cursorPosition: Vector2) -> None: ...
    def MoveCursorToPosition(self, cursorPosition: Vector2) -> None: ...
    def MoveDown(self) -> None: ...
    def MoveGraphicalLineEnd(self) -> None: ...
    def MoveGraphicalLineStart(self) -> None: ...
    def MoveLeft(self) -> None: ...
    def MoveLineEnd(self) -> None: ...
    def MoveLineStart(self) -> None: ...
    def MoveParagraphBackward(self) -> None: ...
    def MoveParagraphForward(self) -> None: ...
    def MoveRight(self) -> None: ...
    def MoveSelectionToAltCursor(self) -> None: ...
    def MoveTextEnd(self) -> None: ...
    def MoveTextStart(self) -> None: ...
    def MoveToEndOfPreviousWord(self) -> None: ...
    def MoveToStartOfNextWord(self) -> None: ...
    def MoveUp(self) -> None: ...
    def MoveWordLeft(self) -> None: ...
    def MoveWordRight(self) -> None: ...
    def OnFocus(self) -> None: ...
    def OnLostFocus(self) -> None: ...
    def Paste(self) -> bool: ...
    def ReplaceSelection(self, replace: str) -> None: ...
    def SaveBackup(self) -> None: ...
    def SelectAll(self) -> None: ...
    def SelectCurrentParagraph(self) -> None: ...
    def SelectCurrentWord(self) -> None: ...
    def SelectDown(self) -> None: ...
    def SelectGraphicalLineEnd(self) -> None: ...
    def SelectGraphicalLineStart(self) -> None: ...
    def SelectLeft(self) -> None: ...
    def SelectNone(self) -> None: ...
    def SelectParagraphBackward(self) -> None: ...
    def SelectParagraphForward(self) -> None: ...
    def SelectRight(self) -> None: ...
    def SelectTextEnd(self) -> None: ...
    def SelectTextStart(self) -> None: ...
    def SelectToEndOfPreviousWord(self) -> None: ...
    def SelectToPosition(self, cursorPosition: Vector2) -> None: ...
    def SelectToStartOfNextWord(self) -> None: ...
    def SelectUp(self) -> None: ...
    def SelectWordLeft(self) -> None: ...
    def SelectWordRight(self) -> None: ...
    def Undo(self) -> None: ...
    def UpdateScrollOffsetIfNeeded(self, evt: Event) -> None: ...

    class DblClickSnapping(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        WORDS : TextEditor.DblClickSnapping # 0
        PARAGRAPHS : TextEditor.DblClickSnapping # 1



class TextGenerationSettings:
    alignByGeometry : bool
    color : Color
    font : Font
    fontSize : int
    fontStyle : FontStyle
    generateOutOfBounds : bool
    generationExtents : Vector2
    horizontalOverflow : HorizontalWrapMode
    lineSpacing : float
    pivot : Vector2
    resizeTextForBestFit : bool
    resizeTextMaxSize : int
    resizeTextMinSize : int
    richText : bool
    scaleFactor : float
    textAnchor : TextAnchor
    updateBounds : bool
    verticalOverflow : VerticalWrapMode
    def Equals(self, other: TextGenerationSettings) -> bool: ...


class TextGenerator(IDisposable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int) -> None: ...
    @property
    def characterCount(self) -> int: ...
    @property
    def characterCountVisible(self) -> int: ...
    @property
    def characters(self) -> IList_1[UICharInfo]: ...
    @property
    def fontSizeUsedForBestFit(self) -> int: ...
    @property
    def lineCount(self) -> int: ...
    @property
    def lines(self) -> IList_1[UILineInfo]: ...
    @property
    def rectExtents(self) -> Rect: ...
    @property
    def vertexCount(self) -> int: ...
    @property
    def verts(self) -> IList_1[UIVertex]: ...
    def GetCharacters(self, characters: List_1[UICharInfo]) -> None: ...
    def GetCharactersArray(self) -> Array_1[UICharInfo]: ...
    def GetLines(self, lines: List_1[UILineInfo]) -> None: ...
    def GetLinesArray(self) -> Array_1[UILineInfo]: ...
    def GetPreferredHeight(self, str: str, settings: TextGenerationSettings) -> float: ...
    def GetPreferredWidth(self, str: str, settings: TextGenerationSettings) -> float: ...
    def GetVertices(self, vertices: List_1[UIVertex]) -> None: ...
    def GetVerticesArray(self) -> Array_1[UIVertex]: ...
    def Invalidate(self) -> None: ...
    def Populate(self, str: str, settings: TextGenerationSettings) -> bool: ...
    def PopulateWithErrors(self, str: str, settings: TextGenerationSettings, context: GameObject) -> bool: ...


class TextMesh(Component):
    def __init__(self) -> None: ...
    @property
    def alignment(self) -> TextAlignment: ...
    @alignment.setter
    def alignment(self, value: TextAlignment) -> TextAlignment: ...
    @property
    def anchor(self) -> TextAnchor: ...
    @anchor.setter
    def anchor(self, value: TextAnchor) -> TextAnchor: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def characterSize(self) -> float: ...
    @characterSize.setter
    def characterSize(self, value: float) -> float: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def color(self) -> Color: ...
    @color.setter
    def color(self, value: Color) -> Color: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def font(self) -> Font: ...
    @font.setter
    def font(self, value: Font) -> Font: ...
    @property
    def fontSize(self) -> int: ...
    @fontSize.setter
    def fontSize(self, value: int) -> int: ...
    @property
    def fontStyle(self) -> FontStyle: ...
    @fontStyle.setter
    def fontStyle(self, value: FontStyle) -> FontStyle: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def light(self) -> Component: ...
    @property
    def lineSpacing(self) -> float: ...
    @lineSpacing.setter
    def lineSpacing(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def offsetZ(self) -> float: ...
    @offsetZ.setter
    def offsetZ(self, value: float) -> float: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def richText(self) -> bool: ...
    @richText.setter
    def richText(self, value: bool) -> bool: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tabSize(self) -> float: ...
    @tabSize.setter
    def tabSize(self, value: float) -> float: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class Texture(Object):
    GenerateAllMips : int
    @classmethod
    @property
    def allowThreadedTextureCreation(cls) -> bool: ...
    @classmethod
    @allowThreadedTextureCreation.setter
    def allowThreadedTextureCreation(cls, value: bool) -> bool: ...
    @property
    def anisoLevel(self) -> int: ...
    @anisoLevel.setter
    def anisoLevel(self, value: int) -> int: ...
    @classmethod
    @property
    def anisotropicFiltering(cls) -> AnisotropicFiltering: ...
    @classmethod
    @anisotropicFiltering.setter
    def anisotropicFiltering(cls, value: AnisotropicFiltering) -> AnisotropicFiltering: ...
    @classmethod
    @property
    def currentTextureMemory(cls) -> int: ...
    @classmethod
    @property
    def desiredTextureMemory(cls) -> int: ...
    @property
    def dimension(self) -> TextureDimension: ...
    @dimension.setter
    def dimension(self, value: TextureDimension) -> TextureDimension: ...
    @property
    def filterMode(self) -> FilterMode: ...
    @filterMode.setter
    def filterMode(self, value: FilterMode) -> FilterMode: ...
    @classmethod
    @property
    def globalMipmapLimit(cls) -> int: ...
    @classmethod
    @globalMipmapLimit.setter
    def globalMipmapLimit(cls, value: int) -> int: ...
    @property
    def graphicsFormat(self) -> GraphicsFormat: ...
    @property
    def height(self) -> int: ...
    @height.setter
    def height(self, value: int) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def imageContentsHash(self) -> Hash128: ...
    @imageContentsHash.setter
    def imageContentsHash(self, value: Hash128) -> Hash128: ...
    @property
    def isDataSRGB(self) -> bool: ...
    @property
    def isReadable(self) -> bool: ...
    @classmethod
    @property
    def masterTextureLimit(cls) -> int: ...
    @classmethod
    @masterTextureLimit.setter
    def masterTextureLimit(cls, value: int) -> int: ...
    @property
    def mipMapBias(self) -> float: ...
    @mipMapBias.setter
    def mipMapBias(self, value: float) -> float: ...
    @property
    def mipmapCount(self) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @classmethod
    @property
    def nonStreamingTextureCount(cls) -> int: ...
    @classmethod
    @property
    def nonStreamingTextureMemory(cls) -> int: ...
    @classmethod
    @property
    def streamingMipmapUploadCount(cls) -> int: ...
    @classmethod
    @property
    def streamingRendererCount(cls) -> int: ...
    @classmethod
    @property
    def streamingTextureCount(cls) -> int: ...
    @classmethod
    @property
    def streamingTextureDiscardUnusedMips(cls) -> bool: ...
    @classmethod
    @streamingTextureDiscardUnusedMips.setter
    def streamingTextureDiscardUnusedMips(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def streamingTextureForceLoadAll(cls) -> bool: ...
    @classmethod
    @streamingTextureForceLoadAll.setter
    def streamingTextureForceLoadAll(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def streamingTextureLoadingCount(cls) -> int: ...
    @classmethod
    @property
    def streamingTexturePendingLoadCount(cls) -> int: ...
    @classmethod
    @property
    def targetTextureMemory(cls) -> int: ...
    @property
    def texelSize(self) -> Vector2: ...
    @classmethod
    @property
    def totalTextureMemory(cls) -> int: ...
    @property
    def updateCount(self) -> int: ...
    @property
    def width(self) -> int: ...
    @width.setter
    def width(self, value: int) -> int: ...
    @property
    def wrapMode(self) -> TextureWrapMode: ...
    @wrapMode.setter
    def wrapMode(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeU(self) -> TextureWrapMode: ...
    @wrapModeU.setter
    def wrapModeU(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeV(self) -> TextureWrapMode: ...
    @wrapModeV.setter
    def wrapModeV(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeW(self) -> TextureWrapMode: ...
    @wrapModeW.setter
    def wrapModeW(self, value: TextureWrapMode) -> TextureWrapMode: ...
    def GetNativeTextureID(self) -> int: ...
    def GetNativeTexturePtr(self) -> int: ...
    def IncrementUpdateCount(self) -> None: ...
    @staticmethod
    def SetGlobalAnisotropicFilteringLimits(forcedMin: int, globalMax: int) -> None: ...
    @staticmethod
    def SetStreamingTextureMaterialDebugProperties() -> None: ...


class Texture2D(Texture):
    # Constructor .ctor(width : Int32, height : Int32, textureFormat : TextureFormat, mipCount : Int32, linear : Boolean) was skipped since it collides with above method
    # Constructor .ctor(width : Int32, height : Int32, textureFormat : TextureFormat, mipCount : Int32, linear : Boolean, createUninitialized : Boolean) was skipped since it collides with above method
    @typing.overload
    def __init__(self, width: int, height: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, format: DefaultFormat, flags: TextureCreationFlags) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, format: GraphicsFormat, flags: TextureCreationFlags) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, format: DefaultFormat, mipCount: int, flags: TextureCreationFlags) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, format: GraphicsFormat, mipCount: int, flags: TextureCreationFlags) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, format: DefaultFormat, mipCount: int, mipmapLimitGroupName: str, flags: TextureCreationFlags) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, format: GraphicsFormat, mipCount: int, mipmapLimitGroupName: str, flags: TextureCreationFlags) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, textureFormat: TextureFormat, mipChain: bool) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, textureFormat: TextureFormat, mipChain: bool, linear: bool) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, textureFormat: TextureFormat, mipChain: bool, linear: bool, createUninitialized: bool) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, textureFormat: TextureFormat, mipCount: int, linear: bool, createUninitialized: bool, ignoreMipmapLimit: bool, mipmapLimitGroupName: str) -> None: ...
    @property
    def activeMipmapLimit(self) -> int: ...
    @property
    def alphaIsTransparency(self) -> bool: ...
    @alphaIsTransparency.setter
    def alphaIsTransparency(self, value: bool) -> bool: ...
    @property
    def anisoLevel(self) -> int: ...
    @anisoLevel.setter
    def anisoLevel(self, value: int) -> int: ...
    @classmethod
    @property
    def blackTexture(cls) -> Texture2D: ...
    @property
    def calculatedMipmapLevel(self) -> int: ...
    @property
    def desiredMipmapLevel(self) -> int: ...
    @property
    def dimension(self) -> TextureDimension: ...
    @dimension.setter
    def dimension(self, value: TextureDimension) -> TextureDimension: ...
    @property
    def filterMode(self) -> FilterMode: ...
    @filterMode.setter
    def filterMode(self, value: FilterMode) -> FilterMode: ...
    @property
    def format(self) -> TextureFormat: ...
    @property
    def graphicsFormat(self) -> GraphicsFormat: ...
    @classmethod
    @property
    def grayTexture(cls) -> Texture2D: ...
    @property
    def height(self) -> int: ...
    @height.setter
    def height(self, value: int) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def ignoreMipmapLimit(self) -> bool: ...
    @ignoreMipmapLimit.setter
    def ignoreMipmapLimit(self, value: bool) -> bool: ...
    @property
    def imageContentsHash(self) -> Hash128: ...
    @imageContentsHash.setter
    def imageContentsHash(self, value: Hash128) -> Hash128: ...
    @property
    def isDataSRGB(self) -> bool: ...
    @property
    def isReadable(self) -> bool: ...
    @classmethod
    @property
    def linearGrayTexture(cls) -> Texture2D: ...
    @property
    def loadedMipmapLevel(self) -> int: ...
    @property
    def loadingMipmapLevel(self) -> int: ...
    @property
    def minimumMipmapLevel(self) -> int: ...
    @minimumMipmapLevel.setter
    def minimumMipmapLevel(self, value: int) -> int: ...
    @property
    def mipMapBias(self) -> float: ...
    @mipMapBias.setter
    def mipMapBias(self, value: float) -> float: ...
    @property
    def mipmapCount(self) -> int: ...
    @property
    def mipmapLimitGroup(self) -> str: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @classmethod
    @property
    def normalTexture(cls) -> Texture2D: ...
    @classmethod
    @property
    def redTexture(cls) -> Texture2D: ...
    @property
    def requestedMipmapLevel(self) -> int: ...
    @requestedMipmapLevel.setter
    def requestedMipmapLevel(self, value: int) -> int: ...
    @property
    def streamingMipmaps(self) -> bool: ...
    @property
    def streamingMipmapsPriority(self) -> int: ...
    @property
    def texelSize(self) -> Vector2: ...
    @property
    def updateCount(self) -> int: ...
    @property
    def vtOnly(self) -> bool: ...
    @classmethod
    @property
    def whiteTexture(cls) -> Texture2D: ...
    @property
    def width(self) -> int: ...
    @width.setter
    def width(self, value: int) -> int: ...
    @property
    def wrapMode(self) -> TextureWrapMode: ...
    @wrapMode.setter
    def wrapMode(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeU(self) -> TextureWrapMode: ...
    @wrapModeU.setter
    def wrapModeU(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeV(self) -> TextureWrapMode: ...
    @wrapModeV.setter
    def wrapModeV(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeW(self) -> TextureWrapMode: ...
    @wrapModeW.setter
    def wrapModeW(self, value: TextureWrapMode) -> TextureWrapMode: ...
    def ClearMinimumMipmapLevel(self) -> None: ...
    def ClearRequestedMipmapLevel(self) -> None: ...
    def Compress(self, highQuality: bool) -> None: ...
    @staticmethod
    def CreateExternalTexture(width: int, height: int, format: TextureFormat, mipChain: bool, linear: bool, nativeTex: int) -> Texture2D: ...
    @staticmethod
    def GenerateAtlas(sizes: Array_1[Vector2], padding: int, atlasSize: int, results: List_1[Rect]) -> bool: ...
    def IsRequestedMipmapLevelLoaded(self) -> bool: ...
    def UpdateExternalTexture(self, nativeTex: int) -> None: ...
    # Skipped Apply due to it being static, abstract and generic.

    Apply : Apply_MethodGroup
    class Apply_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, updateMipmaps: bool) -> None:...
        @typing.overload
        def __call__(self, updateMipmaps: bool, makeNoLongerReadable: bool) -> None:...

    # Skipped GetPixel due to it being static, abstract and generic.

    GetPixel : GetPixel_MethodGroup
    class GetPixel_MethodGroup:
        @typing.overload
        def __call__(self, x: int, y: int) -> Color:...
        @typing.overload
        def __call__(self, x: int, y: int, mipLevel: int) -> Color:...

    # Skipped GetPixelBilinear due to it being static, abstract and generic.

    GetPixelBilinear : GetPixelBilinear_MethodGroup
    class GetPixelBilinear_MethodGroup:
        @typing.overload
        def __call__(self, u: float, v: float) -> Color:...
        @typing.overload
        def __call__(self, u: float, v: float, mipLevel: int) -> Color:...

    # Skipped GetPixelData due to it being static, abstract and generic.

    GetPixelData : GetPixelData_MethodGroup
    class GetPixelData_MethodGroup:
        def __getitem__(self, t:typing.Type[GetPixelData_1_T1]) -> GetPixelData_1[GetPixelData_1_T1]: ...

        GetPixelData_1_T1 = typing.TypeVar('GetPixelData_1_T1')
        class GetPixelData_1(typing.Generic[GetPixelData_1_T1]):
            GetPixelData_1_T = Texture2D.GetPixelData_MethodGroup.GetPixelData_1_T1
            def __call__(self, mipLevel: int) -> NativeArray_1[GetPixelData_1_T]:...


    # Skipped GetPixels due to it being static, abstract and generic.

    GetPixels : GetPixels_MethodGroup
    class GetPixels_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[Color]:...
        @typing.overload
        def __call__(self, miplevel: int) -> Array_1[Color]:...
        @typing.overload
        def __call__(self, x: int, y: int, blockWidth: int, blockHeight: int) -> Array_1[Color]:...
        @typing.overload
        def __call__(self, x: int, y: int, blockWidth: int, blockHeight: int, miplevel: int) -> Array_1[Color]:...

    # Skipped GetPixels32 due to it being static, abstract and generic.

    GetPixels32 : GetPixels32_MethodGroup
    class GetPixels32_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[Color32]:...
        @typing.overload
        def __call__(self, miplevel: int) -> Array_1[Color32]:...

    # Skipped GetRawTextureData due to it being static, abstract and generic.

    GetRawTextureData : GetRawTextureData_MethodGroup
    class GetRawTextureData_MethodGroup:
        def __getitem__(self, t:typing.Type[GetRawTextureData_1_T1]) -> GetRawTextureData_1[GetRawTextureData_1_T1]: ...

        GetRawTextureData_1_T1 = typing.TypeVar('GetRawTextureData_1_T1')
        class GetRawTextureData_1(typing.Generic[GetRawTextureData_1_T1]):
            GetRawTextureData_1_T = Texture2D.GetRawTextureData_MethodGroup.GetRawTextureData_1_T1
            def __call__(self) -> NativeArray_1[GetRawTextureData_1_T]:...

        def __call__(self) -> Array_1[int]:...

    # Skipped LoadRawTextureData due to it being static, abstract and generic.

    LoadRawTextureData : LoadRawTextureData_MethodGroup
    class LoadRawTextureData_MethodGroup:
        def __getitem__(self, t:typing.Type[LoadRawTextureData_1_T1]) -> LoadRawTextureData_1[LoadRawTextureData_1_T1]: ...

        LoadRawTextureData_1_T1 = typing.TypeVar('LoadRawTextureData_1_T1')
        class LoadRawTextureData_1(typing.Generic[LoadRawTextureData_1_T1]):
            LoadRawTextureData_1_T = Texture2D.LoadRawTextureData_MethodGroup.LoadRawTextureData_1_T1
            def __call__(self, data: NativeArray_1[LoadRawTextureData_1_T]) -> None:...

        @typing.overload
        def __call__(self, data: Array_1[int]) -> None:...
        @typing.overload
        def __call__(self, data: int, size: int) -> None:...

    # Skipped PackTextures due to it being static, abstract and generic.

    PackTextures : PackTextures_MethodGroup
    class PackTextures_MethodGroup:
        @typing.overload
        def __call__(self, textures: Array_1[Texture2D], padding: int) -> Array_1[Rect]:...
        @typing.overload
        def __call__(self, textures: Array_1[Texture2D], padding: int, maximumAtlasSize: int) -> Array_1[Rect]:...
        @typing.overload
        def __call__(self, textures: Array_1[Texture2D], padding: int, maximumAtlasSize: int, makeNoLongerReadable: bool) -> Array_1[Rect]:...

    # Skipped ReadPixels due to it being static, abstract and generic.

    ReadPixels : ReadPixels_MethodGroup
    class ReadPixels_MethodGroup:
        @typing.overload
        def __call__(self, source: Rect, destX: int, destY: int) -> None:...
        @typing.overload
        def __call__(self, source: Rect, destX: int, destY: int, recalculateMipMaps: bool) -> None:...

    # Skipped Reinitialize due to it being static, abstract and generic.

    Reinitialize : Reinitialize_MethodGroup
    class Reinitialize_MethodGroup:
        @typing.overload
        def __call__(self, width: int, height: int) -> bool:...
        @typing.overload
        def __call__(self, width: int, height: int, format: TextureFormat, hasMipMap: bool) -> bool:...
        @typing.overload
        def __call__(self, width: int, height: int, format: GraphicsFormat, hasMipMap: bool) -> bool:...

    # Skipped Resize due to it being static, abstract and generic.

    Resize : Resize_MethodGroup
    class Resize_MethodGroup:
        @typing.overload
        def __call__(self, width: int, height: int) -> bool:...
        @typing.overload
        def __call__(self, width: int, height: int, format: TextureFormat, hasMipMap: bool) -> bool:...
        @typing.overload
        def __call__(self, width: int, height: int, format: GraphicsFormat, hasMipMap: bool) -> bool:...

    # Skipped SetPixel due to it being static, abstract and generic.

    SetPixel : SetPixel_MethodGroup
    class SetPixel_MethodGroup:
        @typing.overload
        def __call__(self, x: int, y: int, color: Color) -> None:...
        @typing.overload
        def __call__(self, x: int, y: int, color: Color, mipLevel: int) -> None:...

    # Skipped SetPixelData due to it being static, abstract and generic.

    SetPixelData : SetPixelData_MethodGroup
    class SetPixelData_MethodGroup:
        def __getitem__(self, t:typing.Type[SetPixelData_1_T1]) -> SetPixelData_1[SetPixelData_1_T1]: ...

        SetPixelData_1_T1 = typing.TypeVar('SetPixelData_1_T1')
        class SetPixelData_1(typing.Generic[SetPixelData_1_T1]):
            SetPixelData_1_T = Texture2D.SetPixelData_MethodGroup.SetPixelData_1_T1
            @typing.overload
            def __call__(self, data: Array_1[SetPixelData_1_T], mipLevel: int, sourceDataStartIndex: int = ...) -> None:...
            @typing.overload
            def __call__(self, data: NativeArray_1[SetPixelData_1_T], mipLevel: int, sourceDataStartIndex: int = ...) -> None:...


    # Skipped SetPixels due to it being static, abstract and generic.

    SetPixels : SetPixels_MethodGroup
    class SetPixels_MethodGroup:
        @typing.overload
        def __call__(self, colors: Array_1[Color]) -> None:...
        @typing.overload
        def __call__(self, colors: Array_1[Color], miplevel: int) -> None:...
        @typing.overload
        def __call__(self, x: int, y: int, blockWidth: int, blockHeight: int, colors: Array_1[Color]) -> None:...
        @typing.overload
        def __call__(self, x: int, y: int, blockWidth: int, blockHeight: int, colors: Array_1[Color], miplevel: int) -> None:...

    # Skipped SetPixels32 due to it being static, abstract and generic.

    SetPixels32 : SetPixels32_MethodGroup
    class SetPixels32_MethodGroup:
        @typing.overload
        def __call__(self, colors: Array_1[Color32]) -> None:...
        @typing.overload
        def __call__(self, colors: Array_1[Color32], miplevel: int) -> None:...
        @typing.overload
        def __call__(self, x: int, y: int, blockWidth: int, blockHeight: int, colors: Array_1[Color32]) -> None:...
        @typing.overload
        def __call__(self, x: int, y: int, blockWidth: int, blockHeight: int, colors: Array_1[Color32], miplevel: int) -> None:...


    class EXRFlags(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        None_ : Texture2D.EXRFlags # 0
        OutputAsFloat : Texture2D.EXRFlags # 1
        CompressZIP : Texture2D.EXRFlags # 2
        CompressRLE : Texture2D.EXRFlags # 4
        CompressPIZ : Texture2D.EXRFlags # 8



class Texture2DArray(Texture):
    # Constructor .ctor(width : Int32, height : Int32, depth : Int32, textureFormat : TextureFormat, mipCount : Int32, linear : Boolean) was skipped since it collides with above method
    # Constructor .ctor(width : Int32, height : Int32, depth : Int32, textureFormat : TextureFormat, mipCount : Int32, linear : Boolean, createUninitialized : Boolean) was skipped since it collides with above method
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, format: DefaultFormat, flags: TextureCreationFlags) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, format: GraphicsFormat, flags: TextureCreationFlags) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, format: DefaultFormat, flags: TextureCreationFlags, mipCount: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, format: GraphicsFormat, flags: TextureCreationFlags, mipCount: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, textureFormat: TextureFormat, mipChain: bool) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, textureFormat: TextureFormat, mipChain: bool, linear: bool) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, textureFormat: TextureFormat, mipChain: bool, linear: bool, createUninitialized: bool) -> None: ...
    @classmethod
    @property
    def allSlices(cls) -> int: ...
    @property
    def anisoLevel(self) -> int: ...
    @anisoLevel.setter
    def anisoLevel(self, value: int) -> int: ...
    @property
    def depth(self) -> int: ...
    @property
    def dimension(self) -> TextureDimension: ...
    @dimension.setter
    def dimension(self, value: TextureDimension) -> TextureDimension: ...
    @property
    def filterMode(self) -> FilterMode: ...
    @filterMode.setter
    def filterMode(self, value: FilterMode) -> FilterMode: ...
    @property
    def format(self) -> TextureFormat: ...
    @property
    def graphicsFormat(self) -> GraphicsFormat: ...
    @property
    def height(self) -> int: ...
    @height.setter
    def height(self, value: int) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def imageContentsHash(self) -> Hash128: ...
    @imageContentsHash.setter
    def imageContentsHash(self, value: Hash128) -> Hash128: ...
    @property
    def isDataSRGB(self) -> bool: ...
    @property
    def isReadable(self) -> bool: ...
    @property
    def mipMapBias(self) -> float: ...
    @mipMapBias.setter
    def mipMapBias(self, value: float) -> float: ...
    @property
    def mipmapCount(self) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def texelSize(self) -> Vector2: ...
    @property
    def updateCount(self) -> int: ...
    @property
    def width(self) -> int: ...
    @width.setter
    def width(self, value: int) -> int: ...
    @property
    def wrapMode(self) -> TextureWrapMode: ...
    @wrapMode.setter
    def wrapMode(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeU(self) -> TextureWrapMode: ...
    @wrapModeU.setter
    def wrapModeU(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeV(self) -> TextureWrapMode: ...
    @wrapModeV.setter
    def wrapModeV(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeW(self) -> TextureWrapMode: ...
    @wrapModeW.setter
    def wrapModeW(self, value: TextureWrapMode) -> TextureWrapMode: ...
    # Skipped Apply due to it being static, abstract and generic.

    Apply : Apply_MethodGroup
    class Apply_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, updateMipmaps: bool) -> None:...
        @typing.overload
        def __call__(self, updateMipmaps: bool, makeNoLongerReadable: bool) -> None:...

    # Skipped GetPixelData due to it being static, abstract and generic.

    GetPixelData : GetPixelData_MethodGroup
    class GetPixelData_MethodGroup:
        def __getitem__(self, t:typing.Type[GetPixelData_1_T1]) -> GetPixelData_1[GetPixelData_1_T1]: ...

        GetPixelData_1_T1 = typing.TypeVar('GetPixelData_1_T1')
        class GetPixelData_1(typing.Generic[GetPixelData_1_T1]):
            GetPixelData_1_T = Texture2DArray.GetPixelData_MethodGroup.GetPixelData_1_T1
            def __call__(self, mipLevel: int, element: int) -> NativeArray_1[GetPixelData_1_T]:...


    # Skipped GetPixels due to it being static, abstract and generic.

    GetPixels : GetPixels_MethodGroup
    class GetPixels_MethodGroup:
        @typing.overload
        def __call__(self, arrayElement: int) -> Array_1[Color]:...
        @typing.overload
        def __call__(self, arrayElement: int, miplevel: int) -> Array_1[Color]:...

    # Skipped GetPixels32 due to it being static, abstract and generic.

    GetPixels32 : GetPixels32_MethodGroup
    class GetPixels32_MethodGroup:
        @typing.overload
        def __call__(self, arrayElement: int) -> Array_1[Color32]:...
        @typing.overload
        def __call__(self, arrayElement: int, miplevel: int) -> Array_1[Color32]:...

    # Skipped SetPixelData due to it being static, abstract and generic.

    SetPixelData : SetPixelData_MethodGroup
    class SetPixelData_MethodGroup:
        def __getitem__(self, t:typing.Type[SetPixelData_1_T1]) -> SetPixelData_1[SetPixelData_1_T1]: ...

        SetPixelData_1_T1 = typing.TypeVar('SetPixelData_1_T1')
        class SetPixelData_1(typing.Generic[SetPixelData_1_T1]):
            SetPixelData_1_T = Texture2DArray.SetPixelData_MethodGroup.SetPixelData_1_T1
            @typing.overload
            def __call__(self, data: Array_1[SetPixelData_1_T], mipLevel: int, element: int, sourceDataStartIndex: int = ...) -> None:...
            @typing.overload
            def __call__(self, data: NativeArray_1[SetPixelData_1_T], mipLevel: int, element: int, sourceDataStartIndex: int = ...) -> None:...


    # Skipped SetPixels due to it being static, abstract and generic.

    SetPixels : SetPixels_MethodGroup
    class SetPixels_MethodGroup:
        @typing.overload
        def __call__(self, colors: Array_1[Color], arrayElement: int) -> None:...
        @typing.overload
        def __call__(self, colors: Array_1[Color], arrayElement: int, miplevel: int) -> None:...

    # Skipped SetPixels32 due to it being static, abstract and generic.

    SetPixels32 : SetPixels32_MethodGroup
    class SetPixels32_MethodGroup:
        @typing.overload
        def __call__(self, colors: Array_1[Color32], arrayElement: int) -> None:...
        @typing.overload
        def __call__(self, colors: Array_1[Color32], arrayElement: int, miplevel: int) -> None:...



class Texture3D(Texture):
    # Constructor .ctor(width : Int32, height : Int32, depth : Int32, textureFormat : TextureFormat, mipChain : Boolean, nativeTex : IntPtr) was skipped since it collides with above method
    # Constructor .ctor(width : Int32, height : Int32, depth : Int32, textureFormat : TextureFormat, mipCount : Int32) was skipped since it collides with above method
    # Constructor .ctor(width : Int32, height : Int32, depth : Int32, textureFormat : TextureFormat, mipCount : Int32, nativeTex : IntPtr) was skipped since it collides with above method
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, format: DefaultFormat, flags: TextureCreationFlags) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, format: GraphicsFormat, flags: TextureCreationFlags) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, format: DefaultFormat, flags: TextureCreationFlags, mipCount: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, format: GraphicsFormat, flags: TextureCreationFlags, mipCount: int) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, textureFormat: TextureFormat, mipChain: bool) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, textureFormat: TextureFormat, mipChain: bool, createUninitialized: bool) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, depth: int, textureFormat: TextureFormat, mipCount: int, nativeTex: int, createUninitialized: bool) -> None: ...
    @property
    def anisoLevel(self) -> int: ...
    @anisoLevel.setter
    def anisoLevel(self, value: int) -> int: ...
    @property
    def depth(self) -> int: ...
    @property
    def dimension(self) -> TextureDimension: ...
    @dimension.setter
    def dimension(self, value: TextureDimension) -> TextureDimension: ...
    @property
    def filterMode(self) -> FilterMode: ...
    @filterMode.setter
    def filterMode(self, value: FilterMode) -> FilterMode: ...
    @property
    def format(self) -> TextureFormat: ...
    @property
    def graphicsFormat(self) -> GraphicsFormat: ...
    @property
    def height(self) -> int: ...
    @height.setter
    def height(self, value: int) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def imageContentsHash(self) -> Hash128: ...
    @imageContentsHash.setter
    def imageContentsHash(self, value: Hash128) -> Hash128: ...
    @property
    def isDataSRGB(self) -> bool: ...
    @property
    def isReadable(self) -> bool: ...
    @property
    def mipMapBias(self) -> float: ...
    @mipMapBias.setter
    def mipMapBias(self, value: float) -> float: ...
    @property
    def mipmapCount(self) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def texelSize(self) -> Vector2: ...
    @property
    def updateCount(self) -> int: ...
    @property
    def width(self) -> int: ...
    @width.setter
    def width(self, value: int) -> int: ...
    @property
    def wrapMode(self) -> TextureWrapMode: ...
    @wrapMode.setter
    def wrapMode(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeU(self) -> TextureWrapMode: ...
    @wrapModeU.setter
    def wrapModeU(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeV(self) -> TextureWrapMode: ...
    @wrapModeV.setter
    def wrapModeV(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeW(self) -> TextureWrapMode: ...
    @wrapModeW.setter
    def wrapModeW(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @staticmethod
    def CreateExternalTexture(width: int, height: int, depth: int, format: TextureFormat, mipChain: bool, nativeTex: int) -> Texture3D: ...
    def UpdateExternalTexture(self, nativeTex: int) -> None: ...
    # Skipped Apply due to it being static, abstract and generic.

    Apply : Apply_MethodGroup
    class Apply_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, updateMipmaps: bool) -> None:...
        @typing.overload
        def __call__(self, updateMipmaps: bool, makeNoLongerReadable: bool) -> None:...

    # Skipped GetPixel due to it being static, abstract and generic.

    GetPixel : GetPixel_MethodGroup
    class GetPixel_MethodGroup:
        @typing.overload
        def __call__(self, x: int, y: int, z: int) -> Color:...
        @typing.overload
        def __call__(self, x: int, y: int, z: int, mipLevel: int) -> Color:...

    # Skipped GetPixelBilinear due to it being static, abstract and generic.

    GetPixelBilinear : GetPixelBilinear_MethodGroup
    class GetPixelBilinear_MethodGroup:
        @typing.overload
        def __call__(self, u: float, v: float, w: float) -> Color:...
        @typing.overload
        def __call__(self, u: float, v: float, w: float, mipLevel: int) -> Color:...

    # Skipped GetPixelData due to it being static, abstract and generic.

    GetPixelData : GetPixelData_MethodGroup
    class GetPixelData_MethodGroup:
        def __getitem__(self, t:typing.Type[GetPixelData_1_T1]) -> GetPixelData_1[GetPixelData_1_T1]: ...

        GetPixelData_1_T1 = typing.TypeVar('GetPixelData_1_T1')
        class GetPixelData_1(typing.Generic[GetPixelData_1_T1]):
            GetPixelData_1_T = Texture3D.GetPixelData_MethodGroup.GetPixelData_1_T1
            def __call__(self, mipLevel: int) -> NativeArray_1[GetPixelData_1_T]:...


    # Skipped GetPixels due to it being static, abstract and generic.

    GetPixels : GetPixels_MethodGroup
    class GetPixels_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[Color]:...
        @typing.overload
        def __call__(self, miplevel: int) -> Array_1[Color]:...

    # Skipped GetPixels32 due to it being static, abstract and generic.

    GetPixels32 : GetPixels32_MethodGroup
    class GetPixels32_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[Color32]:...
        @typing.overload
        def __call__(self, miplevel: int) -> Array_1[Color32]:...

    # Skipped SetPixel due to it being static, abstract and generic.

    SetPixel : SetPixel_MethodGroup
    class SetPixel_MethodGroup:
        @typing.overload
        def __call__(self, x: int, y: int, z: int, color: Color) -> None:...
        @typing.overload
        def __call__(self, x: int, y: int, z: int, color: Color, mipLevel: int) -> None:...

    # Skipped SetPixelData due to it being static, abstract and generic.

    SetPixelData : SetPixelData_MethodGroup
    class SetPixelData_MethodGroup:
        def __getitem__(self, t:typing.Type[SetPixelData_1_T1]) -> SetPixelData_1[SetPixelData_1_T1]: ...

        SetPixelData_1_T1 = typing.TypeVar('SetPixelData_1_T1')
        class SetPixelData_1(typing.Generic[SetPixelData_1_T1]):
            SetPixelData_1_T = Texture3D.SetPixelData_MethodGroup.SetPixelData_1_T1
            @typing.overload
            def __call__(self, data: Array_1[SetPixelData_1_T], mipLevel: int, sourceDataStartIndex: int = ...) -> None:...
            @typing.overload
            def __call__(self, data: NativeArray_1[SetPixelData_1_T], mipLevel: int, sourceDataStartIndex: int = ...) -> None:...


    # Skipped SetPixels due to it being static, abstract and generic.

    SetPixels : SetPixels_MethodGroup
    class SetPixels_MethodGroup:
        @typing.overload
        def __call__(self, colors: Array_1[Color]) -> None:...
        @typing.overload
        def __call__(self, colors: Array_1[Color], miplevel: int) -> None:...

    # Skipped SetPixels32 due to it being static, abstract and generic.

    SetPixels32 : SetPixels32_MethodGroup
    class SetPixels32_MethodGroup:
        @typing.overload
        def __call__(self, colors: Array_1[Color32]) -> None:...
        @typing.overload
        def __call__(self, colors: Array_1[Color32], miplevel: int) -> None:...



class TextureFormat(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Alpha8 : TextureFormat # 1
    ARGB4444 : TextureFormat # 2
    RGB24 : TextureFormat # 3
    RGBA32 : TextureFormat # 4
    ARGB32 : TextureFormat # 5
    RGB565 : TextureFormat # 7
    R16 : TextureFormat # 9
    DXT1 : TextureFormat # 10
    DXT5 : TextureFormat # 12
    RGBA4444 : TextureFormat # 13
    BGRA32 : TextureFormat # 14
    RHalf : TextureFormat # 15
    RGHalf : TextureFormat # 16
    RGBAHalf : TextureFormat # 17
    RFloat : TextureFormat # 18
    RGFloat : TextureFormat # 19
    RGBAFloat : TextureFormat # 20
    YUY2 : TextureFormat # 21
    RGB9e5Float : TextureFormat # 22
    BC6H : TextureFormat # 24
    BC7 : TextureFormat # 25
    BC4 : TextureFormat # 26
    BC5 : TextureFormat # 27
    DXT1Crunched : TextureFormat # 28
    DXT5Crunched : TextureFormat # 29
    PVRTC_RGB2 : TextureFormat # 30
    PVRTC_RGBA2 : TextureFormat # 31
    PVRTC_RGB4 : TextureFormat # 32
    PVRTC_RGBA4 : TextureFormat # 33
    ETC_RGB4 : TextureFormat # 34
    EAC_R : TextureFormat # 41
    EAC_R_SIGNED : TextureFormat # 42
    EAC_RG : TextureFormat # 43
    EAC_RG_SIGNED : TextureFormat # 44
    ETC2_RGB : TextureFormat # 45
    ETC2_RGBA1 : TextureFormat # 46
    ETC2_RGBA8 : TextureFormat # 47
    ASTC_RGB_4x4 : TextureFormat # 48
    ASTC_4x4 : TextureFormat # 48
    ASTC_5x5 : TextureFormat # 49
    ASTC_RGB_5x5 : TextureFormat # 49
    ASTC_RGB_6x6 : TextureFormat # 50
    ASTC_6x6 : TextureFormat # 50
    ASTC_8x8 : TextureFormat # 51
    ASTC_RGB_8x8 : TextureFormat # 51
    ASTC_RGB_10x10 : TextureFormat # 52
    ASTC_10x10 : TextureFormat # 52
    ASTC_12x12 : TextureFormat # 53
    ASTC_RGB_12x12 : TextureFormat # 53
    ASTC_RGBA_4x4 : TextureFormat # 54
    ASTC_RGBA_5x5 : TextureFormat # 55
    ASTC_RGBA_6x6 : TextureFormat # 56
    ASTC_RGBA_8x8 : TextureFormat # 57
    ASTC_RGBA_10x10 : TextureFormat # 58
    ASTC_RGBA_12x12 : TextureFormat # 59
    ETC_RGB4_3DS : TextureFormat # 60
    ETC_RGBA8_3DS : TextureFormat # 61
    RG16 : TextureFormat # 62
    R8 : TextureFormat # 63
    ETC_RGB4Crunched : TextureFormat # 64
    ETC2_RGBA8Crunched : TextureFormat # 65
    ASTC_HDR_4x4 : TextureFormat # 66
    ASTC_HDR_5x5 : TextureFormat # 67
    ASTC_HDR_6x6 : TextureFormat # 68
    ASTC_HDR_8x8 : TextureFormat # 69
    ASTC_HDR_10x10 : TextureFormat # 70
    ASTC_HDR_12x12 : TextureFormat # 71
    RG32 : TextureFormat # 72
    RGB48 : TextureFormat # 73
    RGBA64 : TextureFormat # 74
    PVRTC_2BPP_RGB : TextureFormat # -127
    PVRTC_2BPP_RGBA : TextureFormat # -127
    ATC_RGBA8 : TextureFormat # -127
    PVRTC_4BPP_RGB : TextureFormat # -127
    ATC_RGB4 : TextureFormat # -127
    PVRTC_4BPP_RGBA : TextureFormat # -127


class TextureMipmapLimitBiasMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    OffsetGlobalLimit : TextureMipmapLimitBiasMode # 0
    OverrideGlobalLimit : TextureMipmapLimitBiasMode # 1


class TextureMipmapLimitGroups(abc.ABC):
    @staticmethod
    def CreateGroup(groupName: str) -> None: ...
    @staticmethod
    def GetGroups() -> Array_1[str]: ...
    @staticmethod
    def HasGroup(groupName: str) -> bool: ...
    @staticmethod
    def RemoveGroup(groupName: str) -> None: ...


class TextureMipmapLimitSettings:
    @property
    def limitBias(self) -> int: ...
    @limitBias.setter
    def limitBias(self, value: int) -> int: ...
    @property
    def limitBiasMode(self) -> TextureMipmapLimitBiasMode: ...
    @limitBiasMode.setter
    def limitBiasMode(self, value: TextureMipmapLimitBiasMode) -> TextureMipmapLimitBiasMode: ...


class TextureWrapMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Repeat : TextureWrapMode # 0
    Clamp : TextureWrapMode # 1
    Mirror : TextureWrapMode # 2
    MirrorOnce : TextureWrapMode # 3


class ThreadPriority(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Low : ThreadPriority # 0
    BelowNormal : ThreadPriority # 1
    Normal : ThreadPriority # 2
    High : ThreadPriority # 4


class Time:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def captureDeltaTime(cls) -> float: ...
    @classmethod
    @captureDeltaTime.setter
    def captureDeltaTime(cls, value: float) -> float: ...
    @classmethod
    @property
    def captureFramerate(cls) -> int: ...
    @classmethod
    @captureFramerate.setter
    def captureFramerate(cls, value: int) -> int: ...
    @classmethod
    @property
    def deltaTime(cls) -> float: ...
    @classmethod
    @property
    def fixedDeltaTime(cls) -> float: ...
    @classmethod
    @fixedDeltaTime.setter
    def fixedDeltaTime(cls, value: float) -> float: ...
    @classmethod
    @property
    def fixedTime(cls) -> float: ...
    @classmethod
    @property
    def fixedTimeAsDouble(cls) -> float: ...
    @classmethod
    @property
    def fixedUnscaledDeltaTime(cls) -> float: ...
    @classmethod
    @property
    def fixedUnscaledTime(cls) -> float: ...
    @classmethod
    @property
    def fixedUnscaledTimeAsDouble(cls) -> float: ...
    @classmethod
    @property
    def frameCount(cls) -> int: ...
    @classmethod
    @property
    def inFixedTimeStep(cls) -> bool: ...
    @classmethod
    @property
    def maximumDeltaTime(cls) -> float: ...
    @classmethod
    @maximumDeltaTime.setter
    def maximumDeltaTime(cls, value: float) -> float: ...
    @classmethod
    @property
    def maximumParticleDeltaTime(cls) -> float: ...
    @classmethod
    @maximumParticleDeltaTime.setter
    def maximumParticleDeltaTime(cls, value: float) -> float: ...
    @classmethod
    @property
    def realtimeSinceStartup(cls) -> float: ...
    @classmethod
    @property
    def realtimeSinceStartupAsDouble(cls) -> float: ...
    @classmethod
    @property
    def renderedFrameCount(cls) -> int: ...
    @classmethod
    @property
    def smoothDeltaTime(cls) -> float: ...
    @classmethod
    @property
    def time(cls) -> float: ...
    @classmethod
    @property
    def timeAsDouble(cls) -> float: ...
    @classmethod
    @property
    def timeScale(cls) -> float: ...
    @classmethod
    @timeScale.setter
    def timeScale(cls, value: float) -> float: ...
    @classmethod
    @property
    def timeSinceLevelLoad(cls) -> float: ...
    @classmethod
    @property
    def timeSinceLevelLoadAsDouble(cls) -> float: ...
    @classmethod
    @property
    def unscaledDeltaTime(cls) -> float: ...
    @classmethod
    @property
    def unscaledTime(cls) -> float: ...
    @classmethod
    @property
    def unscaledTimeAsDouble(cls) -> float: ...


class TooltipAttribute(PropertyAttribute):
    def __init__(self, tooltip: str) -> None: ...
    tooltip : str
    @property
    def order(self) -> int: ...
    @order.setter
    def order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class Touch:
    @property
    def altitudeAngle(self) -> float: ...
    @altitudeAngle.setter
    def altitudeAngle(self, value: float) -> float: ...
    @property
    def azimuthAngle(self) -> float: ...
    @azimuthAngle.setter
    def azimuthAngle(self, value: float) -> float: ...
    @property
    def deltaPosition(self) -> Vector2: ...
    @deltaPosition.setter
    def deltaPosition(self, value: Vector2) -> Vector2: ...
    @property
    def deltaTime(self) -> float: ...
    @deltaTime.setter
    def deltaTime(self, value: float) -> float: ...
    @property
    def fingerId(self) -> int: ...
    @fingerId.setter
    def fingerId(self, value: int) -> int: ...
    @property
    def maximumPossiblePressure(self) -> float: ...
    @maximumPossiblePressure.setter
    def maximumPossiblePressure(self, value: float) -> float: ...
    @property
    def phase(self) -> TouchPhase: ...
    @phase.setter
    def phase(self, value: TouchPhase) -> TouchPhase: ...
    @property
    def position(self) -> Vector2: ...
    @position.setter
    def position(self, value: Vector2) -> Vector2: ...
    @property
    def pressure(self) -> float: ...
    @pressure.setter
    def pressure(self, value: float) -> float: ...
    @property
    def radius(self) -> float: ...
    @radius.setter
    def radius(self, value: float) -> float: ...
    @property
    def radiusVariance(self) -> float: ...
    @radiusVariance.setter
    def radiusVariance(self, value: float) -> float: ...
    @property
    def rawPosition(self) -> Vector2: ...
    @rawPosition.setter
    def rawPosition(self, value: Vector2) -> Vector2: ...
    @property
    def tapCount(self) -> int: ...
    @tapCount.setter
    def tapCount(self, value: int) -> int: ...
    @property
    def type(self) -> TouchType: ...
    @type.setter
    def type(self, value: TouchType) -> TouchType: ...


class TouchPhase(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Began : TouchPhase # 0
    Moved : TouchPhase # 1
    Stationary : TouchPhase # 2
    Ended : TouchPhase # 3
    Canceled : TouchPhase # 4


class TouchScreenKeyboard:
    def __init__(self, text: str, keyboardType: TouchScreenKeyboardType, autocorrection: bool, multiline: bool, secure: bool, alert: bool, textPlaceholder: str, characterLimit: int) -> None: ...
    @property
    def active(self) -> bool: ...
    @active.setter
    def active(self, value: bool) -> bool: ...
    @classmethod
    @property
    def area(cls) -> Rect: ...
    @property
    def canGetSelection(self) -> bool: ...
    @property
    def canSetSelection(self) -> bool: ...
    @property
    def characterLimit(self) -> int: ...
    @characterLimit.setter
    def characterLimit(self, value: int) -> int: ...
    @property
    def done(self) -> bool: ...
    @classmethod
    @property
    def hideInput(cls) -> bool: ...
    @classmethod
    @hideInput.setter
    def hideInput(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def isInPlaceEditingAllowed(cls) -> bool: ...
    @classmethod
    @property
    def isSupported(cls) -> bool: ...
    @property
    def selection(self) -> RangeInt: ...
    @selection.setter
    def selection(self, value: RangeInt) -> RangeInt: ...
    @property
    def status(self) -> TouchScreenKeyboard.Status: ...
    @property
    def targetDisplay(self) -> int: ...
    @targetDisplay.setter
    def targetDisplay(self, value: int) -> int: ...
    @property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> str: ...
    @property
    def type(self) -> TouchScreenKeyboardType: ...
    @classmethod
    @property
    def visible(cls) -> bool: ...
    @property
    def wasCanceled(self) -> bool: ...
    # Skipped Open due to it being static, abstract and generic.

    Open : Open_MethodGroup
    class Open_MethodGroup:
        @typing.overload
        def __call__(self, text: str) -> TouchScreenKeyboard:...
        @typing.overload
        def __call__(self, text: str, keyboardType: TouchScreenKeyboardType) -> TouchScreenKeyboard:...
        @typing.overload
        def __call__(self, text: str, keyboardType: TouchScreenKeyboardType, autocorrection: bool) -> TouchScreenKeyboard:...
        @typing.overload
        def __call__(self, text: str, keyboardType: TouchScreenKeyboardType, autocorrection: bool, multiline: bool) -> TouchScreenKeyboard:...
        @typing.overload
        def __call__(self, text: str, keyboardType: TouchScreenKeyboardType, autocorrection: bool, multiline: bool, secure: bool) -> TouchScreenKeyboard:...
        @typing.overload
        def __call__(self, text: str, keyboardType: TouchScreenKeyboardType, autocorrection: bool, multiline: bool, secure: bool, alert: bool) -> TouchScreenKeyboard:...
        @typing.overload
        def __call__(self, text: str, keyboardType: TouchScreenKeyboardType, autocorrection: bool, multiline: bool, secure: bool, alert: bool, textPlaceholder: str) -> TouchScreenKeyboard:...
        @typing.overload
        def __call__(self, text: str, keyboardType: TouchScreenKeyboardType, autocorrection: bool, multiline: bool, secure: bool, alert: bool, textPlaceholder: str, characterLimit: int) -> TouchScreenKeyboard:...


    class Android:
        def __init__(self) -> None: ...
        @classmethod
        @property
        def closeKeyboardOnOutsideTap(cls) -> bool: ...
        @classmethod
        @closeKeyboardOnOutsideTap.setter
        def closeKeyboardOnOutsideTap(cls, value: bool) -> bool: ...
        @classmethod
        @property
        def consumesOutsideTouches(cls) -> bool: ...
        @classmethod
        @consumesOutsideTouches.setter
        def consumesOutsideTouches(cls, value: bool) -> bool: ...


    class Status(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Visible : TouchScreenKeyboard.Status # 0
        Done : TouchScreenKeyboard.Status # 1
        Canceled : TouchScreenKeyboard.Status # 2
        LostFocus : TouchScreenKeyboard.Status # 3



class TouchScreenKeyboardType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Default : TouchScreenKeyboardType # 0
    ASCIICapable : TouchScreenKeyboardType # 1
    NumbersAndPunctuation : TouchScreenKeyboardType # 2
    URL : TouchScreenKeyboardType # 3
    NumberPad : TouchScreenKeyboardType # 4
    PhonePad : TouchScreenKeyboardType # 5
    NamePhonePad : TouchScreenKeyboardType # 6
    EmailAddress : TouchScreenKeyboardType # 7
    NintendoNetworkAccount : TouchScreenKeyboardType # 8
    Social : TouchScreenKeyboardType # 9
    Search : TouchScreenKeyboardType # 10
    DecimalPad : TouchScreenKeyboardType # 11
    OneTimeCode : TouchScreenKeyboardType # 12


class TouchType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Direct : TouchType # 0
    Indirect : TouchType # 1
    Stylus : TouchType # 2


class TrackedReference:
    def Equals(self, o: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, x: TrackedReference, y: TrackedReference) -> bool: ...
    # Operator not supported op_Implicit(exists: TrackedReference)
    def __ne__(self, x: TrackedReference, y: TrackedReference) -> bool: ...


class TrailRenderer(Renderer):
    def __init__(self) -> None: ...
    @property
    def alignment(self) -> LineAlignment: ...
    @alignment.setter
    def alignment(self, value: LineAlignment) -> LineAlignment: ...
    @property
    def allowOcclusionWhenDynamic(self) -> bool: ...
    @allowOcclusionWhenDynamic.setter
    def allowOcclusionWhenDynamic(self, value: bool) -> bool: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autodestruct(self) -> bool: ...
    @autodestruct.setter
    def autodestruct(self, value: bool) -> bool: ...
    @property
    def bounds(self) -> Bounds: ...
    @bounds.setter
    def bounds(self, value: Bounds) -> Bounds: ...
    @property
    def camera(self) -> Component: ...
    @property
    def castShadows(self) -> bool: ...
    @castShadows.setter
    def castShadows(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def colorGradient(self) -> Gradient: ...
    @colorGradient.setter
    def colorGradient(self, value: Gradient) -> Gradient: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def emitting(self) -> bool: ...
    @emitting.setter
    def emitting(self, value: bool) -> bool: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def endColor(self) -> Color: ...
    @endColor.setter
    def endColor(self, value: Color) -> Color: ...
    @property
    def endWidth(self) -> float: ...
    @endWidth.setter
    def endWidth(self, value: float) -> float: ...
    @property
    def forceRenderingOff(self) -> bool: ...
    @forceRenderingOff.setter
    def forceRenderingOff(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def generateLightingData(self) -> bool: ...
    @generateLightingData.setter
    def generateLightingData(self, value: bool) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isPartOfStaticBatch(self) -> bool: ...
    @property
    def isVisible(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def lightmapIndex(self) -> int: ...
    @lightmapIndex.setter
    def lightmapIndex(self, value: int) -> int: ...
    @property
    def lightmapScaleOffset(self) -> Vector4: ...
    @lightmapScaleOffset.setter
    def lightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightmapTilingOffset(self) -> Vector4: ...
    @lightmapTilingOffset.setter
    def lightmapTilingOffset(self, value: Vector4) -> Vector4: ...
    @property
    def lightProbeAnchor(self) -> Transform: ...
    @lightProbeAnchor.setter
    def lightProbeAnchor(self, value: Transform) -> Transform: ...
    @property
    def lightProbeProxyVolumeOverride(self) -> GameObject: ...
    @lightProbeProxyVolumeOverride.setter
    def lightProbeProxyVolumeOverride(self, value: GameObject) -> GameObject: ...
    @property
    def lightProbeUsage(self) -> LightProbeUsage: ...
    @lightProbeUsage.setter
    def lightProbeUsage(self, value: LightProbeUsage) -> LightProbeUsage: ...
    @property
    def localBounds(self) -> Bounds: ...
    @localBounds.setter
    def localBounds(self, value: Bounds) -> Bounds: ...
    @property
    def localToWorldMatrix(self) -> Matrix4x4: ...
    @property
    def maskInteraction(self) -> SpriteMaskInteraction: ...
    @maskInteraction.setter
    def maskInteraction(self, value: SpriteMaskInteraction) -> SpriteMaskInteraction: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> Material: ...
    @property
    def materials(self) -> Array_1[Material]: ...
    @materials.setter
    def materials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def minVertexDistance(self) -> float: ...
    @minVertexDistance.setter
    def minVertexDistance(self, value: float) -> float: ...
    @property
    def motionVectorGenerationMode(self) -> MotionVectorGenerationMode: ...
    @motionVectorGenerationMode.setter
    def motionVectorGenerationMode(self, value: MotionVectorGenerationMode) -> MotionVectorGenerationMode: ...
    @property
    def motionVectors(self) -> bool: ...
    @motionVectors.setter
    def motionVectors(self, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def numCapVertices(self) -> int: ...
    @numCapVertices.setter
    def numCapVertices(self, value: int) -> int: ...
    @property
    def numCornerVertices(self) -> int: ...
    @numCornerVertices.setter
    def numCornerVertices(self, value: int) -> int: ...
    @property
    def numPositions(self) -> int: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def positionCount(self) -> int: ...
    @property
    def probeAnchor(self) -> Transform: ...
    @probeAnchor.setter
    def probeAnchor(self, value: Transform) -> Transform: ...
    @property
    def rayTracingMode(self) -> RayTracingMode: ...
    @rayTracingMode.setter
    def rayTracingMode(self, value: RayTracingMode) -> RayTracingMode: ...
    @property
    def realtimeLightmapIndex(self) -> int: ...
    @realtimeLightmapIndex.setter
    def realtimeLightmapIndex(self, value: int) -> int: ...
    @property
    def realtimeLightmapScaleOffset(self) -> Vector4: ...
    @realtimeLightmapScaleOffset.setter
    def realtimeLightmapScaleOffset(self, value: Vector4) -> Vector4: ...
    @property
    def receiveShadows(self) -> bool: ...
    @receiveShadows.setter
    def receiveShadows(self, value: bool) -> bool: ...
    @property
    def reflectionProbeUsage(self) -> ReflectionProbeUsage: ...
    @reflectionProbeUsage.setter
    def reflectionProbeUsage(self, value: ReflectionProbeUsage) -> ReflectionProbeUsage: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rendererPriority(self) -> int: ...
    @rendererPriority.setter
    def rendererPriority(self, value: int) -> int: ...
    @property
    def renderingLayerMask(self) -> int: ...
    @renderingLayerMask.setter
    def renderingLayerMask(self, value: int) -> int: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def shadowBias(self) -> float: ...
    @shadowBias.setter
    def shadowBias(self, value: float) -> float: ...
    @property
    def shadowCastingMode(self) -> ShadowCastingMode: ...
    @shadowCastingMode.setter
    def shadowCastingMode(self, value: ShadowCastingMode) -> ShadowCastingMode: ...
    @property
    def sharedMaterial(self) -> Material: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: Material) -> Material: ...
    @property
    def sharedMaterials(self) -> Array_1[Material]: ...
    @sharedMaterials.setter
    def sharedMaterials(self, value: Array_1[Material]) -> Array_1[Material]: ...
    @property
    def sortingLayerID(self) -> int: ...
    @sortingLayerID.setter
    def sortingLayerID(self, value: int) -> int: ...
    @property
    def sortingLayerName(self) -> str: ...
    @sortingLayerName.setter
    def sortingLayerName(self, value: str) -> str: ...
    @property
    def sortingOrder(self) -> int: ...
    @sortingOrder.setter
    def sortingOrder(self, value: int) -> int: ...
    @property
    def startColor(self) -> Color: ...
    @startColor.setter
    def startColor(self, value: Color) -> Color: ...
    @property
    def startWidth(self) -> float: ...
    @startWidth.setter
    def startWidth(self, value: float) -> float: ...
    @property
    def staticShadowCaster(self) -> bool: ...
    @staticShadowCaster.setter
    def staticShadowCaster(self, value: bool) -> bool: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def textureMode(self) -> LineTextureMode: ...
    @textureMode.setter
    def textureMode(self, value: LineTextureMode) -> LineTextureMode: ...
    @property
    def textureScale(self) -> Vector2: ...
    @textureScale.setter
    def textureScale(self, value: Vector2) -> Vector2: ...
    @property
    def time(self) -> float: ...
    @time.setter
    def time(self, value: float) -> float: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useLightProbes(self) -> bool: ...
    @useLightProbes.setter
    def useLightProbes(self, value: bool) -> bool: ...
    @property
    def widthCurve(self) -> AnimationCurve: ...
    @widthCurve.setter
    def widthCurve(self, value: AnimationCurve) -> AnimationCurve: ...
    @property
    def widthMultiplier(self) -> float: ...
    @widthMultiplier.setter
    def widthMultiplier(self, value: float) -> float: ...
    @property
    def worldToLocalMatrix(self) -> Matrix4x4: ...
    def AddPosition(self, position: Vector3) -> None: ...
    def Clear(self) -> None: ...
    def GetPosition(self, index: int) -> Vector3: ...
    def SetPosition(self, index: int, position: Vector3) -> None: ...
    # Skipped AddPositions due to it being static, abstract and generic.

    AddPositions : AddPositions_MethodGroup
    class AddPositions_MethodGroup:
        @typing.overload
        def __call__(self, positions: Array_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, positions: NativeArray_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, positions: NativeSlice_1[Vector3]) -> None:...

    # Skipped BakeMesh due to it being static, abstract and generic.

    BakeMesh : BakeMesh_MethodGroup
    class BakeMesh_MethodGroup:
        @typing.overload
        def __call__(self, mesh: Mesh, useTransform: bool = ...) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, camera: Camera, useTransform: bool = ...) -> None:...

    # Skipped GetPositions due to it being static, abstract and generic.

    GetPositions : GetPositions_MethodGroup
    class GetPositions_MethodGroup:
        @typing.overload
        def __call__(self, positions: Array_1[Vector3]) -> int:...
        @typing.overload
        def __call__(self, positions: NativeArray_1[Vector3]) -> int:...
        @typing.overload
        def __call__(self, positions: NativeSlice_1[Vector3]) -> int:...

    # Skipped GetVisiblePositions due to it being static, abstract and generic.

    GetVisiblePositions : GetVisiblePositions_MethodGroup
    class GetVisiblePositions_MethodGroup:
        @typing.overload
        def __call__(self, positions: Array_1[Vector3]) -> int:...
        @typing.overload
        def __call__(self, positions: NativeArray_1[Vector3]) -> int:...
        @typing.overload
        def __call__(self, positions: NativeSlice_1[Vector3]) -> int:...

    # Skipped SetPositions due to it being static, abstract and generic.

    SetPositions : SetPositions_MethodGroup
    class SetPositions_MethodGroup:
        @typing.overload
        def __call__(self, positions: Array_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, positions: NativeArray_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, positions: NativeSlice_1[Vector3]) -> None:...



class TransferFunction(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    sRGB : TransferFunction # 0
    BT1886 : TransferFunction # 1
    PQ : TransferFunction # 2
    Linear : TransferFunction # 3
    Gamma22 : TransferFunction # 4
    Unknown : TransferFunction # -1


class Transform(Component, IEnumerable):
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def childCount(self) -> int: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def eulerAngles(self) -> Vector3: ...
    @eulerAngles.setter
    def eulerAngles(self, value: Vector3) -> Vector3: ...
    @property
    def forward(self) -> Vector3: ...
    @forward.setter
    def forward(self, value: Vector3) -> Vector3: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hasChanged(self) -> bool: ...
    @hasChanged.setter
    def hasChanged(self, value: bool) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hierarchyCapacity(self) -> int: ...
    @hierarchyCapacity.setter
    def hierarchyCapacity(self, value: int) -> int: ...
    @property
    def hierarchyCount(self) -> int: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def light(self) -> Component: ...
    @property
    def localEulerAngles(self) -> Vector3: ...
    @localEulerAngles.setter
    def localEulerAngles(self, value: Vector3) -> Vector3: ...
    @property
    def localPosition(self) -> Vector3: ...
    @localPosition.setter
    def localPosition(self, value: Vector3) -> Vector3: ...
    @property
    def localRotation(self) -> Quaternion: ...
    @localRotation.setter
    def localRotation(self, value: Quaternion) -> Quaternion: ...
    @property
    def localScale(self) -> Vector3: ...
    @localScale.setter
    def localScale(self, value: Vector3) -> Vector3: ...
    @property
    def localToWorldMatrix(self) -> Matrix4x4: ...
    @property
    def lossyScale(self) -> Vector3: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def parent(self) -> Transform: ...
    @parent.setter
    def parent(self, value: Transform) -> Transform: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def position(self) -> Vector3: ...
    @position.setter
    def position(self, value: Vector3) -> Vector3: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def right(self) -> Vector3: ...
    @right.setter
    def right(self, value: Vector3) -> Vector3: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def root(self) -> Transform: ...
    @property
    def rotation(self) -> Quaternion: ...
    @rotation.setter
    def rotation(self, value: Quaternion) -> Quaternion: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def up(self) -> Vector3: ...
    @up.setter
    def up(self, value: Vector3) -> Vector3: ...
    @property
    def worldToLocalMatrix(self) -> Matrix4x4: ...
    def DetachChildren(self) -> None: ...
    def Find(self, n: str) -> Transform: ...
    def FindChild(self, n: str) -> Transform: ...
    def GetChild(self, index: int) -> Transform: ...
    def GetChildCount(self) -> int: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def GetLocalPositionAndRotation(self, localPosition: clr.Reference[Vector3], localRotation: clr.Reference[Quaternion]) -> None: ...
    def GetPositionAndRotation(self, position: clr.Reference[Vector3], rotation: clr.Reference[Quaternion]) -> None: ...
    def GetSiblingIndex(self) -> int: ...
    def IsChildOf(self, parent: Transform) -> bool: ...
    def RotateAroundLocal(self, axis: Vector3, angle: float) -> None: ...
    def SetAsFirstSibling(self) -> None: ...
    def SetAsLastSibling(self) -> None: ...
    def SetLocalPositionAndRotation(self, localPosition: Vector3, localRotation: Quaternion) -> None: ...
    def SetPositionAndRotation(self, position: Vector3, rotation: Quaternion) -> None: ...
    def SetSiblingIndex(self, index: int) -> None: ...
    # Skipped InverseTransformDirection due to it being static, abstract and generic.

    InverseTransformDirection : InverseTransformDirection_MethodGroup
    class InverseTransformDirection_MethodGroup:
        @typing.overload
        def __call__(self, direction: Vector3) -> Vector3:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> Vector3:...

    # Skipped InverseTransformDirections due to it being static, abstract and generic.

    InverseTransformDirections : InverseTransformDirections_MethodGroup
    class InverseTransformDirections_MethodGroup:
        @typing.overload
        def __call__(self, directions: Span_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, directions: ReadOnlySpan_1[Vector3], transformedDirections: Span_1[Vector3]) -> None:...

    # Skipped InverseTransformPoint due to it being static, abstract and generic.

    InverseTransformPoint : InverseTransformPoint_MethodGroup
    class InverseTransformPoint_MethodGroup:
        @typing.overload
        def __call__(self, position: Vector3) -> Vector3:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> Vector3:...

    # Skipped InverseTransformPoints due to it being static, abstract and generic.

    InverseTransformPoints : InverseTransformPoints_MethodGroup
    class InverseTransformPoints_MethodGroup:
        @typing.overload
        def __call__(self, positions: Span_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, positions: ReadOnlySpan_1[Vector3], transformedPositions: Span_1[Vector3]) -> None:...

    # Skipped InverseTransformVector due to it being static, abstract and generic.

    InverseTransformVector : InverseTransformVector_MethodGroup
    class InverseTransformVector_MethodGroup:
        @typing.overload
        def __call__(self, vector: Vector3) -> Vector3:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> Vector3:...

    # Skipped InverseTransformVectors due to it being static, abstract and generic.

    InverseTransformVectors : InverseTransformVectors_MethodGroup
    class InverseTransformVectors_MethodGroup:
        @typing.overload
        def __call__(self, vectors: Span_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, vectors: ReadOnlySpan_1[Vector3], transformedVectors: Span_1[Vector3]) -> None:...

    # Skipped LookAt due to it being static, abstract and generic.

    LookAt : LookAt_MethodGroup
    class LookAt_MethodGroup:
        @typing.overload
        def __call__(self, target: Transform) -> None:...
        @typing.overload
        def __call__(self, worldPosition: Vector3) -> None:...
        @typing.overload
        def __call__(self, target: Transform, worldUp: Vector3) -> None:...
        @typing.overload
        def __call__(self, worldPosition: Vector3, worldUp: Vector3) -> None:...

    # Skipped Rotate due to it being static, abstract and generic.

    Rotate : Rotate_MethodGroup
    class Rotate_MethodGroup:
        @typing.overload
        def __call__(self, eulers: Vector3) -> None:...
        @typing.overload
        def __call__(self, axis: Vector3, angle: float) -> None:...
        @typing.overload
        def __call__(self, eulers: Vector3, relativeTo: Space) -> None:...
        @typing.overload
        def __call__(self, xAngle: float, yAngle: float, zAngle: float) -> None:...
        @typing.overload
        def __call__(self, axis: Vector3, angle: float, relativeTo: Space) -> None:...
        @typing.overload
        def __call__(self, xAngle: float, yAngle: float, zAngle: float, relativeTo: Space) -> None:...

    # Skipped RotateAround due to it being static, abstract and generic.

    RotateAround : RotateAround_MethodGroup
    class RotateAround_MethodGroup:
        @typing.overload
        def __call__(self, axis: Vector3, angle: float) -> None:...
        @typing.overload
        def __call__(self, point: Vector3, axis: Vector3, angle: float) -> None:...

    # Skipped SetParent due to it being static, abstract and generic.

    SetParent : SetParent_MethodGroup
    class SetParent_MethodGroup:
        @typing.overload
        def __call__(self, p: Transform) -> None:...
        @typing.overload
        def __call__(self, parent: Transform, worldPositionStays: bool) -> None:...

    # Skipped TransformDirection due to it being static, abstract and generic.

    TransformDirection : TransformDirection_MethodGroup
    class TransformDirection_MethodGroup:
        @typing.overload
        def __call__(self, direction: Vector3) -> Vector3:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> Vector3:...

    # Skipped TransformDirections due to it being static, abstract and generic.

    TransformDirections : TransformDirections_MethodGroup
    class TransformDirections_MethodGroup:
        @typing.overload
        def __call__(self, directions: Span_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, directions: ReadOnlySpan_1[Vector3], transformedDirections: Span_1[Vector3]) -> None:...

    # Skipped TransformPoint due to it being static, abstract and generic.

    TransformPoint : TransformPoint_MethodGroup
    class TransformPoint_MethodGroup:
        @typing.overload
        def __call__(self, position: Vector3) -> Vector3:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> Vector3:...

    # Skipped TransformPoints due to it being static, abstract and generic.

    TransformPoints : TransformPoints_MethodGroup
    class TransformPoints_MethodGroup:
        @typing.overload
        def __call__(self, positions: Span_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, positions: ReadOnlySpan_1[Vector3], transformedPositions: Span_1[Vector3]) -> None:...

    # Skipped TransformVector due to it being static, abstract and generic.

    TransformVector : TransformVector_MethodGroup
    class TransformVector_MethodGroup:
        @typing.overload
        def __call__(self, vector: Vector3) -> Vector3:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> Vector3:...

    # Skipped TransformVectors due to it being static, abstract and generic.

    TransformVectors : TransformVectors_MethodGroup
    class TransformVectors_MethodGroup:
        @typing.overload
        def __call__(self, vectors: Span_1[Vector3]) -> None:...
        @typing.overload
        def __call__(self, vectors: ReadOnlySpan_1[Vector3], transformedVectors: Span_1[Vector3]) -> None:...

    # Skipped Translate due to it being static, abstract and generic.

    Translate : Translate_MethodGroup
    class Translate_MethodGroup:
        @typing.overload
        def __call__(self, translation: Vector3) -> None:...
        @typing.overload
        def __call__(self, translation: Vector3, relativeTo: Space) -> None:...
        @typing.overload
        def __call__(self, translation: Vector3, relativeTo: Transform) -> None:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> None:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float, relativeTo: Space) -> None:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float, relativeTo: Transform) -> None:...



class TransparencySortMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Default : TransparencySortMode # 0
    Perspective : TransparencySortMode # 1
    Orthographic : TransparencySortMode # 2
    CustomAxis : TransparencySortMode # 3


class Tree(Component):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def data(self) -> ScriptableObject: ...
    @data.setter
    def data(self, value: ScriptableObject) -> ScriptableObject: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hasSpeedTreeWind(self) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...


class TreeInstance:
    color : Color32
    heightScale : float
    lightmapColor : Color32
    position : Vector3
    prototypeIndex : int
    rotation : float
    widthScale : float


class TreeMotionVectorModeOverride(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    CameraMotionOnly : TreeMotionVectorModeOverride # 0
    PerObjectMotion : TreeMotionVectorModeOverride # 1
    ForceNoMotion : TreeMotionVectorModeOverride # 2
    InheritFromPrototype : TreeMotionVectorModeOverride # 3


class TreePrototype:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, other: TreePrototype) -> None: ...
    @property
    def bendFactor(self) -> float: ...
    @bendFactor.setter
    def bendFactor(self, value: float) -> float: ...
    @property
    def navMeshLod(self) -> int: ...
    @navMeshLod.setter
    def navMeshLod(self, value: int) -> int: ...
    @property
    def prefab(self) -> GameObject: ...
    @prefab.setter
    def prefab(self, value: GameObject) -> GameObject: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class Types(abc.ABC):
    @staticmethod
    def GetType(typeName: str, assemblyName: str) -> typing.Type[typing.Any]: ...


class UICharInfo:
    charWidth : float
    cursorPos : Vector2


class UILineInfo:
    height : int
    leading : float
    startCharIdx : int
    topY : float


class UISystemProfilerApi(abc.ABC):
    @staticmethod
    def AddMarker(name: str, obj: Object) -> None: ...
    @staticmethod
    def BeginSample(type: UISystemProfilerApi.SampleType) -> None: ...
    @staticmethod
    def EndSample(type: UISystemProfilerApi.SampleType) -> None: ...

    class SampleType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Layout : UISystemProfilerApi.SampleType # 0
        Render : UISystemProfilerApi.SampleType # 1



class UIVertex:
    color : Color32
    normal : Vector3
    position : Vector3
    simpleVert : UIVertex
    tangent : Vector4
    uv0 : Vector4
    uv1 : Vector4
    uv2 : Vector4
    uv3 : Vector4


class UnassignedReferenceException(SystemException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class UnityAPICompatibilityVersionAttribute(Attribute):
    @typing.overload
    def __init__(self, version: str) -> None: ...
    @typing.overload
    def __init__(self, version: str, checkOnlyUnityVersion: bool) -> None: ...
    @typing.overload
    def __init__(self, version: str, configurationAssembliesHashes: Array_1[str]) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def version(self) -> str: ...


class UnityEventQueueSystem:
    def __init__(self) -> None: ...
    @staticmethod
    def GenerateEventIdForPayload(eventPayloadName: str) -> str: ...
    @staticmethod
    def GetGlobalEventQueue() -> int: ...


class UnityException(SystemException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class UserAuthorization(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    WebCam : UserAuthorization # 1
    Microphone : UserAuthorization # 2


class Vector2(IFormattable, IEquatable_1[Vector2]):
    def __init__(self, x: float, y: float) -> None: ...
    kEpsilon : float
    kEpsilonNormalSqrt : float
    x : float
    y : float
    @classmethod
    @property
    def down(cls) -> Vector2: ...
    @property
    def Item(self) -> float: ...
    @Item.setter
    def Item(self, value: float) -> float: ...
    @classmethod
    @property
    def left(cls) -> Vector2: ...
    @property
    def magnitude(self) -> float: ...
    @classmethod
    @property
    def negativeInfinity(cls) -> Vector2: ...
    @property
    def normalized(self) -> Vector2: ...
    @classmethod
    @property
    def one(cls) -> Vector2: ...
    @classmethod
    @property
    def positiveInfinity(cls) -> Vector2: ...
    @classmethod
    @property
    def right(cls) -> Vector2: ...
    @property
    def sqrMagnitude(self) -> float: ...
    @classmethod
    @property
    def up(cls) -> Vector2: ...
    @classmethod
    @property
    def zero(cls) -> Vector2: ...
    @staticmethod
    def Angle(from_: Vector2, to: Vector2) -> float: ...
    @staticmethod
    def ClampMagnitude(vector: Vector2, maxLength: float) -> Vector2: ...
    @staticmethod
    def Distance(a: Vector2, b: Vector2) -> float: ...
    @staticmethod
    def Dot(lhs: Vector2, rhs: Vector2) -> float: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Lerp(a: Vector2, b: Vector2, t: float) -> Vector2: ...
    @staticmethod
    def LerpUnclamped(a: Vector2, b: Vector2, t: float) -> Vector2: ...
    @staticmethod
    def Max(lhs: Vector2, rhs: Vector2) -> Vector2: ...
    @staticmethod
    def Min(lhs: Vector2, rhs: Vector2) -> Vector2: ...
    @staticmethod
    def MoveTowards(current: Vector2, target: Vector2, maxDistanceDelta: float) -> Vector2: ...
    def Normalize(self) -> None: ...
    def __add__(self, a: Vector2, b: Vector2) -> Vector2: ...
    @typing.overload
    def __truediv__(self, a: Vector2, d: float) -> Vector2: ...
    @typing.overload
    def __truediv__(self, a: Vector2, b: Vector2) -> Vector2: ...
    def __eq__(self, lhs: Vector2, rhs: Vector2) -> bool: ...
    # Operator not supported op_Implicit(v: Vector3)
    # Operator not supported op_Implicit(v: Vector2)
    def __ne__(self, lhs: Vector2, rhs: Vector2) -> bool: ...
    @typing.overload
    def __mul__(self, d: float, a: Vector2) -> Vector2: ...
    @typing.overload
    def __mul__(self, a: Vector2, d: float) -> Vector2: ...
    @typing.overload
    def __mul__(self, a: Vector2, b: Vector2) -> Vector2: ...
    def __sub__(self, a: Vector2, b: Vector2) -> Vector2: ...
    def __neg__(self, a: Vector2) -> Vector2: ...
    @staticmethod
    def Perpendicular(inDirection: Vector2) -> Vector2: ...
    @staticmethod
    def Reflect(inDirection: Vector2, inNormal: Vector2) -> Vector2: ...
    def Set(self, newX: float, newY: float) -> None: ...
    @staticmethod
    def SignedAngle(from_: Vector2, to: Vector2) -> float: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Vector2) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped Scale due to it being static, abstract and generic.

    Scale : Scale_MethodGroup
    class Scale_MethodGroup:
        @typing.overload
        def __call__(self, scale: Vector2) -> None:...
        @typing.overload
        def __call__(self, a: Vector2, b: Vector2) -> Vector2:...

    # Skipped SmoothDamp due to it being static, abstract and generic.

    SmoothDamp : SmoothDamp_MethodGroup
    class SmoothDamp_MethodGroup:
        @typing.overload
        def __call__(self, current: Vector2, target: Vector2, currentVelocity: clr.Reference[Vector2], smoothTime: float) -> Vector2:...
        @typing.overload
        def __call__(self, current: Vector2, target: Vector2, currentVelocity: clr.Reference[Vector2], smoothTime: float, maxSpeed: float) -> Vector2:...
        @typing.overload
        def __call__(self, current: Vector2, target: Vector2, currentVelocity: clr.Reference[Vector2], smoothTime: float, maxSpeed: float, deltaTime: float) -> Vector2:...

    # Skipped SqrMagnitude due to it being static, abstract and generic.

    SqrMagnitude : SqrMagnitude_MethodGroup
    class SqrMagnitude_MethodGroup:
        @typing.overload
        def __call__(self) -> float:...
        @typing.overload
        def __call__(self, a: Vector2) -> float:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...



class Vector2Int(IFormattable, IEquatable_1[Vector2Int]):
    def __init__(self, x: int, y: int) -> None: ...
    @classmethod
    @property
    def down(cls) -> Vector2Int: ...
    @property
    def Item(self) -> int: ...
    @Item.setter
    def Item(self, value: int) -> int: ...
    @classmethod
    @property
    def left(cls) -> Vector2Int: ...
    @property
    def magnitude(self) -> float: ...
    @classmethod
    @property
    def one(cls) -> Vector2Int: ...
    @classmethod
    @property
    def right(cls) -> Vector2Int: ...
    @property
    def sqrMagnitude(self) -> int: ...
    @classmethod
    @property
    def up(cls) -> Vector2Int: ...
    @property
    def x(self) -> int: ...
    @x.setter
    def x(self, value: int) -> int: ...
    @property
    def y(self) -> int: ...
    @y.setter
    def y(self, value: int) -> int: ...
    @classmethod
    @property
    def zero(cls) -> Vector2Int: ...
    @staticmethod
    def CeilToInt(v: Vector2) -> Vector2Int: ...
    def Clamp(self, min: Vector2Int, max: Vector2Int) -> None: ...
    @staticmethod
    def Distance(a: Vector2Int, b: Vector2Int) -> float: ...
    @staticmethod
    def FloorToInt(v: Vector2) -> Vector2Int: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Max(lhs: Vector2Int, rhs: Vector2Int) -> Vector2Int: ...
    @staticmethod
    def Min(lhs: Vector2Int, rhs: Vector2Int) -> Vector2Int: ...
    def __add__(self, a: Vector2Int, b: Vector2Int) -> Vector2Int: ...
    def __truediv__(self, a: Vector2Int, b: int) -> Vector2Int: ...
    def __eq__(self, lhs: Vector2Int, rhs: Vector2Int) -> bool: ...
    # Operator not supported op_Explicit(v: Vector2Int)
    # Operator not supported op_Implicit(v: Vector2Int)
    def __ne__(self, lhs: Vector2Int, rhs: Vector2Int) -> bool: ...
    @typing.overload
    def __mul__(self, a: int, b: Vector2Int) -> Vector2Int: ...
    @typing.overload
    def __mul__(self, a: Vector2Int, b: int) -> Vector2Int: ...
    @typing.overload
    def __mul__(self, a: Vector2Int, b: Vector2Int) -> Vector2Int: ...
    def __sub__(self, a: Vector2Int, b: Vector2Int) -> Vector2Int: ...
    def __neg__(self, v: Vector2Int) -> Vector2Int: ...
    @staticmethod
    def RoundToInt(v: Vector2) -> Vector2Int: ...
    def Set(self, x: int, y: int) -> None: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Vector2Int) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped Scale due to it being static, abstract and generic.

    Scale : Scale_MethodGroup
    class Scale_MethodGroup:
        @typing.overload
        def __call__(self, scale: Vector2Int) -> None:...
        @typing.overload
        def __call__(self, a: Vector2Int, b: Vector2Int) -> Vector2Int:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...



class Vector3(IFormattable, IEquatable_1[Vector3]):
    @typing.overload
    def __init__(self, x: float, y: float) -> None: ...
    @typing.overload
    def __init__(self, x: float, y: float, z: float) -> None: ...
    kEpsilon : float
    kEpsilonNormalSqrt : float
    x : float
    y : float
    z : float
    @classmethod
    @property
    def back(cls) -> Vector3: ...
    @classmethod
    @property
    def down(cls) -> Vector3: ...
    @classmethod
    @property
    def forward(cls) -> Vector3: ...
    @classmethod
    @property
    def fwd(cls) -> Vector3: ...
    @property
    def Item(self) -> float: ...
    @Item.setter
    def Item(self, value: float) -> float: ...
    @classmethod
    @property
    def left(cls) -> Vector3: ...
    @property
    def magnitude(self) -> float: ...
    @classmethod
    @property
    def negativeInfinity(cls) -> Vector3: ...
    @property
    def normalized(self) -> Vector3: ...
    @classmethod
    @property
    def one(cls) -> Vector3: ...
    @classmethod
    @property
    def positiveInfinity(cls) -> Vector3: ...
    @classmethod
    @property
    def right(cls) -> Vector3: ...
    @property
    def sqrMagnitude(self) -> float: ...
    @classmethod
    @property
    def up(cls) -> Vector3: ...
    @classmethod
    @property
    def zero(cls) -> Vector3: ...
    @staticmethod
    def Angle(from_: Vector3, to: Vector3) -> float: ...
    @staticmethod
    def AngleBetween(from_: Vector3, to: Vector3) -> float: ...
    @staticmethod
    def ClampMagnitude(vector: Vector3, maxLength: float) -> Vector3: ...
    @staticmethod
    def Cross(lhs: Vector3, rhs: Vector3) -> Vector3: ...
    @staticmethod
    def Distance(a: Vector3, b: Vector3) -> float: ...
    @staticmethod
    def Dot(lhs: Vector3, rhs: Vector3) -> float: ...
    @staticmethod
    def Exclude(excludeThis: Vector3, fromThat: Vector3) -> Vector3: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Lerp(a: Vector3, b: Vector3, t: float) -> Vector3: ...
    @staticmethod
    def LerpUnclamped(a: Vector3, b: Vector3, t: float) -> Vector3: ...
    @staticmethod
    def Magnitude(vector: Vector3) -> float: ...
    @staticmethod
    def Max(lhs: Vector3, rhs: Vector3) -> Vector3: ...
    @staticmethod
    def Min(lhs: Vector3, rhs: Vector3) -> Vector3: ...
    @staticmethod
    def MoveTowards(current: Vector3, target: Vector3, maxDistanceDelta: float) -> Vector3: ...
    def __add__(self, a: Vector3, b: Vector3) -> Vector3: ...
    def __truediv__(self, a: Vector3, d: float) -> Vector3: ...
    def __eq__(self, lhs: Vector3, rhs: Vector3) -> bool: ...
    def __ne__(self, lhs: Vector3, rhs: Vector3) -> bool: ...
    @typing.overload
    def __mul__(self, d: float, a: Vector3) -> Vector3: ...
    @typing.overload
    def __mul__(self, a: Vector3, d: float) -> Vector3: ...
    def __sub__(self, a: Vector3, b: Vector3) -> Vector3: ...
    def __neg__(self, a: Vector3) -> Vector3: ...
    @staticmethod
    def Project(vector: Vector3, onNormal: Vector3) -> Vector3: ...
    @staticmethod
    def ProjectOnPlane(vector: Vector3, planeNormal: Vector3) -> Vector3: ...
    @staticmethod
    def Reflect(inDirection: Vector3, inNormal: Vector3) -> Vector3: ...
    @staticmethod
    def RotateTowards(current: Vector3, target: Vector3, maxRadiansDelta: float, maxMagnitudeDelta: float) -> Vector3: ...
    def Set(self, newX: float, newY: float, newZ: float) -> None: ...
    @staticmethod
    def SignedAngle(from_: Vector3, to: Vector3, axis: Vector3) -> float: ...
    @staticmethod
    def Slerp(a: Vector3, b: Vector3, t: float) -> Vector3: ...
    @staticmethod
    def SlerpUnclamped(a: Vector3, b: Vector3, t: float) -> Vector3: ...
    @staticmethod
    def SqrMagnitude(vector: Vector3) -> float: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Vector3) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped Normalize due to it being static, abstract and generic.

    Normalize : Normalize_MethodGroup
    class Normalize_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, value: Vector3) -> Vector3:...

    # Skipped OrthoNormalize due to it being static, abstract and generic.

    OrthoNormalize : OrthoNormalize_MethodGroup
    class OrthoNormalize_MethodGroup:
        @typing.overload
        def __call__(self, normal: clr.Reference[Vector3], tangent: clr.Reference[Vector3]) -> None:...
        @typing.overload
        def __call__(self, normal: clr.Reference[Vector3], tangent: clr.Reference[Vector3], binormal: clr.Reference[Vector3]) -> None:...

    # Skipped Scale due to it being static, abstract and generic.

    Scale : Scale_MethodGroup
    class Scale_MethodGroup:
        @typing.overload
        def __call__(self, scale: Vector3) -> None:...
        @typing.overload
        def __call__(self, a: Vector3, b: Vector3) -> Vector3:...

    # Skipped SmoothDamp due to it being static, abstract and generic.

    SmoothDamp : SmoothDamp_MethodGroup
    class SmoothDamp_MethodGroup:
        @typing.overload
        def __call__(self, current: Vector3, target: Vector3, currentVelocity: clr.Reference[Vector3], smoothTime: float) -> Vector3:...
        @typing.overload
        def __call__(self, current: Vector3, target: Vector3, currentVelocity: clr.Reference[Vector3], smoothTime: float, maxSpeed: float) -> Vector3:...
        @typing.overload
        def __call__(self, current: Vector3, target: Vector3, currentVelocity: clr.Reference[Vector3], smoothTime: float, maxSpeed: float, deltaTime: float) -> Vector3:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...



class Vector3Int(IFormattable, IEquatable_1[Vector3Int]):
    @typing.overload
    def __init__(self, x: int, y: int) -> None: ...
    @typing.overload
    def __init__(self, x: int, y: int, z: int) -> None: ...
    @classmethod
    @property
    def back(cls) -> Vector3Int: ...
    @classmethod
    @property
    def down(cls) -> Vector3Int: ...
    @classmethod
    @property
    def forward(cls) -> Vector3Int: ...
    @property
    def Item(self) -> int: ...
    @Item.setter
    def Item(self, value: int) -> int: ...
    @classmethod
    @property
    def left(cls) -> Vector3Int: ...
    @property
    def magnitude(self) -> float: ...
    @classmethod
    @property
    def one(cls) -> Vector3Int: ...
    @classmethod
    @property
    def right(cls) -> Vector3Int: ...
    @property
    def sqrMagnitude(self) -> int: ...
    @classmethod
    @property
    def up(cls) -> Vector3Int: ...
    @property
    def x(self) -> int: ...
    @x.setter
    def x(self, value: int) -> int: ...
    @property
    def y(self) -> int: ...
    @y.setter
    def y(self, value: int) -> int: ...
    @property
    def z(self) -> int: ...
    @z.setter
    def z(self, value: int) -> int: ...
    @classmethod
    @property
    def zero(cls) -> Vector3Int: ...
    @staticmethod
    def CeilToInt(v: Vector3) -> Vector3Int: ...
    def Clamp(self, min: Vector3Int, max: Vector3Int) -> None: ...
    @staticmethod
    def Distance(a: Vector3Int, b: Vector3Int) -> float: ...
    @staticmethod
    def FloorToInt(v: Vector3) -> Vector3Int: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Max(lhs: Vector3Int, rhs: Vector3Int) -> Vector3Int: ...
    @staticmethod
    def Min(lhs: Vector3Int, rhs: Vector3Int) -> Vector3Int: ...
    def __add__(self, a: Vector3Int, b: Vector3Int) -> Vector3Int: ...
    def __truediv__(self, a: Vector3Int, b: int) -> Vector3Int: ...
    def __eq__(self, lhs: Vector3Int, rhs: Vector3Int) -> bool: ...
    # Operator not supported op_Explicit(v: Vector3Int)
    # Operator not supported op_Implicit(v: Vector3Int)
    def __ne__(self, lhs: Vector3Int, rhs: Vector3Int) -> bool: ...
    @typing.overload
    def __mul__(self, a: int, b: Vector3Int) -> Vector3Int: ...
    @typing.overload
    def __mul__(self, a: Vector3Int, b: int) -> Vector3Int: ...
    @typing.overload
    def __mul__(self, a: Vector3Int, b: Vector3Int) -> Vector3Int: ...
    def __sub__(self, a: Vector3Int, b: Vector3Int) -> Vector3Int: ...
    def __neg__(self, a: Vector3Int) -> Vector3Int: ...
    @staticmethod
    def RoundToInt(v: Vector3) -> Vector3Int: ...
    def Set(self, x: int, y: int, z: int) -> None: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Vector3Int) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped Scale due to it being static, abstract and generic.

    Scale : Scale_MethodGroup
    class Scale_MethodGroup:
        @typing.overload
        def __call__(self, scale: Vector3Int) -> None:...
        @typing.overload
        def __call__(self, a: Vector3Int, b: Vector3Int) -> Vector3Int:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...



class Vector4(IFormattable, IEquatable_1[Vector4]):
    @typing.overload
    def __init__(self, x: float, y: float) -> None: ...
    @typing.overload
    def __init__(self, x: float, y: float, z: float) -> None: ...
    @typing.overload
    def __init__(self, x: float, y: float, z: float, w: float) -> None: ...
    kEpsilon : float
    w : float
    x : float
    y : float
    z : float
    @property
    def Item(self) -> float: ...
    @Item.setter
    def Item(self, value: float) -> float: ...
    @property
    def magnitude(self) -> float: ...
    @classmethod
    @property
    def negativeInfinity(cls) -> Vector4: ...
    @property
    def normalized(self) -> Vector4: ...
    @classmethod
    @property
    def one(cls) -> Vector4: ...
    @classmethod
    @property
    def positiveInfinity(cls) -> Vector4: ...
    @property
    def sqrMagnitude(self) -> float: ...
    @classmethod
    @property
    def zero(cls) -> Vector4: ...
    @staticmethod
    def Distance(a: Vector4, b: Vector4) -> float: ...
    @staticmethod
    def Dot(a: Vector4, b: Vector4) -> float: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Lerp(a: Vector4, b: Vector4, t: float) -> Vector4: ...
    @staticmethod
    def LerpUnclamped(a: Vector4, b: Vector4, t: float) -> Vector4: ...
    @staticmethod
    def Magnitude(a: Vector4) -> float: ...
    @staticmethod
    def Max(lhs: Vector4, rhs: Vector4) -> Vector4: ...
    @staticmethod
    def Min(lhs: Vector4, rhs: Vector4) -> Vector4: ...
    @staticmethod
    def MoveTowards(current: Vector4, target: Vector4, maxDistanceDelta: float) -> Vector4: ...
    def __add__(self, a: Vector4, b: Vector4) -> Vector4: ...
    def __truediv__(self, a: Vector4, d: float) -> Vector4: ...
    def __eq__(self, lhs: Vector4, rhs: Vector4) -> bool: ...
    # Operator not supported op_Implicit(v: Vector3)
    # Operator not supported op_Implicit(v: Vector4)
    # Operator not supported op_Implicit(v: Vector2)
    # Operator not supported op_Implicit(v: Vector4)
    def __ne__(self, lhs: Vector4, rhs: Vector4) -> bool: ...
    @typing.overload
    def __mul__(self, d: float, a: Vector4) -> Vector4: ...
    @typing.overload
    def __mul__(self, a: Vector4, d: float) -> Vector4: ...
    def __sub__(self, a: Vector4, b: Vector4) -> Vector4: ...
    def __neg__(self, a: Vector4) -> Vector4: ...
    @staticmethod
    def Project(a: Vector4, b: Vector4) -> Vector4: ...
    def Set(self, newX: float, newY: float, newZ: float, newW: float) -> None: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Vector4) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped Normalize due to it being static, abstract and generic.

    Normalize : Normalize_MethodGroup
    class Normalize_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, a: Vector4) -> Vector4:...

    # Skipped Scale due to it being static, abstract and generic.

    Scale : Scale_MethodGroup
    class Scale_MethodGroup:
        @typing.overload
        def __call__(self, scale: Vector4) -> None:...
        @typing.overload
        def __call__(self, a: Vector4, b: Vector4) -> Vector4:...

    # Skipped SqrMagnitude due to it being static, abstract and generic.

    SqrMagnitude : SqrMagnitude_MethodGroup
    class SqrMagnitude_MethodGroup:
        @typing.overload
        def __call__(self) -> float:...
        @typing.overload
        def __call__(self, a: Vector4) -> float:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...



class VerticalWrapMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Truncate : VerticalWrapMode # 0
    Overflow : VerticalWrapMode # 1


class VRTextureUsage(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : VRTextureUsage # 0
    OneEye : VRTextureUsage # 1
    TwoEyes : VRTextureUsage # 2
    DeviceSpecific : VRTextureUsage # 3


class WaitForEndOfFrame(YieldInstruction):
    def __init__(self) -> None: ...


class WaitForFixedUpdate(YieldInstruction):
    def __init__(self) -> None: ...


class WaitForSeconds(YieldInstruction):
    def __init__(self, seconds: float) -> None: ...


class WaitForSecondsRealtime(CustomYieldInstruction):
    def __init__(self, time: float) -> None: ...
    @property
    def Current(self) -> typing.Any: ...
    @property
    def keepWaiting(self) -> bool: ...
    @property
    def waitTime(self) -> float: ...
    @waitTime.setter
    def waitTime(self, value: float) -> float: ...
    def Reset(self) -> None: ...


class WaitUntil(CustomYieldInstruction):
    def __init__(self, predicate: Func_1[bool]) -> None: ...
    @property
    def Current(self) -> typing.Any: ...
    @property
    def keepWaiting(self) -> bool: ...


class WaitWhile(CustomYieldInstruction):
    def __init__(self, predicate: Func_1[bool]) -> None: ...
    @property
    def Current(self) -> typing.Any: ...
    @property
    def keepWaiting(self) -> bool: ...


class WebCamDevice:
    @property
    def availableResolutions(self) -> Array_1[Resolution]: ...
    @property
    def depthCameraName(self) -> str: ...
    @property
    def isAutoFocusPointSupported(self) -> bool: ...
    @property
    def isFrontFacing(self) -> bool: ...
    @property
    def kind(self) -> WebCamKind: ...
    @property
    def name(self) -> str: ...


class WebCamFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    FrontFacing : WebCamFlags # 1
    AutoFocusPointSupported : WebCamFlags # 2


class WebCamKind(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    WideAngle : WebCamKind # 1
    Telephoto : WebCamKind # 2
    ColorAndDepth : WebCamKind # 3
    UltraWideAngle : WebCamKind # 4


class WebCamTexture(Texture):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, deviceName: str) -> None: ...
    @typing.overload
    def __init__(self, deviceName: str, requestedWidth: int, requestedHeight: int) -> None: ...
    @typing.overload
    def __init__(self, deviceName: str, requestedWidth: int, requestedHeight: int, requestedFPS: int) -> None: ...
    @typing.overload
    def __init__(self, requestedWidth: int, requestedHeight: int) -> None: ...
    @typing.overload
    def __init__(self, requestedWidth: int, requestedHeight: int, requestedFPS: int) -> None: ...
    @property
    def anisoLevel(self) -> int: ...
    @anisoLevel.setter
    def anisoLevel(self, value: int) -> int: ...
    @property
    def autoFocusPoint(self) -> typing.Optional[Vector2]: ...
    @autoFocusPoint.setter
    def autoFocusPoint(self, value: typing.Optional[Vector2]) -> typing.Optional[Vector2]: ...
    @property
    def deviceName(self) -> str: ...
    @deviceName.setter
    def deviceName(self, value: str) -> str: ...
    @classmethod
    @property
    def devices(cls) -> Array_1[WebCamDevice]: ...
    @property
    def didUpdateThisFrame(self) -> bool: ...
    @property
    def dimension(self) -> TextureDimension: ...
    @dimension.setter
    def dimension(self, value: TextureDimension) -> TextureDimension: ...
    @property
    def filterMode(self) -> FilterMode: ...
    @filterMode.setter
    def filterMode(self, value: FilterMode) -> FilterMode: ...
    @property
    def graphicsFormat(self) -> GraphicsFormat: ...
    @property
    def height(self) -> int: ...
    @height.setter
    def height(self, value: int) -> int: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def imageContentsHash(self) -> Hash128: ...
    @imageContentsHash.setter
    def imageContentsHash(self, value: Hash128) -> Hash128: ...
    @property
    def isDataSRGB(self) -> bool: ...
    @property
    def isDepth(self) -> bool: ...
    @property
    def isPlaying(self) -> bool: ...
    @property
    def isReadable(self) -> bool: ...
    @property
    def mipMapBias(self) -> float: ...
    @mipMapBias.setter
    def mipMapBias(self, value: float) -> float: ...
    @property
    def mipmapCount(self) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def requestedFPS(self) -> float: ...
    @requestedFPS.setter
    def requestedFPS(self, value: float) -> float: ...
    @property
    def requestedHeight(self) -> int: ...
    @requestedHeight.setter
    def requestedHeight(self, value: int) -> int: ...
    @property
    def requestedWidth(self) -> int: ...
    @requestedWidth.setter
    def requestedWidth(self, value: int) -> int: ...
    @property
    def texelSize(self) -> Vector2: ...
    @property
    def updateCount(self) -> int: ...
    @property
    def videoRotationAngle(self) -> int: ...
    @property
    def videoVerticallyMirrored(self) -> bool: ...
    @property
    def width(self) -> int: ...
    @width.setter
    def width(self, value: int) -> int: ...
    @property
    def wrapMode(self) -> TextureWrapMode: ...
    @wrapMode.setter
    def wrapMode(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeU(self) -> TextureWrapMode: ...
    @wrapModeU.setter
    def wrapModeU(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeV(self) -> TextureWrapMode: ...
    @wrapModeV.setter
    def wrapModeV(self, value: TextureWrapMode) -> TextureWrapMode: ...
    @property
    def wrapModeW(self) -> TextureWrapMode: ...
    @wrapModeW.setter
    def wrapModeW(self, value: TextureWrapMode) -> TextureWrapMode: ...
    def GetPixel(self, x: int, y: int) -> Color: ...
    def Pause(self) -> None: ...
    def Play(self) -> None: ...
    def Stop(self) -> None: ...
    # Skipped GetPixels due to it being static, abstract and generic.

    GetPixels : GetPixels_MethodGroup
    class GetPixels_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[Color]:...
        @typing.overload
        def __call__(self, x: int, y: int, blockWidth: int, blockHeight: int) -> Array_1[Color]:...

    # Skipped GetPixels32 due to it being static, abstract and generic.

    GetPixels32 : GetPixels32_MethodGroup
    class GetPixels32_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[Color32]:...
        @typing.overload
        def __call__(self, colors: Array_1[Color32]) -> Array_1[Color32]:...



class WeightedMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : WeightedMode # 0
    In : WeightedMode # 1
    Out : WeightedMode # 2
    Both : WeightedMode # 3


class WheelCollider(Collider):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedArticulationBody(self) -> ArticulationBody: ...
    @property
    def attachedRigidbody(self) -> Rigidbody: ...
    @property
    def audio(self) -> Component: ...
    @property
    def bounds(self) -> Bounds: ...
    @property
    def brakeTorque(self) -> float: ...
    @brakeTorque.setter
    def brakeTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def center(self) -> Vector3: ...
    @center.setter
    def center(self, value: Vector3) -> Vector3: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def contactOffset(self) -> float: ...
    @contactOffset.setter
    def contactOffset(self, value: float) -> float: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def excludeLayers(self) -> LayerMask: ...
    @excludeLayers.setter
    def excludeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def forceAppPointDistance(self) -> float: ...
    @forceAppPointDistance.setter
    def forceAppPointDistance(self, value: float) -> float: ...
    @property
    def forwardFriction(self) -> WheelFrictionCurve: ...
    @forwardFriction.setter
    def forwardFriction(self, value: WheelFrictionCurve) -> WheelFrictionCurve: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hasModifiableContacts(self) -> bool: ...
    @hasModifiableContacts.setter
    def hasModifiableContacts(self, value: bool) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def includeLayers(self) -> LayerMask: ...
    @includeLayers.setter
    def includeLayers(self, value: LayerMask) -> LayerMask: ...
    @property
    def isGrounded(self) -> bool: ...
    @property
    def isTrigger(self) -> bool: ...
    @isTrigger.setter
    def isTrigger(self, value: bool) -> bool: ...
    @property
    def layerOverridePriority(self) -> int: ...
    @layerOverridePriority.setter
    def layerOverridePriority(self, value: int) -> int: ...
    @property
    def light(self) -> Component: ...
    @property
    def mass(self) -> float: ...
    @mass.setter
    def mass(self, value: float) -> float: ...
    @property
    def material(self) -> PhysicMaterial: ...
    @material.setter
    def material(self, value: PhysicMaterial) -> PhysicMaterial: ...
    @property
    def motorTorque(self) -> float: ...
    @motorTorque.setter
    def motorTorque(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def providesContacts(self) -> bool: ...
    @providesContacts.setter
    def providesContacts(self, value: bool) -> bool: ...
    @property
    def radius(self) -> float: ...
    @radius.setter
    def radius(self, value: float) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def rotationSpeed(self) -> float: ...
    @rotationSpeed.setter
    def rotationSpeed(self, value: float) -> float: ...
    @property
    def rpm(self) -> float: ...
    @property
    def sharedMaterial(self) -> PhysicMaterial: ...
    @sharedMaterial.setter
    def sharedMaterial(self, value: PhysicMaterial) -> PhysicMaterial: ...
    @property
    def sidewaysFriction(self) -> WheelFrictionCurve: ...
    @sidewaysFriction.setter
    def sidewaysFriction(self, value: WheelFrictionCurve) -> WheelFrictionCurve: ...
    @property
    def sprungMass(self) -> float: ...
    @sprungMass.setter
    def sprungMass(self, value: float) -> float: ...
    @property
    def steerAngle(self) -> float: ...
    @steerAngle.setter
    def steerAngle(self, value: float) -> float: ...
    @property
    def suspensionDistance(self) -> float: ...
    @suspensionDistance.setter
    def suspensionDistance(self, value: float) -> float: ...
    @property
    def suspensionExpansionLimited(self) -> bool: ...
    @suspensionExpansionLimited.setter
    def suspensionExpansionLimited(self, value: bool) -> bool: ...
    @property
    def suspensionSpring(self) -> JointSpring: ...
    @suspensionSpring.setter
    def suspensionSpring(self, value: JointSpring) -> JointSpring: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def wheelDampingRate(self) -> float: ...
    @wheelDampingRate.setter
    def wheelDampingRate(self, value: float) -> float: ...
    def ConfigureVehicleSubsteps(self, speedThreshold: float, stepsBelowThreshold: int, stepsAboveThreshold: int) -> None: ...
    def GetGroundHit(self, hit: clr.Reference[WheelHit]) -> bool: ...
    def GetWorldPose(self, pos: clr.Reference[Vector3], quat: clr.Reference[Quaternion]) -> None: ...
    def ResetSprungMasses(self) -> None: ...


class WheelFrictionCurve:
    @property
    def asymptoteSlip(self) -> float: ...
    @asymptoteSlip.setter
    def asymptoteSlip(self, value: float) -> float: ...
    @property
    def asymptoteValue(self) -> float: ...
    @asymptoteValue.setter
    def asymptoteValue(self, value: float) -> float: ...
    @property
    def extremumSlip(self) -> float: ...
    @extremumSlip.setter
    def extremumSlip(self, value: float) -> float: ...
    @property
    def extremumValue(self) -> float: ...
    @extremumValue.setter
    def extremumValue(self, value: float) -> float: ...
    @property
    def stiffness(self) -> float: ...
    @stiffness.setter
    def stiffness(self, value: float) -> float: ...


class WheelHit:
    @property
    def collider(self) -> Collider: ...
    @collider.setter
    def collider(self, value: Collider) -> Collider: ...
    @property
    def force(self) -> float: ...
    @force.setter
    def force(self, value: float) -> float: ...
    @property
    def forwardDir(self) -> Vector3: ...
    @forwardDir.setter
    def forwardDir(self, value: Vector3) -> Vector3: ...
    @property
    def forwardSlip(self) -> float: ...
    @forwardSlip.setter
    def forwardSlip(self, value: float) -> float: ...
    @property
    def normal(self) -> Vector3: ...
    @normal.setter
    def normal(self, value: Vector3) -> Vector3: ...
    @property
    def point(self) -> Vector3: ...
    @point.setter
    def point(self, value: Vector3) -> Vector3: ...
    @property
    def sidewaysDir(self) -> Vector3: ...
    @sidewaysDir.setter
    def sidewaysDir(self, value: Vector3) -> Vector3: ...
    @property
    def sidewaysSlip(self) -> float: ...
    @sidewaysSlip.setter
    def sidewaysSlip(self, value: float) -> float: ...


class WheelJoint2D(AnchoredJoint2D):
    def __init__(self) -> None: ...
    @property
    def anchor(self) -> Vector2: ...
    @anchor.setter
    def anchor(self, value: Vector2) -> Vector2: ...
    @property
    def animation(self) -> Component: ...
    @property
    def attachedRigidbody(self) -> Rigidbody2D: ...
    @property
    def audio(self) -> Component: ...
    @property
    def autoConfigureConnectedAnchor(self) -> bool: ...
    @autoConfigureConnectedAnchor.setter
    def autoConfigureConnectedAnchor(self, value: bool) -> bool: ...
    @property
    def breakAction(self) -> JointBreakAction2D: ...
    @breakAction.setter
    def breakAction(self, value: JointBreakAction2D) -> JointBreakAction2D: ...
    @property
    def breakForce(self) -> float: ...
    @breakForce.setter
    def breakForce(self, value: float) -> float: ...
    @property
    def breakTorque(self) -> float: ...
    @breakTorque.setter
    def breakTorque(self, value: float) -> float: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collideConnected(self) -> bool: ...
    @collideConnected.setter
    def collideConnected(self, value: bool) -> bool: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def connectedAnchor(self) -> Vector2: ...
    @connectedAnchor.setter
    def connectedAnchor(self, value: Vector2) -> Vector2: ...
    @property
    def connectedBody(self) -> Rigidbody2D: ...
    @connectedBody.setter
    def connectedBody(self, value: Rigidbody2D) -> Rigidbody2D: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enableCollision(self) -> bool: ...
    @enableCollision.setter
    def enableCollision(self, value: bool) -> bool: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def jointAngle(self) -> float: ...
    @property
    def jointLinearSpeed(self) -> float: ...
    @property
    def jointSpeed(self) -> float: ...
    @property
    def jointTranslation(self) -> float: ...
    @property
    def light(self) -> Component: ...
    @property
    def motor(self) -> JointMotor2D: ...
    @motor.setter
    def motor(self, value: JointMotor2D) -> JointMotor2D: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def reactionForce(self) -> Vector2: ...
    @property
    def reactionTorque(self) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def suspension(self) -> JointSuspension2D: ...
    @suspension.setter
    def suspension(self, value: JointSuspension2D) -> JointSuspension2D: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def useMotor(self) -> bool: ...
    @useMotor.setter
    def useMotor(self, value: bool) -> bool: ...
    def GetMotorTorque(self, timeStep: float) -> float: ...


class WhitePoint(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    D65 : WhitePoint # 0
    Unknown : WhitePoint # -1


class WindZone(Component):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def light(self) -> Component: ...
    @property
    def mode(self) -> WindZoneMode: ...
    @mode.setter
    def mode(self, value: WindZoneMode) -> WindZoneMode: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def radius(self) -> float: ...
    @radius.setter
    def radius(self, value: float) -> float: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @property
    def windMain(self) -> float: ...
    @windMain.setter
    def windMain(self, value: float) -> float: ...
    @property
    def windPulseFrequency(self) -> float: ...
    @windPulseFrequency.setter
    def windPulseFrequency(self, value: float) -> float: ...
    @property
    def windPulseMagnitude(self) -> float: ...
    @windPulseMagnitude.setter
    def windPulseMagnitude(self, value: float) -> float: ...
    @property
    def windTurbulence(self) -> float: ...
    @windTurbulence.setter
    def windTurbulence(self, value: float) -> float: ...


class WindZoneMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Directional : WindZoneMode # 0
    Spherical : WindZoneMode # 1


class WrapMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Default : WrapMode # 0
    Clamp : WrapMode # 1
    Once : WrapMode # 1
    Loop : WrapMode # 2
    PingPong : WrapMode # 4
    ClampForever : WrapMode # 8


class WWW(CustomYieldInstruction, IDisposable):
    @typing.overload
    def __init__(self, url: str) -> None: ...
    @typing.overload
    def __init__(self, url: str, form: WWWForm) -> None: ...
    @typing.overload
    def __init__(self, url: str, postData: Array_1[int]) -> None: ...
    @typing.overload
    def __init__(self, url: str, postData: Array_1[int], headers: Hashtable) -> None: ...
    @typing.overload
    def __init__(self, url: str, postData: Array_1[int], headers: Dictionary_2[str, str]) -> None: ...
    @property
    def assetBundle(self) -> AssetBundle: ...
    @property
    def audioClip(self) -> Object: ...
    @property
    def bytes(self) -> Array_1[int]: ...
    @property
    def bytesDownloaded(self) -> int: ...
    @property
    def Current(self) -> typing.Any: ...
    @property
    def data(self) -> str: ...
    @property
    def error(self) -> str: ...
    @property
    def isDone(self) -> bool: ...
    @property
    def keepWaiting(self) -> bool: ...
    @property
    def movie(self) -> Object: ...
    @property
    def oggVorbis(self) -> Object: ...
    @property
    def progress(self) -> float: ...
    @property
    def responseHeaders(self) -> Dictionary_2[str, str]: ...
    @property
    def size(self) -> int: ...
    @property
    def text(self) -> str: ...
    @property
    def texture(self) -> Texture2D: ...
    @property
    def textureNonReadable(self) -> Texture2D: ...
    @property
    def threadPriority(self) -> ThreadPriority: ...
    @threadPriority.setter
    def threadPriority(self, value: ThreadPriority) -> ThreadPriority: ...
    @property
    def uploadProgress(self) -> float: ...
    @property
    def url(self) -> str: ...
    def Dispose(self) -> None: ...
    def GetMovieTexture(self) -> MovieTexture: ...
    def LoadImageIntoTexture(self, texture: Texture2D) -> None: ...
    # Skipped EscapeURL due to it being static, abstract and generic.

    EscapeURL : EscapeURL_MethodGroup
    class EscapeURL_MethodGroup:
        @typing.overload
        def __call__(self, s: str) -> str:...
        @typing.overload
        def __call__(self, s: str, e: Encoding) -> str:...

    # Skipped GetAudioClip due to it being static, abstract and generic.

    GetAudioClip : GetAudioClip_MethodGroup
    class GetAudioClip_MethodGroup:
        @typing.overload
        def __call__(self) -> AudioClip:...
        @typing.overload
        def __call__(self, threeD: bool) -> AudioClip:...
        @typing.overload
        def __call__(self, threeD: bool, stream: bool) -> AudioClip:...
        @typing.overload
        def __call__(self, threeD: bool, stream: bool, audioType: AudioType) -> AudioClip:...

    # Skipped GetAudioClipCompressed due to it being static, abstract and generic.

    GetAudioClipCompressed : GetAudioClipCompressed_MethodGroup
    class GetAudioClipCompressed_MethodGroup:
        @typing.overload
        def __call__(self) -> AudioClip:...
        @typing.overload
        def __call__(self, threeD: bool) -> AudioClip:...
        @typing.overload
        def __call__(self, threeD: bool, audioType: AudioType) -> AudioClip:...

    # Skipped LoadFromCacheOrDownload due to it being static, abstract and generic.

    LoadFromCacheOrDownload : LoadFromCacheOrDownload_MethodGroup
    class LoadFromCacheOrDownload_MethodGroup:
        @typing.overload
        def __call__(self, url: str, version: int) -> WWW:...
        @typing.overload
        def __call__(self, url: str, hash: Hash128) -> WWW:...
        @typing.overload
        def __call__(self, url: str, version: int, crc: int) -> WWW:...
        @typing.overload
        def __call__(self, url: str, cachedBundle: CachedAssetBundle, crc: int = ...) -> WWW:...
        @typing.overload
        def __call__(self, url: str, hash: Hash128, crc: int) -> WWW:...

    # Skipped UnEscapeURL due to it being static, abstract and generic.

    UnEscapeURL : UnEscapeURL_MethodGroup
    class UnEscapeURL_MethodGroup:
        @typing.overload
        def __call__(self, s: str) -> str:...
        @typing.overload
        def __call__(self, s: str, e: Encoding) -> str:...



class WWWAudioExtensions(abc.ABC):
    @staticmethod
    def GetMovieTexture(www: WWW) -> MovieTexture: ...
    # Skipped GetAudioClip due to it being static, abstract and generic.

    GetAudioClip : GetAudioClip_MethodGroup
    class GetAudioClip_MethodGroup:
        @typing.overload
        def __call__(self, www: WWW) -> AudioClip:...
        @typing.overload
        def __call__(self, www: WWW, threeD: bool) -> AudioClip:...
        @typing.overload
        def __call__(self, www: WWW, threeD: bool, stream: bool) -> AudioClip:...
        @typing.overload
        def __call__(self, www: WWW, threeD: bool, stream: bool, audioType: AudioType) -> AudioClip:...

    # Skipped GetAudioClipCompressed due to it being static, abstract and generic.

    GetAudioClipCompressed : GetAudioClipCompressed_MethodGroup
    class GetAudioClipCompressed_MethodGroup:
        @typing.overload
        def __call__(self, www: WWW) -> AudioClip:...
        @typing.overload
        def __call__(self, www: WWW, threeD: bool) -> AudioClip:...
        @typing.overload
        def __call__(self, www: WWW, threeD: bool, audioType: AudioType) -> AudioClip:...



class WWWForm:
    def __init__(self) -> None: ...
    @property
    def data(self) -> Array_1[int]: ...
    @property
    def headers(self) -> Dictionary_2[str, str]: ...
    # Skipped AddBinaryData due to it being static, abstract and generic.

    AddBinaryData : AddBinaryData_MethodGroup
    class AddBinaryData_MethodGroup:
        @typing.overload
        def __call__(self, fieldName: str, contents: Array_1[int]) -> None:...
        @typing.overload
        def __call__(self, fieldName: str, contents: Array_1[int], fileName: str) -> None:...
        @typing.overload
        def __call__(self, fieldName: str, contents: Array_1[int], fileName: str, mimeType: str) -> None:...

    # Skipped AddField due to it being static, abstract and generic.

    AddField : AddField_MethodGroup
    class AddField_MethodGroup:
        @typing.overload
        def __call__(self, fieldName: str, i: int) -> None:...
        @typing.overload
        def __call__(self, fieldName: str, value: str) -> None:...
        @typing.overload
        def __call__(self, fieldName: str, value: str, e: Encoding) -> None:...



class YieldInstruction:
    def __init__(self) -> None: ...

