import typing, clr
from UnityEngine import Vector3, Matrix4x4
from System import IDisposable, IEquatable_1
from Unity.Collections import Allocator, NativeArray_1, NativeSlice_1
from UnityEngine.AI import NavMeshHit
from Unity.Jobs import JobHandle

class NavMeshLocation:
    @property
    def polygon(self) -> PolygonId: ...
    @property
    def position(self) -> Vector3: ...


class NavMeshPolyTypes(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Ground : NavMeshPolyTypes # 0
    OffMeshConnection : NavMeshPolyTypes # 1


class NavMeshQuery(IDisposable):
    def __init__(self, world: NavMeshWorld, allocator: Allocator, pathNodePoolSize: int = ...) -> None: ...
    def BeginFindPath(self, start: NavMeshLocation, end: NavMeshLocation, areaMask: int = ..., costs: NativeArray_1[float] = ...) -> PathQueryStatus: ...
    def CreateLocation(self, position: Vector3, polygon: PolygonId) -> NavMeshLocation: ...
    def Dispose(self) -> None: ...
    def EndFindPath(self, pathSize: clr.Reference[int]) -> PathQueryStatus: ...
    def GetAgentTypeIdForPolygon(self, polygon: PolygonId) -> int: ...
    def GetEdgesAndNeighbors(self, node: PolygonId, edgeVertices: NativeSlice_1[Vector3], neighbors: NativeSlice_1[PolygonId], edgeIndices: NativeSlice_1[int], verticesCount: clr.Reference[int], neighborsCount: clr.Reference[int]) -> PathQueryStatus: ...
    def GetPathResult(self, path: NativeSlice_1[PolygonId]) -> int: ...
    def GetPolygonType(self, polygon: PolygonId) -> NavMeshPolyTypes: ...
    def GetPortalPoints(self, polygon: PolygonId, neighbourPolygon: PolygonId, left: clr.Reference[Vector3], right: clr.Reference[Vector3]) -> bool: ...
    def MapLocation(self, position: Vector3, extents: Vector3, agentTypeID: int, areaMask: int = ...) -> NavMeshLocation: ...
    def MoveLocation(self, location: NavMeshLocation, target: Vector3, areaMask: int = ...) -> NavMeshLocation: ...
    def MoveLocations(self, locations: NativeSlice_1[NavMeshLocation], targets: NativeSlice_1[Vector3], areaMasks: NativeSlice_1[int]) -> None: ...
    def MoveLocationsInSameAreas(self, locations: NativeSlice_1[NavMeshLocation], targets: NativeSlice_1[Vector3], areaMask: int = ...) -> None: ...
    def PolygonLocalToWorldMatrix(self, polygon: PolygonId) -> Matrix4x4: ...
    def PolygonWorldToLocalMatrix(self, polygon: PolygonId) -> Matrix4x4: ...
    def UpdateFindPath(self, iterations: int, iterationsPerformed: clr.Reference[int]) -> PathQueryStatus: ...
    # Skipped IsValid due to it being static, abstract and generic.

    IsValid : IsValid_MethodGroup
    class IsValid_MethodGroup:
        @typing.overload
        def __call__(self, location: NavMeshLocation) -> bool:...
        @typing.overload
        def __call__(self, polygon: PolygonId) -> bool:...

    # Skipped Raycast due to it being static, abstract and generic.

    Raycast : Raycast_MethodGroup
    class Raycast_MethodGroup:
        @typing.overload
        def __call__(self, hit: clr.Reference[NavMeshHit], start: NavMeshLocation, targetPosition: Vector3, areaMask: int = ..., costs: NativeArray_1[float] = ...) -> PathQueryStatus:...
        @typing.overload
        def __call__(self, hit: clr.Reference[NavMeshHit], path: NativeSlice_1[PolygonId], pathCount: clr.Reference[int], start: NavMeshLocation, targetPosition: Vector3, areaMask: int = ..., costs: NativeArray_1[float] = ...) -> PathQueryStatus:...



class NavMeshWorld:
    def AddDependency(self, job: JobHandle) -> None: ...
    @staticmethod
    def GetDefaultWorld() -> NavMeshWorld: ...
    def IsValid(self) -> bool: ...


class PathQueryStatus(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    WrongMagic : PathQueryStatus # 1
    WrongVersion : PathQueryStatus # 2
    OutOfMemory : PathQueryStatus # 4
    InvalidParam : PathQueryStatus # 8
    BufferTooSmall : PathQueryStatus # 16
    OutOfNodes : PathQueryStatus # 32
    PartialResult : PathQueryStatus # 64
    StatusDetailMask : PathQueryStatus # 16777215
    InProgress : PathQueryStatus # 536870912
    Success : PathQueryStatus # 1073741824
    Failure : PathQueryStatus # -2147483648


class PolygonId(IEquatable_1[PolygonId]):
    def GetHashCode(self) -> int: ...
    def IsNull(self) -> bool: ...
    def __eq__(self, x: PolygonId, y: PolygonId) -> bool: ...
    def __ne__(self, x: PolygonId, y: PolygonId) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, rhs: PolygonId) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...


