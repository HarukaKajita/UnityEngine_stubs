import typing, clr, abc
from System import IEquatable_1, Array_1, DateTime, Action_1
from System.Collections.Generic import List_1
from UnityEngine import Vector3, Quaternion, Vector2, Mesh, MeshCollider, Camera, IntegratedSubsystem_1, HDROutputSettings, RenderTexture, Transform, Rect, ColorGamut, Matrix4x4, RenderTextureDescriptor, IntegratedSubsystemDescriptor_1
from UnityEngine.Rendering import ScriptableCullingParameters, CommandBuffer, RenderTargetIdentifier, TextureDimension
from Unity.Collections import NativeArray_1, Allocator

class Bone(IEquatable_1[Bone]):
    def GetHashCode(self) -> int: ...
    def __eq__(self, a: Bone, b: Bone) -> bool: ...
    def __ne__(self, a: Bone, b: Bone) -> bool: ...
    def TryGetChildBones(self, childBones: List_1[Bone]) -> bool: ...
    def TryGetParentBone(self, parentBone: clr.Reference[Bone]) -> bool: ...
    def TryGetPosition(self, position: clr.Reference[Vector3]) -> bool: ...
    def TryGetRotation(self, rotation: clr.Reference[Quaternion]) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Bone) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class CommonUsages(abc.ABC):
    batteryLevel : InputFeatureUsage_1[float]
    centerEyeAcceleration : InputFeatureUsage_1[Vector3]
    centerEyeAngularAcceleration : InputFeatureUsage_1[Vector3]
    centerEyeAngularVelocity : InputFeatureUsage_1[Vector3]
    centerEyePosition : InputFeatureUsage_1[Vector3]
    centerEyeRotation : InputFeatureUsage_1[Quaternion]
    centerEyeVelocity : InputFeatureUsage_1[Vector3]
    colorCameraAcceleration : InputFeatureUsage_1[Vector3]
    colorCameraAngularAcceleration : InputFeatureUsage_1[Vector3]
    colorCameraAngularVelocity : InputFeatureUsage_1[Vector3]
    colorCameraPosition : InputFeatureUsage_1[Vector3]
    colorCameraRotation : InputFeatureUsage_1[Quaternion]
    colorCameraVelocity : InputFeatureUsage_1[Vector3]
    deviceAcceleration : InputFeatureUsage_1[Vector3]
    deviceAngularAcceleration : InputFeatureUsage_1[Vector3]
    deviceAngularVelocity : InputFeatureUsage_1[Vector3]
    devicePosition : InputFeatureUsage_1[Vector3]
    deviceRotation : InputFeatureUsage_1[Quaternion]
    deviceVelocity : InputFeatureUsage_1[Vector3]
    dPad : InputFeatureUsage_1[Vector2]
    eyesData : InputFeatureUsage_1[Eyes]
    grip : InputFeatureUsage_1[float]
    gripButton : InputFeatureUsage_1[bool]
    handData : InputFeatureUsage_1[Hand]
    indexFinger : InputFeatureUsage_1[float]
    indexTouch : InputFeatureUsage_1[float]
    isTracked : InputFeatureUsage_1[bool]
    leftEyeAcceleration : InputFeatureUsage_1[Vector3]
    leftEyeAngularAcceleration : InputFeatureUsage_1[Vector3]
    leftEyeAngularVelocity : InputFeatureUsage_1[Vector3]
    leftEyePosition : InputFeatureUsage_1[Vector3]
    leftEyeRotation : InputFeatureUsage_1[Quaternion]
    leftEyeVelocity : InputFeatureUsage_1[Vector3]
    menuButton : InputFeatureUsage_1[bool]
    middleFinger : InputFeatureUsage_1[float]
    pinkyFinger : InputFeatureUsage_1[float]
    primary2DAxis : InputFeatureUsage_1[Vector2]
    primary2DAxisClick : InputFeatureUsage_1[bool]
    primary2DAxisTouch : InputFeatureUsage_1[bool]
    primaryButton : InputFeatureUsage_1[bool]
    primaryTouch : InputFeatureUsage_1[bool]
    rightEyeAcceleration : InputFeatureUsage_1[Vector3]
    rightEyeAngularAcceleration : InputFeatureUsage_1[Vector3]
    rightEyeAngularVelocity : InputFeatureUsage_1[Vector3]
    rightEyePosition : InputFeatureUsage_1[Vector3]
    rightEyeRotation : InputFeatureUsage_1[Quaternion]
    rightEyeVelocity : InputFeatureUsage_1[Vector3]
    ringFinger : InputFeatureUsage_1[float]
    secondary2DAxis : InputFeatureUsage_1[Vector2]
    secondary2DAxisClick : InputFeatureUsage_1[bool]
    secondary2DAxisTouch : InputFeatureUsage_1[bool]
    secondaryButton : InputFeatureUsage_1[bool]
    secondaryTouch : InputFeatureUsage_1[bool]
    thumbrest : InputFeatureUsage_1[bool]
    thumbTouch : InputFeatureUsage_1[float]
    trackingState : InputFeatureUsage_1[InputTrackingState]
    trigger : InputFeatureUsage_1[float]
    triggerButton : InputFeatureUsage_1[bool]
    userPresence : InputFeatureUsage_1[bool]


class Eyes(IEquatable_1[Eyes]):
    def GetHashCode(self) -> int: ...
    def __eq__(self, a: Eyes, b: Eyes) -> bool: ...
    def __ne__(self, a: Eyes, b: Eyes) -> bool: ...
    def TryGetFixationPoint(self, fixationPoint: clr.Reference[Vector3]) -> bool: ...
    def TryGetLeftEyeOpenAmount(self, openAmount: clr.Reference[float]) -> bool: ...
    def TryGetLeftEyePosition(self, position: clr.Reference[Vector3]) -> bool: ...
    def TryGetLeftEyeRotation(self, rotation: clr.Reference[Quaternion]) -> bool: ...
    def TryGetRightEyeOpenAmount(self, openAmount: clr.Reference[float]) -> bool: ...
    def TryGetRightEyePosition(self, position: clr.Reference[Vector3]) -> bool: ...
    def TryGetRightEyeRotation(self, rotation: clr.Reference[Quaternion]) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Eyes) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class GameViewRenderMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : GameViewRenderMode # 0
    LeftEye : GameViewRenderMode # 1
    RightEye : GameViewRenderMode # 2
    BothEyes : GameViewRenderMode # 3
    OcclusionMesh : GameViewRenderMode # 4


class Hand(IEquatable_1[Hand]):
    def GetHashCode(self) -> int: ...
    def __eq__(self, a: Hand, b: Hand) -> bool: ...
    def __ne__(self, a: Hand, b: Hand) -> bool: ...
    def TryGetFingerBones(self, finger: HandFinger, bonesOut: List_1[Bone]) -> bool: ...
    def TryGetRootBone(self, boneOut: clr.Reference[Bone]) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Hand) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class HandFinger(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Thumb : HandFinger # 0
    Index : HandFinger # 1
    Middle : HandFinger # 2
    Ring : HandFinger # 3
    Pinky : HandFinger # 4


class HapticCapabilities(IEquatable_1[HapticCapabilities]):
    @property
    def bufferFrequencyHz(self) -> int: ...
    @bufferFrequencyHz.setter
    def bufferFrequencyHz(self, value: int) -> int: ...
    @property
    def bufferMaxSize(self) -> int: ...
    @bufferMaxSize.setter
    def bufferMaxSize(self, value: int) -> int: ...
    @property
    def bufferOptimalSize(self) -> int: ...
    @bufferOptimalSize.setter
    def bufferOptimalSize(self, value: int) -> int: ...
    @property
    def numChannels(self) -> int: ...
    @numChannels.setter
    def numChannels(self, value: int) -> int: ...
    @property
    def supportsBuffer(self) -> bool: ...
    @supportsBuffer.setter
    def supportsBuffer(self, value: bool) -> bool: ...
    @property
    def supportsImpulse(self) -> bool: ...
    @supportsImpulse.setter
    def supportsImpulse(self, value: bool) -> bool: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, a: HapticCapabilities, b: HapticCapabilities) -> bool: ...
    def __ne__(self, a: HapticCapabilities, b: HapticCapabilities) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: HapticCapabilities) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class InputDevice(IEquatable_1[InputDevice]):
    @property
    def characteristics(self) -> InputDeviceCharacteristics: ...
    @property
    def isValid(self) -> bool: ...
    @property
    def manufacturer(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def role(self) -> InputDeviceRole: ...
    @property
    def serialNumber(self) -> str: ...
    @property
    def subsystem(self) -> XRInputSubsystem: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, a: InputDevice, b: InputDevice) -> bool: ...
    def __ne__(self, a: InputDevice, b: InputDevice) -> bool: ...
    def SendHapticBuffer(self, channel: int, buffer: Array_1[int]) -> bool: ...
    def SendHapticImpulse(self, channel: int, amplitude: float, duration: float = ...) -> bool: ...
    def StopHaptics(self) -> None: ...
    def TryGetFeatureUsages(self, featureUsages: List_1[InputFeatureUsage]) -> bool: ...
    def TryGetHapticCapabilities(self, capabilities: clr.Reference[HapticCapabilities]) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: InputDevice) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped TryGetFeatureValue due to it being static, abstract and generic.

    TryGetFeatureValue : TryGetFeatureValue_MethodGroup
    class TryGetFeatureValue_MethodGroup:
        @typing.overload
        def __call__(self, usage: InputFeatureUsage_1[float], value: clr.Reference[float]) -> bool:...
        # Method TryGetFeatureValue(usage : InputFeatureUsage`1, value : UInt32&) was skipped since it collides with above method
        @typing.overload
        def __call__(self, usage: InputFeatureUsage_1[Array_1[int]], value: Array_1[int]) -> bool:...
        @typing.overload
        def __call__(self, usage: InputFeatureUsage_1[InputTrackingState], value: clr.Reference[InputTrackingState]) -> bool:...
        # Method TryGetFeatureValue(usage : InputFeatureUsage`1, value : Boolean&) was skipped since it collides with above method
        @typing.overload
        def __call__(self, usage: InputFeatureUsage_1[Vector2], value: clr.Reference[Vector2]) -> bool:...
        @typing.overload
        def __call__(self, usage: InputFeatureUsage_1[Vector3], value: clr.Reference[Vector3]) -> bool:...
        @typing.overload
        def __call__(self, usage: InputFeatureUsage_1[Quaternion], value: clr.Reference[Quaternion]) -> bool:...
        @typing.overload
        def __call__(self, usage: InputFeatureUsage_1[Hand], value: clr.Reference[Hand]) -> bool:...
        @typing.overload
        def __call__(self, usage: InputFeatureUsage_1[Bone], value: clr.Reference[Bone]) -> bool:...
        @typing.overload
        def __call__(self, usage: InputFeatureUsage_1[Eyes], value: clr.Reference[Eyes]) -> bool:...
        @typing.overload
        def __call__(self, usage: InputFeatureUsage_1[float], time: DateTime, value: clr.Reference[float]) -> bool:...
        # Method TryGetFeatureValue(usage : InputFeatureUsage`1, time : DateTime, value : UInt32&) was skipped since it collides with above method
        @typing.overload
        def __call__(self, usage: InputFeatureUsage_1[InputTrackingState], time: DateTime, value: clr.Reference[InputTrackingState]) -> bool:...
        # Method TryGetFeatureValue(usage : InputFeatureUsage`1, time : DateTime, value : Boolean&) was skipped since it collides with above method
        @typing.overload
        def __call__(self, usage: InputFeatureUsage_1[Vector2], time: DateTime, value: clr.Reference[Vector2]) -> bool:...
        @typing.overload
        def __call__(self, usage: InputFeatureUsage_1[Vector3], time: DateTime, value: clr.Reference[Vector3]) -> bool:...
        @typing.overload
        def __call__(self, usage: InputFeatureUsage_1[Quaternion], time: DateTime, value: clr.Reference[Quaternion]) -> bool:...



class InputDeviceCharacteristics(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : InputDeviceCharacteristics # 0
    HeadMounted : InputDeviceCharacteristics # 1
    Camera : InputDeviceCharacteristics # 2
    HeldInHand : InputDeviceCharacteristics # 4
    HandTracking : InputDeviceCharacteristics # 8
    EyeTracking : InputDeviceCharacteristics # 16
    TrackedDevice : InputDeviceCharacteristics # 32
    Controller : InputDeviceCharacteristics # 64
    TrackingReference : InputDeviceCharacteristics # 128
    Left : InputDeviceCharacteristics # 256
    Right : InputDeviceCharacteristics # 512
    Simulated6DOF : InputDeviceCharacteristics # 1024


class InputDeviceRole(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : InputDeviceRole # 0
    Generic : InputDeviceRole # 1
    LeftHanded : InputDeviceRole # 2
    RightHanded : InputDeviceRole # 3
    GameController : InputDeviceRole # 4
    TrackingReference : InputDeviceRole # 5
    HardwareTracker : InputDeviceRole # 6
    LegacyController : InputDeviceRole # 7


class InputDevices:
    def __init__(self) -> None: ...
    @staticmethod
    def GetDeviceAtXRNode(node: XRNode) -> InputDevice: ...
    @staticmethod
    def GetDevices(inputDevices: List_1[InputDevice]) -> None: ...
    @staticmethod
    def GetDevicesAtXRNode(node: XRNode, inputDevices: List_1[InputDevice]) -> None: ...
    @staticmethod
    def GetDevicesWithCharacteristics(desiredCharacteristics: InputDeviceCharacteristics, inputDevices: List_1[InputDevice]) -> None: ...
    @staticmethod
    def GetDevicesWithRole(role: InputDeviceRole, inputDevices: List_1[InputDevice]) -> None: ...


class InputFeatureUsage_GenericClasses(abc.ABCMeta):
    Generic_InputFeatureUsage_GenericClasses_InputFeatureUsage_1_T = typing.TypeVar('Generic_InputFeatureUsage_GenericClasses_InputFeatureUsage_1_T')
    def __getitem__(self, types : typing.Type[Generic_InputFeatureUsage_GenericClasses_InputFeatureUsage_1_T]) -> typing.Type[InputFeatureUsage_1[Generic_InputFeatureUsage_GenericClasses_InputFeatureUsage_1_T]]: ...

class InputFeatureUsage(InputFeatureUsage_0, metaclass =InputFeatureUsage_GenericClasses): ...

class InputFeatureUsage_0(IEquatable_1[InputFeatureUsage]):
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def type(self) -> typing.Type[typing.Any]: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, a: InputFeatureUsage, b: InputFeatureUsage) -> bool: ...
    def __ne__(self, a: InputFeatureUsage, b: InputFeatureUsage) -> bool: ...
    # Skipped As due to it being static, abstract and generic.

    As : As_MethodGroup
    class As_MethodGroup:
        def __getitem__(self, t:typing.Type[As_1_T1]) -> As_1[As_1_T1]: ...

        As_1_T1 = typing.TypeVar('As_1_T1')
        class As_1(typing.Generic[As_1_T1]):
            As_1_T = InputFeatureUsage_0.As_MethodGroup.As_1_T1
            def __call__(self) -> InputFeatureUsage_1[As_1_T]:...


    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: InputFeatureUsage) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



InputFeatureUsage_1_T = typing.TypeVar('InputFeatureUsage_1_T')
class InputFeatureUsage_1(typing.Generic[InputFeatureUsage_1_T], IEquatable_1[InputFeatureUsage_1[InputFeatureUsage_1_T]]):
    def __init__(self, usageName: str) -> None: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, a: InputFeatureUsage_1[InputFeatureUsage_1_T], b: InputFeatureUsage_1[InputFeatureUsage_1_T]) -> bool: ...
    # Operator not supported op_Explicit(self: InputFeatureUsage`1)
    def __ne__(self, a: InputFeatureUsage_1[InputFeatureUsage_1_T], b: InputFeatureUsage_1[InputFeatureUsage_1_T]) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup[InputFeatureUsage_1_T]
    Equals_MethodGroup_InputFeatureUsage_1_T = typing.TypeVar('Equals_MethodGroup_InputFeatureUsage_1_T')
    class Equals_MethodGroup(typing.Generic[Equals_MethodGroup_InputFeatureUsage_1_T]):
        Equals_MethodGroup_InputFeatureUsage_1_T = InputFeatureUsage_1.Equals_MethodGroup_InputFeatureUsage_1_T
        @typing.overload
        def __call__(self, other: InputFeatureUsage_1[Equals_MethodGroup_InputFeatureUsage_1_T]) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class InputTracking(abc.ABC):
    @classmethod
    @property
    def disablePositionalTracking(cls) -> bool: ...
    @classmethod
    @disablePositionalTracking.setter
    def disablePositionalTracking(cls, value: bool) -> bool: ...
    @staticmethod
    def GetLocalPosition(node: XRNode) -> Vector3: ...
    @staticmethod
    def GetLocalRotation(node: XRNode) -> Quaternion: ...
    @staticmethod
    def GetNodeName(uniqueId: int) -> str: ...
    @staticmethod
    def GetNodeStates(nodeStates: List_1[XRNodeState]) -> None: ...
    @staticmethod
    def Recenter() -> None: ...


class InputTrackingState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : InputTrackingState # 0
    Position : InputTrackingState # 1
    Rotation : InputTrackingState # 2
    Velocity : InputTrackingState # 4
    AngularVelocity : InputTrackingState # 8
    Acceleration : InputTrackingState # 16
    AngularAcceleration : InputTrackingState # 32
    All : InputTrackingState # 63


class MeshChangeState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Added : MeshChangeState # 0
    Updated : MeshChangeState # 1
    Removed : MeshChangeState # 2
    Unchanged : MeshChangeState # 3


class MeshGenerationOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : MeshGenerationOptions # 0
    ConsumeTransform : MeshGenerationOptions # 1


class MeshGenerationResult(IEquatable_1[MeshGenerationResult]):
    @property
    def Attributes(self) -> MeshVertexAttributes: ...
    @property
    def Mesh(self) -> Mesh: ...
    @property
    def MeshCollider(self) -> MeshCollider: ...
    @property
    def MeshId(self) -> MeshId: ...
    @property
    def Position(self) -> Vector3: ...
    @property
    def Rotation(self) -> Quaternion: ...
    @property
    def Scale(self) -> Vector3: ...
    @property
    def Status(self) -> MeshGenerationStatus: ...
    @property
    def Timestamp(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, lhs: MeshGenerationResult, rhs: MeshGenerationResult) -> bool: ...
    def __ne__(self, lhs: MeshGenerationResult, rhs: MeshGenerationResult) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: MeshGenerationResult) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class MeshGenerationStatus(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Success : MeshGenerationStatus # 0
    InvalidMeshId : MeshGenerationStatus # 1
    GenerationAlreadyInProgress : MeshGenerationStatus # 2
    Canceled : MeshGenerationStatus # 3
    UnknownError : MeshGenerationStatus # 4


class MeshId(IEquatable_1[MeshId]):
    @classmethod
    @property
    def InvalidId(cls) -> MeshId: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, id1: MeshId, id2: MeshId) -> bool: ...
    def __ne__(self, id1: MeshId, id2: MeshId) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: MeshId) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class MeshInfo(IEquatable_1[MeshInfo]):
    @property
    def ChangeState(self) -> MeshChangeState: ...
    @ChangeState.setter
    def ChangeState(self, value: MeshChangeState) -> MeshChangeState: ...
    @property
    def MeshId(self) -> MeshId: ...
    @MeshId.setter
    def MeshId(self, value: MeshId) -> MeshId: ...
    @property
    def PriorityHint(self) -> int: ...
    @PriorityHint.setter
    def PriorityHint(self, value: int) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, lhs: MeshInfo, rhs: MeshInfo) -> bool: ...
    def __ne__(self, lhs: MeshInfo, rhs: MeshInfo) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: MeshInfo) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class MeshTransform(IEquatable_1[MeshTransform]):
    def __init__(self, meshId: clr.Reference[MeshId], timestamp: int, position: clr.Reference[Vector3], rotation: clr.Reference[Quaternion], scale: clr.Reference[Vector3]) -> None: ...
    @property
    def MeshId(self) -> MeshId: ...
    @property
    def Position(self) -> Vector3: ...
    @property
    def Rotation(self) -> Quaternion: ...
    @property
    def Scale(self) -> Vector3: ...
    @property
    def Timestamp(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, lhs: MeshTransform, rhs: MeshTransform) -> bool: ...
    def __ne__(self, lhs: MeshTransform, rhs: MeshTransform) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: MeshTransform) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class MeshVertexAttributes(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : MeshVertexAttributes # 0
    Normals : MeshVertexAttributes # 1
    Tangents : MeshVertexAttributes # 2
    UVs : MeshVertexAttributes # 4
    Colors : MeshVertexAttributes # 8


class TrackingOriginModeFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : TrackingOriginModeFlags # 0
    Device : TrackingOriginModeFlags # 1
    Floor : TrackingOriginModeFlags # 2
    TrackingReference : TrackingOriginModeFlags # 4
    Unbounded : TrackingOriginModeFlags # 8


class TrackingSpaceType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Stationary : TrackingSpaceType # 0
    RoomScale : TrackingSpaceType # 1


class XRDevice(abc.ABC):
    @classmethod
    @property
    def fovZoomFactor(cls) -> float: ...
    @classmethod
    @fovZoomFactor.setter
    def fovZoomFactor(cls, value: float) -> float: ...
    @classmethod
    @property
    def isPresent(cls) -> bool: ...
    @classmethod
    @property
    def refreshRate(cls) -> float: ...
    @staticmethod
    def DisableAutoXRCameraTracking(camera: Camera, disabled: bool) -> None: ...
    @staticmethod
    def GetNativePtr() -> int: ...
    @staticmethod
    def GetTrackingSpaceType() -> TrackingSpaceType: ...
    @staticmethod
    def SetTrackingSpaceType(trackingSpaceType: TrackingSpaceType) -> bool: ...
    @staticmethod
    def UpdateEyeTextureMSAASetting() -> None: ...


class XRDisplaySubsystem(IntegratedSubsystem_1[XRDisplaySubsystemDescriptor]):
    def __init__(self) -> None: ...
    @property
    def contentProtectionEnabled(self) -> bool: ...
    @contentProtectionEnabled.setter
    def contentProtectionEnabled(self, value: bool) -> bool: ...
    @property
    def disableLegacyRenderer(self) -> bool: ...
    @disableLegacyRenderer.setter
    def disableLegacyRenderer(self, value: bool) -> bool: ...
    @property
    def displayOpaque(self) -> bool: ...
    @property
    def foveatedRenderingFlags(self) -> XRDisplaySubsystem.FoveatedRenderingFlags: ...
    @foveatedRenderingFlags.setter
    def foveatedRenderingFlags(self, value: XRDisplaySubsystem.FoveatedRenderingFlags) -> XRDisplaySubsystem.FoveatedRenderingFlags: ...
    @property
    def foveatedRenderingLevel(self) -> float: ...
    @foveatedRenderingLevel.setter
    def foveatedRenderingLevel(self, value: float) -> float: ...
    @property
    def hdrOutputSettings(self) -> HDROutputSettings: ...
    @property
    def occlusionMaskScale(self) -> float: ...
    @occlusionMaskScale.setter
    def occlusionMaskScale(self, value: float) -> float: ...
    @property
    def reprojectionMode(self) -> XRDisplaySubsystem.ReprojectionMode: ...
    @reprojectionMode.setter
    def reprojectionMode(self, value: XRDisplaySubsystem.ReprojectionMode) -> XRDisplaySubsystem.ReprojectionMode: ...
    @property
    def running(self) -> bool: ...
    @property
    def scaleOfAllRenderTargets(self) -> float: ...
    @scaleOfAllRenderTargets.setter
    def scaleOfAllRenderTargets(self, value: float) -> float: ...
    @property
    def scaleOfAllViewports(self) -> float: ...
    @scaleOfAllViewports.setter
    def scaleOfAllViewports(self, value: float) -> float: ...
    @property
    def singlePassRenderingDisabled(self) -> bool: ...
    @singlePassRenderingDisabled.setter
    def singlePassRenderingDisabled(self, value: bool) -> bool: ...
    @property
    def sRGB(self) -> bool: ...
    @sRGB.setter
    def sRGB(self, value: bool) -> bool: ...
    @property
    def subsystemDescriptor(self) -> XRDisplaySubsystemDescriptor: ...
    @property
    def SubsystemDescriptor(self) -> XRDisplaySubsystemDescriptor: ...
    @property
    def supportedTextureLayouts(self) -> XRDisplaySubsystem.TextureLayout: ...
    @property
    def textureLayout(self) -> XRDisplaySubsystem.TextureLayout: ...
    @textureLayout.setter
    def textureLayout(self, value: XRDisplaySubsystem.TextureLayout) -> XRDisplaySubsystem.TextureLayout: ...
    @property
    def zFar(self) -> float: ...
    @zFar.setter
    def zFar(self, value: float) -> float: ...
    @property
    def zNear(self) -> float: ...
    @zNear.setter
    def zNear(self, value: float) -> float: ...
    def BeginRecordingIfLateLatched(self, camera: Camera) -> None: ...
    def EndRecordingIfLateLatched(self, camera: Camera) -> None: ...
    def GetCullingParameters(self, camera: Camera, cullingPassIndex: int, scriptableCullingParameters: clr.Reference[ScriptableCullingParameters]) -> None: ...
    def GetPreferredMirrorBlitMode(self) -> int: ...
    def GetRenderPass(self, renderPassIndex: int, renderPass: clr.Reference[XRDisplaySubsystem.XRRenderPass]) -> None: ...
    def GetRenderPassCount(self) -> int: ...
    def GetRenderTexture(self, unityXrRenderTextureId: int) -> RenderTexture: ...
    def GetRenderTextureForRenderPass(self, renderPass: int) -> RenderTexture: ...
    def GetSharedDepthTextureForRenderPass(self, renderPass: int) -> RenderTexture: ...
    def MarkTransformLateLatched(self, transform: Transform, nodeType: XRDisplaySubsystem.LateLatchNode) -> None: ...
    def SetFocusPlane(self, point: Vector3, normal: Vector3, velocity: Vector3) -> None: ...
    def SetMSAALevel(self, level: int) -> None: ...
    def SetPreferredMirrorBlitMode(self, blitMode: int) -> None: ...
    def TryGetAppGPUTimeLastFrame(self, gpuTimeLastFrame: clr.Reference[float]) -> bool: ...
    def TryGetCompositorGPUTimeLastFrame(self, gpuTimeLastFrameCompositor: clr.Reference[float]) -> bool: ...
    def TryGetDisplayRefreshRate(self, displayRefreshRate: clr.Reference[float]) -> bool: ...
    def TryGetDroppedFrameCount(self, droppedFrameCount: clr.Reference[int]) -> bool: ...
    def TryGetFramePresentCount(self, framePresentCount: clr.Reference[int]) -> bool: ...
    def TryGetMotionToPhoton(self, motionToPhoton: clr.Reference[float]) -> bool: ...
    # Skipped AddGraphicsThreadMirrorViewBlit due to it being static, abstract and generic.

    AddGraphicsThreadMirrorViewBlit : AddGraphicsThreadMirrorViewBlit_MethodGroup
    class AddGraphicsThreadMirrorViewBlit_MethodGroup:
        @typing.overload
        def __call__(self, cmd: CommandBuffer, allowGraphicsStateInvalidate: bool) -> bool:...
        @typing.overload
        def __call__(self, cmd: CommandBuffer, allowGraphicsStateInvalidate: bool, mode: int) -> bool:...

    # Skipped GetMirrorViewBlitDesc due to it being static, abstract and generic.

    GetMirrorViewBlitDesc : GetMirrorViewBlitDesc_MethodGroup
    class GetMirrorViewBlitDesc_MethodGroup:
        @typing.overload
        def __call__(self, mirrorRt: RenderTexture, outDesc: clr.Reference[XRDisplaySubsystem.XRMirrorViewBlitDesc]) -> bool:...
        @typing.overload
        def __call__(self, mirrorRt: RenderTexture, outDesc: clr.Reference[XRDisplaySubsystem.XRMirrorViewBlitDesc], mode: int) -> bool:...


    class FoveatedRenderingFlags(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        None_ : XRDisplaySubsystem.FoveatedRenderingFlags # 0
        GazeAllowed : XRDisplaySubsystem.FoveatedRenderingFlags # 1


    class LateLatchNode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Head : XRDisplaySubsystem.LateLatchNode # 0
        LeftHand : XRDisplaySubsystem.LateLatchNode # 1
        RightHand : XRDisplaySubsystem.LateLatchNode # 2


    class ReprojectionMode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Unspecified : XRDisplaySubsystem.ReprojectionMode # 0
        PositionAndOrientation : XRDisplaySubsystem.ReprojectionMode # 1
        OrientationOnly : XRDisplaySubsystem.ReprojectionMode # 2
        None_ : XRDisplaySubsystem.ReprojectionMode # 3


    class TextureLayout(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Texture2DArray : XRDisplaySubsystem.TextureLayout # 1
        SingleTexture2D : XRDisplaySubsystem.TextureLayout # 2
        SeparateTexture2Ds : XRDisplaySubsystem.TextureLayout # 4


    class XRBlitParams:
        destRect : Rect
        foveatedRenderingInfo : int
        srcHdrColorGamut : ColorGamut
        srcHdrEncoded : bool
        srcHdrMaxLuminance : int
        srcRect : Rect
        srcTex : RenderTexture
        srcTexArraySlice : int


    class XRMirrorViewBlitDesc:
        blitParamsCount : int
        nativeBlitAvailable : bool
        nativeBlitInvalidStates : bool
        def GetBlitParameter(self, blitParameterIndex: int, blitParameter: clr.Reference[XRDisplaySubsystem.XRBlitParams]) -> None: ...


    class XRRenderParameter:
        isPreviousViewValid : bool
        occlusionMesh : Mesh
        previousView : Matrix4x4
        projection : Matrix4x4
        textureArraySlice : int
        view : Matrix4x4
        viewport : Rect


    class XRRenderPass:
        cullingPassIndex : int
        foveatedRenderingInfo : int
        hasMotionVectorPass : bool
        motionVectorRenderTarget : RenderTargetIdentifier
        motionVectorRenderTargetDesc : RenderTextureDescriptor
        renderPassIndex : int
        renderTarget : RenderTargetIdentifier
        renderTargetDesc : RenderTextureDescriptor
        shouldFillOutDepth : bool
        def GetRenderParameter(self, camera: Camera, renderParameterIndex: int, renderParameter: clr.Reference[XRDisplaySubsystem.XRRenderParameter]) -> None: ...
        def GetRenderParameterCount(self) -> int: ...



class XRDisplaySubsystemDescriptor(IntegratedSubsystemDescriptor_1[XRDisplaySubsystem]):
    def __init__(self) -> None: ...
    @property
    def disablesLegacyVr(self) -> bool: ...
    @property
    def enableBackBufferMSAA(self) -> bool: ...
    @property
    def id(self) -> str: ...
    def GetAvailableMirrorBlitModeCount(self) -> int: ...
    def GetMirrorBlitModeByIndex(self, index: int, mode: clr.Reference[XRMirrorViewBlitModeDesc]) -> None: ...


class XRInputSubsystem(IntegratedSubsystem_1[XRInputSubsystemDescriptor]):
    def __init__(self) -> None: ...
    @property
    def running(self) -> bool: ...
    @property
    def subsystemDescriptor(self) -> XRInputSubsystemDescriptor: ...
    @property
    def SubsystemDescriptor(self) -> XRInputSubsystemDescriptor: ...
    def GetSupportedTrackingOriginModes(self) -> TrackingOriginModeFlags: ...
    def GetTrackingOriginMode(self) -> TrackingOriginModeFlags: ...
    def TryGetBoundaryPoints(self, boundaryPoints: List_1[Vector3]) -> bool: ...
    def TryGetInputDevices(self, devices: List_1[InputDevice]) -> bool: ...
    def TryRecenter(self) -> bool: ...
    def TrySetTrackingOriginMode(self, origin: TrackingOriginModeFlags) -> bool: ...


class XRInputSubsystemDescriptor(IntegratedSubsystemDescriptor_1[XRInputSubsystem]):
    def __init__(self) -> None: ...
    @property
    def disablesLegacyInput(self) -> bool: ...
    @property
    def id(self) -> str: ...


class XRMeshSubsystem(IntegratedSubsystem_1[XRMeshSubsystemDescriptor]):
    def __init__(self) -> None: ...
    @property
    def meshDensity(self) -> float: ...
    @meshDensity.setter
    def meshDensity(self, value: float) -> float: ...
    @property
    def running(self) -> bool: ...
    @property
    def subsystemDescriptor(self) -> XRMeshSubsystemDescriptor: ...
    @property
    def SubsystemDescriptor(self) -> XRMeshSubsystemDescriptor: ...
    def GetUpdatedMeshTransforms(self, allocator: Allocator) -> NativeArray_1[MeshTransform]: ...
    def SetBoundingVolume(self, origin: Vector3, extents: Vector3) -> bool: ...
    def TryGetMeshInfos(self, meshInfosOut: List_1[MeshInfo]) -> bool: ...
    # Skipped GenerateMeshAsync due to it being static, abstract and generic.

    GenerateMeshAsync : GenerateMeshAsync_MethodGroup
    class GenerateMeshAsync_MethodGroup:
        @typing.overload
        def __call__(self, meshId: MeshId, mesh: Mesh, meshCollider: MeshCollider, attributes: MeshVertexAttributes, onMeshGenerationComplete: Action_1[MeshGenerationResult]) -> None:...
        @typing.overload
        def __call__(self, meshId: MeshId, mesh: Mesh, meshCollider: MeshCollider, attributes: MeshVertexAttributes, onMeshGenerationComplete: Action_1[MeshGenerationResult], options: MeshGenerationOptions) -> None:...



class XRMeshSubsystemDescriptor(IntegratedSubsystemDescriptor_1[XRMeshSubsystem]):
    def __init__(self) -> None: ...
    @property
    def id(self) -> str: ...


class XRMirrorViewBlitMode:
    Default : int
    Distort : int
    LeftEye : int
    None : int
    RightEye : int
    SideBySide : int
    SideBySideOcclusionMesh : int


class XRMirrorViewBlitModeDesc:
    blitMode : int
    blitModeDesc : str


class XRNode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    LeftEye : XRNode # 0
    RightEye : XRNode # 1
    CenterEye : XRNode # 2
    Head : XRNode # 3
    LeftHand : XRNode # 4
    RightHand : XRNode # 5
    GameController : XRNode # 6
    TrackingReference : XRNode # 7
    HardwareTracker : XRNode # 8


class XRNodeState:
    @property
    def acceleration(self) -> None: ...
    @acceleration.setter
    def acceleration(self, value: Vector3) -> None: ...
    @property
    def angularAcceleration(self) -> None: ...
    @angularAcceleration.setter
    def angularAcceleration(self, value: Vector3) -> None: ...
    @property
    def angularVelocity(self) -> None: ...
    @angularVelocity.setter
    def angularVelocity(self, value: Vector3) -> None: ...
    @property
    def nodeType(self) -> XRNode: ...
    @nodeType.setter
    def nodeType(self, value: XRNode) -> XRNode: ...
    @property
    def position(self) -> None: ...
    @position.setter
    def position(self, value: Vector3) -> None: ...
    @property
    def rotation(self) -> None: ...
    @rotation.setter
    def rotation(self, value: Quaternion) -> None: ...
    @property
    def tracked(self) -> bool: ...
    @tracked.setter
    def tracked(self, value: bool) -> bool: ...
    @property
    def uniqueID(self) -> int: ...
    @uniqueID.setter
    def uniqueID(self, value: int) -> int: ...
    @property
    def velocity(self) -> None: ...
    @velocity.setter
    def velocity(self, value: Vector3) -> None: ...
    def TryGetAcceleration(self, acceleration: clr.Reference[Vector3]) -> bool: ...
    def TryGetAngularAcceleration(self, angularAcceleration: clr.Reference[Vector3]) -> bool: ...
    def TryGetAngularVelocity(self, angularVelocity: clr.Reference[Vector3]) -> bool: ...
    def TryGetPosition(self, position: clr.Reference[Vector3]) -> bool: ...
    def TryGetRotation(self, rotation: clr.Reference[Quaternion]) -> bool: ...
    def TryGetVelocity(self, velocity: clr.Reference[Vector3]) -> bool: ...


class XRSettings(abc.ABC):
    @classmethod
    @property
    def deviceEyeTextureDimension(cls) -> TextureDimension: ...
    @classmethod
    @property
    def enabled(cls) -> bool: ...
    @classmethod
    @enabled.setter
    def enabled(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def eyeTextureDesc(cls) -> RenderTextureDescriptor: ...
    @classmethod
    @property
    def eyeTextureHeight(cls) -> int: ...
    @classmethod
    @property
    def eyeTextureResolutionScale(cls) -> float: ...
    @classmethod
    @eyeTextureResolutionScale.setter
    def eyeTextureResolutionScale(cls, value: float) -> float: ...
    @classmethod
    @property
    def eyeTextureWidth(cls) -> int: ...
    @classmethod
    @property
    def gameViewRenderMode(cls) -> GameViewRenderMode: ...
    @classmethod
    @gameViewRenderMode.setter
    def gameViewRenderMode(cls, value: GameViewRenderMode) -> GameViewRenderMode: ...
    @classmethod
    @property
    def isDeviceActive(cls) -> bool: ...
    @classmethod
    @property
    def loadedDeviceName(cls) -> str: ...
    @classmethod
    @property
    def occlusionMaskScale(cls) -> float: ...
    @classmethod
    @occlusionMaskScale.setter
    def occlusionMaskScale(cls, value: float) -> float: ...
    @classmethod
    @property
    def renderViewportScale(cls) -> float: ...
    @classmethod
    @renderViewportScale.setter
    def renderViewportScale(cls, value: float) -> float: ...
    @classmethod
    @property
    def showDeviceView(cls) -> bool: ...
    @classmethod
    @showDeviceView.setter
    def showDeviceView(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def stereoRenderingMode(cls) -> XRSettings.StereoRenderingMode: ...
    @classmethod
    @property
    def supportedDevices(cls) -> Array_1[str]: ...
    @classmethod
    @property
    def useOcclusionMesh(cls) -> bool: ...
    @classmethod
    @useOcclusionMesh.setter
    def useOcclusionMesh(cls, value: bool) -> bool: ...
    # Skipped LoadDeviceByName due to it being static, abstract and generic.

    LoadDeviceByName : LoadDeviceByName_MethodGroup
    class LoadDeviceByName_MethodGroup:
        @typing.overload
        def __call__(self, prioritizedDeviceNameList: Array_1[str]) -> None:...
        @typing.overload
        def __call__(self, deviceName: str) -> None:...


    class StereoRenderingMode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        MultiPass : XRSettings.StereoRenderingMode # 0
        SinglePass : XRSettings.StereoRenderingMode # 1
        SinglePassInstanced : XRSettings.StereoRenderingMode # 2
        SinglePassMultiview : XRSettings.StereoRenderingMode # 3



class XRStats(abc.ABC):
    @staticmethod
    def TryGetDroppedFrameCount(droppedFrameCount: clr.Reference[int]) -> bool: ...
    @staticmethod
    def TryGetFramePresentCount(framePresentCount: clr.Reference[int]) -> bool: ...
    @staticmethod
    def TryGetGPUTimeLastFrame(gpuTimeLastFrame: clr.Reference[float]) -> bool: ...

