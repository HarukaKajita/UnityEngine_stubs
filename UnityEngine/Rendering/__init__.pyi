import typing, clr, abc
from UnityEngine import ComputeBuffer, GraphicsBuffer, Texture, TextureFormat, RenderTextureFormat, Color, Plane, Matrix4x4, MotionVectorGenerationMode, Material, Mesh, GraphicsBufferHandle, Bounds, Camera, MaterialPropertyBlock, RectInt, Rect, RenderTexture, ComputeShader, Vector2, Vector3, MeshTopology, Renderer, RenderTextureDescriptor, FilterMode, RenderTextureReadWrite, RenderTextureMemoryless, Vector4, CubemapFace, Shader, Object, HideFlags, TransparencySortMode, ReflectionProbe, ScriptableObject, RenderTargetSetup, RenderBuffer, ShadowObjectsFilter, Behaviour, Component, GameObject, Transform, LightmapBakeType, LightmapsMode, Light, LightType
from System import Action_1, IEquatable_1, IDisposable, Array, Array_1, MulticastDelegate, IAsyncResult, AsyncCallback
from UnityEngine.Experimental.Rendering import GraphicsFormat, RayTracingShader, RayTracingAccelerationStructure
from Unity.Collections import NativeArray_1, NativeSlice_1, Allocator
from System.Reflection import MethodInfo
from Unity.Jobs import JobHandle
from Unity.Profiling import ProfilerMarker
from UnityEngine.Profiling import CustomSampler
from System.Collections.Generic import List_1
from UnityEngine.Rendering.RendererUtils import RendererListDesc

class AmbientMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Skybox : AmbientMode # 0
    Trilight : AmbientMode # 1
    Flat : AmbientMode # 3
    Custom : AmbientMode # 4


class AsyncGPUReadback(abc.ABC):
    @staticmethod
    def WaitAllRequests() -> None: ...
    # Skipped Request due to it being static, abstract and generic.

    Request : Request_MethodGroup
    class Request_MethodGroup:
        @typing.overload
        def __call__(self, src: ComputeBuffer, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
        @typing.overload
        def __call__(self, src: GraphicsBuffer, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
        @typing.overload
        def __call__(self, src: Texture, mipIndex: int = ..., callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
        @typing.overload
        def __call__(self, src: Texture, mipIndex: int, dstFormat: TextureFormat, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
        @typing.overload
        def __call__(self, src: Texture, mipIndex: int, dstFormat: GraphicsFormat, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
        @typing.overload
        def __call__(self, src: ComputeBuffer, size: int, offset: int, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
        @typing.overload
        def __call__(self, src: GraphicsBuffer, size: int, offset: int, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
        @typing.overload
        def __call__(self, src: Texture, mipIndex: int, x: int, width: int, y: int, height: int, z: int, depth: int, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
        @typing.overload
        def __call__(self, src: Texture, mipIndex: int, x: int, width: int, y: int, height: int, z: int, depth: int, dstFormat: TextureFormat, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
        @typing.overload
        def __call__(self, src: Texture, mipIndex: int, x: int, width: int, y: int, height: int, z: int, depth: int, dstFormat: GraphicsFormat, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...

    # Skipped RequestIntoNativeArray due to it being static, abstract and generic.

    RequestIntoNativeArray : RequestIntoNativeArray_MethodGroup
    class RequestIntoNativeArray_MethodGroup:
        def __getitem__(self, t:typing.Type[RequestIntoNativeArray_1_T1]) -> RequestIntoNativeArray_1[RequestIntoNativeArray_1_T1]: ...

        RequestIntoNativeArray_1_T1 = typing.TypeVar('RequestIntoNativeArray_1_T1')
        class RequestIntoNativeArray_1(typing.Generic[RequestIntoNativeArray_1_T1]):
            RequestIntoNativeArray_1_T = AsyncGPUReadback.RequestIntoNativeArray_MethodGroup.RequestIntoNativeArray_1_T1
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestIntoNativeArray_1_T]], src: ComputeBuffer, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestIntoNativeArray_1_T]], src: GraphicsBuffer, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestIntoNativeArray_1_T]], src: Texture, mipIndex: int = ..., callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestIntoNativeArray_1_T]], src: Texture, mipIndex: int, dstFormat: TextureFormat, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestIntoNativeArray_1_T]], src: Texture, mipIndex: int, dstFormat: GraphicsFormat, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestIntoNativeArray_1_T]], src: ComputeBuffer, size: int, offset: int, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestIntoNativeArray_1_T]], src: GraphicsBuffer, size: int, offset: int, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestIntoNativeArray_1_T]], src: Texture, mipIndex: int, x: int, width: int, y: int, height: int, z: int, depth: int, dstFormat: TextureFormat, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestIntoNativeArray_1_T]], src: Texture, mipIndex: int, x: int, width: int, y: int, height: int, z: int, depth: int, dstFormat: GraphicsFormat, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...


    # Skipped RequestIntoNativeSlice due to it being static, abstract and generic.

    RequestIntoNativeSlice : RequestIntoNativeSlice_MethodGroup
    class RequestIntoNativeSlice_MethodGroup:
        def __getitem__(self, t:typing.Type[RequestIntoNativeSlice_1_T1]) -> RequestIntoNativeSlice_1[RequestIntoNativeSlice_1_T1]: ...

        RequestIntoNativeSlice_1_T1 = typing.TypeVar('RequestIntoNativeSlice_1_T1')
        class RequestIntoNativeSlice_1(typing.Generic[RequestIntoNativeSlice_1_T1]):
            RequestIntoNativeSlice_1_T = AsyncGPUReadback.RequestIntoNativeSlice_MethodGroup.RequestIntoNativeSlice_1_T1
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestIntoNativeSlice_1_T]], src: ComputeBuffer, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestIntoNativeSlice_1_T]], src: GraphicsBuffer, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestIntoNativeSlice_1_T]], src: Texture, mipIndex: int = ..., callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestIntoNativeSlice_1_T]], src: Texture, mipIndex: int, dstFormat: TextureFormat, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestIntoNativeSlice_1_T]], src: Texture, mipIndex: int, dstFormat: GraphicsFormat, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestIntoNativeSlice_1_T]], src: ComputeBuffer, size: int, offset: int, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestIntoNativeSlice_1_T]], src: GraphicsBuffer, size: int, offset: int, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestIntoNativeSlice_1_T]], src: Texture, mipIndex: int, x: int, width: int, y: int, height: int, z: int, depth: int, dstFormat: TextureFormat, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestIntoNativeSlice_1_T]], src: Texture, mipIndex: int, x: int, width: int, y: int, height: int, z: int, depth: int, dstFormat: GraphicsFormat, callback: Action_1[AsyncGPUReadbackRequest] = ...) -> AsyncGPUReadbackRequest:...




class AsyncGPUReadbackRequest:
    @property
    def depth(self) -> int: ...
    @property
    def done(self) -> bool: ...
    @property
    def forcePlayerLoopUpdate(self) -> bool: ...
    @forcePlayerLoopUpdate.setter
    def forcePlayerLoopUpdate(self, value: bool) -> bool: ...
    @property
    def hasError(self) -> bool: ...
    @property
    def height(self) -> int: ...
    @property
    def layerCount(self) -> int: ...
    @property
    def layerDataSize(self) -> int: ...
    @property
    def width(self) -> int: ...
    def Update(self) -> None: ...
    def WaitForCompletion(self) -> None: ...
    # Skipped GetData due to it being static, abstract and generic.

    GetData : GetData_MethodGroup
    class GetData_MethodGroup:
        def __getitem__(self, t:typing.Type[GetData_1_T1]) -> GetData_1[GetData_1_T1]: ...

        GetData_1_T1 = typing.TypeVar('GetData_1_T1')
        class GetData_1(typing.Generic[GetData_1_T1]):
            GetData_1_T = AsyncGPUReadbackRequest.GetData_MethodGroup.GetData_1_T1
            def __call__(self, layer: int = ...) -> NativeArray_1[GetData_1_T]:...




class AttachmentDescriptor(IEquatable_1[AttachmentDescriptor]):
    @typing.overload
    def __init__(self, format: GraphicsFormat) -> None: ...
    @typing.overload
    def __init__(self, format: RenderTextureFormat) -> None: ...
    @typing.overload
    def __init__(self, format: RenderTextureFormat, target: RenderTargetIdentifier, loadExistingContents: bool = ..., storeResults: bool = ..., resolve: bool = ...) -> None: ...
    @property
    def clearColor(self) -> Color: ...
    @clearColor.setter
    def clearColor(self, value: Color) -> Color: ...
    @property
    def clearDepth(self) -> float: ...
    @clearDepth.setter
    def clearDepth(self, value: float) -> float: ...
    @property
    def clearStencil(self) -> int: ...
    @clearStencil.setter
    def clearStencil(self, value: int) -> int: ...
    @property
    def format(self) -> RenderTextureFormat: ...
    @format.setter
    def format(self, value: RenderTextureFormat) -> RenderTextureFormat: ...
    @property
    def graphicsFormat(self) -> GraphicsFormat: ...
    @graphicsFormat.setter
    def graphicsFormat(self, value: GraphicsFormat) -> GraphicsFormat: ...
    @property
    def loadAction(self) -> RenderBufferLoadAction: ...
    @loadAction.setter
    def loadAction(self, value: RenderBufferLoadAction) -> RenderBufferLoadAction: ...
    @property
    def loadStoreTarget(self) -> RenderTargetIdentifier: ...
    @loadStoreTarget.setter
    def loadStoreTarget(self, value: RenderTargetIdentifier) -> RenderTargetIdentifier: ...
    @property
    def resolveTarget(self) -> RenderTargetIdentifier: ...
    @resolveTarget.setter
    def resolveTarget(self, value: RenderTargetIdentifier) -> RenderTargetIdentifier: ...
    @property
    def storeAction(self) -> RenderBufferStoreAction: ...
    @storeAction.setter
    def storeAction(self, value: RenderBufferStoreAction) -> RenderBufferStoreAction: ...
    def ConfigureClear(self, clearColor: Color, clearDepth: float = ..., clearStencil: int = ...) -> None: ...
    def ConfigureResolveTarget(self, target: RenderTargetIdentifier) -> None: ...
    def ConfigureTarget(self, target: RenderTargetIdentifier, loadExistingContents: bool, storeResults: bool) -> None: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: AttachmentDescriptor, right: AttachmentDescriptor) -> bool: ...
    def __ne__(self, left: AttachmentDescriptor, right: AttachmentDescriptor) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: AttachmentDescriptor) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class BatchBufferTarget(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : BatchBufferTarget # 0
    RawBuffer : BatchBufferTarget # 1
    ConstantBuffer : BatchBufferTarget # 2
    UnsupportedByUnderlyingGraphicsApi : BatchBufferTarget # -1


class BatchCullingContext:
    cullingFlags : BatchCullingFlags
    cullingLayerMask : int
    cullingPlanes : NativeArray_1[Plane]
    cullingSplits : NativeArray_1[CullingSplit]
    isOrthographic : int
    localToWorldMatrix : Matrix4x4
    lodParameters : LODParameters
    projectionType : BatchCullingProjectionType
    receiverPlaneCount : int
    receiverPlaneOffset : int
    sceneCullingMask : int
    viewID : BatchPackedCullingViewID
    viewType : BatchCullingViewType


class BatchCullingFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : BatchCullingFlags # 0
    CullLightmappedShadowCasters : BatchCullingFlags # 1


class BatchCullingOutput:
    drawCommands : NativeArray_1[BatchCullingOutputDrawCommands]


class BatchCullingOutputDrawCommands:
    drawCommandCount : int
    drawCommandPickingInstanceIDs : clr.Reference[int]
    drawCommands : clr.Reference[BatchDrawCommand]
    drawRangeCount : int
    drawRanges : clr.Reference[BatchDrawRange]
    instanceSortingPositionFloatCount : int
    instanceSortingPositions : clr.Reference[float]
    visibleInstanceCount : int
    visibleInstances : clr.Reference[int]


class BatchCullingProjectionType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : BatchCullingProjectionType # 0
    Perspective : BatchCullingProjectionType # 1
    Orthographic : BatchCullingProjectionType # 2


class BatchCullingViewType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : BatchCullingViewType # 0
    Camera : BatchCullingViewType # 1
    Light : BatchCullingViewType # 2
    Picking : BatchCullingViewType # 3
    SelectionOutline : BatchCullingViewType # 4


class BatchDrawCommand:
    batchID : BatchID
    flags : BatchDrawCommandFlags
    materialID : BatchMaterialID
    meshID : BatchMeshID
    sortingPosition : int
    splitVisibilityMask : int
    submeshIndex : int
    visibleCount : int
    visibleOffset : int


class BatchDrawCommandFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : BatchDrawCommandFlags # 0
    FlipWinding : BatchDrawCommandFlags # 1
    HasMotion : BatchDrawCommandFlags # 2
    IsLightMapped : BatchDrawCommandFlags # 4
    HasSortingPosition : BatchDrawCommandFlags # 8
    LODCrossFade : BatchDrawCommandFlags # 16


class BatchDrawRange:
    drawCommandsBegin : int
    drawCommandsCount : int
    filterSettings : BatchFilterSettings


class BatchFilterSettings:
    layer : int
    renderingLayerMask : int
    @property
    def allDepthSorted(self) -> bool: ...
    @allDepthSorted.setter
    def allDepthSorted(self, value: bool) -> bool: ...
    @property
    def motionMode(self) -> MotionVectorGenerationMode: ...
    @motionMode.setter
    def motionMode(self, value: MotionVectorGenerationMode) -> MotionVectorGenerationMode: ...
    @property
    def receiveShadows(self) -> bool: ...
    @receiveShadows.setter
    def receiveShadows(self, value: bool) -> bool: ...
    @property
    def shadowCastingMode(self) -> ShadowCastingMode: ...
    @shadowCastingMode.setter
    def shadowCastingMode(self, value: ShadowCastingMode) -> ShadowCastingMode: ...
    @property
    def staticShadowCaster(self) -> bool: ...
    @staticShadowCaster.setter
    def staticShadowCaster(self, value: bool) -> bool: ...


class BatchID(IEquatable_1[BatchID]):
    Null : BatchID
    value : int
    def CompareTo(self, other: BatchID) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, a: BatchID, b: BatchID) -> bool: ...
    def __ne__(self, a: BatchID, b: BatchID) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: BatchID) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class BatchMaterialID(IEquatable_1[BatchMaterialID]):
    Null : BatchMaterialID
    value : int
    def CompareTo(self, other: BatchMaterialID) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, a: BatchMaterialID, b: BatchMaterialID) -> bool: ...
    def __ne__(self, a: BatchMaterialID, b: BatchMaterialID) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: BatchMaterialID) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class BatchMeshID(IEquatable_1[BatchMeshID]):
    Null : BatchMeshID
    value : int
    def CompareTo(self, other: BatchMeshID) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, a: BatchMeshID, b: BatchMeshID) -> bool: ...
    def __ne__(self, a: BatchMeshID, b: BatchMeshID) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: BatchMeshID) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class BatchPackedCullingViewID(IEquatable_1[BatchPackedCullingViewID]):
    def __init__(self, instanceID: int, sliceIndex: int) -> None: ...
    def GetHashCode(self) -> int: ...
    def GetInstanceID(self) -> int: ...
    def GetSliceIndex(self) -> int: ...
    def __eq__(self, lhs: BatchPackedCullingViewID, rhs: BatchPackedCullingViewID) -> bool: ...
    def __ne__(self, lhs: BatchPackedCullingViewID, rhs: BatchPackedCullingViewID) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: BatchPackedCullingViewID) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class BatchRendererGroup(IDisposable):
    def __init__(self, cullingCallback: BatchRendererGroup.OnPerformCulling, userContext: int) -> None: ...
    @classmethod
    @property
    def BufferTarget(cls) -> BatchBufferTarget: ...
    def Dispose(self) -> None: ...
    @staticmethod
    def GetConstantBufferMaxWindowSize() -> int: ...
    @staticmethod
    def GetConstantBufferOffsetAlignment() -> int: ...
    def GetRegisteredMaterial(self, material: BatchMaterialID) -> Material: ...
    def GetRegisteredMesh(self, mesh: BatchMeshID) -> Mesh: ...
    def GetThreadedBatchContext(self) -> ThreadedBatchContext: ...
    def RegisterMaterial(self, material: Material) -> BatchMaterialID: ...
    def RegisterMesh(self, mesh: Mesh) -> BatchMeshID: ...
    def RemoveBatch(self, batchID: BatchID) -> None: ...
    def SetBatchBuffer(self, batchID: BatchID, buffer: GraphicsBufferHandle) -> None: ...
    def SetEnabledViewTypes(self, viewTypes: Array_1[BatchCullingViewType]) -> None: ...
    def SetErrorMaterial(self, material: Material) -> None: ...
    def SetGlobalBounds(self, bounds: Bounds) -> None: ...
    def SetLoadingMaterial(self, material: Material) -> None: ...
    def SetPickingMaterial(self, material: Material) -> None: ...
    def UnregisterMaterial(self, material: BatchMaterialID) -> None: ...
    def UnregisterMesh(self, mesh: BatchMeshID) -> None: ...
    # Skipped AddBatch due to it being static, abstract and generic.

    AddBatch : AddBatch_MethodGroup
    class AddBatch_MethodGroup:
        @typing.overload
        def __call__(self, batchMetadata: NativeArray_1[MetadataValue], buffer: GraphicsBufferHandle) -> BatchID:...
        @typing.overload
        def __call__(self, batchMetadata: NativeArray_1[MetadataValue], buffer: GraphicsBufferHandle, bufferOffset: int, windowSize: int) -> BatchID:...


    class OnPerformCulling(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, rendererGroup: BatchRendererGroup, cullingContext: BatchCullingContext, cullingOutput: BatchCullingOutput, userContext: int, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> JobHandle: ...
        def Invoke(self, rendererGroup: BatchRendererGroup, cullingContext: BatchCullingContext, cullingOutput: BatchCullingOutput, userContext: int) -> JobHandle: ...



class BlendMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Zero : BlendMode # 0
    One : BlendMode # 1
    DstColor : BlendMode # 2
    SrcColor : BlendMode # 3
    OneMinusDstColor : BlendMode # 4
    SrcAlpha : BlendMode # 5
    OneMinusSrcColor : BlendMode # 6
    DstAlpha : BlendMode # 7
    OneMinusDstAlpha : BlendMode # 8
    SrcAlphaSaturate : BlendMode # 9
    OneMinusSrcAlpha : BlendMode # 10


class BlendOp(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Add : BlendOp # 0
    Subtract : BlendOp # 1
    ReverseSubtract : BlendOp # 2
    Min : BlendOp # 3
    Max : BlendOp # 4
    LogicalClear : BlendOp # 5
    LogicalSet : BlendOp # 6
    LogicalCopy : BlendOp # 7
    LogicalCopyInverted : BlendOp # 8
    LogicalNoop : BlendOp # 9
    LogicalInvert : BlendOp # 10
    LogicalAnd : BlendOp # 11
    LogicalNand : BlendOp # 12
    LogicalOr : BlendOp # 13
    LogicalNor : BlendOp # 14
    LogicalXor : BlendOp # 15
    LogicalEquivalence : BlendOp # 16
    LogicalAndReverse : BlendOp # 17
    LogicalAndInverted : BlendOp # 18
    LogicalOrReverse : BlendOp # 19
    LogicalOrInverted : BlendOp # 20
    Multiply : BlendOp # 21
    Screen : BlendOp # 22
    Overlay : BlendOp # 23
    Darken : BlendOp # 24
    Lighten : BlendOp # 25
    ColorDodge : BlendOp # 26
    ColorBurn : BlendOp # 27
    HardLight : BlendOp # 28
    SoftLight : BlendOp # 29
    Difference : BlendOp # 30
    Exclusion : BlendOp # 31
    HSLHue : BlendOp # 32
    HSLSaturation : BlendOp # 33
    HSLColor : BlendOp # 34
    HSLLuminosity : BlendOp # 35


class BlendShapeBufferLayout(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    PerShape : BlendShapeBufferLayout # 0
    PerVertex : BlendShapeBufferLayout # 1


class BlendState(IEquatable_1[BlendState]):
    def __init__(self, separateMRTBlend: bool = ..., alphaToMask: bool = ...) -> None: ...
    @property
    def alphaToMask(self) -> bool: ...
    @alphaToMask.setter
    def alphaToMask(self, value: bool) -> bool: ...
    @property
    def blendState0(self) -> RenderTargetBlendState: ...
    @blendState0.setter
    def blendState0(self, value: RenderTargetBlendState) -> RenderTargetBlendState: ...
    @property
    def blendState1(self) -> RenderTargetBlendState: ...
    @blendState1.setter
    def blendState1(self, value: RenderTargetBlendState) -> RenderTargetBlendState: ...
    @property
    def blendState2(self) -> RenderTargetBlendState: ...
    @blendState2.setter
    def blendState2(self, value: RenderTargetBlendState) -> RenderTargetBlendState: ...
    @property
    def blendState3(self) -> RenderTargetBlendState: ...
    @blendState3.setter
    def blendState3(self, value: RenderTargetBlendState) -> RenderTargetBlendState: ...
    @property
    def blendState4(self) -> RenderTargetBlendState: ...
    @blendState4.setter
    def blendState4(self, value: RenderTargetBlendState) -> RenderTargetBlendState: ...
    @property
    def blendState5(self) -> RenderTargetBlendState: ...
    @blendState5.setter
    def blendState5(self, value: RenderTargetBlendState) -> RenderTargetBlendState: ...
    @property
    def blendState6(self) -> RenderTargetBlendState: ...
    @blendState6.setter
    def blendState6(self, value: RenderTargetBlendState) -> RenderTargetBlendState: ...
    @property
    def blendState7(self) -> RenderTargetBlendState: ...
    @blendState7.setter
    def blendState7(self, value: RenderTargetBlendState) -> RenderTargetBlendState: ...
    @classmethod
    @property
    def defaultValue(cls) -> BlendState: ...
    @property
    def separateMRTBlendStates(self) -> bool: ...
    @separateMRTBlendStates.setter
    def separateMRTBlendStates(self, value: bool) -> bool: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: BlendState, right: BlendState) -> bool: ...
    def __ne__(self, left: BlendState, right: BlendState) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: BlendState) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class BuiltinRenderTextureType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : BuiltinRenderTextureType # 0
    CurrentActive : BuiltinRenderTextureType # 1
    CameraTarget : BuiltinRenderTextureType # 2
    Depth : BuiltinRenderTextureType # 3
    DepthNormals : BuiltinRenderTextureType # 4
    ResolvedDepth : BuiltinRenderTextureType # 5
    PrepassNormalsSpec : BuiltinRenderTextureType # 7
    PrepassLight : BuiltinRenderTextureType # 8
    PrepassLightSpec : BuiltinRenderTextureType # 9
    GBuffer0 : BuiltinRenderTextureType # 10
    GBuffer1 : BuiltinRenderTextureType # 11
    GBuffer2 : BuiltinRenderTextureType # 12
    GBuffer3 : BuiltinRenderTextureType # 13
    Reflections : BuiltinRenderTextureType # 14
    MotionVectors : BuiltinRenderTextureType # 15
    GBuffer4 : BuiltinRenderTextureType # 16
    GBuffer5 : BuiltinRenderTextureType # 17
    GBuffer6 : BuiltinRenderTextureType # 18
    GBuffer7 : BuiltinRenderTextureType # 19
    PropertyName : BuiltinRenderTextureType # -4
    BufferPtr : BuiltinRenderTextureType # -3
    RenderTexture : BuiltinRenderTextureType # -2
    BindableTexture : BuiltinRenderTextureType # -1


class BuiltinShaderDefine(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    UNITY_NO_DXT5nm : BuiltinShaderDefine # 0
    UNITY_NO_RGBM : BuiltinShaderDefine # 1
    UNITY_USE_NATIVE_HDR : BuiltinShaderDefine # 2
    UNITY_ENABLE_REFLECTION_BUFFERS : BuiltinShaderDefine # 3
    UNITY_FRAMEBUFFER_FETCH_AVAILABLE : BuiltinShaderDefine # 4
    UNITY_ENABLE_NATIVE_SHADOW_LOOKUPS : BuiltinShaderDefine # 5
    UNITY_METAL_SHADOWS_USE_POINT_FILTERING : BuiltinShaderDefine # 6
    UNITY_NO_CUBEMAP_ARRAY : BuiltinShaderDefine # 7
    UNITY_NO_SCREENSPACE_SHADOWS : BuiltinShaderDefine # 8
    UNITY_USE_DITHER_MASK_FOR_ALPHABLENDED_SHADOWS : BuiltinShaderDefine # 9
    UNITY_PBS_USE_BRDF1 : BuiltinShaderDefine # 10
    UNITY_PBS_USE_BRDF2 : BuiltinShaderDefine # 11
    UNITY_PBS_USE_BRDF3 : BuiltinShaderDefine # 12
    UNITY_NO_FULL_STANDARD_SHADER : BuiltinShaderDefine # 13
    UNITY_SPECCUBE_BOX_PROJECTION : BuiltinShaderDefine # 14
    UNITY_SPECCUBE_BLENDING : BuiltinShaderDefine # 15
    UNITY_ENABLE_DETAIL_NORMALMAP : BuiltinShaderDefine # 16
    SHADER_API_MOBILE : BuiltinShaderDefine # 17
    SHADER_API_DESKTOP : BuiltinShaderDefine # 18
    UNITY_HARDWARE_TIER1 : BuiltinShaderDefine # 19
    UNITY_HARDWARE_TIER2 : BuiltinShaderDefine # 20
    UNITY_HARDWARE_TIER3 : BuiltinShaderDefine # 21
    UNITY_COLORSPACE_GAMMA : BuiltinShaderDefine # 22
    UNITY_LIGHT_PROBE_PROXY_VOLUME : BuiltinShaderDefine # 23
    UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS : BuiltinShaderDefine # 24
    UNITY_LIGHTMAP_DLDR_ENCODING : BuiltinShaderDefine # 25
    UNITY_LIGHTMAP_RGBM_ENCODING : BuiltinShaderDefine # 26
    UNITY_LIGHTMAP_FULL_HDR : BuiltinShaderDefine # 27
    UNITY_VIRTUAL_TEXTURING : BuiltinShaderDefine # 28
    UNITY_PRETRANSFORM_TO_DISPLAY_ORIENTATION : BuiltinShaderDefine # 29
    UNITY_ASTC_NORMALMAP_ENCODING : BuiltinShaderDefine # 30
    SHADER_API_GLES30 : BuiltinShaderDefine # 31
    UNITY_UNIFIED_SHADER_PRECISION_MODEL : BuiltinShaderDefine # 32
    UNITY_PLATFORM_SUPPORTS_WAVE_32 : BuiltinShaderDefine # 33
    UNITY_PLATFORM_SUPPORTS_WAVE_64 : BuiltinShaderDefine # 34
    UNITY_NEEDS_RENDERPASS_FBFETCH_FALLBACK : BuiltinShaderDefine # 35


class BuiltinShaderMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Disabled : BuiltinShaderMode # 0
    UseBuiltin : BuiltinShaderMode # 1
    UseCustom : BuiltinShaderMode # 2


class BuiltinShaderType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    DeferredShading : BuiltinShaderType # 0
    DeferredReflections : BuiltinShaderType # 1
    LegacyDeferredLighting : BuiltinShaderType # 2
    ScreenSpaceShadows : BuiltinShaderType # 3
    DepthNormals : BuiltinShaderType # 4
    MotionVectors : BuiltinShaderType # 5
    LightHalo : BuiltinShaderType # 6
    LensFlare : BuiltinShaderType # 7


class CameraEvent(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    BeforeDepthTexture : CameraEvent # 0
    AfterDepthTexture : CameraEvent # 1
    BeforeDepthNormalsTexture : CameraEvent # 2
    AfterDepthNormalsTexture : CameraEvent # 3
    BeforeGBuffer : CameraEvent # 4
    AfterGBuffer : CameraEvent # 5
    BeforeLighting : CameraEvent # 6
    AfterLighting : CameraEvent # 7
    BeforeFinalPass : CameraEvent # 8
    AfterFinalPass : CameraEvent # 9
    BeforeForwardOpaque : CameraEvent # 10
    AfterForwardOpaque : CameraEvent # 11
    BeforeImageEffectsOpaque : CameraEvent # 12
    AfterImageEffectsOpaque : CameraEvent # 13
    BeforeSkybox : CameraEvent # 14
    AfterSkybox : CameraEvent # 15
    BeforeForwardAlpha : CameraEvent # 16
    AfterForwardAlpha : CameraEvent # 17
    BeforeImageEffects : CameraEvent # 18
    AfterImageEffects : CameraEvent # 19
    AfterEverything : CameraEvent # 20
    BeforeReflections : CameraEvent # 21
    AfterReflections : CameraEvent # 22
    BeforeHaloAndLensFlares : CameraEvent # 23
    AfterHaloAndLensFlares : CameraEvent # 24


class CameraHDRMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    FP16 : CameraHDRMode # 1
    R11G11B10 : CameraHDRMode # 2


class CameraLateLatchMatrixType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    View : CameraLateLatchMatrixType # 0
    InverseView : CameraLateLatchMatrixType # 1
    ViewProjection : CameraLateLatchMatrixType # 2
    InverseViewProjection : CameraLateLatchMatrixType # 3


class CameraProperties(IEquatable_1[CameraProperties]):
    def GetCameraCullingPlane(self, index: int) -> Plane: ...
    def GetHashCode(self) -> int: ...
    def GetShadowCullingPlane(self, index: int) -> Plane: ...
    def __eq__(self, left: CameraProperties, right: CameraProperties) -> bool: ...
    def __ne__(self, left: CameraProperties, right: CameraProperties) -> bool: ...
    def SetCameraCullingPlane(self, index: int, plane: Plane) -> None: ...
    def SetShadowCullingPlane(self, index: int, plane: Plane) -> None: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: CameraProperties) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...


    class <layerCullDistances>e__FixedBuffer:
        FixedElementField : float


    class <m_CameraCullPlanes>e__FixedBuffer:
        FixedElementField : int


    class <m_ShadowCullPlanes>e__FixedBuffer:
        FixedElementField : int



class ColorWriteMask(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Alpha : ColorWriteMask # 1
    Blue : ColorWriteMask # 2
    Green : ColorWriteMask # 4
    Red : ColorWriteMask # 8
    All : ColorWriteMask # 15


class CommandBuffer(IDisposable):
    def __init__(self) -> None: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def sizeInBytes(self) -> int: ...
    def Clear(self) -> None: ...
    def ClearRandomWriteTargets(self) -> None: ...
    def ConfigureFoveatedRendering(self, platformData: int) -> None: ...
    def CopyBuffer(self, source: GraphicsBuffer, dest: GraphicsBuffer) -> None: ...
    def CreateGraphicsFence(self, fenceType: GraphicsFenceType, stage: SynchronisationStageFlags) -> GraphicsFence: ...
    def DisableScissorRect(self) -> None: ...
    def DisableShaderKeyword(self, keyword: str) -> None: ...
    def DispatchRays(self, rayTracingShader: RayTracingShader, rayGenName: str, width: int, height: int, depth: int, camera: Camera = ...) -> None: ...
    def Dispose(self) -> None: ...
    def DrawMeshInstancedProcedural(self, mesh: Mesh, submeshIndex: int, material: Material, shaderPass: int, count: int, properties: MaterialPropertyBlock = ...) -> None: ...
    def DrawOcclusionMesh(self, normalizedCamViewport: RectInt) -> None: ...
    def DrawRendererList(self, rendererList: RendererList) -> None: ...
    def EnableScissorRect(self, scissor: Rect) -> None: ...
    def EnableShaderKeyword(self, keyword: str) -> None: ...
    def IncrementUpdateCount(self, dest: RenderTargetIdentifier) -> None: ...
    def IssuePluginCustomBlit(self, callback: int, command: int, source: RenderTargetIdentifier, dest: RenderTargetIdentifier, commandParam: int, commandFlags: int) -> None: ...
    def IssuePluginCustomTextureUpdate(self, callback: int, targetTexture: Texture, userData: int) -> None: ...
    def IssuePluginCustomTextureUpdateV1(self, callback: int, targetTexture: Texture, userData: int) -> None: ...
    def IssuePluginCustomTextureUpdateV2(self, callback: int, targetTexture: Texture, userData: int) -> None: ...
    def IssuePluginEvent(self, callback: int, eventID: int) -> None: ...
    def IssuePluginEventAndData(self, callback: int, eventID: int, data: int) -> None: ...
    def IssuePluginEventAndDataWithFlags(self, callback: int, eventID: int, flags: CustomMarkerCallbackFlags, data: int) -> None: ...
    def MarkLateLatchMatrixShaderPropertyID(self, matrixPropertyType: CameraLateLatchMatrixType, shaderPropertyID: int) -> None: ...
    def ProcessVTFeedback(self, rt: RenderTargetIdentifier, resolver: int, slice: int, x: int, width: int, y: int, height: int, mip: int) -> None: ...
    def Release(self) -> None: ...
    def ReleaseTemporaryRT(self, nameID: int) -> None: ...
    def ResolveAntiAliasedSurface(self, rt: RenderTexture, target: RenderTexture = ...) -> None: ...
    def SetComputeBufferCounterValue(self, buffer: ComputeBuffer, counterValue: int) -> None: ...
    def SetComputeParamsFromMaterial(self, computeShader: ComputeShader, kernelIndex: int, material: Material) -> None: ...
    def SetExecutionFlags(self, flags: CommandBufferExecutionFlags) -> None: ...
    def SetFoveatedRenderingMode(self, foveatedRenderingMode: FoveatedRenderingMode) -> None: ...
    def SetGlobalDepthBias(self, bias: float, slopeBias: float) -> None: ...
    def SetInstanceMultiplier(self, multiplier: int) -> None: ...
    def SetInvertCulling(self, invertCulling: bool) -> None: ...
    def SetLateLatchProjectionMatrices(self, projectionMat: Array_1[Matrix4x4]) -> None: ...
    def SetProjectionMatrix(self, proj: Matrix4x4) -> None: ...
    def SetRayTracingShaderPass(self, rayTracingShader: RayTracingShader, passName: str) -> None: ...
    def SetShadowSamplingMode(self, shadowmap: RenderTargetIdentifier, mode: ShadowSamplingMode) -> None: ...
    def SetSinglePassStereo(self, mode: SinglePassStereoMode) -> None: ...
    def SetViewMatrix(self, view: Matrix4x4) -> None: ...
    def SetViewport(self, pixelRect: Rect) -> None: ...
    def SetViewProjectionMatrices(self, view: Matrix4x4, proj: Matrix4x4) -> None: ...
    def UnmarkLateLatchMatrix(self, matrixPropertyType: CameraLateLatchMatrixType) -> None: ...
    def WaitAllAsyncReadbackRequests(self) -> None: ...
    # Skipped BeginSample due to it being static, abstract and generic.

    BeginSample : BeginSample_MethodGroup
    class BeginSample_MethodGroup:
        @typing.overload
        def __call__(self, marker: ProfilerMarker) -> None:...
        @typing.overload
        def __call__(self, name: str) -> None:...
        @typing.overload
        def __call__(self, sampler: CustomSampler) -> None:...

    # Skipped Blit due to it being static, abstract and generic.

    Blit : Blit_MethodGroup
    class Blit_MethodGroup:
        @typing.overload
        def __call__(self, source: Texture, dest: RenderTargetIdentifier) -> None:...
        @typing.overload
        def __call__(self, source: RenderTargetIdentifier, dest: RenderTargetIdentifier) -> None:...
        @typing.overload
        def __call__(self, source: Texture, dest: RenderTargetIdentifier, mat: Material) -> None:...
        @typing.overload
        def __call__(self, source: RenderTargetIdentifier, dest: RenderTargetIdentifier, mat: Material) -> None:...
        @typing.overload
        def __call__(self, source: RenderTargetIdentifier, dest: RenderTargetIdentifier, sourceDepthSlice: int, destDepthSlice: int) -> None:...
        @typing.overload
        def __call__(self, source: Texture, dest: RenderTargetIdentifier, mat: Material, pass: int) -> None:...
        @typing.overload
        def __call__(self, source: RenderTargetIdentifier, dest: RenderTargetIdentifier, mat: Material, pass: int) -> None:...
        @typing.overload
        def __call__(self, source: Texture, dest: RenderTargetIdentifier, scale: Vector2, offset: Vector2) -> None:...
        @typing.overload
        def __call__(self, source: RenderTargetIdentifier, dest: RenderTargetIdentifier, scale: Vector2, offset: Vector2) -> None:...
        @typing.overload
        def __call__(self, source: RenderTargetIdentifier, dest: RenderTargetIdentifier, mat: Material, pass: int, destDepthSlice: int) -> None:...
        @typing.overload
        def __call__(self, source: RenderTargetIdentifier, dest: RenderTargetIdentifier, scale: Vector2, offset: Vector2, sourceDepthSlice: int, destDepthSlice: int) -> None:...

    # Skipped BuildRayTracingAccelerationStructure due to it being static, abstract and generic.

    BuildRayTracingAccelerationStructure : BuildRayTracingAccelerationStructure_MethodGroup
    class BuildRayTracingAccelerationStructure_MethodGroup:
        @typing.overload
        def __call__(self, accelerationStructure: RayTracingAccelerationStructure) -> None:...
        @typing.overload
        def __call__(self, accelerationStructure: RayTracingAccelerationStructure, relativeOrigin: Vector3) -> None:...

    # Skipped ClearRenderTarget due to it being static, abstract and generic.

    ClearRenderTarget : ClearRenderTarget_MethodGroup
    class ClearRenderTarget_MethodGroup:
        @typing.overload
        def __call__(self, clearDepth: bool, clearColor: bool, backgroundColor: Color) -> None:...
        @typing.overload
        def __call__(self, clearFlags: RTClearFlags, backgroundColor: Color, depth: float, stencil: int) -> None:...
        @typing.overload
        def __call__(self, clearDepth: bool, clearColor: bool, backgroundColor: Color, depth: float) -> None:...

    # Skipped ConvertTexture due to it being static, abstract and generic.

    ConvertTexture : ConvertTexture_MethodGroup
    class ConvertTexture_MethodGroup:
        @typing.overload
        def __call__(self, src: RenderTargetIdentifier, dst: RenderTargetIdentifier) -> None:...
        @typing.overload
        def __call__(self, src: RenderTargetIdentifier, srcElement: int, dst: RenderTargetIdentifier, dstElement: int) -> None:...

    # Skipped CopyCounterValue due to it being static, abstract and generic.

    CopyCounterValue : CopyCounterValue_MethodGroup
    class CopyCounterValue_MethodGroup:
        @typing.overload
        def __call__(self, src: ComputeBuffer, dst: ComputeBuffer, dstOffsetBytes: int) -> None:...
        @typing.overload
        def __call__(self, src: GraphicsBuffer, dst: ComputeBuffer, dstOffsetBytes: int) -> None:...
        @typing.overload
        def __call__(self, src: ComputeBuffer, dst: GraphicsBuffer, dstOffsetBytes: int) -> None:...
        @typing.overload
        def __call__(self, src: GraphicsBuffer, dst: GraphicsBuffer, dstOffsetBytes: int) -> None:...

    # Skipped CopyTexture due to it being static, abstract and generic.

    CopyTexture : CopyTexture_MethodGroup
    class CopyTexture_MethodGroup:
        @typing.overload
        def __call__(self, src: RenderTargetIdentifier, dst: RenderTargetIdentifier) -> None:...
        @typing.overload
        def __call__(self, src: RenderTargetIdentifier, srcElement: int, dst: RenderTargetIdentifier, dstElement: int) -> None:...
        @typing.overload
        def __call__(self, src: RenderTargetIdentifier, srcElement: int, srcMip: int, dst: RenderTargetIdentifier, dstElement: int, dstMip: int) -> None:...
        @typing.overload
        def __call__(self, src: RenderTargetIdentifier, srcElement: int, srcMip: int, srcX: int, srcY: int, srcWidth: int, srcHeight: int, dst: RenderTargetIdentifier, dstElement: int, dstMip: int, dstX: int, dstY: int) -> None:...

    # Skipped CreateAsyncGraphicsFence due to it being static, abstract and generic.

    CreateAsyncGraphicsFence : CreateAsyncGraphicsFence_MethodGroup
    class CreateAsyncGraphicsFence_MethodGroup:
        @typing.overload
        def __call__(self) -> GraphicsFence:...
        @typing.overload
        def __call__(self, stage: SynchronisationStage) -> GraphicsFence:...

    # Skipped CreateGPUFence due to it being static, abstract and generic.

    CreateGPUFence : CreateGPUFence_MethodGroup
    class CreateGPUFence_MethodGroup:
        @typing.overload
        def __call__(self) -> GPUFence:...
        @typing.overload
        def __call__(self, stage: SynchronisationStage) -> GPUFence:...

    # Skipped DisableKeyword due to it being static, abstract and generic.

    DisableKeyword : DisableKeyword_MethodGroup
    class DisableKeyword_MethodGroup:
        @typing.overload
        def __call__(self, keyword: clr.Reference[GlobalKeyword]) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, keyword: clr.Reference[LocalKeyword]) -> None:...
        @typing.overload
        def __call__(self, material: Material, keyword: clr.Reference[LocalKeyword]) -> None:...

    # Skipped DispatchCompute due to it being static, abstract and generic.

    DispatchCompute : DispatchCompute_MethodGroup
    class DispatchCompute_MethodGroup:
        @typing.overload
        def __call__(self, computeShader: ComputeShader, kernelIndex: int, indirectBuffer: ComputeBuffer, argsOffset: int) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, kernelIndex: int, indirectBuffer: GraphicsBuffer, argsOffset: int) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, kernelIndex: int, threadGroupsX: int, threadGroupsY: int, threadGroupsZ: int) -> None:...

    # Skipped DrawMesh due to it being static, abstract and generic.

    DrawMesh : DrawMesh_MethodGroup
    class DrawMesh_MethodGroup:
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, material: Material) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: int) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: int, shaderPass: int) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: int, shaderPass: int, properties: MaterialPropertyBlock) -> None:...

    # Skipped DrawMeshInstanced due to it being static, abstract and generic.

    DrawMeshInstanced : DrawMeshInstanced_MethodGroup
    class DrawMeshInstanced_MethodGroup:
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, shaderPass: int, matrices: Array_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, shaderPass: int, matrices: Array_1[Matrix4x4], count: int) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, shaderPass: int, matrices: Array_1[Matrix4x4], count: int, properties: MaterialPropertyBlock) -> None:...

    # Skipped DrawMeshInstancedIndirect due to it being static, abstract and generic.

    DrawMeshInstancedIndirect : DrawMeshInstancedIndirect_MethodGroup
    class DrawMeshInstancedIndirect_MethodGroup:
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, shaderPass: int, bufferWithArgs: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, shaderPass: int, bufferWithArgs: GraphicsBuffer) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, shaderPass: int, bufferWithArgs: ComputeBuffer, argsOffset: int) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, shaderPass: int, bufferWithArgs: GraphicsBuffer, argsOffset: int) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, shaderPass: int, bufferWithArgs: ComputeBuffer, argsOffset: int, properties: MaterialPropertyBlock) -> None:...
        @typing.overload
        def __call__(self, mesh: Mesh, submeshIndex: int, material: Material, shaderPass: int, bufferWithArgs: GraphicsBuffer, argsOffset: int, properties: MaterialPropertyBlock) -> None:...

    # Skipped DrawProcedural due to it being static, abstract and generic.

    DrawProcedural : DrawProcedural_MethodGroup
    class DrawProcedural_MethodGroup:
        @typing.overload
        def __call__(self, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, vertexCount: int) -> None:...
        @typing.overload
        def __call__(self, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, vertexCount: int, instanceCount: int) -> None:...
        @typing.overload
        def __call__(self, indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, indexCount: int) -> None:...
        @typing.overload
        def __call__(self, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, vertexCount: int, instanceCount: int, properties: MaterialPropertyBlock) -> None:...
        @typing.overload
        def __call__(self, indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, indexCount: int, instanceCount: int) -> None:...
        @typing.overload
        def __call__(self, indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, indexCount: int, instanceCount: int, properties: MaterialPropertyBlock) -> None:...

    # Skipped DrawProceduralIndirect due to it being static, abstract and generic.

    DrawProceduralIndirect : DrawProceduralIndirect_MethodGroup
    class DrawProceduralIndirect_MethodGroup:
        @typing.overload
        def __call__(self, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, bufferWithArgs: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, bufferWithArgs: GraphicsBuffer) -> None:...
        @typing.overload
        def __call__(self, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: int) -> None:...
        @typing.overload
        def __call__(self, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: int) -> None:...
        @typing.overload
        def __call__(self, indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, bufferWithArgs: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, bufferWithArgs: GraphicsBuffer) -> None:...
        @typing.overload
        def __call__(self, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: int, properties: MaterialPropertyBlock) -> None:...
        @typing.overload
        def __call__(self, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: int, properties: MaterialPropertyBlock) -> None:...
        @typing.overload
        def __call__(self, indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: int) -> None:...
        @typing.overload
        def __call__(self, indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: int) -> None:...
        @typing.overload
        def __call__(self, indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: int, properties: MaterialPropertyBlock) -> None:...
        @typing.overload
        def __call__(self, indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: int, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: int, properties: MaterialPropertyBlock) -> None:...

    # Skipped DrawRenderer due to it being static, abstract and generic.

    DrawRenderer : DrawRenderer_MethodGroup
    class DrawRenderer_MethodGroup:
        @typing.overload
        def __call__(self, renderer: Renderer, material: Material) -> None:...
        @typing.overload
        def __call__(self, renderer: Renderer, material: Material, submeshIndex: int) -> None:...
        @typing.overload
        def __call__(self, renderer: Renderer, material: Material, submeshIndex: int, shaderPass: int) -> None:...

    # Skipped EnableKeyword due to it being static, abstract and generic.

    EnableKeyword : EnableKeyword_MethodGroup
    class EnableKeyword_MethodGroup:
        @typing.overload
        def __call__(self, keyword: clr.Reference[GlobalKeyword]) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, keyword: clr.Reference[LocalKeyword]) -> None:...
        @typing.overload
        def __call__(self, material: Material, keyword: clr.Reference[LocalKeyword]) -> None:...

    # Skipped EndSample due to it being static, abstract and generic.

    EndSample : EndSample_MethodGroup
    class EndSample_MethodGroup:
        @typing.overload
        def __call__(self, marker: ProfilerMarker) -> None:...
        @typing.overload
        def __call__(self, name: str) -> None:...
        @typing.overload
        def __call__(self, sampler: CustomSampler) -> None:...

    # Skipped GenerateMips due to it being static, abstract and generic.

    GenerateMips : GenerateMips_MethodGroup
    class GenerateMips_MethodGroup:
        @typing.overload
        def __call__(self, rt: RenderTexture) -> None:...
        @typing.overload
        def __call__(self, rt: RenderTargetIdentifier) -> None:...

    # Skipped GetTemporaryRT due to it being static, abstract and generic.

    GetTemporaryRT : GetTemporaryRT_MethodGroup
    class GetTemporaryRT_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, desc: RenderTextureDescriptor) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int) -> None:...
        @typing.overload
        def __call__(self, nameID: int, desc: RenderTextureDescriptor, filter: FilterMode) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, depthBuffer: int) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, depthBuffer: int, filter: FilterMode) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, depthBuffer: int, filter: FilterMode, format: GraphicsFormat) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, depthBuffer: int, filter: FilterMode, format: RenderTextureFormat) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, depthBuffer: int, filter: FilterMode, format: GraphicsFormat, antiAliasing: int) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, depthBuffer: int, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, depthBuffer: int, filter: FilterMode, format: GraphicsFormat, antiAliasing: int, enableRandomWrite: bool) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, depthBuffer: int, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: int) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, depthBuffer: int, filter: FilterMode, format: GraphicsFormat, antiAliasing: int, enableRandomWrite: bool, memorylessMode: RenderTextureMemoryless) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, depthBuffer: int, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: int, enableRandomWrite: bool) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, depthBuffer: int, filter: FilterMode, format: GraphicsFormat, antiAliasing: int, enableRandomWrite: bool, memorylessMode: RenderTextureMemoryless, useDynamicScale: bool) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, depthBuffer: int, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: int, enableRandomWrite: bool, memorylessMode: RenderTextureMemoryless) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, depthBuffer: int, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: int, enableRandomWrite: bool, memorylessMode: RenderTextureMemoryless, useDynamicScale: bool) -> None:...

    # Skipped GetTemporaryRTArray due to it being static, abstract and generic.

    GetTemporaryRTArray : GetTemporaryRTArray_MethodGroup
    class GetTemporaryRTArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, slices: int) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, slices: int, depthBuffer: int) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, slices: int, depthBuffer: int, filter: FilterMode) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, slices: int, depthBuffer: int, filter: FilterMode, format: GraphicsFormat) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, slices: int, depthBuffer: int, filter: FilterMode, format: RenderTextureFormat) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, slices: int, depthBuffer: int, filter: FilterMode, format: GraphicsFormat, antiAliasing: int) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, slices: int, depthBuffer: int, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, slices: int, depthBuffer: int, filter: FilterMode, format: GraphicsFormat, antiAliasing: int, enableRandomWrite: bool) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, slices: int, depthBuffer: int, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: int) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, slices: int, depthBuffer: int, filter: FilterMode, format: GraphicsFormat, antiAliasing: int, enableRandomWrite: bool, useDynamicScale: bool) -> None:...
        @typing.overload
        def __call__(self, nameID: int, width: int, height: int, slices: int, depthBuffer: int, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: int, enableRandomWrite: bool) -> None:...

    # Skipped RequestAsyncReadback due to it being static, abstract and generic.

    RequestAsyncReadback : RequestAsyncReadback_MethodGroup
    class RequestAsyncReadback_MethodGroup:
        @typing.overload
        def __call__(self, src: Texture, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
        @typing.overload
        def __call__(self, src: ComputeBuffer, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
        @typing.overload
        def __call__(self, src: GraphicsBuffer, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
        @typing.overload
        def __call__(self, src: Texture, mipIndex: int, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
        @typing.overload
        def __call__(self, src: Texture, mipIndex: int, dstFormat: TextureFormat, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
        @typing.overload
        def __call__(self, src: Texture, mipIndex: int, dstFormat: GraphicsFormat, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
        @typing.overload
        def __call__(self, src: ComputeBuffer, size: int, offset: int, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
        @typing.overload
        def __call__(self, src: GraphicsBuffer, size: int, offset: int, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
        @typing.overload
        def __call__(self, src: Texture, mipIndex: int, x: int, width: int, y: int, height: int, z: int, depth: int, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
        @typing.overload
        def __call__(self, src: Texture, mipIndex: int, x: int, width: int, y: int, height: int, z: int, depth: int, dstFormat: TextureFormat, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
        @typing.overload
        def __call__(self, src: Texture, mipIndex: int, x: int, width: int, y: int, height: int, z: int, depth: int, dstFormat: GraphicsFormat, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...

    # Skipped RequestAsyncReadbackIntoNativeArray due to it being static, abstract and generic.

    RequestAsyncReadbackIntoNativeArray : RequestAsyncReadbackIntoNativeArray_MethodGroup
    class RequestAsyncReadbackIntoNativeArray_MethodGroup:
        def __getitem__(self, t:typing.Type[RequestAsyncReadbackIntoNativeArray_1_T1]) -> RequestAsyncReadbackIntoNativeArray_1[RequestAsyncReadbackIntoNativeArray_1_T1]: ...

        RequestAsyncReadbackIntoNativeArray_1_T1 = typing.TypeVar('RequestAsyncReadbackIntoNativeArray_1_T1')
        class RequestAsyncReadbackIntoNativeArray_1(typing.Generic[RequestAsyncReadbackIntoNativeArray_1_T1]):
            RequestAsyncReadbackIntoNativeArray_1_T = CommandBuffer.RequestAsyncReadbackIntoNativeArray_MethodGroup.RequestAsyncReadbackIntoNativeArray_1_T1
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestAsyncReadbackIntoNativeArray_1_T]], src: Texture, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestAsyncReadbackIntoNativeArray_1_T]], src: ComputeBuffer, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestAsyncReadbackIntoNativeArray_1_T]], src: GraphicsBuffer, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestAsyncReadbackIntoNativeArray_1_T]], src: Texture, mipIndex: int, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestAsyncReadbackIntoNativeArray_1_T]], src: Texture, mipIndex: int, dstFormat: TextureFormat, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestAsyncReadbackIntoNativeArray_1_T]], src: Texture, mipIndex: int, dstFormat: GraphicsFormat, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestAsyncReadbackIntoNativeArray_1_T]], src: ComputeBuffer, size: int, offset: int, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestAsyncReadbackIntoNativeArray_1_T]], src: GraphicsBuffer, size: int, offset: int, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestAsyncReadbackIntoNativeArray_1_T]], src: Texture, mipIndex: int, x: int, width: int, y: int, height: int, z: int, depth: int, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestAsyncReadbackIntoNativeArray_1_T]], src: Texture, mipIndex: int, x: int, width: int, y: int, height: int, z: int, depth: int, dstFormat: TextureFormat, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeArray_1[RequestAsyncReadbackIntoNativeArray_1_T]], src: Texture, mipIndex: int, x: int, width: int, y: int, height: int, z: int, depth: int, dstFormat: GraphicsFormat, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...


    # Skipped RequestAsyncReadbackIntoNativeSlice due to it being static, abstract and generic.

    RequestAsyncReadbackIntoNativeSlice : RequestAsyncReadbackIntoNativeSlice_MethodGroup
    class RequestAsyncReadbackIntoNativeSlice_MethodGroup:
        def __getitem__(self, t:typing.Type[RequestAsyncReadbackIntoNativeSlice_1_T1]) -> RequestAsyncReadbackIntoNativeSlice_1[RequestAsyncReadbackIntoNativeSlice_1_T1]: ...

        RequestAsyncReadbackIntoNativeSlice_1_T1 = typing.TypeVar('RequestAsyncReadbackIntoNativeSlice_1_T1')
        class RequestAsyncReadbackIntoNativeSlice_1(typing.Generic[RequestAsyncReadbackIntoNativeSlice_1_T1]):
            RequestAsyncReadbackIntoNativeSlice_1_T = CommandBuffer.RequestAsyncReadbackIntoNativeSlice_MethodGroup.RequestAsyncReadbackIntoNativeSlice_1_T1
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestAsyncReadbackIntoNativeSlice_1_T]], src: Texture, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestAsyncReadbackIntoNativeSlice_1_T]], src: ComputeBuffer, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestAsyncReadbackIntoNativeSlice_1_T]], src: GraphicsBuffer, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestAsyncReadbackIntoNativeSlice_1_T]], src: Texture, mipIndex: int, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestAsyncReadbackIntoNativeSlice_1_T]], src: Texture, mipIndex: int, dstFormat: TextureFormat, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestAsyncReadbackIntoNativeSlice_1_T]], src: Texture, mipIndex: int, dstFormat: GraphicsFormat, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestAsyncReadbackIntoNativeSlice_1_T]], src: ComputeBuffer, size: int, offset: int, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestAsyncReadbackIntoNativeSlice_1_T]], src: GraphicsBuffer, size: int, offset: int, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestAsyncReadbackIntoNativeSlice_1_T]], src: Texture, mipIndex: int, x: int, width: int, y: int, height: int, z: int, depth: int, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestAsyncReadbackIntoNativeSlice_1_T]], src: Texture, mipIndex: int, x: int, width: int, y: int, height: int, z: int, depth: int, dstFormat: TextureFormat, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...
            @typing.overload
            def __call__(self, output: clr.Reference[NativeSlice_1[RequestAsyncReadbackIntoNativeSlice_1_T]], src: Texture, mipIndex: int, x: int, width: int, y: int, height: int, z: int, depth: int, dstFormat: GraphicsFormat, callback: Action_1[AsyncGPUReadbackRequest]) -> None:...


    # Skipped SetBufferCounterValue due to it being static, abstract and generic.

    SetBufferCounterValue : SetBufferCounterValue_MethodGroup
    class SetBufferCounterValue_MethodGroup:
        @typing.overload
        def __call__(self, buffer: ComputeBuffer, counterValue: int) -> None:...
        @typing.overload
        def __call__(self, buffer: GraphicsBuffer, counterValue: int) -> None:...

    # Skipped SetBufferData due to it being static, abstract and generic.

    SetBufferData : SetBufferData_MethodGroup
    class SetBufferData_MethodGroup:
        def __getitem__(self, t:typing.Type[SetBufferData_1_T1]) -> SetBufferData_1[SetBufferData_1_T1]: ...

        SetBufferData_1_T1 = typing.TypeVar('SetBufferData_1_T1')
        class SetBufferData_1(typing.Generic[SetBufferData_1_T1]):
            SetBufferData_1_T = CommandBuffer.SetBufferData_MethodGroup.SetBufferData_1_T1
            @typing.overload
            def __call__(self, buffer: ComputeBuffer, data: List_1[SetBufferData_1_T]) -> None:...
            @typing.overload
            def __call__(self, buffer: GraphicsBuffer, data: List_1[SetBufferData_1_T]) -> None:...
            @typing.overload
            def __call__(self, buffer: ComputeBuffer, data: NativeArray_1[SetBufferData_1_T]) -> None:...
            @typing.overload
            def __call__(self, buffer: GraphicsBuffer, data: NativeArray_1[SetBufferData_1_T]) -> None:...
            @typing.overload
            def __call__(self, buffer: ComputeBuffer, data: List_1[SetBufferData_1_T], managedBufferStartIndex: int, graphicsBufferStartIndex: int, count: int) -> None:...
            @typing.overload
            def __call__(self, buffer: GraphicsBuffer, data: List_1[SetBufferData_1_T], managedBufferStartIndex: int, graphicsBufferStartIndex: int, count: int) -> None:...
            @typing.overload
            def __call__(self, buffer: ComputeBuffer, data: NativeArray_1[SetBufferData_1_T], nativeBufferStartIndex: int, graphicsBufferStartIndex: int, count: int) -> None:...
            @typing.overload
            def __call__(self, buffer: GraphicsBuffer, data: NativeArray_1[SetBufferData_1_T], nativeBufferStartIndex: int, graphicsBufferStartIndex: int, count: int) -> None:...

        @typing.overload
        def __call__(self, buffer: ComputeBuffer, data: Array) -> None:...
        @typing.overload
        def __call__(self, buffer: GraphicsBuffer, data: Array) -> None:...
        @typing.overload
        def __call__(self, buffer: ComputeBuffer, data: Array, managedBufferStartIndex: int, graphicsBufferStartIndex: int, count: int) -> None:...
        @typing.overload
        def __call__(self, buffer: GraphicsBuffer, data: Array, managedBufferStartIndex: int, graphicsBufferStartIndex: int, count: int) -> None:...

    # Skipped SetComputeBufferData due to it being static, abstract and generic.

    SetComputeBufferData : SetComputeBufferData_MethodGroup
    class SetComputeBufferData_MethodGroup:
        def __getitem__(self, t:typing.Type[SetComputeBufferData_1_T1]) -> SetComputeBufferData_1[SetComputeBufferData_1_T1]: ...

        SetComputeBufferData_1_T1 = typing.TypeVar('SetComputeBufferData_1_T1')
        class SetComputeBufferData_1(typing.Generic[SetComputeBufferData_1_T1]):
            SetComputeBufferData_1_T = CommandBuffer.SetComputeBufferData_MethodGroup.SetComputeBufferData_1_T1
            @typing.overload
            def __call__(self, buffer: ComputeBuffer, data: List_1[SetComputeBufferData_1_T]) -> None:...
            @typing.overload
            def __call__(self, buffer: ComputeBuffer, data: NativeArray_1[SetComputeBufferData_1_T]) -> None:...
            @typing.overload
            def __call__(self, buffer: ComputeBuffer, data: List_1[SetComputeBufferData_1_T], managedBufferStartIndex: int, graphicsBufferStartIndex: int, count: int) -> None:...
            @typing.overload
            def __call__(self, buffer: ComputeBuffer, data: NativeArray_1[SetComputeBufferData_1_T], nativeBufferStartIndex: int, graphicsBufferStartIndex: int, count: int) -> None:...

        @typing.overload
        def __call__(self, buffer: ComputeBuffer, data: Array) -> None:...
        @typing.overload
        def __call__(self, buffer: ComputeBuffer, data: Array, managedBufferStartIndex: int, graphicsBufferStartIndex: int, count: int) -> None:...

    # Skipped SetComputeBufferParam due to it being static, abstract and generic.

    SetComputeBufferParam : SetComputeBufferParam_MethodGroup
    class SetComputeBufferParam_MethodGroup:
        @typing.overload
        def __call__(self, computeShader: ComputeShader, kernelIndex: int, nameID: int, bufferHandle: GraphicsBufferHandle) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, kernelIndex: int, nameID: int, buffer: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, kernelIndex: int, nameID: int, buffer: GraphicsBuffer) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, kernelIndex: int, name: str, bufferHandle: GraphicsBufferHandle) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, kernelIndex: int, name: str, buffer: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, kernelIndex: int, name: str, buffer: GraphicsBuffer) -> None:...

    # Skipped SetComputeConstantBufferParam due to it being static, abstract and generic.

    SetComputeConstantBufferParam : SetComputeConstantBufferParam_MethodGroup
    class SetComputeConstantBufferParam_MethodGroup:
        @typing.overload
        def __call__(self, computeShader: ComputeShader, nameID: int, buffer: ComputeBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, nameID: int, buffer: GraphicsBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, name: str, buffer: ComputeBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, name: str, buffer: GraphicsBuffer, offset: int, size: int) -> None:...

    # Skipped SetComputeFloatParam due to it being static, abstract and generic.

    SetComputeFloatParam : SetComputeFloatParam_MethodGroup
    class SetComputeFloatParam_MethodGroup:
        @typing.overload
        def __call__(self, computeShader: ComputeShader, nameID: int, val: float) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, name: str, val: float) -> None:...

    # Skipped SetComputeFloatParams due to it being static, abstract and generic.

    SetComputeFloatParams : SetComputeFloatParams_MethodGroup
    class SetComputeFloatParams_MethodGroup:
        @typing.overload
        def __call__(self, computeShader: ComputeShader, nameID: int, values: Array_1[float]) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, name: str, values: Array_1[float]) -> None:...

    # Skipped SetComputeIntParam due to it being static, abstract and generic.

    SetComputeIntParam : SetComputeIntParam_MethodGroup
    class SetComputeIntParam_MethodGroup:
        @typing.overload
        def __call__(self, computeShader: ComputeShader, nameID: int, val: int) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, name: str, val: int) -> None:...

    # Skipped SetComputeIntParams due to it being static, abstract and generic.

    SetComputeIntParams : SetComputeIntParams_MethodGroup
    class SetComputeIntParams_MethodGroup:
        @typing.overload
        def __call__(self, computeShader: ComputeShader, nameID: int, values: Array_1[int]) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, name: str, values: Array_1[int]) -> None:...

    # Skipped SetComputeMatrixArrayParam due to it being static, abstract and generic.

    SetComputeMatrixArrayParam : SetComputeMatrixArrayParam_MethodGroup
    class SetComputeMatrixArrayParam_MethodGroup:
        @typing.overload
        def __call__(self, computeShader: ComputeShader, nameID: int, values: Array_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, name: str, values: Array_1[Matrix4x4]) -> None:...

    # Skipped SetComputeMatrixParam due to it being static, abstract and generic.

    SetComputeMatrixParam : SetComputeMatrixParam_MethodGroup
    class SetComputeMatrixParam_MethodGroup:
        @typing.overload
        def __call__(self, computeShader: ComputeShader, nameID: int, val: Matrix4x4) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, name: str, val: Matrix4x4) -> None:...

    # Skipped SetComputeTextureParam due to it being static, abstract and generic.

    SetComputeTextureParam : SetComputeTextureParam_MethodGroup
    class SetComputeTextureParam_MethodGroup:
        @typing.overload
        def __call__(self, computeShader: ComputeShader, kernelIndex: int, nameID: int, rt: RenderTargetIdentifier) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, kernelIndex: int, name: str, rt: RenderTargetIdentifier) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, kernelIndex: int, nameID: int, rt: RenderTargetIdentifier, mipLevel: int) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, kernelIndex: int, name: str, rt: RenderTargetIdentifier, mipLevel: int) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, kernelIndex: int, nameID: int, rt: RenderTargetIdentifier, mipLevel: int, element: RenderTextureSubElement) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, kernelIndex: int, name: str, rt: RenderTargetIdentifier, mipLevel: int, element: RenderTextureSubElement) -> None:...

    # Skipped SetComputeVectorArrayParam due to it being static, abstract and generic.

    SetComputeVectorArrayParam : SetComputeVectorArrayParam_MethodGroup
    class SetComputeVectorArrayParam_MethodGroup:
        @typing.overload
        def __call__(self, computeShader: ComputeShader, nameID: int, values: Array_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, name: str, values: Array_1[Vector4]) -> None:...

    # Skipped SetComputeVectorParam due to it being static, abstract and generic.

    SetComputeVectorParam : SetComputeVectorParam_MethodGroup
    class SetComputeVectorParam_MethodGroup:
        @typing.overload
        def __call__(self, computeShader: ComputeShader, nameID: int, val: Vector4) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, name: str, val: Vector4) -> None:...

    # Skipped SetGlobalBuffer due to it being static, abstract and generic.

    SetGlobalBuffer : SetGlobalBuffer_MethodGroup
    class SetGlobalBuffer_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, nameID: int, value: GraphicsBuffer) -> None:...
        @typing.overload
        def __call__(self, name: str, value: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, name: str, value: GraphicsBuffer) -> None:...

    # Skipped SetGlobalColor due to it being static, abstract and generic.

    SetGlobalColor : SetGlobalColor_MethodGroup
    class SetGlobalColor_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Color) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Color) -> None:...

    # Skipped SetGlobalConstantBuffer due to it being static, abstract and generic.

    SetGlobalConstantBuffer : SetGlobalConstantBuffer_MethodGroup
    class SetGlobalConstantBuffer_MethodGroup:
        @typing.overload
        def __call__(self, buffer: ComputeBuffer, nameID: int, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, buffer: GraphicsBuffer, nameID: int, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, buffer: ComputeBuffer, name: str, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, buffer: GraphicsBuffer, name: str, offset: int, size: int) -> None:...

    # Skipped SetGlobalFloat due to it being static, abstract and generic.

    SetGlobalFloat : SetGlobalFloat_MethodGroup
    class SetGlobalFloat_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: float) -> None:...
        @typing.overload
        def __call__(self, name: str, value: float) -> None:...

    # Skipped SetGlobalFloatArray due to it being static, abstract and generic.

    SetGlobalFloatArray : SetGlobalFloatArray_MethodGroup
    class SetGlobalFloatArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, values: List_1[float]) -> None:...
        @typing.overload
        def __call__(self, nameID: int, values: Array_1[float]) -> None:...
        @typing.overload
        def __call__(self, propertyName: str, values: List_1[float]) -> None:...
        @typing.overload
        def __call__(self, propertyName: str, values: Array_1[float]) -> None:...

    # Skipped SetGlobalInt due to it being static, abstract and generic.

    SetGlobalInt : SetGlobalInt_MethodGroup
    class SetGlobalInt_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: int) -> None:...
        @typing.overload
        def __call__(self, name: str, value: int) -> None:...

    # Skipped SetGlobalInteger due to it being static, abstract and generic.

    SetGlobalInteger : SetGlobalInteger_MethodGroup
    class SetGlobalInteger_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: int) -> None:...
        @typing.overload
        def __call__(self, name: str, value: int) -> None:...

    # Skipped SetGlobalMatrix due to it being static, abstract and generic.

    SetGlobalMatrix : SetGlobalMatrix_MethodGroup
    class SetGlobalMatrix_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Matrix4x4) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Matrix4x4) -> None:...

    # Skipped SetGlobalMatrixArray due to it being static, abstract and generic.

    SetGlobalMatrixArray : SetGlobalMatrixArray_MethodGroup
    class SetGlobalMatrixArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, values: List_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, nameID: int, values: Array_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, propertyName: str, values: List_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, propertyName: str, values: Array_1[Matrix4x4]) -> None:...

    # Skipped SetGlobalTexture due to it being static, abstract and generic.

    SetGlobalTexture : SetGlobalTexture_MethodGroup
    class SetGlobalTexture_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: RenderTargetIdentifier) -> None:...
        @typing.overload
        def __call__(self, name: str, value: RenderTargetIdentifier) -> None:...
        @typing.overload
        def __call__(self, nameID: int, value: RenderTargetIdentifier, element: RenderTextureSubElement) -> None:...
        @typing.overload
        def __call__(self, name: str, value: RenderTargetIdentifier, element: RenderTextureSubElement) -> None:...

    # Skipped SetGlobalVector due to it being static, abstract and generic.

    SetGlobalVector : SetGlobalVector_MethodGroup
    class SetGlobalVector_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, value: Vector4) -> None:...
        @typing.overload
        def __call__(self, name: str, value: Vector4) -> None:...

    # Skipped SetGlobalVectorArray due to it being static, abstract and generic.

    SetGlobalVectorArray : SetGlobalVectorArray_MethodGroup
    class SetGlobalVectorArray_MethodGroup:
        @typing.overload
        def __call__(self, nameID: int, values: List_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, nameID: int, values: Array_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, propertyName: str, values: List_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, propertyName: str, values: Array_1[Vector4]) -> None:...

    # Skipped SetKeyword due to it being static, abstract and generic.

    SetKeyword : SetKeyword_MethodGroup
    class SetKeyword_MethodGroup:
        @typing.overload
        def __call__(self, keyword: clr.Reference[GlobalKeyword], value: bool) -> None:...
        @typing.overload
        def __call__(self, computeShader: ComputeShader, keyword: clr.Reference[LocalKeyword], value: bool) -> None:...
        @typing.overload
        def __call__(self, material: Material, keyword: clr.Reference[LocalKeyword], value: bool) -> None:...

    # Skipped SetRandomWriteTarget due to it being static, abstract and generic.

    SetRandomWriteTarget : SetRandomWriteTarget_MethodGroup
    class SetRandomWriteTarget_MethodGroup:
        @typing.overload
        def __call__(self, index: int, rt: RenderTargetIdentifier) -> None:...
        @typing.overload
        def __call__(self, index: int, buffer: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, index: int, buffer: GraphicsBuffer) -> None:...
        @typing.overload
        def __call__(self, index: int, buffer: ComputeBuffer, preserveCounterValue: bool) -> None:...
        @typing.overload
        def __call__(self, index: int, buffer: GraphicsBuffer, preserveCounterValue: bool) -> None:...

    # Skipped SetRayTracingAccelerationStructure due to it being static, abstract and generic.

    SetRayTracingAccelerationStructure : SetRayTracingAccelerationStructure_MethodGroup
    class SetRayTracingAccelerationStructure_MethodGroup:
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, nameID: int, rayTracingAccelerationStructure: RayTracingAccelerationStructure) -> None:...
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, name: str, rayTracingAccelerationStructure: RayTracingAccelerationStructure) -> None:...

    # Skipped SetRayTracingBufferParam due to it being static, abstract and generic.

    SetRayTracingBufferParam : SetRayTracingBufferParam_MethodGroup
    class SetRayTracingBufferParam_MethodGroup:
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, nameID: int, buffer: ComputeBuffer) -> None:...
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, name: str, buffer: ComputeBuffer) -> None:...

    # Skipped SetRayTracingConstantBufferParam due to it being static, abstract and generic.

    SetRayTracingConstantBufferParam : SetRayTracingConstantBufferParam_MethodGroup
    class SetRayTracingConstantBufferParam_MethodGroup:
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, nameID: int, buffer: ComputeBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, nameID: int, buffer: GraphicsBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, name: str, buffer: ComputeBuffer, offset: int, size: int) -> None:...
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, name: str, buffer: GraphicsBuffer, offset: int, size: int) -> None:...

    # Skipped SetRayTracingFloatParam due to it being static, abstract and generic.

    SetRayTracingFloatParam : SetRayTracingFloatParam_MethodGroup
    class SetRayTracingFloatParam_MethodGroup:
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, nameID: int, val: float) -> None:...
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, name: str, val: float) -> None:...

    # Skipped SetRayTracingFloatParams due to it being static, abstract and generic.

    SetRayTracingFloatParams : SetRayTracingFloatParams_MethodGroup
    class SetRayTracingFloatParams_MethodGroup:
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, nameID: int, values: Array_1[float]) -> None:...
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, name: str, values: Array_1[float]) -> None:...

    # Skipped SetRayTracingIntParam due to it being static, abstract and generic.

    SetRayTracingIntParam : SetRayTracingIntParam_MethodGroup
    class SetRayTracingIntParam_MethodGroup:
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, nameID: int, val: int) -> None:...
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, name: str, val: int) -> None:...

    # Skipped SetRayTracingIntParams due to it being static, abstract and generic.

    SetRayTracingIntParams : SetRayTracingIntParams_MethodGroup
    class SetRayTracingIntParams_MethodGroup:
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, nameID: int, values: Array_1[int]) -> None:...
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, name: str, values: Array_1[int]) -> None:...

    # Skipped SetRayTracingMatrixArrayParam due to it being static, abstract and generic.

    SetRayTracingMatrixArrayParam : SetRayTracingMatrixArrayParam_MethodGroup
    class SetRayTracingMatrixArrayParam_MethodGroup:
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, nameID: int, values: Array_1[Matrix4x4]) -> None:...
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, name: str, values: Array_1[Matrix4x4]) -> None:...

    # Skipped SetRayTracingMatrixParam due to it being static, abstract and generic.

    SetRayTracingMatrixParam : SetRayTracingMatrixParam_MethodGroup
    class SetRayTracingMatrixParam_MethodGroup:
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, nameID: int, val: Matrix4x4) -> None:...
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, name: str, val: Matrix4x4) -> None:...

    # Skipped SetRayTracingTextureParam due to it being static, abstract and generic.

    SetRayTracingTextureParam : SetRayTracingTextureParam_MethodGroup
    class SetRayTracingTextureParam_MethodGroup:
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, nameID: int, rt: RenderTargetIdentifier) -> None:...
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, name: str, rt: RenderTargetIdentifier) -> None:...

    # Skipped SetRayTracingVectorArrayParam due to it being static, abstract and generic.

    SetRayTracingVectorArrayParam : SetRayTracingVectorArrayParam_MethodGroup
    class SetRayTracingVectorArrayParam_MethodGroup:
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, nameID: int, values: Array_1[Vector4]) -> None:...
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, name: str, values: Array_1[Vector4]) -> None:...

    # Skipped SetRayTracingVectorParam due to it being static, abstract and generic.

    SetRayTracingVectorParam : SetRayTracingVectorParam_MethodGroup
    class SetRayTracingVectorParam_MethodGroup:
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, nameID: int, val: Vector4) -> None:...
        @typing.overload
        def __call__(self, rayTracingShader: RayTracingShader, name: str, val: Vector4) -> None:...

    # Skipped SetRenderTarget due to it being static, abstract and generic.

    SetRenderTarget : SetRenderTarget_MethodGroup
    class SetRenderTarget_MethodGroup:
        @typing.overload
        def __call__(self, binding: RenderTargetBinding) -> None:...
        @typing.overload
        def __call__(self, rt: RenderTargetIdentifier) -> None:...
        @typing.overload
        def __call__(self, colors: Array_1[RenderTargetIdentifier], depth: RenderTargetIdentifier) -> None:...
        @typing.overload
        def __call__(self, rt: RenderTargetIdentifier, mipLevel: int) -> None:...
        @typing.overload
        def __call__(self, color: RenderTargetIdentifier, depth: RenderTargetIdentifier) -> None:...
        @typing.overload
        def __call__(self, rt: RenderTargetIdentifier, mipLevel: int, cubemapFace: CubemapFace) -> None:...
        @typing.overload
        def __call__(self, rt: RenderTargetIdentifier, loadAction: RenderBufferLoadAction, storeAction: RenderBufferStoreAction) -> None:...
        @typing.overload
        def __call__(self, color: RenderTargetIdentifier, depth: RenderTargetIdentifier, mipLevel: int) -> None:...
        @typing.overload
        def __call__(self, binding: RenderTargetBinding, mipLevel: int, cubemapFace: CubemapFace, depthSlice: int) -> None:...
        @typing.overload
        def __call__(self, rt: RenderTargetIdentifier, mipLevel: int, cubemapFace: CubemapFace, depthSlice: int) -> None:...
        @typing.overload
        def __call__(self, color: RenderTargetIdentifier, depth: RenderTargetIdentifier, mipLevel: int, cubemapFace: CubemapFace) -> None:...
        @typing.overload
        def __call__(self, colors: Array_1[RenderTargetIdentifier], depth: RenderTargetIdentifier, mipLevel: int, cubemapFace: CubemapFace, depthSlice: int) -> None:...
        @typing.overload
        def __call__(self, rt: RenderTargetIdentifier, colorLoadAction: RenderBufferLoadAction, colorStoreAction: RenderBufferStoreAction, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction) -> None:...
        @typing.overload
        def __call__(self, color: RenderTargetIdentifier, depth: RenderTargetIdentifier, mipLevel: int, cubemapFace: CubemapFace, depthSlice: int) -> None:...
        @typing.overload
        def __call__(self, color: RenderTargetIdentifier, colorLoadAction: RenderBufferLoadAction, colorStoreAction: RenderBufferStoreAction, depth: RenderTargetIdentifier, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction) -> None:...

    # Skipped WaitOnAsyncGraphicsFence due to it being static, abstract and generic.

    WaitOnAsyncGraphicsFence : WaitOnAsyncGraphicsFence_MethodGroup
    class WaitOnAsyncGraphicsFence_MethodGroup:
        @typing.overload
        def __call__(self, fence: GraphicsFence) -> None:...
        @typing.overload
        def __call__(self, fence: GraphicsFence, stage: SynchronisationStage) -> None:...
        @typing.overload
        def __call__(self, fence: GraphicsFence, stage: SynchronisationStageFlags) -> None:...

    # Skipped WaitOnGPUFence due to it being static, abstract and generic.

    WaitOnGPUFence : WaitOnGPUFence_MethodGroup
    class WaitOnGPUFence_MethodGroup:
        @typing.overload
        def __call__(self, fence: GPUFence) -> None:...
        @typing.overload
        def __call__(self, fence: GPUFence, stage: SynchronisationStage) -> None:...



class CommandBufferExecutionFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : CommandBufferExecutionFlags # 0
    AsyncCompute : CommandBufferExecutionFlags # 2


class CommandBufferExtensions(abc.ABC):
    @staticmethod
    def SwitchIntoFastMemory(cmd: CommandBuffer, rid: RenderTargetIdentifier, fastMemoryFlags: FastMemoryFlags, residency: float, copyContents: bool) -> None: ...
    @staticmethod
    def SwitchOutOfFastMemory(cmd: CommandBuffer, rid: RenderTargetIdentifier, copyContents: bool) -> None: ...


class CompareFunction(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Disabled : CompareFunction # 0
    Never : CompareFunction # 1
    Less : CompareFunction # 2
    Equal : CompareFunction # 3
    LessEqual : CompareFunction # 4
    Greater : CompareFunction # 5
    NotEqual : CompareFunction # 6
    GreaterEqual : CompareFunction # 7
    Always : CompareFunction # 8


class ComputeQueueType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Default : ComputeQueueType # 0
    Background : ComputeQueueType # 1
    Urgent : ComputeQueueType # 2


class CopyTextureSupport(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : CopyTextureSupport # 0
    Basic : CopyTextureSupport # 1
    Copy3D : CopyTextureSupport # 2
    DifferentTypes : CopyTextureSupport # 4
    TextureToRT : CopyTextureSupport # 8
    RTToTexture : CopyTextureSupport # 16


class CullingOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : CullingOptions # 0
    ForceEvenIfCameraIsNotActive : CullingOptions # 1
    OcclusionCull : CullingOptions # 2
    NeedsLighting : CullingOptions # 4
    NeedsReflectionProbes : CullingOptions # 8
    Stereo : CullingOptions # 16
    DisablePerObjectCulling : CullingOptions # 32
    ShadowCasters : CullingOptions # 64


class CullingResults(IEquatable_1[CullingResults]):
    @property
    def lightAndReflectionProbeIndexCount(self) -> int: ...
    @property
    def lightIndexCount(self) -> int: ...
    @property
    def reflectionProbeIndexCount(self) -> int: ...
    @property
    def visibleLights(self) -> NativeArray_1[VisibleLight]: ...
    @property
    def visibleOffscreenVertexLights(self) -> NativeArray_1[VisibleLight]: ...
    @property
    def visibleReflectionProbes(self) -> NativeArray_1[VisibleReflectionProbe]: ...
    def ComputeDirectionalShadowMatricesAndCullingPrimitives(self, activeLightIndex: int, splitIndex: int, splitCount: int, splitRatio: Vector3, shadowResolution: int, shadowNearPlaneOffset: float, viewMatrix: clr.Reference[Matrix4x4], projMatrix: clr.Reference[Matrix4x4], shadowSplitData: clr.Reference[ShadowSplitData]) -> bool: ...
    def ComputePointShadowMatricesAndCullingPrimitives(self, activeLightIndex: int, cubemapFace: CubemapFace, fovBias: float, viewMatrix: clr.Reference[Matrix4x4], projMatrix: clr.Reference[Matrix4x4], shadowSplitData: clr.Reference[ShadowSplitData]) -> bool: ...
    def ComputeSpotShadowMatricesAndCullingPrimitives(self, activeLightIndex: int, viewMatrix: clr.Reference[Matrix4x4], projMatrix: clr.Reference[Matrix4x4], shadowSplitData: clr.Reference[ShadowSplitData]) -> bool: ...
    def GetHashCode(self) -> int: ...
    def GetLightIndexMap(self, allocator: Allocator) -> NativeArray_1[int]: ...
    def GetReflectionProbeIndexMap(self, allocator: Allocator) -> NativeArray_1[int]: ...
    def GetShadowCasterBounds(self, lightIndex: int, outBounds: clr.Reference[Bounds]) -> bool: ...
    def __eq__(self, left: CullingResults, right: CullingResults) -> bool: ...
    def __ne__(self, left: CullingResults, right: CullingResults) -> bool: ...
    def SetLightIndexMap(self, lightIndexMap: NativeArray_1[int]) -> None: ...
    def SetReflectionProbeIndexMap(self, lightIndexMap: NativeArray_1[int]) -> None: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: CullingResults) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped FillLightAndReflectionProbeIndices due to it being static, abstract and generic.

    FillLightAndReflectionProbeIndices : FillLightAndReflectionProbeIndices_MethodGroup
    class FillLightAndReflectionProbeIndices_MethodGroup:
        @typing.overload
        def __call__(self, buffer: GraphicsBuffer) -> None:...
        @typing.overload
        def __call__(self, computeBuffer: ComputeBuffer) -> None:...



class CullingSplit:
    cascadeBlendCullingFactor : float
    cullingMatrix : Matrix4x4
    cullingPlaneCount : int
    cullingPlaneOffset : int
    nearPlane : float
    sphereCenter : Vector3
    sphereRadius : float


class CullMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Off : CullMode # 0
    Front : CullMode # 1
    Back : CullMode # 2


class CustomMarkerCallbackFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    CustomMarkerCallbackDefault : CustomMarkerCallbackFlags # 0
    CustomMarkerCallbackForceInvalidateStateTracking : CustomMarkerCallbackFlags # 4


class DefaultReflectionMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Skybox : DefaultReflectionMode # 0
    Custom : DefaultReflectionMode # 1


class DepthState(IEquatable_1[DepthState]):
    def __init__(self, writeEnabled: bool = ..., compareFunction: CompareFunction = ...) -> None: ...
    @property
    def compareFunction(self) -> CompareFunction: ...
    @compareFunction.setter
    def compareFunction(self, value: CompareFunction) -> CompareFunction: ...
    @classmethod
    @property
    def defaultValue(cls) -> DepthState: ...
    @property
    def writeEnabled(self) -> bool: ...
    @writeEnabled.setter
    def writeEnabled(self, value: bool) -> bool: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: DepthState, right: DepthState) -> bool: ...
    def __ne__(self, left: DepthState, right: DepthState) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: DepthState) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class DistanceMetric(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Perspective : DistanceMetric # 0
    Orthographic : DistanceMetric # 1
    CustomAxis : DistanceMetric # 2


class DrawingSettings(IEquatable_1[DrawingSettings]):
    def __init__(self, shaderPassName: ShaderTagId, sortingSettings: SortingSettings) -> None: ...
    maxShaderPasses : int
    @property
    def enableDynamicBatching(self) -> bool: ...
    @enableDynamicBatching.setter
    def enableDynamicBatching(self, value: bool) -> bool: ...
    @property
    def enableInstancing(self) -> bool: ...
    @enableInstancing.setter
    def enableInstancing(self, value: bool) -> bool: ...
    @property
    def fallbackMaterial(self) -> Material: ...
    @fallbackMaterial.setter
    def fallbackMaterial(self, value: Material) -> Material: ...
    @property
    def mainLightIndex(self) -> int: ...
    @mainLightIndex.setter
    def mainLightIndex(self, value: int) -> int: ...
    @property
    def overrideMaterial(self) -> Material: ...
    @overrideMaterial.setter
    def overrideMaterial(self, value: Material) -> Material: ...
    @property
    def overrideMaterialPassIndex(self) -> int: ...
    @overrideMaterialPassIndex.setter
    def overrideMaterialPassIndex(self, value: int) -> int: ...
    @property
    def overrideShader(self) -> Shader: ...
    @overrideShader.setter
    def overrideShader(self, value: Shader) -> Shader: ...
    @property
    def overrideShaderPassIndex(self) -> int: ...
    @overrideShaderPassIndex.setter
    def overrideShaderPassIndex(self, value: int) -> int: ...
    @property
    def perObjectData(self) -> PerObjectData: ...
    @perObjectData.setter
    def perObjectData(self, value: PerObjectData) -> PerObjectData: ...
    @property
    def sortingSettings(self) -> SortingSettings: ...
    @sortingSettings.setter
    def sortingSettings(self, value: SortingSettings) -> SortingSettings: ...
    def GetHashCode(self) -> int: ...
    def GetShaderPassName(self, index: int) -> ShaderTagId: ...
    def __eq__(self, left: DrawingSettings, right: DrawingSettings) -> bool: ...
    def __ne__(self, left: DrawingSettings, right: DrawingSettings) -> bool: ...
    def SetShaderPassName(self, index: int, shaderPassName: ShaderTagId) -> None: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: DrawingSettings) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...


    class <shaderPassNames>e__FixedBuffer:
        FixedElementField : int



class FastMemoryFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : FastMemoryFlags # 0
    SpillTop : FastMemoryFlags # 1
    SpillBottom : FastMemoryFlags # 2


class FilteringSettings(IEquatable_1[FilteringSettings]):
    def __init__(self, renderQueueRange: typing.Optional[RenderQueueRange] = ..., layerMask: int = ..., renderingLayerMask: int = ..., excludeMotionVectorObjects: int = ...) -> None: ...
    @classmethod
    @property
    def defaultValue(cls) -> FilteringSettings: ...
    @property
    def excludeMotionVectorObjects(self) -> bool: ...
    @excludeMotionVectorObjects.setter
    def excludeMotionVectorObjects(self, value: bool) -> bool: ...
    @property
    def layerMask(self) -> int: ...
    @layerMask.setter
    def layerMask(self, value: int) -> int: ...
    @property
    def renderingLayerMask(self) -> int: ...
    @renderingLayerMask.setter
    def renderingLayerMask(self, value: int) -> int: ...
    @property
    def renderQueueRange(self) -> RenderQueueRange: ...
    @renderQueueRange.setter
    def renderQueueRange(self, value: RenderQueueRange) -> RenderQueueRange: ...
    @property
    def sortingLayerRange(self) -> SortingLayerRange: ...
    @sortingLayerRange.setter
    def sortingLayerRange(self, value: SortingLayerRange) -> SortingLayerRange: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: FilteringSettings, right: FilteringSettings) -> bool: ...
    def __ne__(self, left: FilteringSettings, right: FilteringSettings) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: FilteringSettings) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class FormatSwizzle(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    FormatSwizzleR : FormatSwizzle # 0
    FormatSwizzleG : FormatSwizzle # 1
    FormatSwizzleB : FormatSwizzle # 2
    FormatSwizzleA : FormatSwizzle # 3
    FormatSwizzle0 : FormatSwizzle # 4
    FormatSwizzle1 : FormatSwizzle # 5


class FoveatedRenderingCaps(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : FoveatedRenderingCaps # 0
    FoveationImage : FoveatedRenderingCaps # 1
    NonUniformRaster : FoveatedRenderingCaps # 2


class FoveatedRenderingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Disabled : FoveatedRenderingMode # 0
    Enabled : FoveatedRenderingMode # 1


class GizmoSubset(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    PreImageEffects : GizmoSubset # 0
    PostImageEffects : GizmoSubset # 1


class GlobalKeyword:
    def __init__(self, name: str) -> None: ...
    @property
    def name(self) -> str: ...
    @staticmethod
    def Create(name: str) -> GlobalKeyword: ...
    def ToString(self) -> str: ...


class GPUFence:
    @property
    def passed(self) -> bool: ...


class GraphicsDeviceType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    OpenGL2 : GraphicsDeviceType # 0
    Direct3D9 : GraphicsDeviceType # 1
    Direct3D11 : GraphicsDeviceType # 2
    PlayStation3 : GraphicsDeviceType # 3
    Null : GraphicsDeviceType # 4
    Xbox360 : GraphicsDeviceType # 6
    OpenGLES2 : GraphicsDeviceType # 8
    OpenGLES3 : GraphicsDeviceType # 11
    PlayStationVita : GraphicsDeviceType # 12
    PlayStation4 : GraphicsDeviceType # 13
    XboxOne : GraphicsDeviceType # 14
    PlayStationMobile : GraphicsDeviceType # 15
    Metal : GraphicsDeviceType # 16
    OpenGLCore : GraphicsDeviceType # 17
    Direct3D12 : GraphicsDeviceType # 18
    N3DS : GraphicsDeviceType # 19
    Vulkan : GraphicsDeviceType # 21
    Switch : GraphicsDeviceType # 22
    XboxOneD3D12 : GraphicsDeviceType # 23
    GameCoreXboxOne : GraphicsDeviceType # 24
    GameCoreXboxSeries : GraphicsDeviceType # 25
    PlayStation5 : GraphicsDeviceType # 26
    PlayStation5NGGC : GraphicsDeviceType # 27
    GameCoreScarlett : GraphicsDeviceType # -1


class GraphicsFence:
    @property
    def passed(self) -> bool: ...


class GraphicsFenceType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    AsyncQueueSynchronisation : GraphicsFenceType # 0
    CPUSynchronisation : GraphicsFenceType # 1


class GraphicsSettings(Object):
    @classmethod
    @property
    def allConfiguredRenderPipelines(cls) -> Array_1[RenderPipelineAsset]: ...
    @classmethod
    @property
    def cameraRelativeLightCulling(cls) -> bool: ...
    @classmethod
    @cameraRelativeLightCulling.setter
    def cameraRelativeLightCulling(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def cameraRelativeShadowCulling(cls) -> bool: ...
    @classmethod
    @cameraRelativeShadowCulling.setter
    def cameraRelativeShadowCulling(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def currentRenderPipeline(cls) -> RenderPipelineAsset: ...
    @classmethod
    @property
    def defaultRenderingLayerMask(cls) -> int: ...
    @classmethod
    @defaultRenderingLayerMask.setter
    def defaultRenderingLayerMask(cls, value: int) -> int: ...
    @classmethod
    @property
    def defaultRenderPipeline(cls) -> RenderPipelineAsset: ...
    @classmethod
    @defaultRenderPipeline.setter
    def defaultRenderPipeline(cls, value: RenderPipelineAsset) -> RenderPipelineAsset: ...
    @classmethod
    @property
    def disableBuiltinCustomRenderTextureUpdate(cls) -> bool: ...
    @classmethod
    @disableBuiltinCustomRenderTextureUpdate.setter
    def disableBuiltinCustomRenderTextureUpdate(cls, value: bool) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @classmethod
    @property
    def lightProbeOutsideHullStrategy(cls) -> LightProbeOutsideHullStrategy: ...
    @classmethod
    @lightProbeOutsideHullStrategy.setter
    def lightProbeOutsideHullStrategy(cls, value: LightProbeOutsideHullStrategy) -> LightProbeOutsideHullStrategy: ...
    @classmethod
    @property
    def lightsUseColorTemperature(cls) -> bool: ...
    @classmethod
    @lightsUseColorTemperature.setter
    def lightsUseColorTemperature(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def lightsUseLinearIntensity(cls) -> bool: ...
    @classmethod
    @lightsUseLinearIntensity.setter
    def lightsUseLinearIntensity(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def logWhenShaderIsCompiled(cls) -> bool: ...
    @classmethod
    @logWhenShaderIsCompiled.setter
    def logWhenShaderIsCompiled(cls, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @classmethod
    @property
    def realtimeDirectRectangularAreaLights(cls) -> bool: ...
    @classmethod
    @realtimeDirectRectangularAreaLights.setter
    def realtimeDirectRectangularAreaLights(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def renderPipelineAsset(cls) -> RenderPipelineAsset: ...
    @classmethod
    @renderPipelineAsset.setter
    def renderPipelineAsset(cls, value: RenderPipelineAsset) -> RenderPipelineAsset: ...
    @classmethod
    @property
    def transparencySortAxis(cls) -> Vector3: ...
    @classmethod
    @transparencySortAxis.setter
    def transparencySortAxis(cls, value: Vector3) -> Vector3: ...
    @classmethod
    @property
    def transparencySortMode(cls) -> TransparencySortMode: ...
    @classmethod
    @transparencySortMode.setter
    def transparencySortMode(cls, value: TransparencySortMode) -> TransparencySortMode: ...
    @classmethod
    @property
    def useScriptableRenderPipelineBatching(cls) -> bool: ...
    @classmethod
    @useScriptableRenderPipelineBatching.setter
    def useScriptableRenderPipelineBatching(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def videoShadersIncludeMode(cls) -> VideoShadersIncludeMode: ...
    @classmethod
    @videoShadersIncludeMode.setter
    def videoShadersIncludeMode(cls, value: VideoShadersIncludeMode) -> VideoShadersIncludeMode: ...
    @staticmethod
    def GetCustomShader(type: BuiltinShaderType) -> Shader: ...
    @staticmethod
    def GetGraphicsSettings() -> Object: ...
    @staticmethod
    def GetShaderMode(type: BuiltinShaderType) -> BuiltinShaderMode: ...
    @staticmethod
    def SetCustomShader(type: BuiltinShaderType, shader: Shader) -> None: ...
    @staticmethod
    def SetShaderMode(type: BuiltinShaderType, mode: BuiltinShaderMode) -> None: ...
    # Skipped GetSettingsForRenderPipeline due to it being static, abstract and generic.

    GetSettingsForRenderPipeline : GetSettingsForRenderPipeline_MethodGroup
    class GetSettingsForRenderPipeline_MethodGroup:
        def __getitem__(self, t:typing.Type[GetSettingsForRenderPipeline_1_T1]) -> GetSettingsForRenderPipeline_1[GetSettingsForRenderPipeline_1_T1]: ...

        GetSettingsForRenderPipeline_1_T1 = typing.TypeVar('GetSettingsForRenderPipeline_1_T1')
        class GetSettingsForRenderPipeline_1(typing.Generic[GetSettingsForRenderPipeline_1_T1]):
            GetSettingsForRenderPipeline_1_T = GraphicsSettings.GetSettingsForRenderPipeline_MethodGroup.GetSettingsForRenderPipeline_1_T1
            def __call__(self) -> RenderPipelineGlobalSettings:...


    # Skipped HasShaderDefine due to it being static, abstract and generic.

    HasShaderDefine : HasShaderDefine_MethodGroup
    class HasShaderDefine_MethodGroup:
        @typing.overload
        def __call__(self, defineHash: BuiltinShaderDefine) -> bool:...
        @typing.overload
        def __call__(self, tier: GraphicsTier, defineHash: BuiltinShaderDefine) -> bool:...

    # Skipped RegisterRenderPipelineSettings due to it being static, abstract and generic.

    RegisterRenderPipelineSettings : RegisterRenderPipelineSettings_MethodGroup
    class RegisterRenderPipelineSettings_MethodGroup:
        def __getitem__(self, t:typing.Type[RegisterRenderPipelineSettings_1_T1]) -> RegisterRenderPipelineSettings_1[RegisterRenderPipelineSettings_1_T1]: ...

        RegisterRenderPipelineSettings_1_T1 = typing.TypeVar('RegisterRenderPipelineSettings_1_T1')
        class RegisterRenderPipelineSettings_1(typing.Generic[RegisterRenderPipelineSettings_1_T1]):
            RegisterRenderPipelineSettings_1_T = GraphicsSettings.RegisterRenderPipelineSettings_MethodGroup.RegisterRenderPipelineSettings_1_T1
            def __call__(self, settings: RenderPipelineGlobalSettings) -> None:...


    # Skipped UnregisterRenderPipelineSettings due to it being static, abstract and generic.

    UnregisterRenderPipelineSettings : UnregisterRenderPipelineSettings_MethodGroup
    class UnregisterRenderPipelineSettings_MethodGroup:
        def __getitem__(self, t:typing.Type[UnregisterRenderPipelineSettings_1_T1]) -> UnregisterRenderPipelineSettings_1[UnregisterRenderPipelineSettings_1_T1]: ...

        UnregisterRenderPipelineSettings_1_T1 = typing.TypeVar('UnregisterRenderPipelineSettings_1_T1')
        class UnregisterRenderPipelineSettings_1(typing.Generic[UnregisterRenderPipelineSettings_1_T1]):
            UnregisterRenderPipelineSettings_1_T = GraphicsSettings.UnregisterRenderPipelineSettings_MethodGroup.UnregisterRenderPipelineSettings_1_T1
            def __call__(self) -> None:...




class GraphicsTier(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Tier1 : GraphicsTier # 0
    Tier2 : GraphicsTier # 1
    Tier3 : GraphicsTier # 2


class IndexFormat(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    UInt16 : IndexFormat # 0
    UInt32 : IndexFormat # 1


class LightEvent(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    BeforeShadowMap : LightEvent # 0
    AfterShadowMap : LightEvent # 1
    BeforeScreenspaceMask : LightEvent # 2
    AfterScreenspaceMask : LightEvent # 3
    BeforeShadowMapPass : LightEvent # 4
    AfterShadowMapPass : LightEvent # 5


class LightProbeOutsideHullStrategy(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    kLightProbeSearchTetrahedralHull : LightProbeOutsideHullStrategy # 0
    kLightProbeUseAmbientProbe : LightProbeOutsideHullStrategy # 1


class LightProbeUsage(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Off : LightProbeUsage # 0
    BlendProbes : LightProbeUsage # 1
    UseProxyVolume : LightProbeUsage # 2
    CustomProvided : LightProbeUsage # 4


class LightShadowResolution(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Low : LightShadowResolution # 0
    Medium : LightShadowResolution # 1
    High : LightShadowResolution # 2
    VeryHigh : LightShadowResolution # 3
    FromQualitySettings : LightShadowResolution # -1


class LoadStoreActionDebugModeSettings(abc.ABC):
    @classmethod
    @property
    def LoadStoreDebugModeEnabled(cls) -> bool: ...
    @classmethod
    @LoadStoreDebugModeEnabled.setter
    def LoadStoreDebugModeEnabled(cls, value: bool) -> bool: ...


class LocalKeyword(IEquatable_1[LocalKeyword]):
    @typing.overload
    def __init__(self, shader: Shader, name: str) -> None: ...
    @typing.overload
    def __init__(self, shader: ComputeShader, name: str) -> None: ...
    @property
    def isDynamic(self) -> bool: ...
    @property
    def isOverridable(self) -> bool: ...
    @property
    def isValid(self) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def type(self) -> ShaderKeywordType: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, lhs: LocalKeyword, rhs: LocalKeyword) -> bool: ...
    def __ne__(self, lhs: LocalKeyword, rhs: LocalKeyword) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, rhs: LocalKeyword) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...



class LocalKeywordSpace(IEquatable_1[LocalKeywordSpace]):
    @property
    def keywordCount(self) -> int: ...
    @property
    def keywordNames(self) -> Array_1[str]: ...
    @property
    def keywords(self) -> Array_1[LocalKeyword]: ...
    def FindKeyword(self, name: str) -> LocalKeyword: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, lhs: LocalKeywordSpace, rhs: LocalKeywordSpace) -> bool: ...
    def __ne__(self, lhs: LocalKeywordSpace, rhs: LocalKeywordSpace) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, rhs: LocalKeywordSpace) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...



class LODParameters(IEquatable_1[LODParameters]):
    @property
    def cameraPixelHeight(self) -> int: ...
    @cameraPixelHeight.setter
    def cameraPixelHeight(self, value: int) -> int: ...
    @property
    def cameraPosition(self) -> Vector3: ...
    @cameraPosition.setter
    def cameraPosition(self, value: Vector3) -> Vector3: ...
    @property
    def fieldOfView(self) -> float: ...
    @fieldOfView.setter
    def fieldOfView(self, value: float) -> float: ...
    @property
    def isOrthographic(self) -> bool: ...
    @isOrthographic.setter
    def isOrthographic(self, value: bool) -> bool: ...
    @property
    def orthoSize(self) -> float: ...
    @orthoSize.setter
    def orthoSize(self, value: float) -> float: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: LODParameters, right: LODParameters) -> bool: ...
    def __ne__(self, left: LODParameters, right: LODParameters) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: LODParameters) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class MeshUpdateFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Default : MeshUpdateFlags # 0
    DontValidateIndices : MeshUpdateFlags # 1
    DontResetBoneBounds : MeshUpdateFlags # 2
    DontNotifyMeshUsers : MeshUpdateFlags # 4
    DontRecalculateBounds : MeshUpdateFlags # 8


class MetadataValue:
    NameID : int
    Value : int


class ObjectIdRequest:
    def __init__(self, destination: RenderTexture, mipLevel: int = ..., face: CubemapFace = ..., slice: int = ...) -> None: ...
    @property
    def destination(self) -> RenderTexture: ...
    @destination.setter
    def destination(self, value: RenderTexture) -> RenderTexture: ...
    @property
    def face(self) -> CubemapFace: ...
    @face.setter
    def face(self, value: CubemapFace) -> CubemapFace: ...
    @property
    def mipLevel(self) -> int: ...
    @mipLevel.setter
    def mipLevel(self, value: int) -> int: ...
    @property
    def result(self) -> ObjectIdResult: ...
    @result.setter
    def result(self, value: ObjectIdResult) -> ObjectIdResult: ...
    @property
    def slice(self) -> int: ...
    @slice.setter
    def slice(self, value: int) -> int: ...


class ObjectIdResult:
    @property
    def idToObjectMapping(self) -> Array_1[Object]: ...
    @staticmethod
    def DecodeIdFromColor(color: Color) -> int: ...


class OnDemandRendering:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def effectiveRenderFrameRate(cls) -> int: ...
    @classmethod
    @property
    def renderFrameInterval(cls) -> int: ...
    @classmethod
    @renderFrameInterval.setter
    def renderFrameInterval(cls, value: int) -> int: ...
    @classmethod
    @property
    def willCurrentFrameRender(cls) -> bool: ...


class OpaqueSortMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Default : OpaqueSortMode # 0
    FrontToBack : OpaqueSortMode # 1
    NoDistanceSort : OpaqueSortMode # 2


class OpenGLESVersion(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : OpenGLESVersion # 0
    OpenGLES20 : OpenGLESVersion # 1
    OpenGLES30 : OpenGLESVersion # 2
    OpenGLES31 : OpenGLESVersion # 3
    OpenGLES31AEP : OpenGLESVersion # 4
    OpenGLES32 : OpenGLESVersion # 5


class PassIdentifier(IEquatable_1[PassIdentifier]):
    def __init__(self, subshaderIndex: int, passIndex: int) -> None: ...
    @property
    def PassIndex(self) -> int: ...
    @property
    def SubshaderIndex(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, lhs: PassIdentifier, rhs: PassIdentifier) -> bool: ...
    def __ne__(self, lhs: PassIdentifier, rhs: PassIdentifier) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, rhs: PassIdentifier) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...



class PassType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Normal : PassType # 0
    Vertex : PassType # 1
    VertexLM : PassType # 2
    VertexLMRGBM : PassType # 3
    ForwardBase : PassType # 4
    ForwardAdd : PassType # 5
    LightPrePassBase : PassType # 6
    LightPrePassFinal : PassType # 7
    ShadowCaster : PassType # 8
    Deferred : PassType # 10
    Meta : PassType # 11
    MotionVectors : PassType # 12
    ScriptableRenderPipeline : PassType # 13
    ScriptableRenderPipelineDefaultUnlit : PassType # 14
    GrabPass : PassType # 15


class PerObjectData(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : PerObjectData # 0
    LightProbe : PerObjectData # 1
    ReflectionProbes : PerObjectData # 2
    LightProbeProxyVolume : PerObjectData # 4
    Lightmaps : PerObjectData # 8
    LightData : PerObjectData # 16
    MotionVectors : PerObjectData # 32
    LightIndices : PerObjectData # 64
    ReflectionProbeData : PerObjectData # 128
    OcclusionProbe : PerObjectData # 256
    OcclusionProbeProxyVolume : PerObjectData # 512
    ShadowMask : PerObjectData # 1024


class PIX:
    def __init__(self) -> None: ...
    @staticmethod
    def BeginGPUCapture() -> None: ...
    @staticmethod
    def EndGPUCapture() -> None: ...
    @staticmethod
    def IsAttached() -> bool: ...


class PlatformKeywordSet:
    def Disable(self, define: BuiltinShaderDefine) -> None: ...
    def Enable(self, define: BuiltinShaderDefine) -> None: ...
    def IsEnabled(self, define: BuiltinShaderDefine) -> bool: ...


class RasterState(IEquatable_1[RasterState]):
    def __init__(self, cullingMode: CullMode = ..., offsetUnits: int = ..., offsetFactor: float = ..., depthClip: bool = ...) -> None: ...
    defaultValue : RasterState
    @property
    def conservative(self) -> bool: ...
    @conservative.setter
    def conservative(self, value: bool) -> bool: ...
    @property
    def cullingMode(self) -> CullMode: ...
    @cullingMode.setter
    def cullingMode(self, value: CullMode) -> CullMode: ...
    @property
    def depthClip(self) -> bool: ...
    @depthClip.setter
    def depthClip(self, value: bool) -> bool: ...
    @property
    def offsetFactor(self) -> float: ...
    @offsetFactor.setter
    def offsetFactor(self, value: float) -> float: ...
    @property
    def offsetUnits(self) -> int: ...
    @offsetUnits.setter
    def offsetUnits(self, value: int) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: RasterState, right: RasterState) -> bool: ...
    def __ne__(self, left: RasterState, right: RasterState) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: RasterState) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class RealtimeGICPUUsage(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Low : RealtimeGICPUUsage # 25
    Medium : RealtimeGICPUUsage # 50
    High : RealtimeGICPUUsage # 75
    Unlimited : RealtimeGICPUUsage # 100


class ReflectionCubemapCompression(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Uncompressed : ReflectionCubemapCompression # 0
    Compressed : ReflectionCubemapCompression # 1
    Auto : ReflectionCubemapCompression # 2


class ReflectionProbeBlendInfo:
    probe : ReflectionProbe
    weight : float


class ReflectionProbeClearFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Skybox : ReflectionProbeClearFlags # 1
    SolidColor : ReflectionProbeClearFlags # 2


class ReflectionProbeMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Baked : ReflectionProbeMode # 0
    Realtime : ReflectionProbeMode # 1
    Custom : ReflectionProbeMode # 2


class ReflectionProbeRefreshMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    OnAwake : ReflectionProbeRefreshMode # 0
    EveryFrame : ReflectionProbeRefreshMode # 1
    ViaScripting : ReflectionProbeRefreshMode # 2


class ReflectionProbeSortingCriteria(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : ReflectionProbeSortingCriteria # 0
    Importance : ReflectionProbeSortingCriteria # 1
    Size : ReflectionProbeSortingCriteria # 2
    ImportanceThenSize : ReflectionProbeSortingCriteria # 3


class ReflectionProbeTimeSlicingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    AllFacesAtOnce : ReflectionProbeTimeSlicingMode # 0
    IndividualFaces : ReflectionProbeTimeSlicingMode # 1
    NoTimeSlicing : ReflectionProbeTimeSlicingMode # 2


class ReflectionProbeType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Cube : ReflectionProbeType # 0
    Card : ReflectionProbeType # 1


class ReflectionProbeUsage(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Off : ReflectionProbeUsage # 0
    BlendProbes : ReflectionProbeUsage # 1
    BlendProbesAndSkybox : ReflectionProbeUsage # 2
    Simple : ReflectionProbeUsage # 3


class RenderBufferLoadAction(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Load : RenderBufferLoadAction # 0
    Clear : RenderBufferLoadAction # 1
    DontCare : RenderBufferLoadAction # 2


class RenderBufferStoreAction(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Store : RenderBufferStoreAction # 0
    Resolve : RenderBufferStoreAction # 1
    StoreAndResolve : RenderBufferStoreAction # 2
    DontCare : RenderBufferStoreAction # 3


class RendererList:
    nullRendererList : RendererList
    @property
    def isValid(self) -> bool: ...


class RendererListParams(IEquatable_1[RendererListParams]):
    def __init__(self, cullingResults: CullingResults, drawSettings: DrawingSettings, filteringSettings: FilteringSettings) -> None: ...
    cullingResults : CullingResults
    drawSettings : DrawingSettings
    filteringSettings : FilteringSettings
    Invalid : RendererListParams
    isPassTagName : bool
    stateBlocks : typing.Optional[NativeArray_1[RenderStateBlock]]
    tagName : ShaderTagId
    tagValues : typing.Optional[NativeArray_1[ShaderTagId]]
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: RendererListParams, right: RendererListParams) -> bool: ...
    def __ne__(self, left: RendererListParams, right: RendererListParams) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: RendererListParams) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class RendererListStatus(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    kRendererListEmpty : RendererListStatus # 0
    kRendererListPopulated : RendererListStatus # 1
    kRendererListInvalid : RendererListStatus # -2
    kRendererListProcessing : RendererListStatus # -1


class RenderingThreadingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Direct : RenderingThreadingMode # 0
    SingleThreaded : RenderingThreadingMode # 1
    MultiThreaded : RenderingThreadingMode # 2
    LegacyJobified : RenderingThreadingMode # 3
    NativeGraphicsJobs : RenderingThreadingMode # 4
    NativeGraphicsJobsWithoutRenderThread : RenderingThreadingMode # 5


class RenderPipeline(abc.ABC):
    @property
    def defaultSettings(self) -> RenderPipelineGlobalSettings: ...
    @property
    def disposed(self) -> bool: ...
    @disposed.setter
    def disposed(self, value: bool) -> bool: ...
    # Skipped SubmitRenderRequest due to it being static, abstract and generic.

    SubmitRenderRequest : SubmitRenderRequest_MethodGroup
    class SubmitRenderRequest_MethodGroup:
        def __getitem__(self, t:typing.Type[SubmitRenderRequest_1_T1]) -> SubmitRenderRequest_1[SubmitRenderRequest_1_T1]: ...

        SubmitRenderRequest_1_T1 = typing.TypeVar('SubmitRenderRequest_1_T1')
        class SubmitRenderRequest_1(typing.Generic[SubmitRenderRequest_1_T1]):
            SubmitRenderRequest_1_RequestData = RenderPipeline.SubmitRenderRequest_MethodGroup.SubmitRenderRequest_1_T1
            def __call__(self, camera: Camera, data: SubmitRenderRequest_1_RequestData) -> None:...


    # Skipped SupportsRenderRequest due to it being static, abstract and generic.

    SupportsRenderRequest : SupportsRenderRequest_MethodGroup
    class SupportsRenderRequest_MethodGroup:
        def __getitem__(self, t:typing.Type[SupportsRenderRequest_1_T1]) -> SupportsRenderRequest_1[SupportsRenderRequest_1_T1]: ...

        SupportsRenderRequest_1_T1 = typing.TypeVar('SupportsRenderRequest_1_T1')
        class SupportsRenderRequest_1(typing.Generic[SupportsRenderRequest_1_T1]):
            SupportsRenderRequest_1_RequestData = RenderPipeline.SupportsRenderRequest_MethodGroup.SupportsRenderRequest_1_T1
            def __call__(self, camera: Camera, data: SupportsRenderRequest_1_RequestData) -> bool:...



    class StandardRequest:
        def __init__(self) -> None: ...
        destination : RenderTexture
        face : CubemapFace
        mipLevel : int
        slice : int



class RenderPipelineAsset(ScriptableObject, abc.ABC):
    @property
    def autodeskInteractiveMaskedShader(self) -> Shader: ...
    @property
    def autodeskInteractiveShader(self) -> Shader: ...
    @property
    def autodeskInteractiveTransparentShader(self) -> Shader: ...
    @property
    def default2DMaskMaterial(self) -> Material: ...
    @property
    def default2DMaterial(self) -> Material: ...
    @property
    def defaultLineMaterial(self) -> Material: ...
    @property
    def defaultMaterial(self) -> Material: ...
    @property
    def defaultParticleMaterial(self) -> Material: ...
    @property
    def defaultShader(self) -> Shader: ...
    @property
    def defaultSpeedTree7Shader(self) -> Shader: ...
    @property
    def defaultSpeedTree8Shader(self) -> Shader: ...
    @property
    def defaultTerrainMaterial(self) -> Material: ...
    @property
    def defaultUIETC1SupportedMaterial(self) -> Material: ...
    @property
    def defaultUIMaterial(self) -> Material: ...
    @property
    def defaultUIOverdrawMaterial(self) -> Material: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def prefixedRenderingLayerMaskNames(self) -> Array_1[str]: ...
    @property
    def renderingLayerMaskNames(self) -> Array_1[str]: ...
    @property
    def renderPipelineShaderTag(self) -> str: ...
    @property
    def terrainBrushPassIndex(self) -> int: ...
    @property
    def terrainDetailGrassBillboardShader(self) -> Shader: ...
    @property
    def terrainDetailGrassShader(self) -> Shader: ...
    @property
    def terrainDetailLitShader(self) -> Shader: ...


class RenderPipelineGlobalSettings(ScriptableObject, abc.ABC):
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...


class RenderPipelineManager(abc.ABC):
    @classmethod
    @property
    def currentPipeline(cls) -> RenderPipeline: ...
    @classmethod
    @currentPipeline.setter
    def currentPipeline(cls, value: RenderPipeline) -> RenderPipeline: ...
    @classmethod
    @property
    def pipelineSwitchCompleted(cls) -> bool: ...


class RenderQueue(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Background : RenderQueue # 1000
    Geometry : RenderQueue # 2000
    AlphaTest : RenderQueue # 2450
    GeometryLast : RenderQueue # 2500
    Transparent : RenderQueue # 3000
    Overlay : RenderQueue # 4000


class RenderQueueRange(IEquatable_1[RenderQueueRange]):
    def __init__(self, lowerBound: int, upperBound: int) -> None: ...
    maximumBound : int
    minimumBound : int
    @classmethod
    @property
    def all(cls) -> RenderQueueRange: ...
    @property
    def lowerBound(self) -> int: ...
    @lowerBound.setter
    def lowerBound(self, value: int) -> int: ...
    @classmethod
    @property
    def opaque(cls) -> RenderQueueRange: ...
    @classmethod
    @property
    def transparent(cls) -> RenderQueueRange: ...
    @property
    def upperBound(self) -> int: ...
    @upperBound.setter
    def upperBound(self, value: int) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: RenderQueueRange, right: RenderQueueRange) -> bool: ...
    def __ne__(self, left: RenderQueueRange, right: RenderQueueRange) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: RenderQueueRange) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class RenderStateBlock(IEquatable_1[RenderStateBlock]):
    def __init__(self, mask: RenderStateMask) -> None: ...
    @property
    def blendState(self) -> BlendState: ...
    @blendState.setter
    def blendState(self, value: BlendState) -> BlendState: ...
    @property
    def depthState(self) -> DepthState: ...
    @depthState.setter
    def depthState(self, value: DepthState) -> DepthState: ...
    @property
    def mask(self) -> RenderStateMask: ...
    @mask.setter
    def mask(self, value: RenderStateMask) -> RenderStateMask: ...
    @property
    def rasterState(self) -> RasterState: ...
    @rasterState.setter
    def rasterState(self, value: RasterState) -> RasterState: ...
    @property
    def stencilReference(self) -> int: ...
    @stencilReference.setter
    def stencilReference(self, value: int) -> int: ...
    @property
    def stencilState(self) -> StencilState: ...
    @stencilState.setter
    def stencilState(self, value: StencilState) -> StencilState: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: RenderStateBlock, right: RenderStateBlock) -> bool: ...
    def __ne__(self, left: RenderStateBlock, right: RenderStateBlock) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: RenderStateBlock) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class RenderStateMask(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Nothing : RenderStateMask # 0
    Blend : RenderStateMask # 1
    Raster : RenderStateMask # 2
    Depth : RenderStateMask # 4
    Stencil : RenderStateMask # 8
    Everything : RenderStateMask # 15


class RenderTargetBinding:
    @typing.overload
    def __init__(self, colorRenderTarget: RenderTargetIdentifier, colorLoadAction: RenderBufferLoadAction, colorStoreAction: RenderBufferStoreAction, depthRenderTarget: RenderTargetIdentifier, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction) -> None: ...
    @typing.overload
    def __init__(self, colorRenderTargets: Array_1[RenderTargetIdentifier], colorLoadActions: Array_1[RenderBufferLoadAction], colorStoreActions: Array_1[RenderBufferStoreAction], depthRenderTarget: RenderTargetIdentifier, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction) -> None: ...
    @typing.overload
    def __init__(self, setup: RenderTargetSetup) -> None: ...
    @property
    def colorLoadActions(self) -> Array_1[RenderBufferLoadAction]: ...
    @colorLoadActions.setter
    def colorLoadActions(self, value: Array_1[RenderBufferLoadAction]) -> Array_1[RenderBufferLoadAction]: ...
    @property
    def colorRenderTargets(self) -> Array_1[RenderTargetIdentifier]: ...
    @colorRenderTargets.setter
    def colorRenderTargets(self, value: Array_1[RenderTargetIdentifier]) -> Array_1[RenderTargetIdentifier]: ...
    @property
    def colorStoreActions(self) -> Array_1[RenderBufferStoreAction]: ...
    @colorStoreActions.setter
    def colorStoreActions(self, value: Array_1[RenderBufferStoreAction]) -> Array_1[RenderBufferStoreAction]: ...
    @property
    def depthLoadAction(self) -> RenderBufferLoadAction: ...
    @depthLoadAction.setter
    def depthLoadAction(self, value: RenderBufferLoadAction) -> RenderBufferLoadAction: ...
    @property
    def depthRenderTarget(self) -> RenderTargetIdentifier: ...
    @depthRenderTarget.setter
    def depthRenderTarget(self, value: RenderTargetIdentifier) -> RenderTargetIdentifier: ...
    @property
    def depthStoreAction(self) -> RenderBufferStoreAction: ...
    @depthStoreAction.setter
    def depthStoreAction(self, value: RenderBufferStoreAction) -> RenderBufferStoreAction: ...
    @property
    def flags(self) -> RenderTargetFlags: ...
    @flags.setter
    def flags(self, value: RenderTargetFlags) -> RenderTargetFlags: ...


class RenderTargetBlendState(IEquatable_1[RenderTargetBlendState]):
    def __init__(self, writeMask: ColorWriteMask = ..., sourceColorBlendMode: BlendMode = ..., destinationColorBlendMode: BlendMode = ..., sourceAlphaBlendMode: BlendMode = ..., destinationAlphaBlendMode: BlendMode = ..., colorBlendOperation: BlendOp = ..., alphaBlendOperation: BlendOp = ...) -> None: ...
    @property
    def alphaBlendOperation(self) -> BlendOp: ...
    @alphaBlendOperation.setter
    def alphaBlendOperation(self, value: BlendOp) -> BlendOp: ...
    @property
    def colorBlendOperation(self) -> BlendOp: ...
    @colorBlendOperation.setter
    def colorBlendOperation(self, value: BlendOp) -> BlendOp: ...
    @classmethod
    @property
    def defaultValue(cls) -> RenderTargetBlendState: ...
    @property
    def destinationAlphaBlendMode(self) -> BlendMode: ...
    @destinationAlphaBlendMode.setter
    def destinationAlphaBlendMode(self, value: BlendMode) -> BlendMode: ...
    @property
    def destinationColorBlendMode(self) -> BlendMode: ...
    @destinationColorBlendMode.setter
    def destinationColorBlendMode(self, value: BlendMode) -> BlendMode: ...
    @property
    def sourceAlphaBlendMode(self) -> BlendMode: ...
    @sourceAlphaBlendMode.setter
    def sourceAlphaBlendMode(self, value: BlendMode) -> BlendMode: ...
    @property
    def sourceColorBlendMode(self) -> BlendMode: ...
    @sourceColorBlendMode.setter
    def sourceColorBlendMode(self, value: BlendMode) -> BlendMode: ...
    @property
    def writeMask(self) -> ColorWriteMask: ...
    @writeMask.setter
    def writeMask(self, value: ColorWriteMask) -> ColorWriteMask: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: RenderTargetBlendState, right: RenderTargetBlendState) -> bool: ...
    def __ne__(self, left: RenderTargetBlendState, right: RenderTargetBlendState) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: RenderTargetBlendState) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class RenderTargetFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : RenderTargetFlags # 0
    ReadOnlyDepth : RenderTargetFlags # 1
    ReadOnlyStencil : RenderTargetFlags # 2
    ReadOnlyDepthStencil : RenderTargetFlags # 3


class RenderTargetIdentifier(IEquatable_1[RenderTargetIdentifier]):
    @typing.overload
    def __init__(self, buf: RenderBuffer, mipLevel: int = ..., cubeFace: CubemapFace = ..., depthSlice: int = ...) -> None: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: str, mipLevel: int = ..., cubeFace: CubemapFace = ..., depthSlice: int = ...) -> None: ...
    @typing.overload
    def __init__(self, nameID: int) -> None: ...
    @typing.overload
    def __init__(self, nameID: int, mipLevel: int = ..., cubeFace: CubemapFace = ..., depthSlice: int = ...) -> None: ...
    @typing.overload
    def __init__(self, renderTargetIdentifier: RenderTargetIdentifier, mipLevel: int, cubeFace: CubemapFace = ..., depthSlice: int = ...) -> None: ...
    @typing.overload
    def __init__(self, tex: Texture) -> None: ...
    @typing.overload
    def __init__(self, tex: Texture, mipLevel: int = ..., cubeFace: CubemapFace = ..., depthSlice: int = ...) -> None: ...
    @typing.overload
    def __init__(self, type: BuiltinRenderTextureType) -> None: ...
    @typing.overload
    def __init__(self, type: BuiltinRenderTextureType, mipLevel: int = ..., cubeFace: CubemapFace = ..., depthSlice: int = ...) -> None: ...
    AllDepthSlices : int
    def GetHashCode(self) -> int: ...
    def __eq__(self, lhs: RenderTargetIdentifier, rhs: RenderTargetIdentifier) -> bool: ...
    # Operator not supported op_Implicit(nameID: Int32)
    # Operator not supported op_Implicit(type: BuiltinRenderTextureType)
    # Operator not supported op_Implicit(buf: RenderBuffer)
    # Operator not supported op_Implicit(name: String)
    # Operator not supported op_Implicit(tex: Texture)
    def __ne__(self, lhs: RenderTargetIdentifier, rhs: RenderTargetIdentifier) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, rhs: RenderTargetIdentifier) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class RenderTextureSubElement(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Color : RenderTextureSubElement # 0
    Depth : RenderTextureSubElement # 1
    Stencil : RenderTextureSubElement # 2
    Default : RenderTextureSubElement # 3


class RTClearFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : RTClearFlags # 0
    Color : RTClearFlags # 1
    Depth : RTClearFlags # 2
    ColorDepth : RTClearFlags # 3
    Stencil : RTClearFlags # 4
    ColorStencil : RTClearFlags # 5
    DepthStencil : RTClearFlags # 6
    All : RTClearFlags # 7


class ScopedRenderPass(IDisposable):
    def Dispose(self) -> None: ...


class ScopedSubPass(IDisposable):
    def Dispose(self) -> None: ...


class ScriptableCullingParameters(IEquatable_1[ScriptableCullingParameters]):
    layerCount : int
    maximumCullingPlaneCount : int
    @property
    def accurateOcclusionThreshold(self) -> float: ...
    @accurateOcclusionThreshold.setter
    def accurateOcclusionThreshold(self, value: float) -> float: ...
    @property
    def cameraProperties(self) -> CameraProperties: ...
    @cameraProperties.setter
    def cameraProperties(self, value: CameraProperties) -> CameraProperties: ...
    @property
    def conservativeEnclosingSphere(self) -> bool: ...
    @conservativeEnclosingSphere.setter
    def conservativeEnclosingSphere(self, value: bool) -> bool: ...
    @classmethod
    @property
    def cullingJobsLowerLimit(cls) -> int: ...
    @classmethod
    @property
    def cullingJobsUpperLimit(cls) -> int: ...
    @property
    def cullingMask(self) -> int: ...
    @cullingMask.setter
    def cullingMask(self, value: int) -> int: ...
    @property
    def cullingMatrix(self) -> Matrix4x4: ...
    @cullingMatrix.setter
    def cullingMatrix(self, value: Matrix4x4) -> Matrix4x4: ...
    @property
    def cullingOptions(self) -> CullingOptions: ...
    @cullingOptions.setter
    def cullingOptions(self, value: CullingOptions) -> CullingOptions: ...
    @property
    def cullingPlaneCount(self) -> int: ...
    @cullingPlaneCount.setter
    def cullingPlaneCount(self, value: int) -> int: ...
    @property
    def isOrthographic(self) -> bool: ...
    @isOrthographic.setter
    def isOrthographic(self, value: bool) -> bool: ...
    @property
    def lodParameters(self) -> LODParameters: ...
    @lodParameters.setter
    def lodParameters(self, value: LODParameters) -> LODParameters: ...
    @property
    def maximumPortalCullingJobs(self) -> int: ...
    @maximumPortalCullingJobs.setter
    def maximumPortalCullingJobs(self, value: int) -> int: ...
    @property
    def maximumVisibleLights(self) -> int: ...
    @maximumVisibleLights.setter
    def maximumVisibleLights(self, value: int) -> int: ...
    @property
    def numIterationsEnclosingSphere(self) -> int: ...
    @numIterationsEnclosingSphere.setter
    def numIterationsEnclosingSphere(self, value: int) -> int: ...
    @property
    def origin(self) -> Vector3: ...
    @origin.setter
    def origin(self, value: Vector3) -> Vector3: ...
    @property
    def reflectionProbeSortingCriteria(self) -> ReflectionProbeSortingCriteria: ...
    @reflectionProbeSortingCriteria.setter
    def reflectionProbeSortingCriteria(self, value: ReflectionProbeSortingCriteria) -> ReflectionProbeSortingCriteria: ...
    @property
    def shadowDistance(self) -> float: ...
    @shadowDistance.setter
    def shadowDistance(self, value: float) -> float: ...
    @property
    def shadowNearPlaneOffset(self) -> float: ...
    @shadowNearPlaneOffset.setter
    def shadowNearPlaneOffset(self, value: float) -> float: ...
    @property
    def stereoProjectionMatrix(self) -> Matrix4x4: ...
    @stereoProjectionMatrix.setter
    def stereoProjectionMatrix(self, value: Matrix4x4) -> Matrix4x4: ...
    @property
    def stereoSeparationDistance(self) -> float: ...
    @stereoSeparationDistance.setter
    def stereoSeparationDistance(self, value: float) -> float: ...
    @property
    def stereoViewMatrix(self) -> Matrix4x4: ...
    @stereoViewMatrix.setter
    def stereoViewMatrix(self, value: Matrix4x4) -> Matrix4x4: ...
    def GetCullingPlane(self, index: int) -> Plane: ...
    def GetHashCode(self) -> int: ...
    def GetLayerCullingDistance(self, layerIndex: int) -> float: ...
    def __eq__(self, left: ScriptableCullingParameters, right: ScriptableCullingParameters) -> bool: ...
    def __ne__(self, left: ScriptableCullingParameters, right: ScriptableCullingParameters) -> bool: ...
    def SetCullingPlane(self, index: int, plane: Plane) -> None: ...
    def SetLayerCullingDistance(self, layerIndex: int, distance: float) -> None: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: ScriptableCullingParameters) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...


    class <m_CullingPlanes>e__FixedBuffer:
        FixedElementField : int


    class <m_LayerFarCullDistances>e__FixedBuffer:
        FixedElementField : float



class ScriptableRenderContext(IEquatable_1[ScriptableRenderContext]):
    def BeginScopedRenderPass(self, width: int, height: int, samples: int, attachments: NativeArray_1[AttachmentDescriptor], depthAttachmentIndex: int = ...) -> ScopedRenderPass: ...
    def CreateShadowRendererList(self, settings: clr.Reference[ShadowDrawingSettings]) -> RendererList: ...
    def Cull(self, parameters: clr.Reference[ScriptableCullingParameters]) -> CullingResults: ...
    def DrawGizmos(self, camera: Camera, gizmoSubset: GizmoSubset) -> None: ...
    def DrawShadows(self, settings: clr.Reference[ShadowDrawingSettings]) -> None: ...
    def DrawSkybox(self, camera: Camera) -> None: ...
    def DrawUIOverlay(self, camera: Camera) -> None: ...
    def DrawWireOverlay(self, camera: Camera) -> None: ...
    @staticmethod
    def EmitGeometryForCamera(camera: Camera) -> None: ...
    @staticmethod
    def EmitWorldGeometryForSceneView(cullingCamera: Camera) -> None: ...
    def EndRenderPass(self) -> None: ...
    def EndSubPass(self) -> None: ...
    def ExecuteCommandBuffer(self, commandBuffer: CommandBuffer) -> None: ...
    def ExecuteCommandBufferAsync(self, commandBuffer: CommandBuffer, queueType: ComputeQueueType) -> None: ...
    def GetHashCode(self) -> int: ...
    def InvokeOnRenderObjectCallback(self) -> None: ...
    def __eq__(self, left: ScriptableRenderContext, right: ScriptableRenderContext) -> bool: ...
    def __ne__(self, left: ScriptableRenderContext, right: ScriptableRenderContext) -> bool: ...
    def PrepareRendererListsAsync(self, rendererLists: List_1[RendererList]) -> None: ...
    def QueryRendererListStatus(self, rendererList: RendererList) -> RendererListStatus: ...
    def StopMultiEye(self, camera: Camera) -> None: ...
    def Submit(self) -> None: ...
    def SubmitForRenderPassValidation(self) -> bool: ...
    # Skipped BeginRenderPass due to it being static, abstract and generic.

    BeginRenderPass : BeginRenderPass_MethodGroup
    class BeginRenderPass_MethodGroup:
        @typing.overload
        def __call__(self, width: int, height: int, samples: int, attachments: NativeArray_1[AttachmentDescriptor], depthAttachmentIndex: int = ...) -> None:...
        @typing.overload
        def __call__(self, width: int, height: int, volumeDepth: int, samples: int, attachments: NativeArray_1[AttachmentDescriptor], depthAttachmentIndex: int = ...) -> None:...

    # Skipped BeginScopedSubPass due to it being static, abstract and generic.

    BeginScopedSubPass : BeginScopedSubPass_MethodGroup
    class BeginScopedSubPass_MethodGroup:
        @typing.overload
        def __call__(self, colors: NativeArray_1[int], isDepthStencilReadOnly: bool = ...) -> ScopedSubPass:...
        @typing.overload
        def __call__(self, colors: NativeArray_1[int], inputs: NativeArray_1[int], isDepthStencilReadOnly: bool = ...) -> ScopedSubPass:...
        @typing.overload
        def __call__(self, colors: NativeArray_1[int], isDepthReadOnly: bool, isStencilReadOnly: bool) -> ScopedSubPass:...
        @typing.overload
        def __call__(self, colors: NativeArray_1[int], inputs: NativeArray_1[int], isDepthReadOnly: bool, isStencilReadOnly: bool) -> ScopedSubPass:...

    # Skipped BeginSubPass due to it being static, abstract and generic.

    BeginSubPass : BeginSubPass_MethodGroup
    class BeginSubPass_MethodGroup:
        @typing.overload
        def __call__(self, colors: NativeArray_1[int], isDepthStencilReadOnly: bool = ...) -> None:...
        @typing.overload
        def __call__(self, colors: NativeArray_1[int], inputs: NativeArray_1[int], isDepthStencilReadOnly: bool = ...) -> None:...
        @typing.overload
        def __call__(self, colors: NativeArray_1[int], isDepthReadOnly: bool, isStencilReadOnly: bool) -> None:...
        @typing.overload
        def __call__(self, colors: NativeArray_1[int], inputs: NativeArray_1[int], isDepthReadOnly: bool, isStencilReadOnly: bool) -> None:...

    # Skipped CreateRendererList due to it being static, abstract and generic.

    CreateRendererList : CreateRendererList_MethodGroup
    class CreateRendererList_MethodGroup:
        @typing.overload
        def __call__(self, desc: RendererListDesc) -> RendererList:...
        @typing.overload
        def __call__(self, param: clr.Reference[RendererListParams]) -> RendererList:...

    # Skipped CreateSkyboxRendererList due to it being static, abstract and generic.

    CreateSkyboxRendererList : CreateSkyboxRendererList_MethodGroup
    class CreateSkyboxRendererList_MethodGroup:
        @typing.overload
        def __call__(self, camera: Camera) -> RendererList:...
        @typing.overload
        def __call__(self, camera: Camera, projectionMatrix: Matrix4x4, viewMatrix: Matrix4x4) -> RendererList:...
        @typing.overload
        def __call__(self, camera: Camera, projectionMatrixL: Matrix4x4, viewMatrixL: Matrix4x4, projectionMatrixR: Matrix4x4, viewMatrixR: Matrix4x4) -> RendererList:...

    # Skipped DrawRenderers due to it being static, abstract and generic.

    DrawRenderers : DrawRenderers_MethodGroup
    class DrawRenderers_MethodGroup:
        @typing.overload
        def __call__(self, cullingResults: CullingResults, drawingSettings: clr.Reference[DrawingSettings], filteringSettings: clr.Reference[FilteringSettings]) -> None:...
        @typing.overload
        def __call__(self, cullingResults: CullingResults, drawingSettings: clr.Reference[DrawingSettings], filteringSettings: clr.Reference[FilteringSettings], stateBlock: clr.Reference[RenderStateBlock]) -> None:...
        @typing.overload
        def __call__(self, cullingResults: CullingResults, drawingSettings: clr.Reference[DrawingSettings], filteringSettings: clr.Reference[FilteringSettings], renderTypes: NativeArray_1[ShaderTagId], stateBlocks: NativeArray_1[RenderStateBlock]) -> None:...
        @typing.overload
        def __call__(self, cullingResults: CullingResults, drawingSettings: clr.Reference[DrawingSettings], filteringSettings: clr.Reference[FilteringSettings], tagName: ShaderTagId, isPassTagName: bool, tagValues: NativeArray_1[ShaderTagId], stateBlocks: NativeArray_1[RenderStateBlock]) -> None:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: ScriptableRenderContext) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped SetupCameraProperties due to it being static, abstract and generic.

    SetupCameraProperties : SetupCameraProperties_MethodGroup
    class SetupCameraProperties_MethodGroup:
        @typing.overload
        def __call__(self, camera: Camera, stereoSetup: bool = ...) -> None:...
        @typing.overload
        def __call__(self, camera: Camera, stereoSetup: bool, eye: int) -> None:...

    # Skipped StartMultiEye due to it being static, abstract and generic.

    StartMultiEye : StartMultiEye_MethodGroup
    class StartMultiEye_MethodGroup:
        @typing.overload
        def __call__(self, camera: Camera) -> None:...
        @typing.overload
        def __call__(self, camera: Camera, eye: int) -> None:...

    # Skipped StereoEndRender due to it being static, abstract and generic.

    StereoEndRender : StereoEndRender_MethodGroup
    class StereoEndRender_MethodGroup:
        @typing.overload
        def __call__(self, camera: Camera) -> None:...
        @typing.overload
        def __call__(self, camera: Camera, eye: int) -> None:...
        @typing.overload
        def __call__(self, camera: Camera, eye: int, isFinalPass: bool) -> None:...



class ShaderConstantType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Vector : ShaderConstantType # 0
    Matrix : ShaderConstantType # 1
    Struct : ShaderConstantType # 2


class ShaderHardwareTier(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Tier1 : ShaderHardwareTier # 0
    Tier2 : ShaderHardwareTier # 1
    Tier3 : ShaderHardwareTier # 2


class ShaderKeyword:
    @typing.overload
    def __init__(self, keywordName: str) -> None: ...
    @typing.overload
    def __init__(self, shader: Shader, keywordName: str) -> None: ...
    @typing.overload
    def __init__(self, shader: ComputeShader, keywordName: str) -> None: ...
    @property
    def index(self) -> int: ...
    @property
    def name(self) -> str: ...
    @staticmethod
    def GetGlobalKeywordName(index: ShaderKeyword) -> str: ...
    @staticmethod
    def GetGlobalKeywordType(index: ShaderKeyword) -> ShaderKeywordType: ...
    def GetName(self) -> str: ...
    @staticmethod
    def IsKeywordLocal(keyword: ShaderKeyword) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped GetKeywordName due to it being static, abstract and generic.

    GetKeywordName : GetKeywordName_MethodGroup
    class GetKeywordName_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, shader: Shader, index: ShaderKeyword) -> str:...
        @typing.overload
        def __call__(self, shader: ComputeShader, index: ShaderKeyword) -> str:...

    # Skipped GetKeywordType due to it being static, abstract and generic.

    GetKeywordType : GetKeywordType_MethodGroup
    class GetKeywordType_MethodGroup:
        @typing.overload
        def __call__(self) -> ShaderKeywordType:...
        @typing.overload
        def __call__(self, shader: Shader, index: ShaderKeyword) -> ShaderKeywordType:...
        @typing.overload
        def __call__(self, shader: ComputeShader, index: ShaderKeyword) -> ShaderKeywordType:...

    # Skipped IsValid due to it being static, abstract and generic.

    IsValid : IsValid_MethodGroup
    class IsValid_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, shader: ComputeShader) -> bool:...
        @typing.overload
        def __call__(self, shader: Shader) -> bool:...



class ShaderKeywordSet:
    def Disable(self, keyword: ShaderKeyword) -> None: ...
    def Enable(self, keyword: ShaderKeyword) -> None: ...
    def GetShaderKeywords(self) -> Array_1[ShaderKeyword]: ...
    # Skipped IsEnabled due to it being static, abstract and generic.

    IsEnabled : IsEnabled_MethodGroup
    class IsEnabled_MethodGroup:
        @typing.overload
        def __call__(self, keyword: ShaderKeyword) -> bool:...
        @typing.overload
        def __call__(self, keyword: GlobalKeyword) -> bool:...
        @typing.overload
        def __call__(self, keyword: LocalKeyword) -> bool:...



class ShaderKeywordType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : ShaderKeywordType # 0
    BuiltinDefault : ShaderKeywordType # 2
    BuiltinExtra : ShaderKeywordType # 6
    BuiltinAutoStripped : ShaderKeywordType # 10
    UserDefined : ShaderKeywordType # 16
    Plugin : ShaderKeywordType # 32


class ShaderParamType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Float : ShaderParamType # 0
    Int : ShaderParamType # 1
    Bool : ShaderParamType # 2
    Half : ShaderParamType # 3
    Short : ShaderParamType # 4
    UInt : ShaderParamType # 5


class ShaderPropertyFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : ShaderPropertyFlags # 0
    HideInInspector : ShaderPropertyFlags # 1
    PerRendererData : ShaderPropertyFlags # 2
    NoScaleOffset : ShaderPropertyFlags # 4
    Normal : ShaderPropertyFlags # 8
    HDR : ShaderPropertyFlags # 16
    Gamma : ShaderPropertyFlags # 32
    NonModifiableTextureData : ShaderPropertyFlags # 64
    MainTexture : ShaderPropertyFlags # 128
    MainColor : ShaderPropertyFlags # 256


class ShaderPropertyType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Color : ShaderPropertyType # 0
    Vector : ShaderPropertyType # 1
    Float : ShaderPropertyType # 2
    Range : ShaderPropertyType # 3
    Texture : ShaderPropertyType # 4
    Int : ShaderPropertyType # 5


class ShaderTagId(IEquatable_1[ShaderTagId]):
    def __init__(self, name: str) -> None: ...
    none : ShaderTagId
    @property
    def name(self) -> str: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, tag1: ShaderTagId, tag2: ShaderTagId) -> bool: ...
    # Operator not supported op_Explicit(name: String)
    # Operator not supported op_Explicit(tagId: ShaderTagId)
    def __ne__(self, tag1: ShaderTagId, tag2: ShaderTagId) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: ShaderTagId) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class ShadowCastingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Off : ShadowCastingMode # 0
    On : ShadowCastingMode # 1
    TwoSided : ShadowCastingMode # 2
    ShadowsOnly : ShadowCastingMode # 3


class ShadowDrawingSettings(IEquatable_1[ShadowDrawingSettings]):
    @typing.overload
    def __init__(self, cullingResults: CullingResults, lightIndex: int) -> None: ...
    @typing.overload
    def __init__(self, cullingResults: CullingResults, lightIndex: int, projectionType: BatchCullingProjectionType) -> None: ...
    @property
    def cullingResults(self) -> CullingResults: ...
    @cullingResults.setter
    def cullingResults(self, value: CullingResults) -> CullingResults: ...
    @property
    def lightIndex(self) -> int: ...
    @lightIndex.setter
    def lightIndex(self, value: int) -> int: ...
    @property
    def objectsFilter(self) -> ShadowObjectsFilter: ...
    @objectsFilter.setter
    def objectsFilter(self, value: ShadowObjectsFilter) -> ShadowObjectsFilter: ...
    @property
    def projectionType(self) -> BatchCullingProjectionType: ...
    @projectionType.setter
    def projectionType(self, value: BatchCullingProjectionType) -> BatchCullingProjectionType: ...
    @property
    def splitData(self) -> ShadowSplitData: ...
    @splitData.setter
    def splitData(self, value: ShadowSplitData) -> ShadowSplitData: ...
    @property
    def useRenderingLayerMaskTest(self) -> bool: ...
    @useRenderingLayerMaskTest.setter
    def useRenderingLayerMaskTest(self, value: bool) -> bool: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: ShadowDrawingSettings, right: ShadowDrawingSettings) -> bool: ...
    def __ne__(self, left: ShadowDrawingSettings, right: ShadowDrawingSettings) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: ShadowDrawingSettings) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class ShadowMapPass(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    PointlightPositiveX : ShadowMapPass # 1
    PointlightNegativeX : ShadowMapPass # 2
    PointlightPositiveY : ShadowMapPass # 4
    PointlightNegativeY : ShadowMapPass # 8
    PointlightPositiveZ : ShadowMapPass # 16
    PointlightNegativeZ : ShadowMapPass # 32
    Pointlight : ShadowMapPass # 63
    DirectionalCascade0 : ShadowMapPass # 64
    DirectionalCascade1 : ShadowMapPass # 128
    DirectionalCascade2 : ShadowMapPass # 256
    DirectionalCascade3 : ShadowMapPass # 512
    Directional : ShadowMapPass # 960
    Spotlight : ShadowMapPass # 1024
    All : ShadowMapPass # 2047


class ShadowSamplingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    CompareDepths : ShadowSamplingMode # 0
    RawDepth : ShadowSamplingMode # 1
    None_ : ShadowSamplingMode # 2


class ShadowSplitData(IEquatable_1[ShadowSplitData]):
    maximumCullingPlaneCount : int
    @property
    def cullingMatrix(self) -> Matrix4x4: ...
    @cullingMatrix.setter
    def cullingMatrix(self, value: Matrix4x4) -> Matrix4x4: ...
    @property
    def cullingNearPlane(self) -> float: ...
    @cullingNearPlane.setter
    def cullingNearPlane(self, value: float) -> float: ...
    @property
    def cullingPlaneCount(self) -> int: ...
    @cullingPlaneCount.setter
    def cullingPlaneCount(self, value: int) -> int: ...
    @property
    def cullingSphere(self) -> Vector4: ...
    @cullingSphere.setter
    def cullingSphere(self, value: Vector4) -> Vector4: ...
    @property
    def shadowCascadeBlendCullingFactor(self) -> float: ...
    @shadowCascadeBlendCullingFactor.setter
    def shadowCascadeBlendCullingFactor(self, value: float) -> float: ...
    def GetCullingPlane(self, index: int) -> Plane: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: ShadowSplitData, right: ShadowSplitData) -> bool: ...
    def __ne__(self, left: ShadowSplitData, right: ShadowSplitData) -> bool: ...
    def SetCullingPlane(self, index: int, plane: Plane) -> None: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: ShadowSplitData) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...


    class <m_CullingPlanes>e__FixedBuffer:
        FixedElementField : int



class SinglePassStereoMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : SinglePassStereoMode # 0
    SideBySide : SinglePassStereoMode # 1
    Instancing : SinglePassStereoMode # 2
    Multiview : SinglePassStereoMode # 3


class SortingCriteria(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : SortingCriteria # 0
    SortingLayer : SortingCriteria # 1
    RenderQueue : SortingCriteria # 2
    BackToFront : SortingCriteria # 4
    QuantizedFrontToBack : SortingCriteria # 8
    OptimizeStateChanges : SortingCriteria # 16
    CommonTransparent : SortingCriteria # 23
    CanvasOrder : SortingCriteria # 32
    CommonOpaque : SortingCriteria # 59
    RendererPriority : SortingCriteria # 64


class SortingGroup(Behaviour):
    def __init__(self) -> None: ...
    @property
    def animation(self) -> Component: ...
    @property
    def audio(self) -> Component: ...
    @property
    def camera(self) -> Component: ...
    @property
    def collider(self) -> Component: ...
    @property
    def collider2D(self) -> Component: ...
    @property
    def constantForce(self) -> Component: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def gameObject(self) -> GameObject: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def hingeJoint(self) -> Component: ...
    @property
    def isActiveAndEnabled(self) -> bool: ...
    @property
    def light(self) -> Component: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def networkView(self) -> Component: ...
    @property
    def particleSystem(self) -> Component: ...
    @property
    def renderer(self) -> Component: ...
    @property
    def rigidbody(self) -> Component: ...
    @property
    def rigidbody2D(self) -> Component: ...
    @property
    def sortAtRoot(self) -> bool: ...
    @sortAtRoot.setter
    def sortAtRoot(self, value: bool) -> bool: ...
    @property
    def sortingLayerID(self) -> int: ...
    @sortingLayerID.setter
    def sortingLayerID(self, value: int) -> int: ...
    @property
    def sortingLayerName(self) -> str: ...
    @sortingLayerName.setter
    def sortingLayerName(self, value: str) -> str: ...
    @property
    def sortingOrder(self) -> int: ...
    @sortingOrder.setter
    def sortingOrder(self, value: int) -> int: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def transform(self) -> Transform: ...
    @staticmethod
    def UpdateAllSortingGroups() -> None: ...


class SortingLayerRange(IEquatable_1[SortingLayerRange]):
    def __init__(self, lowerBound: int, upperBound: int) -> None: ...
    @classmethod
    @property
    def all(cls) -> SortingLayerRange: ...
    @property
    def lowerBound(self) -> int: ...
    @lowerBound.setter
    def lowerBound(self, value: int) -> int: ...
    @property
    def upperBound(self) -> int: ...
    @upperBound.setter
    def upperBound(self, value: int) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, lhs: SortingLayerRange, rhs: SortingLayerRange) -> bool: ...
    def __ne__(self, lhs: SortingLayerRange, rhs: SortingLayerRange) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: SortingLayerRange) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class SortingSettings(IEquatable_1[SortingSettings]):
    def __init__(self, camera: Camera) -> None: ...
    @property
    def cameraPosition(self) -> Vector3: ...
    @cameraPosition.setter
    def cameraPosition(self, value: Vector3) -> Vector3: ...
    @property
    def criteria(self) -> SortingCriteria: ...
    @criteria.setter
    def criteria(self, value: SortingCriteria) -> SortingCriteria: ...
    @property
    def customAxis(self) -> Vector3: ...
    @customAxis.setter
    def customAxis(self, value: Vector3) -> Vector3: ...
    @property
    def distanceMetric(self) -> DistanceMetric: ...
    @distanceMetric.setter
    def distanceMetric(self, value: DistanceMetric) -> DistanceMetric: ...
    @property
    def worldToCameraMatrix(self) -> Matrix4x4: ...
    @worldToCameraMatrix.setter
    def worldToCameraMatrix(self, value: Matrix4x4) -> Matrix4x4: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: SortingSettings, right: SortingSettings) -> bool: ...
    def __ne__(self, left: SortingSettings, right: SortingSettings) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: SortingSettings) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class SphericalHarmonicsL2(IEquatable_1[SphericalHarmonicsL2]):
    @property
    def Item(self) -> float: ...
    @Item.setter
    def Item(self, value: float) -> float: ...
    def AddAmbientLight(self, color: Color) -> None: ...
    def AddDirectionalLight(self, direction: Vector3, color: Color, intensity: float) -> None: ...
    def Clear(self) -> None: ...
    def Evaluate(self, directions: Array_1[Vector3], results: Array_1[Color]) -> None: ...
    def GetHashCode(self) -> int: ...
    def __add__(self, lhs: SphericalHarmonicsL2, rhs: SphericalHarmonicsL2) -> SphericalHarmonicsL2: ...
    def __eq__(self, lhs: SphericalHarmonicsL2, rhs: SphericalHarmonicsL2) -> bool: ...
    def __ne__(self, lhs: SphericalHarmonicsL2, rhs: SphericalHarmonicsL2) -> bool: ...
    @typing.overload
    def __mul__(self, lhs: float, rhs: SphericalHarmonicsL2) -> SphericalHarmonicsL2: ...
    @typing.overload
    def __mul__(self, lhs: SphericalHarmonicsL2, rhs: float) -> SphericalHarmonicsL2: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: SphericalHarmonicsL2) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...



class SplashScreen:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def isFinished(cls) -> bool: ...
    @staticmethod
    def Begin() -> None: ...
    @staticmethod
    def Draw() -> None: ...
    @staticmethod
    def Stop(stopBehavior: SplashScreen.StopBehavior) -> None: ...

    class StopBehavior(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        StopImmediate : SplashScreen.StopBehavior # 0
        FadeOut : SplashScreen.StopBehavior # 1



class StencilOp(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Keep : StencilOp # 0
    Zero : StencilOp # 1
    Replace : StencilOp # 2
    IncrementSaturate : StencilOp # 3
    DecrementSaturate : StencilOp # 4
    Invert : StencilOp # 5
    IncrementWrap : StencilOp # 6
    DecrementWrap : StencilOp # 7


class StencilState(IEquatable_1[StencilState]):
    @typing.overload
    def __init__(self, enabled: bool = ..., readMask: int = ..., writeMask: int = ..., compareFunction: CompareFunction = ..., passOperation: StencilOp = ..., failOperation: StencilOp = ..., zFailOperation: StencilOp = ...) -> None: ...
    @typing.overload
    def __init__(self, enabled: bool, readMask: int, writeMask: int, compareFunctionFront: CompareFunction, passOperationFront: StencilOp, failOperationFront: StencilOp, zFailOperationFront: StencilOp, compareFunctionBack: CompareFunction, passOperationBack: StencilOp, failOperationBack: StencilOp, zFailOperationBack: StencilOp) -> None: ...
    @property
    def compareFunctionBack(self) -> CompareFunction: ...
    @compareFunctionBack.setter
    def compareFunctionBack(self, value: CompareFunction) -> CompareFunction: ...
    @property
    def compareFunctionFront(self) -> CompareFunction: ...
    @compareFunctionFront.setter
    def compareFunctionFront(self, value: CompareFunction) -> CompareFunction: ...
    @classmethod
    @property
    def defaultValue(cls) -> StencilState: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> bool: ...
    @property
    def failOperationBack(self) -> StencilOp: ...
    @failOperationBack.setter
    def failOperationBack(self, value: StencilOp) -> StencilOp: ...
    @property
    def failOperationFront(self) -> StencilOp: ...
    @failOperationFront.setter
    def failOperationFront(self, value: StencilOp) -> StencilOp: ...
    @property
    def passOperationBack(self) -> StencilOp: ...
    @passOperationBack.setter
    def passOperationBack(self, value: StencilOp) -> StencilOp: ...
    @property
    def passOperationFront(self) -> StencilOp: ...
    @passOperationFront.setter
    def passOperationFront(self, value: StencilOp) -> StencilOp: ...
    @property
    def readMask(self) -> int: ...
    @readMask.setter
    def readMask(self, value: int) -> int: ...
    @property
    def writeMask(self) -> int: ...
    @writeMask.setter
    def writeMask(self, value: int) -> int: ...
    @property
    def zFailOperationBack(self) -> StencilOp: ...
    @zFailOperationBack.setter
    def zFailOperationBack(self, value: StencilOp) -> StencilOp: ...
    @property
    def zFailOperationFront(self) -> StencilOp: ...
    @zFailOperationFront.setter
    def zFailOperationFront(self, value: StencilOp) -> StencilOp: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: StencilState, right: StencilState) -> bool: ...
    def __ne__(self, left: StencilState, right: StencilState) -> bool: ...
    def SetCompareFunction(self, value: CompareFunction) -> None: ...
    def SetFailOperation(self, value: StencilOp) -> None: ...
    def SetPassOperation(self, value: StencilOp) -> None: ...
    def SetZFailOperation(self, value: StencilOp) -> None: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: StencilState) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class SubMeshDescriptor:
    def __init__(self, indexStart: int, indexCount: int, topology: MeshTopology = ...) -> None: ...
    @property
    def baseVertex(self) -> int: ...
    @baseVertex.setter
    def baseVertex(self, value: int) -> int: ...
    @property
    def bounds(self) -> Bounds: ...
    @bounds.setter
    def bounds(self, value: Bounds) -> Bounds: ...
    @property
    def firstVertex(self) -> int: ...
    @firstVertex.setter
    def firstVertex(self, value: int) -> int: ...
    @property
    def indexCount(self) -> int: ...
    @indexCount.setter
    def indexCount(self, value: int) -> int: ...
    @property
    def indexStart(self) -> int: ...
    @indexStart.setter
    def indexStart(self, value: int) -> int: ...
    @property
    def topology(self) -> MeshTopology: ...
    @topology.setter
    def topology(self, value: MeshTopology) -> MeshTopology: ...
    @property
    def vertexCount(self) -> int: ...
    @vertexCount.setter
    def vertexCount(self, value: int) -> int: ...
    def ToString(self) -> str: ...


class SupportedRenderingFeatures:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def active(cls) -> SupportedRenderingFeatures: ...
    @classmethod
    @active.setter
    def active(cls, value: SupportedRenderingFeatures) -> SupportedRenderingFeatures: ...
    @property
    def autoAmbientProbeBaking(self) -> bool: ...
    @autoAmbientProbeBaking.setter
    def autoAmbientProbeBaking(self, value: bool) -> bool: ...
    @property
    def autoDefaultReflectionProbeBaking(self) -> bool: ...
    @autoDefaultReflectionProbeBaking.setter
    def autoDefaultReflectionProbeBaking(self, value: bool) -> bool: ...
    @property
    def defaultMixedLightingModes(self) -> SupportedRenderingFeatures.LightmapMixedBakeModes: ...
    @defaultMixedLightingModes.setter
    def defaultMixedLightingModes(self, value: SupportedRenderingFeatures.LightmapMixedBakeModes) -> SupportedRenderingFeatures.LightmapMixedBakeModes: ...
    @property
    def editableMaterialRenderQueue(self) -> bool: ...
    @editableMaterialRenderQueue.setter
    def editableMaterialRenderQueue(self, value: bool) -> bool: ...
    @property
    def enlighten(self) -> bool: ...
    @enlighten.setter
    def enlighten(self, value: bool) -> bool: ...
    @property
    def enlightenLightmapper(self) -> bool: ...
    @enlightenLightmapper.setter
    def enlightenLightmapper(self, value: bool) -> bool: ...
    @property
    def lightmapBakeTypes(self) -> LightmapBakeType: ...
    @lightmapBakeTypes.setter
    def lightmapBakeTypes(self, value: LightmapBakeType) -> LightmapBakeType: ...
    @property
    def lightmapsModes(self) -> LightmapsMode: ...
    @lightmapsModes.setter
    def lightmapsModes(self, value: LightmapsMode) -> LightmapsMode: ...
    @property
    def lightProbeProxyVolumes(self) -> bool: ...
    @lightProbeProxyVolumes.setter
    def lightProbeProxyVolumes(self, value: bool) -> bool: ...
    @property
    def mixedLightingModes(self) -> SupportedRenderingFeatures.LightmapMixedBakeModes: ...
    @mixedLightingModes.setter
    def mixedLightingModes(self, value: SupportedRenderingFeatures.LightmapMixedBakeModes) -> SupportedRenderingFeatures.LightmapMixedBakeModes: ...
    @property
    def motionVectors(self) -> bool: ...
    @motionVectors.setter
    def motionVectors(self, value: bool) -> bool: ...
    @property
    def overridesEnableLODCrossFade(self) -> bool: ...
    @overridesEnableLODCrossFade.setter
    def overridesEnableLODCrossFade(self, value: bool) -> bool: ...
    @property
    def overridesEnvironmentLighting(self) -> bool: ...
    @overridesEnvironmentLighting.setter
    def overridesEnvironmentLighting(self, value: bool) -> bool: ...
    @property
    def overridesFog(self) -> bool: ...
    @overridesFog.setter
    def overridesFog(self, value: bool) -> bool: ...
    @property
    def overridesLightProbeSystem(self) -> bool: ...
    @overridesLightProbeSystem.setter
    def overridesLightProbeSystem(self, value: bool) -> bool: ...
    @property
    def overridesLightProbeSystemWarningMessage(self) -> str: ...
    @overridesLightProbeSystemWarningMessage.setter
    def overridesLightProbeSystemWarningMessage(self, value: str) -> str: ...
    @property
    def overridesLODBias(self) -> bool: ...
    @overridesLODBias.setter
    def overridesLODBias(self, value: bool) -> bool: ...
    @property
    def overridesMaximumLODLevel(self) -> bool: ...
    @overridesMaximumLODLevel.setter
    def overridesMaximumLODLevel(self, value: bool) -> bool: ...
    @property
    def overridesOtherLightingSettings(self) -> bool: ...
    @overridesOtherLightingSettings.setter
    def overridesOtherLightingSettings(self, value: bool) -> bool: ...
    @property
    def overridesRealtimeReflectionProbes(self) -> bool: ...
    @overridesRealtimeReflectionProbes.setter
    def overridesRealtimeReflectionProbes(self, value: bool) -> bool: ...
    @property
    def overridesShadowmask(self) -> bool: ...
    @overridesShadowmask.setter
    def overridesShadowmask(self, value: bool) -> bool: ...
    @property
    def particleSystemInstancing(self) -> bool: ...
    @particleSystemInstancing.setter
    def particleSystemInstancing(self, value: bool) -> bool: ...
    @property
    def receiveShadows(self) -> bool: ...
    @receiveShadows.setter
    def receiveShadows(self, value: bool) -> bool: ...
    @property
    def reflectionProbeModes(self) -> SupportedRenderingFeatures.ReflectionProbeModes: ...
    @reflectionProbeModes.setter
    def reflectionProbeModes(self, value: SupportedRenderingFeatures.ReflectionProbeModes) -> SupportedRenderingFeatures.ReflectionProbeModes: ...
    @property
    def reflectionProbes(self) -> bool: ...
    @reflectionProbes.setter
    def reflectionProbes(self, value: bool) -> bool: ...
    @property
    def reflectionProbesBlendDistance(self) -> bool: ...
    @reflectionProbesBlendDistance.setter
    def reflectionProbesBlendDistance(self, value: bool) -> bool: ...
    @property
    def rendererPriority(self) -> bool: ...
    @rendererPriority.setter
    def rendererPriority(self, value: bool) -> bool: ...
    @property
    def rendererProbes(self) -> bool: ...
    @rendererProbes.setter
    def rendererProbes(self, value: bool) -> bool: ...
    @property
    def rendersUIOverlay(self) -> bool: ...
    @rendersUIOverlay.setter
    def rendersUIOverlay(self, value: bool) -> bool: ...
    @property
    def supportsHDR(self) -> bool: ...
    @supportsHDR.setter
    def supportsHDR(self, value: bool) -> bool: ...
    @property
    def terrainDetailUnsupported(self) -> bool: ...
    @terrainDetailUnsupported.setter
    def terrainDetailUnsupported(self, value: bool) -> bool: ...

    class LightmapMixedBakeModes(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        None_ : SupportedRenderingFeatures.LightmapMixedBakeModes # 0
        IndirectOnly : SupportedRenderingFeatures.LightmapMixedBakeModes # 1
        Subtractive : SupportedRenderingFeatures.LightmapMixedBakeModes # 2
        Shadowmask : SupportedRenderingFeatures.LightmapMixedBakeModes # 4


    class ReflectionProbeModes(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        None_ : SupportedRenderingFeatures.ReflectionProbeModes # 0
        Rotation : SupportedRenderingFeatures.ReflectionProbeModes # 1



class SynchronisationStage(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    VertexProcessing : SynchronisationStage # 0
    PixelProcessing : SynchronisationStage # 1


class SynchronisationStageFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    VertexProcessing : SynchronisationStageFlags # 1
    PixelProcessing : SynchronisationStageFlags # 2
    ComputeProcessing : SynchronisationStageFlags # 4
    AllGPUOperations : SynchronisationStageFlags # 7


class TextureDimension(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : TextureDimension # 0
    Any : TextureDimension # 1
    Tex2D : TextureDimension # 2
    Tex3D : TextureDimension # 3
    Cube : TextureDimension # 4
    Tex2DArray : TextureDimension # 5
    CubeArray : TextureDimension # 6
    Unknown : TextureDimension # -1


class ThreadedBatchContext:
    batchRendererGroup : int
    def RemoveBatch(self, batchID: BatchID) -> None: ...
    def SetBatchBuffer(self, batchID: BatchID, buffer: GraphicsBufferHandle) -> None: ...
    # Skipped AddBatch due to it being static, abstract and generic.

    AddBatch : AddBatch_MethodGroup
    class AddBatch_MethodGroup:
        @typing.overload
        def __call__(self, batchMetadata: NativeArray_1[MetadataValue], buffer: GraphicsBufferHandle) -> BatchID:...
        @typing.overload
        def __call__(self, batchMetadata: NativeArray_1[MetadataValue], buffer: GraphicsBufferHandle, bufferOffset: int, windowSize: int) -> BatchID:...



class UVChannelFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    UV0 : UVChannelFlags # 1
    UV1 : UVChannelFlags # 2
    UV2 : UVChannelFlags # 4
    UV3 : UVChannelFlags # 8


class VertexAttribute(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Position : VertexAttribute # 0
    Normal : VertexAttribute # 1
    Tangent : VertexAttribute # 2
    Color : VertexAttribute # 3
    TexCoord0 : VertexAttribute # 4
    TexCoord1 : VertexAttribute # 5
    TexCoord2 : VertexAttribute # 6
    TexCoord3 : VertexAttribute # 7
    TexCoord4 : VertexAttribute # 8
    TexCoord5 : VertexAttribute # 9
    TexCoord6 : VertexAttribute # 10
    TexCoord7 : VertexAttribute # 11
    BlendWeight : VertexAttribute # 12
    BlendIndices : VertexAttribute # 13


class VertexAttributeDescriptor(IEquatable_1[VertexAttributeDescriptor]):
    def __init__(self, attribute: VertexAttribute = ..., format: VertexAttributeFormat = ..., dimension: int = ..., stream: int = ...) -> None: ...
    @property
    def attribute(self) -> VertexAttribute: ...
    @attribute.setter
    def attribute(self, value: VertexAttribute) -> VertexAttribute: ...
    @property
    def dimension(self) -> int: ...
    @dimension.setter
    def dimension(self, value: int) -> int: ...
    @property
    def format(self) -> VertexAttributeFormat: ...
    @format.setter
    def format(self, value: VertexAttributeFormat) -> VertexAttributeFormat: ...
    @property
    def stream(self) -> int: ...
    @stream.setter
    def stream(self, value: int) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, lhs: VertexAttributeDescriptor, rhs: VertexAttributeDescriptor) -> bool: ...
    def __ne__(self, lhs: VertexAttributeDescriptor, rhs: VertexAttributeDescriptor) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: VertexAttributeDescriptor) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...



class VertexAttributeFormat(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Float32 : VertexAttributeFormat # 0
    Float16 : VertexAttributeFormat # 1
    UNorm8 : VertexAttributeFormat # 2
    SNorm8 : VertexAttributeFormat # 3
    UNorm16 : VertexAttributeFormat # 4
    SNorm16 : VertexAttributeFormat # 5
    UInt8 : VertexAttributeFormat # 6
    SInt8 : VertexAttributeFormat # 7
    UInt16 : VertexAttributeFormat # 8
    SInt16 : VertexAttributeFormat # 9
    UInt32 : VertexAttributeFormat # 10
    SInt32 : VertexAttributeFormat # 11


class VideoShadersIncludeMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Never : VideoShadersIncludeMode # 0
    Referenced : VideoShadersIncludeMode # 1
    Always : VideoShadersIncludeMode # 2


class VisibleLight(IEquatable_1[VisibleLight]):
    @property
    def finalColor(self) -> Color: ...
    @finalColor.setter
    def finalColor(self, value: Color) -> Color: ...
    @property
    def intersectsFarPlane(self) -> bool: ...
    @intersectsFarPlane.setter
    def intersectsFarPlane(self, value: bool) -> bool: ...
    @property
    def intersectsNearPlane(self) -> bool: ...
    @intersectsNearPlane.setter
    def intersectsNearPlane(self, value: bool) -> bool: ...
    @property
    def light(self) -> Light: ...
    @property
    def lightType(self) -> LightType: ...
    @lightType.setter
    def lightType(self, value: LightType) -> LightType: ...
    @property
    def localToWorldMatrix(self) -> Matrix4x4: ...
    @localToWorldMatrix.setter
    def localToWorldMatrix(self, value: Matrix4x4) -> Matrix4x4: ...
    @property
    def range(self) -> float: ...
    @range.setter
    def range(self, value: float) -> float: ...
    @property
    def screenRect(self) -> Rect: ...
    @screenRect.setter
    def screenRect(self, value: Rect) -> Rect: ...
    @property
    def spotAngle(self) -> float: ...
    @spotAngle.setter
    def spotAngle(self, value: float) -> float: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: VisibleLight, right: VisibleLight) -> bool: ...
    def __ne__(self, left: VisibleLight, right: VisibleLight) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: VisibleLight) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class VisibleReflectionProbe(IEquatable_1[VisibleReflectionProbe]):
    @property
    def blendDistance(self) -> float: ...
    @blendDistance.setter
    def blendDistance(self, value: float) -> float: ...
    @property
    def bounds(self) -> Bounds: ...
    @bounds.setter
    def bounds(self, value: Bounds) -> Bounds: ...
    @property
    def center(self) -> Vector3: ...
    @center.setter
    def center(self, value: Vector3) -> Vector3: ...
    @property
    def hdrData(self) -> Vector4: ...
    @hdrData.setter
    def hdrData(self, value: Vector4) -> Vector4: ...
    @property
    def importance(self) -> int: ...
    @importance.setter
    def importance(self, value: int) -> int: ...
    @property
    def isBoxProjection(self) -> bool: ...
    @isBoxProjection.setter
    def isBoxProjection(self, value: bool) -> bool: ...
    @property
    def localToWorldMatrix(self) -> Matrix4x4: ...
    @localToWorldMatrix.setter
    def localToWorldMatrix(self, value: Matrix4x4) -> Matrix4x4: ...
    @property
    def reflectionProbe(self) -> ReflectionProbe: ...
    @property
    def texture(self) -> Texture: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: VisibleReflectionProbe, right: VisibleReflectionProbe) -> bool: ...
    def __ne__(self, left: VisibleReflectionProbe, right: VisibleReflectionProbe) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: VisibleReflectionProbe) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...


