import typing, clr
from System.Collections.Generic import List_1
from UnityEngine import Matrix4x4, Vector3, Quaternion, Texture2D, Color, Vector2, Rect, GUIContent, ScriptableObject, Mesh, Material, HideFlags, Shader, AnimationCurve, GameObject, Vector4
from System import Attribute, Array_1

class FractalNoise:
    @typing.overload
    def __init__(self, inH: float, inLacunarity: float, inOctaves: float) -> None: ...
    @typing.overload
    def __init__(self, inH: float, inLacunarity: float, inOctaves: float, noise: Perlin) -> None: ...
    def BrownianMotion(self, x: float, y: float) -> float: ...
    def HybridMultifractal(self, x: float, y: float, offset: float) -> float: ...
    def RidgedMultifractal(self, x: float, y: float, offset: float, gain: float) -> float: ...


class Perlin:
    def __init__(self) -> None: ...
    def SetSeed(self, seed: int) -> None: ...
    # Skipped Noise due to it being static, abstract and generic.

    Noise : Noise_MethodGroup
    class Noise_MethodGroup:
        @typing.overload
        def __call__(self, arg: float) -> float:...
        @typing.overload
        def __call__(self, x: float, y: float) -> float:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> float:...



class RingLoop:
    def __init__(self) -> None: ...
    baseOffset : float
    radius : float
    def BuildVertices(self, verts: List_1[TreeVertex]) -> None: ...
    def Cap(self, sphereFactor: float, noise: float, mappingMode: int, mappingScale: float, verts: List_1[TreeVertex], tris: List_1[TreeTriangle], materialIndex: int) -> None: ...
    def Clone(self) -> RingLoop: ...
    def Connect(self, other: RingLoop, tris: List_1[TreeTriangle], materialIndex: int, flipTris: bool, lowres: bool) -> None: ...
    def Reset(self, r: float, m: Matrix4x4, bOffset: float, segs: int) -> None: ...
    def SetAnimationProperties(self, primaryFactor: float, secondaryFactor: float, edgeFactor: float, phase: float) -> None: ...
    def SetFlares(self, radius: float, noise: float) -> None: ...
    def SetNoise(self, scale: float, scaleU: float, scaleV: float) -> None: ...
    @staticmethod
    def SetNoiseSeed(seed: int) -> None: ...
    def SetSpread(self, top: float, bottom: float) -> None: ...
    def SetSurfaceAngle(self, angleDeg: float) -> None: ...


class SmoothRandom:
    def __init__(self) -> None: ...
    @staticmethod
    def Get(speed: float) -> float: ...
    @staticmethod
    def GetVector3(speed: float) -> Vector3: ...


class SplineNode:
    @typing.overload
    def __init__(self, o: SplineNode) -> None: ...
    @typing.overload
    def __init__(self, p: Vector3, t: float) -> None: ...
    normal : Vector3
    point : Vector3
    rot : Quaternion
    tangent : Vector3
    time : float


class TextureAtlas:
    def __init__(self) -> None: ...
    atlasHeight : int
    atlasPadding : int
    atlasWidth : int
    nodes : List_1[TextureAtlas.TextureNode]
    def AddTexture(self, name: str, diffuse: Texture2D, diffuseColor: Color, normal: Texture2D, gloss: Texture2D, transtex: Texture2D, shadowOffsetTex: Texture2D, shininess: float, scale: Vector2, tileV: bool, uvTiling: Vector2) -> None: ...
    def GetHashCode(self) -> int: ...
    def GetTexTiling(self, name: str) -> Vector2: ...
    def GetUVRect(self, name: str) -> Rect: ...
    def Pack(self, targetWidth: clr.Reference[int], targetHeight: int, padding: int, correctPow2: bool) -> None: ...

    class TextureNode:
        def __init__(self) -> None: ...
        diffuseColor : Color
        diffuseTexture : Texture2D
        glossTexture : Texture2D
        name : str
        normalTexture : Texture2D
        packedRect : Rect
        scale : Vector2
        shadowOffsetTexture : Texture2D
        shininess : float
        sourceRect : Rect
        tileV : bool
        translucencyTexture : Texture2D
        uvRect : Rect
        uvTiling : Vector2
        def CompareTo(self, b: TextureAtlas.TextureNode) -> int: ...
        @staticmethod
        def Overlap(a: TextureAtlas.TextureNode, b: TextureAtlas.TextureNode) -> bool: ...



class TreeAOSphere:
    def __init__(self, pos: Vector3, radius: float, density: float) -> None: ...
    area : float
    density : float
    flag : bool
    position : Vector3
    radius : float
    def PointOcclusion(self, pos: Vector3, nor: Vector3) -> float: ...


class TreeAttribute(Attribute):
    @typing.overload
    def __init__(self, uiLabel: str, uiGadget: str, uiMin: float, uiMax: float) -> None: ...
    @typing.overload
    def __init__(self, uiLabel: str, uiGadget: str, uiMin: float, uiMax: float, uiCurve: str, uiCurveMin: float, uiCurveMax: float) -> None: ...
    @typing.overload
    def __init__(self, uiLabel: str, uiGadget: str, uiMin: float, uiMax: float, uiCurve: str, uiCurveMin: float, uiCurveMax: float, uiRequirement: str) -> None: ...
    @typing.overload
    def __init__(self, uiLabel: str, uiGadget: str, uiMin: float, uiMax: float, uiRequirement: str) -> None: ...
    @typing.overload
    def __init__(self, uiLabel: str, uiGadget: str, uiOptions: str) -> None: ...
    @typing.overload
    def __init__(self, uiLabel: str, uiGadget: str, uiOptions: str, uiCurve: str, uiCurveMin: float, uiCurveMax: float, uiRequirement: str) -> None: ...
    uiCurve : str
    uiCurveMax : float
    uiCurveMin : float
    uiGadget : str
    uiLabel : str
    uiMax : float
    uiMin : float
    uiOptions : Array_1[GUIContent]
    uiRequirement : str
    @property
    def TypeId(self) -> typing.Any: ...
    def ToString(self) -> str: ...


class TreeData(ScriptableObject):
    def __init__(self) -> None: ...
    branchGroups : Array_1[TreeGroupBranch]
    isInPreviewMode : bool
    leafGroups : Array_1[TreeGroupLeaf]
    materialHash : str
    mesh : Mesh
    nodes : Array_1[TreeNode]
    optimizedCutoutMaterial : Material
    optimizedSolidMaterial : Material
    root : TreeGroupRoot
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    def AddGroup(self, parent: TreeGroup, type: typing.Type[typing.Any]) -> TreeGroup: ...
    def CheckExternalChanges(self) -> bool: ...
    def ClearReferences(self) -> None: ...
    def DeleteGroup(self, g: TreeGroup) -> None: ...
    def DuplicateGroup(self, g: TreeGroup) -> TreeGroup: ...
    def DuplicateNode(self, n: TreeNode) -> TreeNode: ...
    @staticmethod
    def GetAdaptiveHeightSegments(h: float, adaptiveQuality: float) -> int: ...
    @staticmethod
    def GetAdaptiveRadialSegments(r: float, adaptiveQuality: float) -> int: ...
    @staticmethod
    def GetAdaptiveSamples(group: TreeGroup, node: TreeNode, adaptiveQuality: float) -> List_1[float]: ...
    def GetGroup(self, id: int) -> TreeGroup: ...
    def GetNode(self, id: int) -> TreeNode: ...
    def Initialize(self) -> None: ...
    def IsAncestor(self, ancestor: TreeGroup, g: TreeGroup) -> bool: ...
    def LockGroup(self, g: TreeGroup) -> None: ...
    def OptimizeMaterial(self, materials: List_1[TreeMaterial], vertices: List_1[TreeVertex], triangles: List_1[TreeTriangle]) -> bool: ...
    def PreviewMesh(self, worldToLocalMatrix: Matrix4x4, outMaterials: clr.Reference[Array_1[Material]]) -> None: ...
    def SetGroupParent(self, g: TreeGroup, parent: TreeGroup) -> None: ...
    def SetNodeParent(self, n: TreeNode, parent: TreeNode) -> None: ...
    def UnlockGroup(self, g: TreeGroup) -> None: ...
    def UpdateDistribution(self, id: int) -> None: ...
    def UpdateFrequency(self, id: int) -> None: ...
    def UpdateSeed(self, id: int) -> None: ...
    def ValidateReferences(self) -> None: ...
    # Skipped AddNode due to it being static, abstract and generic.

    AddNode : AddNode_MethodGroup
    class AddNode_MethodGroup:
        @typing.overload
        def __call__(self, g: TreeGroup, parent: TreeNode) -> TreeNode:...
        @typing.overload
        def __call__(self, g: TreeGroup, parent: TreeNode, validate: bool) -> TreeNode:...

    # Skipped DeleteNode due to it being static, abstract and generic.

    DeleteNode : DeleteNode_MethodGroup
    class DeleteNode_MethodGroup:
        @typing.overload
        def __call__(self, n: TreeNode) -> None:...
        @typing.overload
        def __call__(self, n: TreeNode, validate: bool) -> None:...

    # Skipped UpdateMesh due to it being static, abstract and generic.

    UpdateMesh : UpdateMesh_MethodGroup
    class UpdateMesh_MethodGroup:
        @typing.overload
        def __call__(self, worldToLocalMatrix: Matrix4x4, outMaterials: clr.Reference[Array_1[Material]]) -> None:...
        @typing.overload
        def __call__(self, matrix: Matrix4x4, materials: List_1[TreeMaterial], verts: List_1[TreeVertex], tris: List_1[TreeTriangle], aoSpheres: List_1[TreeAOSphere], buildFlags: int, adaptiveQuality: float, aoDensity: float) -> None:...



class TreeEditorHelper:
    def __init__(self) -> None: ...
    def AreShadersCorrect(self) -> bool: ...
    @staticmethod
    def ExtractLabel(uiString: str) -> str: ...
    @staticmethod
    def ExtractTooltip(uiString: str) -> str: ...
    @staticmethod
    def GetGUIContent(id: str) -> GUIContent: ...
    @staticmethod
    def GetOptimizedShaderName(shader: Shader) -> str: ...
    def GUITooManyShaders(self) -> bool: ...
    def GUIWrongShader(self, uniqueID: str, value: Material, nodeType: TreeEditorHelper.NodeType) -> bool: ...
    @staticmethod
    def IsTreeBarkShader(shader: Shader) -> bool: ...
    @staticmethod
    def IsTreeLeafShader(shader: Shader) -> bool: ...
    def NodeHasWrongMaterial(self, group: TreeGroup) -> bool: ...
    def OnEnable(self, treeData: TreeData) -> None: ...
    def RefreshAllTreeShaders(self) -> None: ...

    class NodeType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        BarkNode : TreeEditorHelper.NodeType # 0
        LeafNode : TreeEditorHelper.NodeType # 1



class TreeGroup:
    def __init__(self) -> None: ...
    animationEdge : float
    animationPrimary : float
    animationSecondary : float
    childGroupIDs : Array_1[int]
    distributionCurve : AnimationCurve
    distributionFrequency : int
    distributionMode : TreeGroup.DistributionMode
    distributionNodes : int
    distributionPitch : float
    distributionPitchCurve : AnimationCurve
    distributionScale : float
    distributionScaleCurve : AnimationCurve
    distributionTwirl : float
    lockFlags : int
    nodeIDs : Array_1[int]
    parentGroupID : int
    seed : int
    showAnimationProps : bool
    visible : bool
    @property
    def uniqueID(self) -> int: ...
    @uniqueID.setter
    def uniqueID(self, value: int) -> int: ...
    def BuildAOSpheres(self, aoSpheres: List_1[TreeAOSphere]) -> None: ...
    def CanHaveSubGroups(self) -> bool: ...
    def CheckExternalChanges(self) -> bool: ...
    def ComputeWindFactor(self, node: TreeNode, offset: float) -> Vector2: ...
    def GetRadiusAtTime(self, node: TreeNode, t: float, includeModifications: bool) -> float: ...
    def GetRootMatrix(self) -> Matrix4x4: ...
    def GetRootSpread(self) -> float: ...
    def Lock(self) -> None: ...
    def Unlock(self) -> None: ...
    def UpdateDistribution(self, completeUpdate: bool, updateSubGroups: bool) -> None: ...
    def UpdateFrequency(self, owner: TreeData) -> None: ...
    def UpdateMatrix(self) -> None: ...
    def UpdateMesh(self, materials: List_1[TreeMaterial], verts: List_1[TreeVertex], tris: List_1[TreeTriangle], aoSpheres: List_1[TreeAOSphere], buildFlags: int, adaptiveQuality: float, aoDensity: float) -> None: ...
    def UpdateParameters(self) -> None: ...
    def UpdateSeed(self) -> None: ...

    class BuildFlag(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        BuildAmbientOcclusion : TreeGroup.BuildFlag # 1
        BuildWeldParts : TreeGroup.BuildFlag # 2


    class DistributionMode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Random : TreeGroup.DistributionMode # 0
        Alternate : TreeGroup.DistributionMode # 1
        Opposite : TreeGroup.DistributionMode # 2
        Whorled : TreeGroup.DistributionMode # 3


    class LockFlag(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        LockPosition : TreeGroup.LockFlag # 1
        LockAlignment : TreeGroup.LockFlag # 2
        LockShape : TreeGroup.LockFlag # 4



class TreeGroupBranch(TreeGroup):
    def __init__(self) -> None: ...
    animationEdge : float
    animationPrimary : float
    animationSecondary : float
    breakingChance : float
    breakingSpot : Vector2
    capSmoothing : float
    childGroupIDs : Array_1[int]
    crinkCurve : AnimationCurve
    crinklyness : float
    distributionCurve : AnimationCurve
    distributionFrequency : int
    distributionMode : TreeGroup.DistributionMode
    distributionNodes : int
    distributionPitch : float
    distributionPitchCurve : AnimationCurve
    distributionScale : float
    distributionScaleCurve : AnimationCurve
    distributionTwirl : float
    flareHeight : float
    flareNoise : float
    flareSize : float
    frondCount : int
    frondCrease : float
    frondCurve : AnimationCurve
    frondRange : Vector2
    frondRotation : float
    frondWidth : float
    geometryMode : TreeGroupBranch.GeometryMode
    height : Vector2
    lockFlags : int
    lodQualityMultiplier : float
    materialBranch : Material
    materialBreak : Material
    materialFrond : Material
    nodeIDs : Array_1[int]
    noise : float
    noiseCurve : AnimationCurve
    noiseScaleU : float
    noiseScaleV : float
    parentGroupID : int
    radius : float
    radiusCurve : AnimationCurve
    radiusMode : bool
    seed : int
    seekBlend : float
    seekCurve : AnimationCurve
    showAnimationProps : bool
    visible : bool
    weldHeight : float
    weldSpreadBottom : float
    weldSpreadTop : float
    @property
    def uniqueID(self) -> int: ...
    @uniqueID.setter
    def uniqueID(self, value: int) -> int: ...
    def BuildAOSpheres(self, aoSpheres: List_1[TreeAOSphere]) -> None: ...
    def GetRadiusAtTime(self, node: TreeNode, time: float, includeModifications: bool) -> float: ...
    def UpdateMatrix(self) -> None: ...
    def UpdateMesh(self, materials: List_1[TreeMaterial], verts: List_1[TreeVertex], tris: List_1[TreeTriangle], aoSpheres: List_1[TreeAOSphere], buildFlags: int, adaptiveQuality: float, aoDensity: float) -> None: ...
    def UpdateParameters(self) -> None: ...
    def UpdateSpline(self, node: TreeNode) -> None: ...
    def UpdateSplines(self) -> None: ...

    class GeometryMode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Branch : TreeGroupBranch.GeometryMode # 0
        BranchFrond : TreeGroupBranch.GeometryMode # 1
        Frond : TreeGroupBranch.GeometryMode # 2



class TreeGroupLeaf(TreeGroup):
    def __init__(self) -> None: ...
    animationEdge : float
    animationPrimary : float
    animationSecondary : float
    childGroupIDs : Array_1[int]
    distributionCurve : AnimationCurve
    distributionFrequency : int
    distributionMode : TreeGroup.DistributionMode
    distributionNodes : int
    distributionPitch : float
    distributionPitchCurve : AnimationCurve
    distributionScale : float
    distributionScaleCurve : AnimationCurve
    distributionTwirl : float
    geometryMode : int
    horizontalAlign : float
    instanceMesh : GameObject
    lockFlags : int
    materialLeaf : Material
    nodeIDs : Array_1[int]
    parentGroupID : int
    perpendicularAlign : float
    seed : int
    showAnimationProps : bool
    size : Vector2
    visible : bool
    @property
    def uniqueID(self) -> int: ...
    @uniqueID.setter
    def uniqueID(self, value: int) -> int: ...
    def BuildAOSpheres(self, aoSpheres: List_1[TreeAOSphere]) -> None: ...
    def CanHaveSubGroups(self) -> bool: ...
    def UpdateMatrix(self) -> None: ...
    def UpdateMesh(self, materials: List_1[TreeMaterial], verts: List_1[TreeVertex], tris: List_1[TreeTriangle], aoSpheres: List_1[TreeAOSphere], buildFlags: int, adaptiveQuality: float, aoDensity: float) -> None: ...
    def UpdateParameters(self) -> None: ...

    class GeometryMode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        PLANE : TreeGroupLeaf.GeometryMode # 0
        CROSS : TreeGroupLeaf.GeometryMode # 1
        TRI_CROSS : TreeGroupLeaf.GeometryMode # 2
        BILLBOARD : TreeGroupLeaf.GeometryMode # 3
        MESH : TreeGroupLeaf.GeometryMode # 4



class TreeGroupRoot(TreeGroup):
    def __init__(self) -> None: ...
    adaptiveLODQuality : float
    animationEdge : float
    animationPrimary : float
    animationSecondary : float
    aoDensity : float
    childGroupIDs : Array_1[int]
    distributionCurve : AnimationCurve
    distributionFrequency : int
    distributionMode : TreeGroup.DistributionMode
    distributionNodes : int
    distributionPitch : float
    distributionPitchCurve : AnimationCurve
    distributionScale : float
    distributionScaleCurve : AnimationCurve
    distributionTwirl : float
    enableAmbientOcclusion : bool
    enableMaterialOptimize : bool
    enableWelding : bool
    groundOffset : float
    lockFlags : int
    nodeIDs : Array_1[int]
    parentGroupID : int
    rootMatrix : Matrix4x4
    rootSpread : float
    seed : int
    shadowTextureQuality : int
    showAnimationProps : bool
    visible : bool
    @property
    def uniqueID(self) -> int: ...
    @uniqueID.setter
    def uniqueID(self, value: int) -> int: ...
    def CanHaveSubGroups(self) -> bool: ...
    def SetRootMatrix(self, m: Matrix4x4) -> None: ...
    def UpdateParameters(self) -> None: ...


class TreeMaterial:
    def __init__(self) -> None: ...
    material : Material
    tileV : bool


class TreeNode:
    def __init__(self) -> None: ...
    angle : float
    animSeed : float
    baseAngle : float
    breakOffset : float
    capRange : float
    groupID : int
    matrix : Matrix4x4
    offset : float
    parentID : int
    pitch : float
    rotation : Quaternion
    scale : float
    seed : int
    size : float
    spline : TreeSpline
    triEnd : int
    triStart : int
    vertEnd : int
    vertStart : int
    visible : bool
    @property
    def uniqueID(self) -> int: ...
    @uniqueID.setter
    def uniqueID(self, value: int) -> int: ...
    def GetLocalMatrixAtTime(self, time: float) -> Matrix4x4: ...
    def GetPropertiesAtTime(self, time: float, pos: clr.Reference[Vector3], rot: clr.Reference[Quaternion], rad: clr.Reference[float]) -> None: ...
    def GetRadiusAtTime(self, time: float) -> float: ...
    def GetScale(self) -> float: ...
    def GetSurfaceAngleAtTime(self, time: float) -> float: ...


class TreeSpline:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, o: TreeSpline) -> None: ...
    nodes : Array_1[SplineNode]
    tension : float
    def AddPoint(self, pos: Vector3, timeInSeconds: float) -> None: ...
    def GetApproximateLength(self) -> float: ...
    def GetNodeCount(self) -> int: ...
    def GetNodes(self) -> Array_1[SplineNode]: ...
    def GetPositionAtTime(self, timeParam: float) -> Vector3: ...
    def GetRotationAtTime(self, timeParam: float) -> Quaternion: ...
    def RemoveNode(self, c: int) -> None: ...
    def Reset(self) -> None: ...
    def SetNodeCount(self, c: int) -> None: ...
    def UpdateRotations(self) -> None: ...
    def UpdateTime(self) -> None: ...


class TreeTriangle:
    @typing.overload
    def __init__(self, material: int, v0: int, v1: int, v2: int) -> None: ...
    @typing.overload
    def __init__(self, material: int, v0: int, v1: int, v2: int, isBillboard: bool) -> None: ...
    @typing.overload
    def __init__(self, material: int, v0: int, v1: int, v2: int, isBillboard: bool, tileV: bool, isCutout: bool) -> None: ...
    isBillboard : bool
    isCutout : bool
    materialIndex : int
    tileV : bool
    v : Array_1[int]
    def flip(self) -> None: ...


class TreeVertex:
    def __init__(self) -> None: ...
    color : Color
    flag : bool
    nor : Vector3
    pos : Vector3
    tangent : Vector4
    uv0 : Vector2
    uv1 : Vector2
    def Lerp4(self, tv: Array_1[TreeVertex], factor: Vector2) -> None: ...
    def SetAmbientOcclusion(self, ao: float) -> None: ...
    def SetAnimationProperties(self, primaryFactor: float, secondaryFactor: float, edgeFactor: float, phase: float) -> None: ...

