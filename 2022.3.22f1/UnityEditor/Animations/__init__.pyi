import typing, clr
from UnityEngine import RuntimeAnimatorController, AnimationClip, HideFlags, AnimatorControllerParameter, StateMachineBehaviour, Animator, Motion, AnimatorControllerParameterType, AvatarMask, Object, Vector3, Vector2, GameObject, Component
from System import Array_1
from UnityEditor import MonoScript, EditorCurveBinding

class AnimatorCondition:
    @property
    def mode(self) -> AnimatorConditionMode: ...
    @mode.setter
    def mode(self, value: AnimatorConditionMode) -> AnimatorConditionMode: ...
    @property
    def parameter(self) -> str: ...
    @parameter.setter
    def parameter(self, value: str) -> str: ...
    @property
    def threshold(self) -> float: ...
    @threshold.setter
    def threshold(self, value: float) -> float: ...


class AnimatorConditionMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    If : AnimatorConditionMode # 1
    IfNot : AnimatorConditionMode # 2
    Greater : AnimatorConditionMode # 3
    Less : AnimatorConditionMode # 4
    Equals : AnimatorConditionMode # 6
    NotEqual : AnimatorConditionMode # 7


class AnimatorController(RuntimeAnimatorController):
    def __init__(self) -> None: ...
    @property
    def animationClips(self) -> Array_1[AnimationClip]: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def layers(self) -> Array_1[AnimatorControllerLayer]: ...
    @layers.setter
    def layers(self, value: Array_1[AnimatorControllerLayer]) -> Array_1[AnimatorControllerLayer]: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def parameters(self) -> Array_1[AnimatorControllerParameter]: ...
    @parameters.setter
    def parameters(self, value: Array_1[AnimatorControllerParameter]) -> Array_1[AnimatorControllerParameter]: ...
    @staticmethod
    def AllocateAnimatorClip(name: str) -> AnimationClip: ...
    @staticmethod
    def CreateAnimatorControllerAtPath(path: str) -> AnimatorController: ...
    @staticmethod
    def CreateAnimatorControllerAtPathWithClip(path: str, clip: AnimationClip) -> AnimatorController: ...
    @staticmethod
    def CreateStateMachineBehaviour(script: MonoScript) -> int: ...
    @staticmethod
    def FindStateMachineBehaviourContext(behaviour: StateMachineBehaviour) -> Array_1[StateMachineBehaviourContext]: ...
    def GetStateEffectiveBehaviours(self, state: AnimatorState, layerIndex: int) -> Array_1[StateMachineBehaviour]: ...
    def MakeUniqueLayerName(self, name: str) -> str: ...
    def MakeUniqueParameterName(self, name: str) -> str: ...
    def RemoveLayer(self, index: int) -> None: ...
    @staticmethod
    def SetAnimatorController(animator: Animator, controller: AnimatorController) -> None: ...
    def SetStateEffectiveBehaviours(self, state: AnimatorState, layerIndex: int, behaviours: Array_1[StateMachineBehaviour]) -> None: ...
    # Skipped AddEffectiveStateMachineBehaviour due to it being static, abstract and generic.

    AddEffectiveStateMachineBehaviour : AddEffectiveStateMachineBehaviour_MethodGroup
    class AddEffectiveStateMachineBehaviour_MethodGroup:
        def __getitem__(self, t:typing.Type[AddEffectiveStateMachineBehaviour_1_T1]) -> AddEffectiveStateMachineBehaviour_1[AddEffectiveStateMachineBehaviour_1_T1]: ...

        AddEffectiveStateMachineBehaviour_1_T1 = typing.TypeVar('AddEffectiveStateMachineBehaviour_1_T1')
        class AddEffectiveStateMachineBehaviour_1(typing.Generic[AddEffectiveStateMachineBehaviour_1_T1]):
            AddEffectiveStateMachineBehaviour_1_T = AnimatorController.AddEffectiveStateMachineBehaviour_MethodGroup.AddEffectiveStateMachineBehaviour_1_T1
            def __call__(self, state: AnimatorState, layerIndex: int) -> AddEffectiveStateMachineBehaviour_1_T:...

        def __call__(self, stateMachineBehaviourType: typing.Type[typing.Any], state: AnimatorState, layerIndex: int) -> StateMachineBehaviour:...

    # Skipped AddLayer due to it being static, abstract and generic.

    AddLayer : AddLayer_MethodGroup
    class AddLayer_MethodGroup:
        @typing.overload
        def __call__(self, name: str) -> None:...
        @typing.overload
        def __call__(self, layer: AnimatorControllerLayer) -> None:...

    # Skipped AddMotion due to it being static, abstract and generic.

    AddMotion : AddMotion_MethodGroup
    class AddMotion_MethodGroup:
        @typing.overload
        def __call__(self, motion: Motion) -> AnimatorState:...
        @typing.overload
        def __call__(self, motion: Motion, layerIndex: int) -> AnimatorState:...

    # Skipped AddParameter due to it being static, abstract and generic.

    AddParameter : AddParameter_MethodGroup
    class AddParameter_MethodGroup:
        @typing.overload
        def __call__(self, paramater: AnimatorControllerParameter) -> None:...
        @typing.overload
        def __call__(self, name: str, type: AnimatorControllerParameterType) -> None:...

    # Skipped CreateBlendTreeInController due to it being static, abstract and generic.

    CreateBlendTreeInController : CreateBlendTreeInController_MethodGroup
    class CreateBlendTreeInController_MethodGroup:
        @typing.overload
        def __call__(self, name: str, tree: clr.Reference[BlendTree]) -> AnimatorState:...
        @typing.overload
        def __call__(self, name: str, tree: clr.Reference[BlendTree], layerIndex: int) -> AnimatorState:...

    # Skipped GetBehaviours due to it being static, abstract and generic.

    GetBehaviours : GetBehaviours_MethodGroup
    class GetBehaviours_MethodGroup:
        def __getitem__(self, t:typing.Type[GetBehaviours_1_T1]) -> GetBehaviours_1[GetBehaviours_1_T1]: ...

        GetBehaviours_1_T1 = typing.TypeVar('GetBehaviours_1_T1')
        class GetBehaviours_1(typing.Generic[GetBehaviours_1_T1]):
            GetBehaviours_1_T = AnimatorController.GetBehaviours_MethodGroup.GetBehaviours_1_T1
            def __call__(self) -> Array_1[GetBehaviours_1_T]:...


    # Skipped GetStateEffectiveMotion due to it being static, abstract and generic.

    GetStateEffectiveMotion : GetStateEffectiveMotion_MethodGroup
    class GetStateEffectiveMotion_MethodGroup:
        @typing.overload
        def __call__(self, state: AnimatorState) -> Motion:...
        @typing.overload
        def __call__(self, state: AnimatorState, layerIndex: int) -> Motion:...

    # Skipped RemoveParameter due to it being static, abstract and generic.

    RemoveParameter : RemoveParameter_MethodGroup
    class RemoveParameter_MethodGroup:
        @typing.overload
        def __call__(self, index: int) -> None:...
        @typing.overload
        def __call__(self, parameter: AnimatorControllerParameter) -> None:...

    # Skipped SetStateEffectiveMotion due to it being static, abstract and generic.

    SetStateEffectiveMotion : SetStateEffectiveMotion_MethodGroup
    class SetStateEffectiveMotion_MethodGroup:
        @typing.overload
        def __call__(self, state: AnimatorState, motion: Motion) -> None:...
        @typing.overload
        def __call__(self, state: AnimatorState, motion: Motion, layerIndex: int) -> None:...



class AnimatorControllerLayer:
    def __init__(self) -> None: ...
    @property
    def avatarMask(self) -> AvatarMask: ...
    @avatarMask.setter
    def avatarMask(self, value: AvatarMask) -> AvatarMask: ...
    @property
    def blendingMode(self) -> AnimatorLayerBlendingMode: ...
    @blendingMode.setter
    def blendingMode(self, value: AnimatorLayerBlendingMode) -> AnimatorLayerBlendingMode: ...
    @property
    def defaultWeight(self) -> float: ...
    @defaultWeight.setter
    def defaultWeight(self, value: float) -> float: ...
    @property
    def iKPass(self) -> bool: ...
    @iKPass.setter
    def iKPass(self, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def stateMachine(self) -> AnimatorStateMachine: ...
    @stateMachine.setter
    def stateMachine(self, value: AnimatorStateMachine) -> AnimatorStateMachine: ...
    @property
    def syncedLayerAffectsTiming(self) -> bool: ...
    @syncedLayerAffectsTiming.setter
    def syncedLayerAffectsTiming(self, value: bool) -> bool: ...
    @property
    def syncedLayerIndex(self) -> int: ...
    @syncedLayerIndex.setter
    def syncedLayerIndex(self, value: int) -> int: ...
    def GetOverrideBehaviours(self, state: AnimatorState) -> Array_1[StateMachineBehaviour]: ...
    def GetOverrideMotion(self, state: AnimatorState) -> Motion: ...
    def SetOverrideBehaviours(self, state: AnimatorState, behaviours: Array_1[StateMachineBehaviour]) -> None: ...
    def SetOverrideMotion(self, state: AnimatorState, motion: Motion) -> None: ...


class AnimatorLayerBlendingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Override : AnimatorLayerBlendingMode # 0
    Additive : AnimatorLayerBlendingMode # 1


class AnimatorState(Object):
    def __init__(self) -> None: ...
    @property
    def behaviours(self) -> Array_1[StateMachineBehaviour]: ...
    @behaviours.setter
    def behaviours(self, value: Array_1[StateMachineBehaviour]) -> Array_1[StateMachineBehaviour]: ...
    @property
    def cycleOffset(self) -> float: ...
    @cycleOffset.setter
    def cycleOffset(self, value: float) -> float: ...
    @property
    def cycleOffsetParameter(self) -> str: ...
    @cycleOffsetParameter.setter
    def cycleOffsetParameter(self, value: str) -> str: ...
    @property
    def cycleOffsetParameterActive(self) -> bool: ...
    @cycleOffsetParameterActive.setter
    def cycleOffsetParameterActive(self, value: bool) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def iKOnFeet(self) -> bool: ...
    @iKOnFeet.setter
    def iKOnFeet(self, value: bool) -> bool: ...
    @property
    def mirror(self) -> bool: ...
    @mirror.setter
    def mirror(self, value: bool) -> bool: ...
    @property
    def mirrorParameter(self) -> str: ...
    @mirrorParameter.setter
    def mirrorParameter(self, value: str) -> str: ...
    @property
    def mirrorParameterActive(self) -> bool: ...
    @mirrorParameterActive.setter
    def mirrorParameterActive(self, value: bool) -> bool: ...
    @property
    def motion(self) -> Motion: ...
    @motion.setter
    def motion(self, value: Motion) -> Motion: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def nameHash(self) -> int: ...
    @property
    def speed(self) -> float: ...
    @speed.setter
    def speed(self, value: float) -> float: ...
    @property
    def speedParameter(self) -> str: ...
    @speedParameter.setter
    def speedParameter(self, value: str) -> str: ...
    @property
    def speedParameterActive(self) -> bool: ...
    @speedParameterActive.setter
    def speedParameterActive(self, value: bool) -> bool: ...
    @property
    def tag(self) -> str: ...
    @tag.setter
    def tag(self, value: str) -> str: ...
    @property
    def timeParameter(self) -> str: ...
    @timeParameter.setter
    def timeParameter(self, value: str) -> str: ...
    @property
    def timeParameterActive(self) -> bool: ...
    @timeParameterActive.setter
    def timeParameterActive(self, value: bool) -> bool: ...
    @property
    def transitions(self) -> Array_1[AnimatorStateTransition]: ...
    @transitions.setter
    def transitions(self, value: Array_1[AnimatorStateTransition]) -> Array_1[AnimatorStateTransition]: ...
    @property
    def uniqueName(self) -> str: ...
    @property
    def uniqueNameHash(self) -> int: ...
    @property
    def writeDefaultValues(self) -> bool: ...
    @writeDefaultValues.setter
    def writeDefaultValues(self, value: bool) -> bool: ...
    def GetMotion(self) -> Motion: ...
    def RemoveTransition(self, transition: AnimatorStateTransition) -> None: ...
    # Skipped AddExitTransition due to it being static, abstract and generic.

    AddExitTransition : AddExitTransition_MethodGroup
    class AddExitTransition_MethodGroup:
        @typing.overload
        def __call__(self) -> AnimatorStateTransition:...
        @typing.overload
        def __call__(self, defaultExitTime: bool) -> AnimatorStateTransition:...

    # Skipped AddStateMachineBehaviour due to it being static, abstract and generic.

    AddStateMachineBehaviour : AddStateMachineBehaviour_MethodGroup
    class AddStateMachineBehaviour_MethodGroup:
        def __getitem__(self, t:typing.Type[AddStateMachineBehaviour_1_T1]) -> AddStateMachineBehaviour_1[AddStateMachineBehaviour_1_T1]: ...

        AddStateMachineBehaviour_1_T1 = typing.TypeVar('AddStateMachineBehaviour_1_T1')
        class AddStateMachineBehaviour_1(typing.Generic[AddStateMachineBehaviour_1_T1]):
            AddStateMachineBehaviour_1_T = AnimatorState.AddStateMachineBehaviour_MethodGroup.AddStateMachineBehaviour_1_T1
            def __call__(self) -> AddStateMachineBehaviour_1_T:...

        def __call__(self, stateMachineBehaviourType: typing.Type[typing.Any]) -> StateMachineBehaviour:...

    # Skipped AddTransition due to it being static, abstract and generic.

    AddTransition : AddTransition_MethodGroup
    class AddTransition_MethodGroup:
        @typing.overload
        def __call__(self, transition: AnimatorStateTransition) -> None:...
        @typing.overload
        def __call__(self, destinationState: AnimatorState) -> AnimatorStateTransition:...
        @typing.overload
        def __call__(self, destinationStateMachine: AnimatorStateMachine) -> AnimatorStateTransition:...
        @typing.overload
        def __call__(self, destinationStateMachine: AnimatorStateMachine, defaultExitTime: bool) -> AnimatorStateTransition:...
        @typing.overload
        def __call__(self, destinationState: AnimatorState, defaultExitTime: bool) -> AnimatorStateTransition:...



class AnimatorStateMachine(Object):
    def __init__(self) -> None: ...
    @property
    def anyStatePosition(self) -> Vector3: ...
    @anyStatePosition.setter
    def anyStatePosition(self, value: Vector3) -> Vector3: ...
    @property
    def anyStateTransitions(self) -> Array_1[AnimatorStateTransition]: ...
    @anyStateTransitions.setter
    def anyStateTransitions(self, value: Array_1[AnimatorStateTransition]) -> Array_1[AnimatorStateTransition]: ...
    @property
    def behaviours(self) -> Array_1[StateMachineBehaviour]: ...
    @behaviours.setter
    def behaviours(self, value: Array_1[StateMachineBehaviour]) -> Array_1[StateMachineBehaviour]: ...
    @property
    def defaultState(self) -> AnimatorState: ...
    @defaultState.setter
    def defaultState(self, value: AnimatorState) -> AnimatorState: ...
    @property
    def entryPosition(self) -> Vector3: ...
    @entryPosition.setter
    def entryPosition(self, value: Vector3) -> Vector3: ...
    @property
    def entryTransitions(self) -> Array_1[AnimatorTransition]: ...
    @entryTransitions.setter
    def entryTransitions(self, value: Array_1[AnimatorTransition]) -> Array_1[AnimatorTransition]: ...
    @property
    def exitPosition(self) -> Vector3: ...
    @exitPosition.setter
    def exitPosition(self, value: Vector3) -> Vector3: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def parentStateMachinePosition(self) -> Vector3: ...
    @parentStateMachinePosition.setter
    def parentStateMachinePosition(self, value: Vector3) -> Vector3: ...
    @property
    def stateMachines(self) -> Array_1[ChildAnimatorStateMachine]: ...
    @stateMachines.setter
    def stateMachines(self, value: Array_1[ChildAnimatorStateMachine]) -> Array_1[ChildAnimatorStateMachine]: ...
    @property
    def states(self) -> Array_1[ChildAnimatorState]: ...
    @states.setter
    def states(self, value: Array_1[ChildAnimatorState]) -> Array_1[ChildAnimatorState]: ...
    def AddStateMachineExitTransition(self, sourceStateMachine: AnimatorStateMachine) -> AnimatorTransition: ...
    def GetStateMachineTransitions(self, sourceStateMachine: AnimatorStateMachine) -> Array_1[AnimatorTransition]: ...
    def MakeUniqueStateMachineName(self, name: str) -> str: ...
    def MakeUniqueStateName(self, name: str) -> str: ...
    def RemoveAnyStateTransition(self, transition: AnimatorStateTransition) -> bool: ...
    def RemoveEntryTransition(self, transition: AnimatorTransition) -> bool: ...
    def RemoveState(self, state: AnimatorState) -> None: ...
    def RemoveStateMachine(self, stateMachine: AnimatorStateMachine) -> None: ...
    def RemoveStateMachineTransition(self, sourceStateMachine: AnimatorStateMachine, transition: AnimatorTransition) -> bool: ...
    def SetStateMachineTransitions(self, sourceStateMachine: AnimatorStateMachine, transitions: Array_1[AnimatorTransition]) -> None: ...
    # Skipped AddAnyStateTransition due to it being static, abstract and generic.

    AddAnyStateTransition : AddAnyStateTransition_MethodGroup
    class AddAnyStateTransition_MethodGroup:
        @typing.overload
        def __call__(self, destinationState: AnimatorState) -> AnimatorStateTransition:...
        @typing.overload
        def __call__(self, destinationStateMachine: AnimatorStateMachine) -> AnimatorStateTransition:...

    # Skipped AddEntryTransition due to it being static, abstract and generic.

    AddEntryTransition : AddEntryTransition_MethodGroup
    class AddEntryTransition_MethodGroup:
        @typing.overload
        def __call__(self, destinationState: AnimatorState) -> AnimatorTransition:...
        @typing.overload
        def __call__(self, destinationStateMachine: AnimatorStateMachine) -> AnimatorTransition:...

    # Skipped AddState due to it being static, abstract and generic.

    AddState : AddState_MethodGroup
    class AddState_MethodGroup:
        @typing.overload
        def __call__(self, name: str) -> AnimatorState:...
        @typing.overload
        def __call__(self, name: str, position: Vector3) -> AnimatorState:...
        @typing.overload
        def __call__(self, state: AnimatorState, position: Vector3) -> None:...

    # Skipped AddStateMachine due to it being static, abstract and generic.

    AddStateMachine : AddStateMachine_MethodGroup
    class AddStateMachine_MethodGroup:
        @typing.overload
        def __call__(self, name: str) -> AnimatorStateMachine:...
        @typing.overload
        def __call__(self, name: str, position: Vector3) -> AnimatorStateMachine:...
        @typing.overload
        def __call__(self, stateMachine: AnimatorStateMachine, position: Vector3) -> None:...

    # Skipped AddStateMachineBehaviour due to it being static, abstract and generic.

    AddStateMachineBehaviour : AddStateMachineBehaviour_MethodGroup
    class AddStateMachineBehaviour_MethodGroup:
        def __getitem__(self, t:typing.Type[AddStateMachineBehaviour_1_T1]) -> AddStateMachineBehaviour_1[AddStateMachineBehaviour_1_T1]: ...

        AddStateMachineBehaviour_1_T1 = typing.TypeVar('AddStateMachineBehaviour_1_T1')
        class AddStateMachineBehaviour_1(typing.Generic[AddStateMachineBehaviour_1_T1]):
            AddStateMachineBehaviour_1_T = AnimatorStateMachine.AddStateMachineBehaviour_MethodGroup.AddStateMachineBehaviour_1_T1
            def __call__(self) -> AddStateMachineBehaviour_1_T:...

        def __call__(self, stateMachineBehaviourType: typing.Type[typing.Any]) -> StateMachineBehaviour:...

    # Skipped AddStateMachineTransition due to it being static, abstract and generic.

    AddStateMachineTransition : AddStateMachineTransition_MethodGroup
    class AddStateMachineTransition_MethodGroup:
        @typing.overload
        def __call__(self, sourceStateMachine: AnimatorStateMachine) -> AnimatorTransition:...
        @typing.overload
        def __call__(self, sourceStateMachine: AnimatorStateMachine, destinationState: AnimatorState) -> AnimatorTransition:...
        @typing.overload
        def __call__(self, sourceStateMachine: AnimatorStateMachine, destinationStateMachine: AnimatorStateMachine) -> AnimatorTransition:...



class AnimatorStateTransition(AnimatorTransitionBase):
    def __init__(self) -> None: ...
    @property
    def canTransitionToSelf(self) -> bool: ...
    @canTransitionToSelf.setter
    def canTransitionToSelf(self, value: bool) -> bool: ...
    @property
    def conditions(self) -> Array_1[AnimatorCondition]: ...
    @conditions.setter
    def conditions(self, value: Array_1[AnimatorCondition]) -> Array_1[AnimatorCondition]: ...
    @property
    def destinationState(self) -> AnimatorState: ...
    @destinationState.setter
    def destinationState(self, value: AnimatorState) -> AnimatorState: ...
    @property
    def destinationStateMachine(self) -> AnimatorStateMachine: ...
    @destinationStateMachine.setter
    def destinationStateMachine(self, value: AnimatorStateMachine) -> AnimatorStateMachine: ...
    @property
    def duration(self) -> float: ...
    @duration.setter
    def duration(self, value: float) -> float: ...
    @property
    def exitTime(self) -> float: ...
    @exitTime.setter
    def exitTime(self, value: float) -> float: ...
    @property
    def hasExitTime(self) -> bool: ...
    @hasExitTime.setter
    def hasExitTime(self, value: bool) -> bool: ...
    @property
    def hasFixedDuration(self) -> bool: ...
    @hasFixedDuration.setter
    def hasFixedDuration(self, value: bool) -> bool: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def interruptionSource(self) -> TransitionInterruptionSource: ...
    @interruptionSource.setter
    def interruptionSource(self, value: TransitionInterruptionSource) -> TransitionInterruptionSource: ...
    @property
    def isExit(self) -> bool: ...
    @isExit.setter
    def isExit(self, value: bool) -> bool: ...
    @property
    def mute(self) -> bool: ...
    @mute.setter
    def mute(self, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def offset(self) -> float: ...
    @offset.setter
    def offset(self, value: float) -> float: ...
    @property
    def orderedInterruption(self) -> bool: ...
    @orderedInterruption.setter
    def orderedInterruption(self, value: bool) -> bool: ...
    @property
    def solo(self) -> bool: ...
    @solo.setter
    def solo(self, value: bool) -> bool: ...


class AnimatorTransition(AnimatorTransitionBase):
    def __init__(self) -> None: ...
    @property
    def conditions(self) -> Array_1[AnimatorCondition]: ...
    @conditions.setter
    def conditions(self, value: Array_1[AnimatorCondition]) -> Array_1[AnimatorCondition]: ...
    @property
    def destinationState(self) -> AnimatorState: ...
    @destinationState.setter
    def destinationState(self, value: AnimatorState) -> AnimatorState: ...
    @property
    def destinationStateMachine(self) -> AnimatorStateMachine: ...
    @destinationStateMachine.setter
    def destinationStateMachine(self, value: AnimatorStateMachine) -> AnimatorStateMachine: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def isExit(self) -> bool: ...
    @isExit.setter
    def isExit(self, value: bool) -> bool: ...
    @property
    def mute(self) -> bool: ...
    @mute.setter
    def mute(self, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def solo(self) -> bool: ...
    @solo.setter
    def solo(self, value: bool) -> bool: ...


class AnimatorTransitionBase(Object):
    @property
    def conditions(self) -> Array_1[AnimatorCondition]: ...
    @conditions.setter
    def conditions(self, value: Array_1[AnimatorCondition]) -> Array_1[AnimatorCondition]: ...
    @property
    def destinationState(self) -> AnimatorState: ...
    @destinationState.setter
    def destinationState(self, value: AnimatorState) -> AnimatorState: ...
    @property
    def destinationStateMachine(self) -> AnimatorStateMachine: ...
    @destinationStateMachine.setter
    def destinationStateMachine(self, value: AnimatorStateMachine) -> AnimatorStateMachine: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def isExit(self) -> bool: ...
    @isExit.setter
    def isExit(self, value: bool) -> bool: ...
    @property
    def mute(self) -> bool: ...
    @mute.setter
    def mute(self, value: bool) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def solo(self) -> bool: ...
    @solo.setter
    def solo(self, value: bool) -> bool: ...
    def AddCondition(self, mode: AnimatorConditionMode, threshold: float, parameter: str) -> None: ...
    def GetDisplayName(self, source: Object) -> str: ...
    def RemoveCondition(self, condition: AnimatorCondition) -> None: ...


class BlendTree(Motion):
    def __init__(self) -> None: ...
    @property
    def apparentSpeed(self) -> float: ...
    @property
    def averageAngularSpeed(self) -> float: ...
    @property
    def averageDuration(self) -> float: ...
    @property
    def averageSpeed(self) -> Vector3: ...
    @property
    def blendParameter(self) -> str: ...
    @blendParameter.setter
    def blendParameter(self, value: str) -> str: ...
    @property
    def blendParameterY(self) -> str: ...
    @blendParameterY.setter
    def blendParameterY(self, value: str) -> str: ...
    @property
    def blendType(self) -> BlendTreeType: ...
    @blendType.setter
    def blendType(self, value: BlendTreeType) -> BlendTreeType: ...
    @property
    def children(self) -> Array_1[ChildMotion]: ...
    @children.setter
    def children(self, value: Array_1[ChildMotion]) -> Array_1[ChildMotion]: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def isAnimatorMotion(self) -> bool: ...
    @property
    def isHumanMotion(self) -> bool: ...
    @property
    def isLooping(self) -> bool: ...
    @property
    def legacy(self) -> bool: ...
    @property
    def maxThreshold(self) -> float: ...
    @maxThreshold.setter
    def maxThreshold(self, value: float) -> float: ...
    @property
    def minThreshold(self) -> float: ...
    @minThreshold.setter
    def minThreshold(self, value: float) -> float: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def useAutomaticThresholds(self) -> bool: ...
    @useAutomaticThresholds.setter
    def useAutomaticThresholds(self, value: bool) -> bool: ...
    def RemoveChild(self, index: int) -> None: ...
    # Skipped AddChild due to it being static, abstract and generic.

    AddChild : AddChild_MethodGroup
    class AddChild_MethodGroup:
        @typing.overload
        def __call__(self, motion: Motion) -> None:...
        @typing.overload
        def __call__(self, motion: Motion, threshold: float) -> None:...
        @typing.overload
        def __call__(self, motion: Motion, position: Vector2) -> None:...

    # Skipped CreateBlendTreeChild due to it being static, abstract and generic.

    CreateBlendTreeChild : CreateBlendTreeChild_MethodGroup
    class CreateBlendTreeChild_MethodGroup:
        @typing.overload
        def __call__(self, threshold: float) -> BlendTree:...
        @typing.overload
        def __call__(self, position: Vector2) -> BlendTree:...



class BlendTreeType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Simple1D : BlendTreeType # 0
    SimpleDirectional2D : BlendTreeType # 1
    FreeformDirectional2D : BlendTreeType # 2
    FreeformCartesian2D : BlendTreeType # 3
    Direct : BlendTreeType # 4


class ChildAnimatorState:
    @property
    def position(self) -> Vector3: ...
    @position.setter
    def position(self, value: Vector3) -> Vector3: ...
    @property
    def state(self) -> AnimatorState: ...
    @state.setter
    def state(self, value: AnimatorState) -> AnimatorState: ...


class ChildAnimatorStateMachine:
    @property
    def position(self) -> Vector3: ...
    @position.setter
    def position(self, value: Vector3) -> Vector3: ...
    @property
    def stateMachine(self) -> AnimatorStateMachine: ...
    @stateMachine.setter
    def stateMachine(self, value: AnimatorStateMachine) -> AnimatorStateMachine: ...


class ChildMotion:
    @property
    def cycleOffset(self) -> float: ...
    @cycleOffset.setter
    def cycleOffset(self, value: float) -> float: ...
    @property
    def directBlendParameter(self) -> str: ...
    @directBlendParameter.setter
    def directBlendParameter(self, value: str) -> str: ...
    @property
    def mirror(self) -> bool: ...
    @mirror.setter
    def mirror(self, value: bool) -> bool: ...
    @property
    def motion(self) -> Motion: ...
    @motion.setter
    def motion(self, value: Motion) -> Motion: ...
    @property
    def position(self) -> Vector2: ...
    @position.setter
    def position(self, value: Vector2) -> Vector2: ...
    @property
    def threshold(self) -> float: ...
    @threshold.setter
    def threshold(self, value: float) -> float: ...
    @property
    def timeScale(self) -> float: ...
    @timeScale.setter
    def timeScale(self, value: float) -> float: ...


class CurveFilterOptions:
    floatError : float
    keyframeReduction : bool
    positionError : float
    rotationError : float
    scaleError : float
    unrollRotation : bool


class GameObjectRecorder(Object):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, root: GameObject) -> None: ...
    @property
    def currentTime(self) -> float: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def isRecording(self) -> bool: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def root(self) -> GameObject: ...
    def Bind(self, binding: EditorCurveBinding) -> None: ...
    def BindAll(self, target: GameObject, recursive: bool) -> None: ...
    def GetBindings(self) -> Array_1[EditorCurveBinding]: ...
    def ResetRecording(self) -> None: ...
    def TakeSnapshot(self, dt: float) -> None: ...
    # Skipped BindComponent due to it being static, abstract and generic.

    BindComponent : BindComponent_MethodGroup
    class BindComponent_MethodGroup:
        def __getitem__(self, t:typing.Type[BindComponent_1_T1]) -> BindComponent_1[BindComponent_1_T1]: ...

        BindComponent_1_T1 = typing.TypeVar('BindComponent_1_T1')
        class BindComponent_1(typing.Generic[BindComponent_1_T1]):
            BindComponent_1_T = GameObjectRecorder.BindComponent_MethodGroup.BindComponent_1_T1
            def __call__(self, target: GameObject, recursive: bool) -> None:...

        @typing.overload
        def __call__(self, component: Component) -> None:...
        @typing.overload
        def __call__(self, target: GameObject, componentType: typing.Type[typing.Any], recursive: bool) -> None:...

    # Skipped BindComponentsOfType due to it being static, abstract and generic.

    BindComponentsOfType : BindComponentsOfType_MethodGroup
    class BindComponentsOfType_MethodGroup:
        def __getitem__(self, t:typing.Type[BindComponentsOfType_1_T1]) -> BindComponentsOfType_1[BindComponentsOfType_1_T1]: ...

        BindComponentsOfType_1_T1 = typing.TypeVar('BindComponentsOfType_1_T1')
        class BindComponentsOfType_1(typing.Generic[BindComponentsOfType_1_T1]):
            BindComponentsOfType_1_T = GameObjectRecorder.BindComponentsOfType_MethodGroup.BindComponentsOfType_1_T1
            def __call__(self, target: GameObject, recursive: bool) -> None:...

        def __call__(self, target: GameObject, componentType: typing.Type[typing.Any], recursive: bool) -> None:...

    # Skipped SaveToClip due to it being static, abstract and generic.

    SaveToClip : SaveToClip_MethodGroup
    class SaveToClip_MethodGroup:
        @typing.overload
        def __call__(self, clip: AnimationClip) -> None:...
        @typing.overload
        def __call__(self, clip: AnimationClip, fps: float) -> None:...
        @typing.overload
        def __call__(self, clip: AnimationClip, fps: float, filterOptions: CurveFilterOptions) -> None:...



class StateMachineBehaviourContext:
    def __init__(self) -> None: ...
    animatorController : AnimatorController
    animatorObject : Object
    layerIndex : int


class TransitionInterruptionSource(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : TransitionInterruptionSource # 0
    Source : TransitionInterruptionSource # 1
    Destination : TransitionInterruptionSource # 2
    SourceThenDestination : TransitionInterruptionSource # 3
    DestinationThenSource : TransitionInterruptionSource # 4

