import typing, clr
from System import ReadOnlySpan_1, Array, Array_1, MulticastDelegate, IAsyncResult, AsyncCallback, TimeSpan
from System.Collections.Generic import IReadOnlyList_1, IList_1, IReadOnlyDictionary_2, IEnumerable_1
from System.Collections import IList, IEnumerator
from System.Reflection import MethodInfo, AssemblyName
from System.Runtime.Serialization import ISerializable
from System.Reflection.Emit import CustomAttributeBuilder

class Capture:
    @property
    def Index(self) -> int: ...
    @Index.setter
    def Index(self, value: int) -> int: ...
    @property
    def Length(self) -> int: ...
    @Length.setter
    def Length(self, value: int) -> int: ...
    @property
    def Value(self) -> str: ...
    @property
    def ValueSpan(self) -> ReadOnlySpan_1[str]: ...
    def ToString(self) -> str: ...


class CaptureCollection(IReadOnlyList_1[Capture], IList_1[Capture], IList):
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> Capture: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def GetEnumerator(self) -> IEnumerator: ...
    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo : CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[Capture], arrayIndex: int) -> None:...
        @typing.overload
        def __call__(self, array: Array, arrayIndex: int) -> None:...



class Group(Capture):
    @property
    def Captures(self) -> CaptureCollection: ...
    @property
    def Index(self) -> int: ...
    @Index.setter
    def Index(self, value: int) -> int: ...
    @property
    def Length(self) -> int: ...
    @Length.setter
    def Length(self, value: int) -> int: ...
    @property
    def Name(self) -> str: ...
    @property
    def Success(self) -> bool: ...
    @property
    def Value(self) -> str: ...
    @property
    def ValueSpan(self) -> ReadOnlySpan_1[str]: ...
    @staticmethod
    def Synchronized(inner: Group) -> Group: ...


class GroupCollection(IReadOnlyDictionary_2[str, Group], IReadOnlyList_1[Group], IList_1[Group], IList):
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> Group: ...
    @property
    def Item(self) -> Group: ...
    @property
    def Keys(self) -> IEnumerable_1[str]: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    @property
    def Values(self) -> IEnumerable_1[Group]: ...
    def ContainsKey(self, key: str) -> bool: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def TryGetValue(self, key: str, value: clr.Reference[Group]) -> bool: ...
    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo : CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[Group], arrayIndex: int) -> None:...
        @typing.overload
        def __call__(self, array: Array, arrayIndex: int) -> None:...



class Match(Group):
    @property
    def Captures(self) -> CaptureCollection: ...
    @classmethod
    @property
    def Empty(cls) -> Match: ...
    @property
    def Groups(self) -> GroupCollection: ...
    @property
    def Index(self) -> int: ...
    @Index.setter
    def Index(self, value: int) -> int: ...
    @property
    def Length(self) -> int: ...
    @Length.setter
    def Length(self, value: int) -> int: ...
    @property
    def Name(self) -> str: ...
    @property
    def Success(self) -> bool: ...
    @property
    def Value(self) -> str: ...
    @property
    def ValueSpan(self) -> ReadOnlySpan_1[str]: ...
    def NextMatch(self) -> Match: ...
    def Result(self, replacement: str) -> str: ...
    @staticmethod
    def Synchronized(inner: Match) -> Match: ...


class MatchCollection(IReadOnlyList_1[Match], IList_1[Match], IList):
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> Match: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def GetEnumerator(self) -> IEnumerator: ...
    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo : CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[Match], arrayIndex: int) -> None:...
        @typing.overload
        def __call__(self, array: Array, arrayIndex: int) -> None:...



class MatchEvaluator(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, match: Match, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> str: ...
    def Invoke(self, match: Match) -> str: ...


class Regex(ISerializable):
    @typing.overload
    def __init__(self, pattern: str) -> None: ...
    @typing.overload
    def __init__(self, pattern: str, options: RegexOptions) -> None: ...
    @typing.overload
    def __init__(self, pattern: str, options: RegexOptions, matchTimeout: TimeSpan) -> None: ...
    InfiniteMatchTimeout : TimeSpan
    @classmethod
    @property
    def CacheSize(cls) -> int: ...
    @classmethod
    @CacheSize.setter
    def CacheSize(cls, value: int) -> int: ...
    @property
    def MatchTimeout(self) -> TimeSpan: ...
    @property
    def Options(self) -> RegexOptions: ...
    @property
    def RightToLeft(self) -> bool: ...
    @staticmethod
    def Escape(str: str) -> str: ...
    def GetGroupNames(self) -> Array_1[str]: ...
    def GetGroupNumbers(self) -> Array_1[int]: ...
    def GroupNameFromNumber(self, i: int) -> str: ...
    def GroupNumberFromName(self, name: str) -> int: ...
    def ToString(self) -> str: ...
    @staticmethod
    def Unescape(str: str) -> str: ...
    # Skipped CompileToAssembly due to it being static, abstract and generic.

    CompileToAssembly : CompileToAssembly_MethodGroup
    class CompileToAssembly_MethodGroup:
        @typing.overload
        def __call__(self, regexinfos: Array_1[RegexCompilationInfo], assemblyname: AssemblyName) -> None:...
        @typing.overload
        def __call__(self, regexinfos: Array_1[RegexCompilationInfo], assemblyname: AssemblyName, attributes: Array_1[CustomAttributeBuilder]) -> None:...
        @typing.overload
        def __call__(self, regexinfos: Array_1[RegexCompilationInfo], assemblyname: AssemblyName, attributes: Array_1[CustomAttributeBuilder], resourceFile: str) -> None:...

    # Skipped IsMatch due to it being static, abstract and generic.

    IsMatch : IsMatch_MethodGroup
    class IsMatch_MethodGroup:
        @typing.overload
        def __call__(self, input: str) -> bool:...
        @typing.overload
        def __call__(self, input: str, startat: int) -> bool:...
        @typing.overload
        def __call__(self, input: str, pattern: str) -> bool:...
        @typing.overload
        def __call__(self, input: str, pattern: str, options: RegexOptions) -> bool:...
        @typing.overload
        def __call__(self, input: str, pattern: str, options: RegexOptions, matchTimeout: TimeSpan) -> bool:...

    # Skipped Match due to it being static, abstract and generic.

    Match : Match_MethodGroup
    class Match_MethodGroup:
        @typing.overload
        def __call__(self, input: str) -> Match:...
        @typing.overload
        def __call__(self, input: str, startat: int) -> Match:...
        @typing.overload
        def __call__(self, input: str, pattern: str) -> Match:...
        @typing.overload
        def __call__(self, input: str, beginning: int, length: int) -> Match:...
        @typing.overload
        def __call__(self, input: str, pattern: str, options: RegexOptions) -> Match:...
        @typing.overload
        def __call__(self, input: str, pattern: str, options: RegexOptions, matchTimeout: TimeSpan) -> Match:...

    # Skipped Matches due to it being static, abstract and generic.

    Matches : Matches_MethodGroup
    class Matches_MethodGroup:
        @typing.overload
        def __call__(self, input: str) -> MatchCollection:...
        @typing.overload
        def __call__(self, input: str, startat: int) -> MatchCollection:...
        @typing.overload
        def __call__(self, input: str, pattern: str) -> MatchCollection:...
        @typing.overload
        def __call__(self, input: str, pattern: str, options: RegexOptions) -> MatchCollection:...
        @typing.overload
        def __call__(self, input: str, pattern: str, options: RegexOptions, matchTimeout: TimeSpan) -> MatchCollection:...

    # Skipped Replace due to it being static, abstract and generic.

    Replace : Replace_MethodGroup
    class Replace_MethodGroup:
        @typing.overload
        def __call__(self, input: str, evaluator: MatchEvaluator) -> str:...
        @typing.overload
        def __call__(self, input: str, replacement: str) -> str:...
        @typing.overload
        def __call__(self, input: str, evaluator: MatchEvaluator, count: int) -> str:...
        @typing.overload
        def __call__(self, input: str, replacement: str, count: int) -> str:...
        @typing.overload
        def __call__(self, input: str, pattern: str, evaluator: MatchEvaluator) -> str:...
        @typing.overload
        def __call__(self, input: str, pattern: str, replacement: str) -> str:...
        @typing.overload
        def __call__(self, input: str, evaluator: MatchEvaluator, count: int, startat: int) -> str:...
        @typing.overload
        def __call__(self, input: str, replacement: str, count: int, startat: int) -> str:...
        @typing.overload
        def __call__(self, input: str, pattern: str, evaluator: MatchEvaluator, options: RegexOptions) -> str:...
        @typing.overload
        def __call__(self, input: str, pattern: str, replacement: str, options: RegexOptions) -> str:...
        @typing.overload
        def __call__(self, input: str, pattern: str, evaluator: MatchEvaluator, options: RegexOptions, matchTimeout: TimeSpan) -> str:...
        @typing.overload
        def __call__(self, input: str, pattern: str, replacement: str, options: RegexOptions, matchTimeout: TimeSpan) -> str:...

    # Skipped Split due to it being static, abstract and generic.

    Split : Split_MethodGroup
    class Split_MethodGroup:
        @typing.overload
        def __call__(self, input: str) -> Array_1[str]:...
        @typing.overload
        def __call__(self, input: str, count: int) -> Array_1[str]:...
        @typing.overload
        def __call__(self, input: str, pattern: str) -> Array_1[str]:...
        @typing.overload
        def __call__(self, input: str, count: int, startat: int) -> Array_1[str]:...
        @typing.overload
        def __call__(self, input: str, pattern: str, options: RegexOptions) -> Array_1[str]:...
        @typing.overload
        def __call__(self, input: str, pattern: str, options: RegexOptions, matchTimeout: TimeSpan) -> Array_1[str]:...



class RegexCompilationInfo:
    @typing.overload
    def __init__(self, pattern: str, options: RegexOptions, name: str, fullnamespace: str, ispublic: bool) -> None: ...
    @typing.overload
    def __init__(self, pattern: str, options: RegexOptions, name: str, fullnamespace: str, ispublic: bool, matchTimeout: TimeSpan) -> None: ...
    @property
    def IsPublic(self) -> bool: ...
    @IsPublic.setter
    def IsPublic(self, value: bool) -> bool: ...
    @property
    def MatchTimeout(self) -> TimeSpan: ...
    @MatchTimeout.setter
    def MatchTimeout(self, value: TimeSpan) -> TimeSpan: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def Namespace(self) -> str: ...
    @Namespace.setter
    def Namespace(self, value: str) -> str: ...
    @property
    def Options(self) -> RegexOptions: ...
    @Options.setter
    def Options(self, value: RegexOptions) -> RegexOptions: ...
    @property
    def Pattern(self) -> str: ...
    @Pattern.setter
    def Pattern(self, value: str) -> str: ...


class RegexOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : RegexOptions # 0
    IgnoreCase : RegexOptions # 1
    Multiline : RegexOptions # 2
    ExplicitCapture : RegexOptions # 4
    Compiled : RegexOptions # 8
    Singleline : RegexOptions # 16
    IgnorePatternWhitespace : RegexOptions # 32
    RightToLeft : RegexOptions # 64
    ECMAScript : RegexOptions # 256
    CultureInvariant : RegexOptions # 512

