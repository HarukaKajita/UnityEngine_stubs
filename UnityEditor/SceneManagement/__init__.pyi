import typing, abc
from UnityEngine import Component, Object, GameObject, AsyncOperation, HideFlags, Transform, Color32, ScriptableObject, Camera
from UnityEditor import InteractionMode, SceneAsset
from UnityEngine.SceneManagement import SceneManager, Scene, LoadSceneParameters
from System import Array_1, MulticastDelegate, IAsyncResult, AsyncCallback, Func_2, Func_1, IEquatable_1
from System.Reflection import MethodInfo

class AddedComponent(PrefabOverride):
    def __init__(self) -> None: ...
    @property
    def instanceComponent(self) -> Component: ...
    @instanceComponent.setter
    def instanceComponent(self, value: Component) -> Component: ...
    def Apply(self, prefabAssetPath: str, mode: InteractionMode) -> None: ...
    def GetAssetObject(self) -> Object: ...
    def Revert(self, mode: InteractionMode) -> None: ...


class AddedGameObject(PrefabOverride):
    def __init__(self) -> None: ...
    @property
    def instanceGameObject(self) -> GameObject: ...
    @instanceGameObject.setter
    def instanceGameObject(self, value: GameObject) -> GameObject: ...
    @property
    def siblingIndex(self) -> int: ...
    @siblingIndex.setter
    def siblingIndex(self, value: int) -> int: ...
    def Apply(self, prefabAssetPath: str, mode: InteractionMode) -> None: ...
    def GetAssetObject(self) -> Object: ...
    def Revert(self, mode: InteractionMode) -> None: ...


class EditorSceneManager(SceneManager):
    def __init__(self) -> None: ...
    DefaultSceneCullingMask : int
    @classmethod
    @property
    def loadedRootSceneCount(cls) -> int: ...
    @classmethod
    @property
    def loadedSceneCount(cls) -> int: ...
    @classmethod
    @property
    def playModeStartScene(cls) -> SceneAsset: ...
    @classmethod
    @playModeStartScene.setter
    def playModeStartScene(cls, value: SceneAsset) -> SceneAsset: ...
    @classmethod
    @property
    def preventCrossSceneReferences(cls) -> bool: ...
    @classmethod
    @preventCrossSceneReferences.setter
    def preventCrossSceneReferences(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def previewSceneCount(cls) -> int: ...
    @staticmethod
    def CalculateAvailableSceneCullingMask() -> int: ...
    @staticmethod
    def ClosePreviewScene(scene: Scene) -> bool: ...
    @staticmethod
    def CloseScene(scene: Scene, removeScene: bool) -> bool: ...
    @staticmethod
    def DetectCrossSceneReferences(scene: Scene) -> bool: ...
    @staticmethod
    def EnsureUntitledSceneHasBeenSaved(dialogContent: str) -> bool: ...
    @staticmethod
    def GetSceneCullingMask(scene: Scene) -> int: ...
    @staticmethod
    def GetSceneManagerSetup() -> Array_1[SceneSetup]: ...
    @staticmethod
    def IsPreviewScene(scene: Scene) -> bool: ...
    @staticmethod
    def IsPreviewSceneObject(obj: Object) -> bool: ...
    @staticmethod
    def IsReloading(scene: Scene) -> bool: ...
    @staticmethod
    def LoadSceneAsyncInPlayMode(path: str, parameters: LoadSceneParameters) -> AsyncOperation: ...
    @staticmethod
    def LoadSceneInPlayMode(path: str, parameters: LoadSceneParameters) -> Scene: ...
    @staticmethod
    def MarkAllScenesDirty() -> None: ...
    @staticmethod
    def MarkSceneDirty(scene: Scene) -> bool: ...
    @staticmethod
    def MoveSceneAfter(src: Scene, dst: Scene) -> None: ...
    @staticmethod
    def MoveSceneBefore(src: Scene, dst: Scene) -> None: ...
    @staticmethod
    def NewPreviewScene() -> Scene: ...
    @staticmethod
    def RestoreSceneManagerSetup(value: Array_1[SceneSetup]) -> None: ...
    @staticmethod
    def SaveCurrentModifiedScenesIfUserWantsTo() -> bool: ...
    @staticmethod
    def SaveModifiedScenesIfUserWantsTo(scenes: Array_1[Scene]) -> bool: ...
    @staticmethod
    def SaveOpenScenes() -> bool: ...
    @staticmethod
    def SaveScenes(scenes: Array_1[Scene]) -> bool: ...
    @staticmethod
    def SetSceneCullingMask(scene: Scene, sceneCullingMask: int) -> None: ...
    # Skipped NewScene due to it being static, abstract and generic.

    NewScene : NewScene_MethodGroup
    class NewScene_MethodGroup:
        @typing.overload
        def __call__(self, setup: NewSceneSetup) -> Scene:...
        @typing.overload
        def __call__(self, setup: NewSceneSetup, mode: NewSceneMode) -> Scene:...

    # Skipped OpenScene due to it being static, abstract and generic.

    OpenScene : OpenScene_MethodGroup
    class OpenScene_MethodGroup:
        @typing.overload
        def __call__(self, scenePath: str) -> Scene:...
        @typing.overload
        def __call__(self, scenePath: str, mode: OpenSceneMode) -> Scene:...

    # Skipped SaveScene due to it being static, abstract and generic.

    SaveScene : SaveScene_MethodGroup
    class SaveScene_MethodGroup:
        @typing.overload
        def __call__(self, scene: Scene) -> bool:...
        @typing.overload
        def __call__(self, scene: Scene, dstScenePath: str) -> bool:...
        @typing.overload
        def __call__(self, scene: Scene, dstScenePath: str, saveAsCopy: bool) -> bool:...


    class NewSceneCreatedCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, scene: Scene, setup: NewSceneSetup, mode: NewSceneMode, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, scene: Scene, setup: NewSceneSetup, mode: NewSceneMode) -> None: ...


    class SceneClosedCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, scene: Scene, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, scene: Scene) -> None: ...


    class SceneClosingCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, scene: Scene, removingScene: bool, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, scene: Scene, removingScene: bool) -> None: ...


    class SceneDirtiedCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, scene: Scene, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, scene: Scene) -> None: ...


    class SceneManagerSetupRestoredCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, scenes: Array_1[Scene], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, scenes: Array_1[Scene]) -> None: ...


    class SceneOpenedCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, scene: Scene, mode: OpenSceneMode, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, scene: Scene, mode: OpenSceneMode) -> None: ...


    class SceneOpeningCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, path: str, mode: OpenSceneMode, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, path: str, mode: OpenSceneMode) -> None: ...


    class SceneSavedCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, scene: Scene, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, scene: Scene) -> None: ...


    class SceneSavingCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, scene: Scene, path: str, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, scene: Scene, path: str) -> None: ...



class MainStage(Stage):
    def __init__(self) -> None: ...
    @property
    def assetPath(self) -> str: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def stageHandle(self) -> StageHandle: ...


class NewSceneMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Single : NewSceneMode # 0
    Additive : NewSceneMode # 1


class NewSceneSetup(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    EmptyScene : NewSceneSetup # 0
    DefaultGameObjects : NewSceneSetup # 1


class ObjectOverride(PrefabOverride):
    def __init__(self) -> None: ...
    @property
    def coupledOverride(self) -> PrefabOverride: ...
    @coupledOverride.setter
    def coupledOverride(self, value: PrefabOverride) -> PrefabOverride: ...
    @property
    def instanceObject(self) -> Object: ...
    @instanceObject.setter
    def instanceObject(self, value: Object) -> Object: ...
    def Apply(self, prefabAssetPath: str, mode: InteractionMode) -> None: ...
    def GetAssetObject(self) -> Object: ...
    def Revert(self, mode: InteractionMode) -> None: ...


class OpenSceneMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Single : OpenSceneMode # 0
    Additive : OpenSceneMode # 1
    AdditiveWithoutLoading : OpenSceneMode # 2


class PrefabOverride(abc.ABC):
    @abc.abstractmethod
    def GetAssetObject(self) -> Object: ...
    # Skipped Apply due to it being static, abstract and generic.

    Apply : Apply_MethodGroup
    class Apply_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, mode: InteractionMode) -> None:...
        @typing.overload
        def __call__(self, prefabAssetPath: str) -> None:...
        @typing.overload
        def __call__(self, prefabAssetPath: str, mode: InteractionMode) -> None:...

    # Skipped Revert due to it being static, abstract and generic.

    Revert : Revert_MethodGroup
    class Revert_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, mode: InteractionMode) -> None:...



class PrefabStage(PreviewSceneStage):
    @property
    def assetPath(self) -> str: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def mode(self) -> PrefabStage.Mode: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def openedFromInstanceObject(self) -> GameObject: ...
    @property
    def openedFromInstanceRoot(self) -> GameObject: ...
    @property
    def prefabAssetPath(self) -> str: ...
    @property
    def prefabContentsRoot(self) -> GameObject: ...
    @property
    def scene(self) -> Scene: ...
    @scene.setter
    def scene(self, value: Scene) -> Scene: ...
    @property
    def stageHandle(self) -> StageHandle: ...
    def ClearDirtiness(self) -> None: ...
    def GetCombinedSceneCullingMaskForCamera(self) -> int: ...
    def IsPartOfPrefabContents(self, gameObject: GameObject) -> bool: ...

    class Mode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        InIsolation : PrefabStage.Mode # 0
        InContext : PrefabStage.Mode # 1



class PrefabStageUtility(abc.ABC):
    @staticmethod
    def GetCurrentPrefabStage() -> PrefabStage: ...
    @staticmethod
    def GetPrefabStage(gameObject: GameObject) -> PrefabStage: ...
    # Skipped OpenPrefab due to it being static, abstract and generic.

    OpenPrefab : OpenPrefab_MethodGroup
    class OpenPrefab_MethodGroup:
        @typing.overload
        def __call__(self, prefabAssetPath: str) -> PrefabStage:...
        @typing.overload
        def __call__(self, prefabAssetPath: str, openedFromInstance: GameObject) -> PrefabStage:...
        @typing.overload
        def __call__(self, prefabAssetPath: str, openedFromInstance: GameObject, prefabStageMode: PrefabStage.Mode) -> PrefabStage:...



class PreviewSceneStage(Stage):
    @property
    def assetPath(self) -> str: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def scene(self) -> Scene: ...
    @scene.setter
    def scene(self, value: Scene) -> Scene: ...
    @property
    def stageHandle(self) -> StageHandle: ...


class RemovedComponent(PrefabOverride):
    def __init__(self) -> None: ...
    @property
    def assetComponent(self) -> Component: ...
    @assetComponent.setter
    def assetComponent(self, value: Component) -> Component: ...
    @property
    def containingInstanceGameObject(self) -> GameObject: ...
    @containingInstanceGameObject.setter
    def containingInstanceGameObject(self, value: GameObject) -> GameObject: ...
    def Apply(self, prefabAssetPath: str, mode: InteractionMode) -> None: ...
    def GetAssetObject(self) -> Object: ...
    def Revert(self, mode: InteractionMode) -> None: ...


class RemovedGameObject(PrefabOverride):
    def __init__(self) -> None: ...
    @property
    def assetGameObject(self) -> GameObject: ...
    @assetGameObject.setter
    def assetGameObject(self, value: GameObject) -> GameObject: ...
    @property
    def parentOfRemovedGameObjectInInstance(self) -> GameObject: ...
    @parentOfRemovedGameObjectInInstance.setter
    def parentOfRemovedGameObjectInInstance(self, value: GameObject) -> GameObject: ...
    def Apply(self, prefabAssetPath: str, mode: InteractionMode) -> None: ...
    def GetAssetObject(self) -> Object: ...
    def Revert(self, mode: InteractionMode) -> None: ...


class SceneCullingMasks(abc.ABC):
    DefaultSceneCullingMask : int
    GameViewObjects : int
    MainStageSceneViewObjects : int


class SceneHierarchyHooks(abc.ABC):
    provideSubSceneName : Func_2[SceneHierarchyHooks.SubSceneInfo, str]
    provideSubScenes : Func_1[Array_1[SceneHierarchyHooks.SubSceneInfo]]
    @staticmethod
    def CanMoveTransformToScene(transform: Transform, scene: Scene) -> bool: ...
    @staticmethod
    def CanSetNewParent(transform: Transform, newParent: Transform) -> bool: ...
    @staticmethod
    def ReloadAllSceneHierarchies() -> None: ...

    class SubSceneInfo:
        color : Color32
        scene : Scene
        sceneAsset : SceneAsset
        sceneName : str
        transform : Transform
        @property
        def isValid(self) -> bool: ...



class SceneSetup:
    def __init__(self) -> None: ...
    @property
    def isActive(self) -> bool: ...
    @isActive.setter
    def isActive(self, value: bool) -> bool: ...
    @property
    def isLoaded(self) -> bool: ...
    @isLoaded.setter
    def isLoaded(self, value: bool) -> bool: ...
    @property
    def isSubScene(self) -> bool: ...
    @isSubScene.setter
    def isSubScene(self, value: bool) -> bool: ...
    @property
    def path(self) -> str: ...
    @path.setter
    def path(self, value: str) -> str: ...


class Stage(ScriptableObject, abc.ABC):
    @property
    def assetPath(self) -> str: ...
    @property
    def hideFlags(self) -> HideFlags: ...
    @hideFlags.setter
    def hideFlags(self, value: HideFlags) -> HideFlags: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def stageHandle(self) -> StageHandle: ...
    def GetCombinedSceneCullingMaskForCamera(self) -> int: ...
    # Skipped FindComponentOfType due to it being static, abstract and generic.

    FindComponentOfType : FindComponentOfType_MethodGroup
    class FindComponentOfType_MethodGroup:
        def __getitem__(self, t:typing.Type[FindComponentOfType_1_T1]) -> FindComponentOfType_1[FindComponentOfType_1_T1]: ...

        FindComponentOfType_1_T1 = typing.TypeVar('FindComponentOfType_1_T1')
        class FindComponentOfType_1(typing.Generic[FindComponentOfType_1_T1]):
            FindComponentOfType_1_T = Stage.FindComponentOfType_MethodGroup.FindComponentOfType_1_T1
            def __call__(self) -> FindComponentOfType_1_T:...


    # Skipped FindComponentsOfType due to it being static, abstract and generic.

    FindComponentsOfType : FindComponentsOfType_MethodGroup
    class FindComponentsOfType_MethodGroup:
        def __getitem__(self, t:typing.Type[FindComponentsOfType_1_T1]) -> FindComponentsOfType_1[FindComponentsOfType_1_T1]: ...

        FindComponentsOfType_1_T1 = typing.TypeVar('FindComponentsOfType_1_T1')
        class FindComponentsOfType_1(typing.Generic[FindComponentsOfType_1_T1]):
            FindComponentsOfType_1_T = Stage.FindComponentsOfType_MethodGroup.FindComponentsOfType_1_T1
            def __call__(self) -> Array_1[FindComponentsOfType_1_T]:...




class StageHandle(IEquatable_1[StageHandle]):
    def Contains(self, gameObject: GameObject) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsValid(self) -> bool: ...
    def __eq__(self, s1: StageHandle, s2: StageHandle) -> bool: ...
    def __ne__(self, s1: StageHandle, s2: StageHandle) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: StageHandle) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped FindComponentOfType due to it being static, abstract and generic.

    FindComponentOfType : FindComponentOfType_MethodGroup
    class FindComponentOfType_MethodGroup:
        def __getitem__(self, t:typing.Type[FindComponentOfType_1_T1]) -> FindComponentOfType_1[FindComponentOfType_1_T1]: ...

        FindComponentOfType_1_T1 = typing.TypeVar('FindComponentOfType_1_T1')
        class FindComponentOfType_1(typing.Generic[FindComponentOfType_1_T1]):
            FindComponentOfType_1_T = StageHandle.FindComponentOfType_MethodGroup.FindComponentOfType_1_T1
            def __call__(self) -> FindComponentOfType_1_T:...


    # Skipped FindComponentsOfType due to it being static, abstract and generic.

    FindComponentsOfType : FindComponentsOfType_MethodGroup
    class FindComponentsOfType_MethodGroup:
        def __getitem__(self, t:typing.Type[FindComponentsOfType_1_T1]) -> FindComponentsOfType_1[FindComponentsOfType_1_T1]: ...

        FindComponentsOfType_1_T1 = typing.TypeVar('FindComponentsOfType_1_T1')
        class FindComponentsOfType_1(typing.Generic[FindComponentsOfType_1_T1]):
            FindComponentsOfType_1_T = StageHandle.FindComponentsOfType_MethodGroup.FindComponentsOfType_1_T1
            def __call__(self) -> Array_1[FindComponentsOfType_1_T]:...




class StageUtility(abc.ABC):
    @staticmethod
    def GetCurrentStage() -> Stage: ...
    @staticmethod
    def GetCurrentStageHandle() -> StageHandle: ...
    @staticmethod
    def GetMainStage() -> MainStage: ...
    @staticmethod
    def GetMainStageHandle() -> StageHandle: ...
    @staticmethod
    def GoBackToPreviousStage() -> None: ...
    @staticmethod
    def GoToMainStage() -> None: ...
    @staticmethod
    def GoToStage(stage: Stage, setAsFirstItemAfterMainStage: bool) -> None: ...
    @staticmethod
    def IsGameObjectRenderedByCamera(gameObject: GameObject, camera: Camera) -> bool: ...
    @staticmethod
    def IsGameObjectRenderedByCameraAndPartOfEditableScene(gameObject: GameObject, camera: Camera) -> bool: ...
    @staticmethod
    def PlaceGameObjectInCurrentStage(gameObject: GameObject) -> None: ...
    # Skipped GetStage due to it being static, abstract and generic.

    GetStage : GetStage_MethodGroup
    class GetStage_MethodGroup:
        @typing.overload
        def __call__(self, gameObject: GameObject) -> Stage:...
        @typing.overload
        def __call__(self, scene: Scene) -> Stage:...

    # Skipped GetStageHandle due to it being static, abstract and generic.

    GetStageHandle : GetStageHandle_MethodGroup
    class GetStageHandle_MethodGroup:
        @typing.overload
        def __call__(self, gameObject: GameObject) -> StageHandle:...
        @typing.overload
        def __call__(self, scene: Scene) -> StageHandle:...


