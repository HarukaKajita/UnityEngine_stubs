import typing, clr, abc
from System import Array_1, Func_2, Attribute, Action, IDisposable, StringComparison, Action_2, Action_1, IEquatable_1, IComparable_1, Func_5, Func_6, Func_4, Func_3, MulticastDelegate, IAsyncResult, AsyncCallback, Action_3, IComparable, Func_1
from System.Collections.Generic import IEnumerable_1, List_1, IReadOnlyDictionary_2, ICollection_1, IReadOnlyCollection_1, IList_1, Stack_1, IEnumerator_1, HashSet_1
from UnityEditor import SerializedObject, EditorApplication, GenericMenu, SerializedProperty, EditorWindow
from UnityEngine import Object, Hash128, Texture2D, Rect, Vector2, Event, GUIStyle, Matrix4x4, GUIContent, ISerializationCallbackReceiver, Color, GameObject, Transform
from System.Text.RegularExpressions import Regex
from UnityEditor.IMGUI.Controls import MultiColumnHeaderState, TreeView, MultiColumnHeader, TreeViewState
from UnityEngine.UIElements import BaseField_1, IBinding, VisualElement, ICustomStyle, IExperimentalFeatures, FocusController, MeshGenerationContext, Label, LanguageDirection, IPanel, PickingMode, IResolvedStyle, IVisualElementScheduler, IStyle, VisualElementStyleSheetSet, ITransform, UsageHints, VisualTreeAsset
from UnityEngine.Search import SearchViewFlags
from System.Reflection import MethodInfo
from System.IO import Stream
from UnityEngine.SceneManagement import Scene

class AssetIndexChangeSet:
    @typing.overload
    def __init__(self, updated: Array_1[str], removed: Array_1[str]) -> None: ...
    @typing.overload
    def __init__(self, updated: IEnumerable_1[str], removed: IEnumerable_1[str], moved: IEnumerable_1[str], predicate: Func_2[str, bool]) -> None: ...
    @typing.overload
    def __init__(self, updated: IEnumerable_1[str], removed: IEnumerable_1[str], predicate: Func_2[str, bool]) -> None: ...
    removed : Array_1[str]
    updated : Array_1[str]
    @property
    def all(self) -> IEnumerable_1[str]: ...
    @property
    def empty(self) -> bool: ...


class CustomObjectIndexerAttribute(Attribute):
    def __init__(self, type: typing.Type[typing.Any]) -> None: ...
    @property
    def type(self) -> typing.Type[typing.Any]: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def version(self) -> int: ...
    @version.setter
    def version(self, value: int) -> int: ...


class CustomObjectIndexerTarget:
    documentIndex : int
    id : str
    serializedObject : SerializedObject
    target : Object
    targetType : typing.Type[typing.Any]


class Dispatcher(abc.ABC):
    @staticmethod
    def CallDelayed(callback: EditorApplication.CallbackFunction, seconds: float = ...) -> Action: ...
    @staticmethod
    def ProcessOne() -> bool: ...
    # Skipped Enqueue due to it being static, abstract and generic.

    Enqueue : Enqueue_MethodGroup
    class Enqueue_MethodGroup:
        @typing.overload
        def __call__(self, action: Action) -> None:...
        @typing.overload
        def __call__(self, action: Action, delayInSeconds: float) -> None:...



class DisplayMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : DisplayMode # 0
    List : DisplayMode # 32
    Grid : DisplayMode # 96
    Limit : DisplayMode # 128
    Table : DisplayMode # 129


class FetchPreviewOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : FetchPreviewOptions # 0
    Preview2D : FetchPreviewOptions # 1
    Preview3D : FetchPreviewOptions # 2
    Normal : FetchPreviewOptions # 1024
    Large : FetchPreviewOptions # 2048


class FuzzySearch(abc.ABC):
    # Skipped FuzzyMatch due to it being static, abstract and generic.

    FuzzyMatch : FuzzyMatch_MethodGroup
    class FuzzyMatch_MethodGroup:
        @typing.overload
        def __call__(self, pattern: str, origin: str, matches: List_1[int] = ...) -> bool:...
        @typing.overload
        def __call__(self, pattern: str, origin: str, outScore: clr.Reference[int], matches: List_1[int] = ...) -> bool:...



class IFilterNode(IQueryNode, typing.Protocol):
    @property
    def filterId(self) -> str: ...
    @property
    def filterValue(self) -> str: ...
    @property
    def operatorId(self) -> str: ...
    @property
    def paramValue(self) -> str: ...
    @property
    def usesParameter(self) -> bool: ...


class IndexingOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : IndexingOptions # 0
    Types : IndexingOptions # 1
    Properties : IndexingOptions # 2
    Extended : IndexingOptions # 4
    Dependencies : IndexingOptions # 8
    All : IndexingOptions # 15
    Keep : IndexingOptions # 64
    Temporary : IndexingOptions # 128


class INestedQueryNode(IQueryNode, typing.Protocol):
    @property
    def associatedFilter(self) -> str: ...


class IPropertyDatabaseRecord(typing.Protocol):
    @property
    def key(self) -> PropertyDatabaseRecordKey: ...
    @property
    def validRecord(self) -> bool: ...
    @property
    def value(self) -> IPropertyDatabaseRecordValue: ...


class IPropertyDatabaseRecordValue(typing.Protocol):
    @property
    def type(self) -> PropertyDatabaseType: ...


class IPropertyDatabaseView(IDisposable, typing.Protocol):
    @abc.abstractmethod
    def Clear(self) -> None: ...
    @abc.abstractmethod
    def CreateDocumentKey(self, documentId: str) -> int: ...
    @abc.abstractmethod
    def CreatePropertyHash(self, propertyPath: str) -> Hash128: ...
    @abc.abstractmethod
    def EnumerateAll(self) -> IEnumerable_1[IPropertyDatabaseRecord]: ...
    @abc.abstractmethod
    def InvalidateMask(self, documentKeyMask: int) -> None: ...
    @abc.abstractmethod
    def IsPersistableType(self, type: typing.Type[typing.Any]) -> bool: ...
    @abc.abstractmethod
    def Sync(self) -> None: ...
    # Skipped CreateRecordKey due to it being static, abstract and generic.

    CreateRecordKey : CreateRecordKey_MethodGroup
    class CreateRecordKey_MethodGroup:
        @typing.overload
        def __call__(self, propertyHash: Hash128) -> PropertyDatabaseRecordKey:...
        @typing.overload
        def __call__(self, propertyPath: str) -> PropertyDatabaseRecordKey:...
        @typing.overload
        def __call__(self, documentKey: int, propertyPathHash: Hash128) -> PropertyDatabaseRecordKey:...
        @typing.overload
        def __call__(self, documentId: str, propertyHash: Hash128) -> PropertyDatabaseRecordKey:...
        @typing.overload
        def __call__(self, documentId: str, propertyPath: str) -> PropertyDatabaseRecordKey:...

    # Skipped GetValueFromRecord due to it being static, abstract and generic.

    GetValueFromRecord : GetValueFromRecord_MethodGroup
    class GetValueFromRecord_MethodGroup:
        def __getitem__(self, t:typing.Type[GetValueFromRecord_1_T1]) -> GetValueFromRecord_1[GetValueFromRecord_1_T1]: ...

        GetValueFromRecord_1_T1 = typing.TypeVar('GetValueFromRecord_1_T1')
        class GetValueFromRecord_1(typing.Generic[GetValueFromRecord_1_T1]):
            GetValueFromRecord_1_TValue = IPropertyDatabaseView.GetValueFromRecord_MethodGroup.GetValueFromRecord_1_T1
            def __call__(self, recordValue: IPropertyDatabaseRecordValue) -> GetValueFromRecord_1_TValue:...


    # Skipped Invalidate due to it being static, abstract and generic.

    Invalidate : Invalidate_MethodGroup
    class Invalidate_MethodGroup:
        @typing.overload
        def __call__(self, documentKey: int) -> None:...
        @typing.overload
        def __call__(self, documentId: str) -> None:...
        @typing.overload
        def __call__(self, recordKey: clr.Reference[PropertyDatabaseRecordKey]) -> None:...

    # Skipped Store due to it being static, abstract and generic.

    Store : Store_MethodGroup
    class Store_MethodGroup:
        @typing.overload
        def __call__(self, propertyHash: Hash128, value: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, recordKey: clr.Reference[PropertyDatabaseRecordKey], value: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, documentKey: int, propertyHash: Hash128, value: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, documentId: str, propertyPath: str, value: typing.Any) -> bool:...

    # Skipped TryLoad due to it being static, abstract and generic.

    TryLoad : TryLoad_MethodGroup
    class TryLoad_MethodGroup:
        @typing.overload
        def __call__(self, documentKey: int, data: clr.Reference[IEnumerable_1[typing.Any]]) -> bool:...
        @typing.overload
        def __call__(self, documentKey: int, records: clr.Reference[IEnumerable_1[IPropertyDatabaseRecord]]) -> bool:...
        @typing.overload
        def __call__(self, recordKey: clr.Reference[PropertyDatabaseRecordKey], data: clr.Reference[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, recordKey: clr.Reference[PropertyDatabaseRecordKey], data: clr.Reference[IPropertyDatabaseRecordValue]) -> bool:...



class IQueryEngineFilter(typing.Protocol):
    @property
    def metaInfo(self) -> IReadOnlyDictionary_2[str, str]: ...
    @property
    def operators(self) -> IReadOnlyDictionary_2[str, QueryFilterOperator]: ...
    @property
    def overridesStringComparison(self) -> bool: ...
    @property
    def parameterType(self) -> typing.Type[typing.Any]: ...
    @property
    def regexToken(self) -> Regex: ...
    @property
    def stringComparison(self) -> StringComparison: ...
    @property
    def supportedOperators(self) -> IEnumerable_1[str]: ...
    @property
    def token(self) -> str: ...
    @property
    def type(self) -> typing.Type[typing.Any]: ...
    @property
    def usesParameter(self) -> bool: ...
    @property
    def usesRegularExpressionToken(self) -> bool: ...
    @property
    def usesResolver(self) -> bool: ...
    @abc.abstractmethod
    def AddOperator(self, op: str) -> QueryFilterOperator: ...
    @abc.abstractmethod
    def AddOrUpdateMetaInfo(self, key: str, value: str) -> IQueryEngineFilter: ...
    @abc.abstractmethod
    def ClearMetaInfo(self) -> IQueryEngineFilter: ...
    @abc.abstractmethod
    def RemoveMetaInfo(self, key: str) -> IQueryEngineFilter: ...
    @abc.abstractmethod
    def RemoveOperator(self, op: str) -> IQueryEngineFilter: ...
    # Skipped AddTypeParser due to it being static, abstract and generic.

    AddTypeParser : AddTypeParser_MethodGroup
    class AddTypeParser_MethodGroup:
        def __getitem__(self, t:typing.Type[AddTypeParser_1_T1]) -> AddTypeParser_1[AddTypeParser_1_T1]: ...

        AddTypeParser_1_T1 = typing.TypeVar('AddTypeParser_1_T1')
        class AddTypeParser_1(typing.Generic[AddTypeParser_1_T1]):
            AddTypeParser_1_TFilterConstant = IQueryEngineFilter.AddTypeParser_MethodGroup.AddTypeParser_1_T1
            def __call__(self, parser: Func_2[str, ParseResult_1[AddTypeParser_1_TFilterConstant]]) -> IQueryEngineFilter:...


    # Skipped SetNestedQueryTransformer due to it being static, abstract and generic.

    SetNestedQueryTransformer : SetNestedQueryTransformer_MethodGroup
    class SetNestedQueryTransformer_MethodGroup:
        def __getitem__(self, t:typing.Tuple[typing.Type[SetNestedQueryTransformer_2_T1], typing.Type[SetNestedQueryTransformer_2_T2]]) -> SetNestedQueryTransformer_2[SetNestedQueryTransformer_2_T1, SetNestedQueryTransformer_2_T2]: ...

        SetNestedQueryTransformer_2_T1 = typing.TypeVar('SetNestedQueryTransformer_2_T1')
        SetNestedQueryTransformer_2_T2 = typing.TypeVar('SetNestedQueryTransformer_2_T2')
        class SetNestedQueryTransformer_2(typing.Generic[SetNestedQueryTransformer_2_T1, SetNestedQueryTransformer_2_T2]):
            SetNestedQueryTransformer_2_TNestedQueryData = IQueryEngineFilter.SetNestedQueryTransformer_MethodGroup.SetNestedQueryTransformer_2_T1
            SetNestedQueryTransformer_2_TRhs = IQueryEngineFilter.SetNestedQueryTransformer_MethodGroup.SetNestedQueryTransformer_2_T2
            def __call__(self, transformer: Func_2[SetNestedQueryTransformer_2_TNestedQueryData, SetNestedQueryTransformer_2_TRhs]) -> None:...




class IQueryHandler_GenericClasses(abc.ABCMeta):
    Generic_IQueryHandler_GenericClasses_IQueryHandler_2_TData = typing.TypeVar('Generic_IQueryHandler_GenericClasses_IQueryHandler_2_TData')
    Generic_IQueryHandler_GenericClasses_IQueryHandler_2_TPayload = typing.TypeVar('Generic_IQueryHandler_GenericClasses_IQueryHandler_2_TPayload')
    def __getitem__(self, types : typing.Tuple[typing.Type[Generic_IQueryHandler_GenericClasses_IQueryHandler_2_TData], typing.Type[Generic_IQueryHandler_GenericClasses_IQueryHandler_2_TPayload]]) -> typing.Type[IQueryHandler_2[Generic_IQueryHandler_GenericClasses_IQueryHandler_2_TData, Generic_IQueryHandler_GenericClasses_IQueryHandler_2_TPayload]]: ...

IQueryHandler : IQueryHandler_GenericClasses

IQueryHandler_2_TData = typing.TypeVar('IQueryHandler_2_TData')
IQueryHandler_2_TPayload = typing.TypeVar('IQueryHandler_2_TPayload', contravariant=True)
class IQueryHandler_2(typing.Generic[IQueryHandler_2_TData, IQueryHandler_2_TPayload], typing.Protocol):
    # Skipped Eval due to it being static, abstract and generic.

    Eval : Eval_MethodGroup[IQueryHandler_2_TData, IQueryHandler_2_TPayload]
    Eval_MethodGroup_IQueryHandler_2_TData = typing.TypeVar('Eval_MethodGroup_IQueryHandler_2_TData')
    Eval_MethodGroup_IQueryHandler_2_TPayload = typing.TypeVar('Eval_MethodGroup_IQueryHandler_2_TPayload', contravariant=True)
    class Eval_MethodGroup(typing.Generic[Eval_MethodGroup_IQueryHandler_2_TData, Eval_MethodGroup_IQueryHandler_2_TPayload]):
        Eval_MethodGroup_IQueryHandler_2_TData = IQueryHandler_2.Eval_MethodGroup_IQueryHandler_2_TData
        Eval_MethodGroup_IQueryHandler_2_TPayload = IQueryHandler_2.Eval_MethodGroup_IQueryHandler_2_TPayload
        @typing.overload
        def __call__(self, element: Eval_MethodGroup_IQueryHandler_2_TData) -> bool:...
        @typing.overload
        def __call__(self, payload: Eval_MethodGroup_IQueryHandler_2_TPayload) -> IEnumerable_1[Eval_MethodGroup_IQueryHandler_2_TData]:...



class IQueryHandlerFactory_GenericClasses(abc.ABCMeta):
    Generic_IQueryHandlerFactory_GenericClasses_IQueryHandlerFactory_3_TData = typing.TypeVar('Generic_IQueryHandlerFactory_GenericClasses_IQueryHandlerFactory_3_TData')
    Generic_IQueryHandlerFactory_GenericClasses_IQueryHandlerFactory_3_TQueryHandler = typing.TypeVar('Generic_IQueryHandlerFactory_GenericClasses_IQueryHandlerFactory_3_TQueryHandler')
    Generic_IQueryHandlerFactory_GenericClasses_IQueryHandlerFactory_3_TPayload = typing.TypeVar('Generic_IQueryHandlerFactory_GenericClasses_IQueryHandlerFactory_3_TPayload')
    def __getitem__(self, types : typing.Tuple[typing.Type[Generic_IQueryHandlerFactory_GenericClasses_IQueryHandlerFactory_3_TData], typing.Type[Generic_IQueryHandlerFactory_GenericClasses_IQueryHandlerFactory_3_TQueryHandler], typing.Type[Generic_IQueryHandlerFactory_GenericClasses_IQueryHandlerFactory_3_TPayload]]) -> typing.Type[IQueryHandlerFactory_3[Generic_IQueryHandlerFactory_GenericClasses_IQueryHandlerFactory_3_TData, Generic_IQueryHandlerFactory_GenericClasses_IQueryHandlerFactory_3_TQueryHandler, Generic_IQueryHandlerFactory_GenericClasses_IQueryHandlerFactory_3_TPayload]]: ...

IQueryHandlerFactory : IQueryHandlerFactory_GenericClasses

IQueryHandlerFactory_3_TData = typing.TypeVar('IQueryHandlerFactory_3_TData')
IQueryHandlerFactory_3_TQueryHandler = typing.TypeVar('IQueryHandlerFactory_3_TQueryHandler', covariant=True)
IQueryHandlerFactory_3_TPayload = typing.TypeVar('IQueryHandlerFactory_3_TPayload')
class IQueryHandlerFactory_3(typing.Generic[IQueryHandlerFactory_3_TData, IQueryHandlerFactory_3_TQueryHandler, IQueryHandlerFactory_3_TPayload], typing.Protocol):
    @abc.abstractmethod
    def Create(self, graph: QueryGraph, errors: ICollection_1[QueryError]) -> IQueryHandlerFactory_3_TQueryHandler: ...


class IQueryNode(typing.Protocol):
    @property
    def children(self) -> List_1[IQueryNode]: ...
    @property
    def identifier(self) -> str: ...
    @property
    def leaf(self) -> bool: ...
    @property
    def parent(self) -> IQueryNode: ...
    @parent.setter
    def parent(self, value: IQueryNode) -> IQueryNode: ...
    @property
    def skipped(self) -> bool: ...
    @skipped.setter
    def skipped(self, value: bool) -> bool: ...
    @property
    def token(self) -> QueryToken: ...
    @token.setter
    def token(self, value: QueryToken) -> QueryToken: ...
    @property
    def type(self) -> QueryNodeType: ...
    @abc.abstractmethod
    def QueryHashCode(self) -> int: ...


class IQuerySource(typing.Protocol):
    @property
    def context(self) -> SearchContext: ...
    @property
    def searchView(self) -> ISearchView: ...
    @abc.abstractmethod
    def Apply(self) -> None: ...
    @abc.abstractmethod
    def Repaint(self) -> None: ...


class ISearchDatabase(typing.Protocol):
    @property
    def excludePatterns(self) -> IReadOnlyCollection_1[str]: ...
    @property
    def includePatterns(self) -> IReadOnlyCollection_1[str]: ...
    @property
    def indexingOptions(self) -> IndexingOptions: ...
    @property
    def name(self) -> str: ...
    @property
    def roots(self) -> IReadOnlyCollection_1[str]: ...


class ISearchList(IList_1[SearchItem], IDisposable, typing.Protocol):
    @property
    def context(self) -> SearchContext: ...
    @property
    def pending(self) -> bool: ...
    @abc.abstractmethod
    def AddItems(self, items: IEnumerable_1[SearchItem]) -> None: ...
    @abc.abstractmethod
    def Fetch(self) -> IEnumerable_1[SearchItem]: ...
    @abc.abstractmethod
    def GetRange(self, skipCount: int, count: int) -> IEnumerable_1[SearchItem]: ...
    @abc.abstractmethod
    def InsertRange(self, index: int, items: IEnumerable_1[SearchItem]) -> None: ...
    # Skipped Select due to it being static, abstract and generic.

    Select : Select_MethodGroup
    class Select_MethodGroup:
        def __getitem__(self, t:typing.Type[Select_1_T1]) -> Select_1[Select_1_T1]: ...

        Select_1_T1 = typing.TypeVar('Select_1_T1')
        class Select_1(typing.Generic[Select_1_T1]):
            Select_1_TResult = ISearchList.Select_MethodGroup.Select_1_T1
            def __call__(self, selector: Func_2[SearchItem, Select_1_TResult]) -> IEnumerable_1[Select_1_TResult]:...




class ISearchNode(IQueryNode, typing.Protocol):
    @property
    def exact(self) -> bool: ...
    @property
    def searchValue(self) -> str: ...


class ISearchQuery(typing.Protocol):
    @property
    def creationTime(self) -> int: ...
    @property
    def details(self) -> str: ...
    @details.setter
    def details(self, value: str) -> str: ...
    @property
    def displayName(self) -> str: ...
    @displayName.setter
    def displayName(self, value: str) -> str: ...
    @property
    def filePath(self) -> str: ...
    @property
    def guid(self) -> str: ...
    @property
    def isSearchTemplate(self) -> bool: ...
    @property
    def itemCount(self) -> int: ...
    @property
    def lastUsedTime(self) -> int: ...
    @property
    def searchText(self) -> str: ...
    @property
    def thumbnail(self) -> Texture2D: ...
    @thumbnail.setter
    def thumbnail(self, value: Texture2D) -> Texture2D: ...
    @abc.abstractmethod
    def GetName(self) -> str: ...
    @abc.abstractmethod
    def GetProviderIds(self) -> IEnumerable_1[str]: ...
    @abc.abstractmethod
    def GetProviderTypes(self) -> IEnumerable_1[str]: ...
    @abc.abstractmethod
    def GetSearchTable(self) -> SearchTable: ...
    @abc.abstractmethod
    def GetViewState(self) -> SearchViewState: ...


class ISearchView(IDisposable, typing.Protocol):
    @property
    def context(self) -> SearchContext: ...
    @property
    def displayMode(self) -> DisplayMode: ...
    @property
    def filterCallback(self) -> Func_2[SearchItem, bool]: ...
    @property
    def itemIconSize(self) -> float: ...
    @itemIconSize.setter
    def itemIconSize(self, value: float) -> float: ...
    @property
    def multiselect(self) -> bool: ...
    @multiselect.setter
    def multiselect(self, value: bool) -> bool: ...
    @property
    def position(self) -> Rect: ...
    @property
    def results(self) -> ISearchList: ...
    @property
    def selectCallback(self) -> Action_2[SearchItem, bool]: ...
    @property
    def selection(self) -> SearchSelection: ...
    @property
    def trackingCallback(self) -> Action_1[SearchItem]: ...
    @abc.abstractmethod
    def AddSelection(self, selection: Array_1[int]) -> None: ...
    @abc.abstractmethod
    def Close(self) -> None: ...
    @abc.abstractmethod
    def ExecuteAction(self, action: SearchAction, items: Array_1[SearchItem], endSearch: bool = ...) -> None: ...
    @abc.abstractmethod
    def ExecuteSelection(self) -> None: ...
    @abc.abstractmethod
    def Focus(self) -> None: ...
    @abc.abstractmethod
    def FocusSearch(self) -> None: ...
    @abc.abstractmethod
    def Refresh(self, reason: RefreshFlags = ...) -> None: ...
    @abc.abstractmethod
    def Repaint(self) -> None: ...
    @abc.abstractmethod
    def SelectSearch(self) -> None: ...
    @abc.abstractmethod
    def SetColumns(self, columns: IEnumerable_1[SearchColumn]) -> None: ...
    @abc.abstractmethod
    def SetSelection(self, selection: Array_1[int]) -> None: ...
    @abc.abstractmethod
    def ShowItemContextualMenu(self, item: SearchItem, contextualActionPosition: Rect) -> None: ...
    # Skipped SetSearchText due to it being static, abstract and generic.

    SetSearchText : SetSearchText_MethodGroup
    class SetSearchText_MethodGroup:
        @typing.overload
        def __call__(self, searchText: str, moveCursor: TextCursorPlacement = ...) -> None:...
        @typing.overload
        def __call__(self, searchText: str, moveCursor: TextCursorPlacement, cursorInsertPosition: int) -> None:...



class ITableView(typing.Protocol):
    @property
    def context(self) -> SearchContext: ...
    @property
    def readOnly(self) -> bool: ...
    @abc.abstractmethod
    def AddColumn(self, mousePosition: Vector2, activeColumnIndex: int) -> None: ...
    @abc.abstractmethod
    def AddColumns(self, descriptors: IEnumerable_1[SearchColumn], activeColumnIndex: int) -> None: ...
    @abc.abstractmethod
    def GetColumns(self) -> IEnumerable_1[SearchColumn]: ...
    @abc.abstractmethod
    def GetElements(self) -> IEnumerable_1[SearchItem]: ...
    @abc.abstractmethod
    def GetRows(self) -> IEnumerable_1[SearchItem]: ...
    @abc.abstractmethod
    def GetSearchTable(self) -> SearchTable: ...
    @abc.abstractmethod
    def OnItemExecuted(self, item: SearchItem) -> None: ...
    @abc.abstractmethod
    def OpenContextualMenu(self, evt: Event, item: SearchItem) -> bool: ...
    @abc.abstractmethod
    def RemoveColumn(self, activeColumnIndex: int) -> None: ...
    @abc.abstractmethod
    def SetDirty(self) -> None: ...
    @abc.abstractmethod
    def SetSelection(self, items: IEnumerable_1[SearchItem]) -> None: ...
    @abc.abstractmethod
    def SetupColumns(self, elements: IEnumerable_1[SearchItem] = ...) -> None: ...
    @abc.abstractmethod
    def SwapColumns(self, columnIndex: int, swappedColumnIndex: int) -> None: ...
    @abc.abstractmethod
    def UpdateColumnSettings(self, columnIndex: int, columnSettings: MultiColumnHeaderState.Column) -> None: ...
    # Skipped AddColumnHeaderContextMenuItems due to it being static, abstract and generic.

    AddColumnHeaderContextMenuItems : AddColumnHeaderContextMenuItems_MethodGroup
    class AddColumnHeaderContextMenuItems_MethodGroup:
        @typing.overload
        def __call__(self, menu: GenericMenu) -> bool:...
        @typing.overload
        def __call__(self, menu: GenericMenu, sourceColumn: SearchColumn) -> None:...



class ItemSelectors(abc.ABC):
    @staticmethod
    def CreateColumn(path: str, selector: str = ..., provider: str = ..., options: SearchColumnFlags = ...) -> SearchColumn: ...
    @staticmethod
    def Enumerate(items: IEnumerable_1[SearchItem] = ...) -> IEnumerable_1[SearchColumn]: ...
    @staticmethod
    def GetItemContentStyle(column: SearchColumn) -> GUIStyle: ...


class ObjectField(BaseField_1[Object]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, label: str) -> None: ...
    @property
    def binding(self) -> IBinding: ...
    @binding.setter
    def binding(self, value: IBinding) -> IBinding: ...
    @property
    def bindingPath(self) -> str: ...
    @bindingPath.setter
    def bindingPath(self, value: str) -> str: ...
    @property
    def cacheAsBitmap(self) -> bool: ...
    @cacheAsBitmap.setter
    def cacheAsBitmap(self, value: bool) -> bool: ...
    @property
    def canGrabFocus(self) -> bool: ...
    @property
    def childCount(self) -> int: ...
    @property
    def contentContainer(self) -> VisualElement: ...
    @property
    def contentRect(self) -> Rect: ...
    @property
    def customStyle(self) -> ICustomStyle: ...
    @property
    def delegatesFocus(self) -> bool: ...
    @delegatesFocus.setter
    def delegatesFocus(self, value: bool) -> bool: ...
    @property
    def enabledInHierarchy(self) -> bool: ...
    @property
    def enabledSelf(self) -> bool: ...
    @property
    def experimental(self) -> IExperimentalFeatures: ...
    @property
    def focusable(self) -> bool: ...
    @focusable.setter
    def focusable(self, value: bool) -> bool: ...
    @property
    def focusController(self) -> FocusController: ...
    @property
    def generateVisualContent(self) -> Action_1[MeshGenerationContext]: ...
    @generateVisualContent.setter
    def generateVisualContent(self, value: Action_1[MeshGenerationContext]) -> Action_1[MeshGenerationContext]: ...
    @property
    def hierarchy(self) -> VisualElement.Hierarchy: ...
    @property
    def Item(self) -> VisualElement: ...
    @classmethod
    @property
    def kSingleLineHeight(cls) -> float: ...
    @property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> str: ...
    @property
    def labelElement(self) -> Label: ...
    @property
    def languageDirection(self) -> LanguageDirection: ...
    @languageDirection.setter
    def languageDirection(self, value: LanguageDirection) -> LanguageDirection: ...
    @property
    def layout(self) -> Rect: ...
    @layout.setter
    def layout(self, value: Rect) -> Rect: ...
    @property
    def localBound(self) -> Rect: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def objectType(self) -> typing.Type[typing.Any]: ...
    @objectType.setter
    def objectType(self, value: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    @property
    def panel(self) -> IPanel: ...
    @property
    def parent(self) -> VisualElement: ...
    @property
    def pickingMode(self) -> PickingMode: ...
    @pickingMode.setter
    def pickingMode(self, value: PickingMode) -> PickingMode: ...
    @property
    def resolvedStyle(self) -> IResolvedStyle: ...
    @property
    def schedule(self) -> IVisualElementScheduler: ...
    @property
    def searchContext(self) -> SearchContext: ...
    @searchContext.setter
    def searchContext(self, value: SearchContext) -> SearchContext: ...
    @property
    def searchViewFlags(self) -> SearchViewFlags: ...
    @searchViewFlags.setter
    def searchViewFlags(self, value: SearchViewFlags) -> SearchViewFlags: ...
    @property
    def showMixedValue(self) -> bool: ...
    @showMixedValue.setter
    def showMixedValue(self, value: bool) -> bool: ...
    @classmethod
    @property
    def singleLineHeight(cls) -> float: ...
    @property
    def style(self) -> IStyle: ...
    @property
    def styleSheets(self) -> VisualElementStyleSheetSet: ...
    @property
    def tabIndex(self) -> int: ...
    @tabIndex.setter
    def tabIndex(self, value: int) -> int: ...
    @property
    def tooltip(self) -> str: ...
    @tooltip.setter
    def tooltip(self, value: str) -> str: ...
    @property
    def transform(self) -> ITransform: ...
    @property
    def usageHints(self) -> UsageHints: ...
    @usageHints.setter
    def usageHints(self, value: UsageHints) -> UsageHints: ...
    @property
    def userData(self) -> typing.Any: ...
    @userData.setter
    def userData(self, value: typing.Any) -> typing.Any: ...
    @property
    def value(self) -> Object: ...
    @value.setter
    def value(self, value: Object) -> Object: ...
    @property
    def viewDataKey(self) -> str: ...
    @viewDataKey.setter
    def viewDataKey(self, value: str) -> str: ...
    @property
    def visible(self) -> bool: ...
    @visible.setter
    def visible(self, value: bool) -> bool: ...
    @property
    def visualTreeAssetSource(self) -> VisualTreeAsset: ...
    @visualTreeAssetSource.setter
    def visualTreeAssetSource(self, value: VisualTreeAsset) -> VisualTreeAsset: ...
    @property
    def worldBound(self) -> Rect: ...
    @property
    def worldTransform(self) -> Matrix4x4: ...
    def SetValueWithoutNotify(self, newValue: Object) -> None: ...
    # Skipped DoObjectField due to it being static, abstract and generic.

    DoObjectField : DoObjectField_MethodGroup
    class DoObjectField_MethodGroup:
        @typing.overload
        def __call__(self, position: Rect, obj: Object, objType: typing.Type[typing.Any], label: GUIContent, context: SearchContext, searchViewFlags: SearchViewFlags = ...) -> Object:...
        @typing.overload
        def __call__(self, position: Rect, property: SerializedProperty, objType: typing.Type[typing.Any], label: GUIContent, context: SearchContext, searchViewFlags: SearchViewFlags = ...) -> None:...



class ObjectIndexer(SearchIndexer, abc.ABC):
    @property
    def documentCount(self) -> int: ...
    @property
    def keywordCount(self) -> int: ...
    @property
    def minQueryLength(self) -> int: ...
    @minQueryLength.setter
    def minQueryLength(self, value: int) -> int: ...
    @property
    def minWordIndexationLength(self) -> int: ...
    @minWordIndexationLength.setter
    def minWordIndexationLength(self, value: int) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def resolveDocumentHandler(self) -> Func_2[str, str]: ...
    @resolveDocumentHandler.setter
    def resolveDocumentHandler(self, value: Func_2[str, str]) -> Func_2[str, str]: ...
    @property
    def skipEntryHandler(self) -> Func_2[str, bool]: ...
    @skipEntryHandler.setter
    def skipEntryHandler(self, value: Func_2[str, bool]) -> Func_2[str, bool]: ...
    @property
    def timestamp(self) -> int: ...
    def GetEntryComponents(self, entry: clr.Reference[str], documentIndex: int) -> IEnumerable_1[str]: ...
    @abc.abstractmethod
    def IndexDocument(self, id: str, checkIfDocumentExists: bool) -> None: ...
    def IndexNumber(self, documentIndex: int, name: str, number: float) -> None: ...
    def IndexPropertyComponents(self, documentIndex: int, name: str, value: str) -> None: ...
    def IndexWordComponents(self, documentIndex: int, word: clr.Reference[str]) -> None: ...
    def Search(self, searchQuery: str, context: SearchContext, provider: SearchProvider, maxScore: int = ..., patternMatchLimit: int = ...) -> IEnumerable_1[SearchResult]: ...
    def SkipEntry(self, path: str, checkRoots: bool = ...) -> bool: ...
    # Skipped IndexProperty due to it being static, abstract and generic.

    IndexProperty : IndexProperty_MethodGroup
    class IndexProperty_MethodGroup:
        def __getitem__(self, t:typing.Tuple[typing.Type[IndexProperty_2_T1], typing.Type[IndexProperty_2_T2]]) -> IndexProperty_2[IndexProperty_2_T1, IndexProperty_2_T2]: ...

        IndexProperty_2_T1 = typing.TypeVar('IndexProperty_2_T1')
        IndexProperty_2_T2 = typing.TypeVar('IndexProperty_2_T2')
        class IndexProperty_2(typing.Generic[IndexProperty_2_T1, IndexProperty_2_T2]):
            IndexProperty_2_TProperty = ObjectIndexer.IndexProperty_MethodGroup.IndexProperty_2_T1
            IndexProperty_2_TPropertyOwner = ObjectIndexer.IndexProperty_MethodGroup.IndexProperty_2_T2
            def __call__(self, documentIndex: int, name: str, value: str, saveKeyword: bool, exact: bool) -> None:...

        def __call__(self, documentIndex: int, name: str, value: str, saveKeyword: bool, exact: bool = ...) -> None:...

    # Skipped IndexWord due to it being static, abstract and generic.

    IndexWord : IndexWord_MethodGroup
    class IndexWord_MethodGroup:
        @typing.overload
        def __call__(self, documentIndex: int, word: clr.Reference[str], exact: bool = ..., scoreModifier: int = ...) -> None:...
        @typing.overload
        def __call__(self, documentIndex: int, word: clr.Reference[str], maxVariations: int, exact: bool, scoreModifier: int = ...) -> None:...



class ParsedQuery_GenericClasses(abc.ABCMeta):
    Generic_ParsedQuery_GenericClasses_ParsedQuery_1_T = typing.TypeVar('Generic_ParsedQuery_GenericClasses_ParsedQuery_1_T')
    @typing.overload
    def __getitem__(self, types : typing.Type[Generic_ParsedQuery_GenericClasses_ParsedQuery_1_T]) -> typing.Type[ParsedQuery_1[Generic_ParsedQuery_GenericClasses_ParsedQuery_1_T]]: ...
    Generic_ParsedQuery_GenericClasses_ParsedQuery_2_TData = typing.TypeVar('Generic_ParsedQuery_GenericClasses_ParsedQuery_2_TData')
    Generic_ParsedQuery_GenericClasses_ParsedQuery_2_TPayload = typing.TypeVar('Generic_ParsedQuery_GenericClasses_ParsedQuery_2_TPayload')
    @typing.overload
    def __getitem__(self, types : typing.Tuple[typing.Type[Generic_ParsedQuery_GenericClasses_ParsedQuery_2_TData], typing.Type[Generic_ParsedQuery_GenericClasses_ParsedQuery_2_TPayload]]) -> typing.Type[ParsedQuery_2[Generic_ParsedQuery_GenericClasses_ParsedQuery_2_TData, Generic_ParsedQuery_GenericClasses_ParsedQuery_2_TPayload]]: ...

ParsedQuery : ParsedQuery_GenericClasses

ParsedQuery_1_T = typing.TypeVar('ParsedQuery_1_T')
class ParsedQuery_1(typing.Generic[ParsedQuery_1_T], ParsedQuery_2[ParsedQuery_1_T, IEnumerable_1[ParsedQuery_1_T]]):
    @property
    def errors(self) -> ICollection_1[QueryError]: ...
    @property
    def evaluationGraph(self) -> QueryGraph: ...
    @property
    def queryGraph(self) -> QueryGraph: ...
    @property
    def returnPayloadIfEmpty(self) -> bool: ...
    @returnPayloadIfEmpty.setter
    def returnPayloadIfEmpty(self, value: bool) -> bool: ...
    @property
    def text(self) -> str: ...
    @property
    def tokens(self) -> ICollection_1[str]: ...
    @property
    def valid(self) -> bool: ...
    def Apply(self, data: IEnumerable_1[ParsedQuery_1_T]) -> IEnumerable_1[ParsedQuery_1_T]: ...
    def Test(self, element: ParsedQuery_1_T) -> bool: ...


ParsedQuery_2_TData = typing.TypeVar('ParsedQuery_2_TData')
ParsedQuery_2_TPayload = typing.TypeVar('ParsedQuery_2_TPayload')
class ParsedQuery_2(typing.Generic[ParsedQuery_2_TData, ParsedQuery_2_TPayload]):
    @property
    def errors(self) -> ICollection_1[QueryError]: ...
    @property
    def evaluationGraph(self) -> QueryGraph: ...
    @property
    def queryGraph(self) -> QueryGraph: ...
    @property
    def text(self) -> str: ...
    @property
    def tokens(self) -> ICollection_1[str]: ...
    @property
    def valid(self) -> bool: ...
    def Apply(self, payload: ParsedQuery_2_TPayload = ...) -> IEnumerable_1[ParsedQuery_2_TData]: ...
    def GetNodeAtPosition(self, position: int) -> IQueryNode: ...
    # Skipped Optimize due to it being static, abstract and generic.

    Optimize : Optimize_MethodGroup[ParsedQuery_2_TData, ParsedQuery_2_TPayload]
    Optimize_MethodGroup_ParsedQuery_2_TData = typing.TypeVar('Optimize_MethodGroup_ParsedQuery_2_TData')
    Optimize_MethodGroup_ParsedQuery_2_TPayload = typing.TypeVar('Optimize_MethodGroup_ParsedQuery_2_TPayload')
    class Optimize_MethodGroup(typing.Generic[Optimize_MethodGroup_ParsedQuery_2_TData, Optimize_MethodGroup_ParsedQuery_2_TPayload]):
        Optimize_MethodGroup_ParsedQuery_2_TData = ParsedQuery_2.Optimize_MethodGroup_ParsedQuery_2_TData
        Optimize_MethodGroup_ParsedQuery_2_TPayload = ParsedQuery_2.Optimize_MethodGroup_ParsedQuery_2_TPayload
        @typing.overload
        def __call__(self, options: QueryGraphOptimizationOptions) -> None:...
        @typing.overload
        def __call__(self, propagateNotToLeaves: bool, swapNotToRightHandSide: bool) -> None:...



class ParseResult_GenericClasses(abc.ABCMeta):
    Generic_ParseResult_GenericClasses_ParseResult_1_T = typing.TypeVar('Generic_ParseResult_GenericClasses_ParseResult_1_T')
    def __getitem__(self, types : typing.Type[Generic_ParseResult_GenericClasses_ParseResult_1_T]) -> typing.Type[ParseResult_1[Generic_ParseResult_GenericClasses_ParseResult_1_T]]: ...

ParseResult : ParseResult_GenericClasses

ParseResult_1_T = typing.TypeVar('ParseResult_1_T')
class ParseResult_1(typing.Generic[ParseResult_1_T]):
    def __init__(self, success: bool, value: ParseResult_1_T) -> None: ...
    none : ParseResult_1[ParseResult_1_T]
    parsedValue : ParseResult_1_T
    @property
    def success(self) -> bool: ...


class PropertyDatabase(IDisposable):
    @typing.overload
    def __init__(self, filePath: str) -> None: ...
    @typing.overload
    def __init__(self, filePath: str, autoFlush: bool, backgroundUpdateDebounceInSeconds: float = ...) -> None: ...
    @property
    def autoFlush(self) -> bool: ...
    @property
    def filePath(self) -> str: ...
    @property
    def valid(self) -> bool: ...
    def Clear(self) -> None: ...
    @staticmethod
    def CreateDocumentKey(documentId: str) -> int: ...
    @staticmethod
    def CreatePropertyHash(propertyPath: str) -> Hash128: ...
    def Dispose(self) -> None: ...
    def Flush(self) -> None: ...
    def GetInfo(self) -> str: ...
    def GetView(self, delayedSync: bool = ...) -> IPropertyDatabaseView: ...
    def InvalidateMask(self, documentKeyMask: int) -> None: ...
    @staticmethod
    def IsPersistableType(type: typing.Type[typing.Any]) -> bool: ...
    # Skipped CreateRecordKey due to it being static, abstract and generic.

    CreateRecordKey : CreateRecordKey_MethodGroup
    class CreateRecordKey_MethodGroup:
        @typing.overload
        def __call__(self, propertyHash: Hash128) -> PropertyDatabaseRecordKey:...
        @typing.overload
        def __call__(self, propertyPath: str) -> PropertyDatabaseRecordKey:...
        @typing.overload
        def __call__(self, documentKey: int, propertyPathHash: Hash128) -> PropertyDatabaseRecordKey:...
        @typing.overload
        def __call__(self, documentId: str, propertyHash: Hash128) -> PropertyDatabaseRecordKey:...
        @typing.overload
        def __call__(self, documentId: str, propertyPath: str) -> PropertyDatabaseRecordKey:...

    # Skipped GetValueFromRecord due to it being static, abstract and generic.

    GetValueFromRecord : GetValueFromRecord_MethodGroup
    class GetValueFromRecord_MethodGroup:
        def __getitem__(self, t:typing.Type[GetValueFromRecord_1_T1]) -> GetValueFromRecord_1[GetValueFromRecord_1_T1]: ...

        GetValueFromRecord_1_T1 = typing.TypeVar('GetValueFromRecord_1_T1')
        class GetValueFromRecord_1(typing.Generic[GetValueFromRecord_1_T1]):
            GetValueFromRecord_1_TValue = PropertyDatabase.GetValueFromRecord_MethodGroup.GetValueFromRecord_1_T1
            def __call__(self, recordValue: IPropertyDatabaseRecordValue) -> GetValueFromRecord_1_TValue:...


    # Skipped Invalidate due to it being static, abstract and generic.

    Invalidate : Invalidate_MethodGroup
    class Invalidate_MethodGroup:
        @typing.overload
        def __call__(self, documentKey: int) -> None:...
        @typing.overload
        def __call__(self, documentId: str) -> None:...
        @typing.overload
        def __call__(self, recordKey: clr.Reference[PropertyDatabaseRecordKey]) -> None:...

    # Skipped Store due to it being static, abstract and generic.

    Store : Store_MethodGroup
    class Store_MethodGroup:
        @typing.overload
        def __call__(self, propertyHash: Hash128, value: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, recordKey: clr.Reference[PropertyDatabaseRecordKey], value: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, documentKey: int, propertyHash: Hash128, value: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, documentId: str, propertyPath: str, value: typing.Any) -> bool:...

    # Skipped TryLoad due to it being static, abstract and generic.

    TryLoad : TryLoad_MethodGroup
    class TryLoad_MethodGroup:
        @typing.overload
        def __call__(self, documentKey: int, data: clr.Reference[IEnumerable_1[typing.Any]]) -> bool:...
        @typing.overload
        def __call__(self, documentKey: int, records: clr.Reference[IEnumerable_1[IPropertyDatabaseRecord]]) -> bool:...
        @typing.overload
        def __call__(self, recordKey: clr.Reference[PropertyDatabaseRecordKey], value: clr.Reference[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, recordKey: clr.Reference[PropertyDatabaseRecordKey], value: clr.Reference[IPropertyDatabaseRecordValue]) -> bool:...



class PropertyDatabaseRecordKey(IEquatable_1[PropertyDatabaseRecordKey], IComparable_1[PropertyDatabaseRecordKey]):
    def __init__(self, documentKey: int, propertyKey: Hash128) -> None: ...
    documentKey : int
    propertyKey : Hash128
    @classmethod
    @property
    def size(cls) -> int: ...
    def CompareTo(self, other: PropertyDatabaseRecordKey) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, lhs: PropertyDatabaseRecordKey, rhs: PropertyDatabaseRecordKey) -> bool: ...
    def __gt__(self, lhs: PropertyDatabaseRecordKey, rhs: PropertyDatabaseRecordKey) -> bool: ...
    def __ne__(self, lhs: PropertyDatabaseRecordKey, rhs: PropertyDatabaseRecordKey) -> bool: ...
    def __lt__(self, lhs: PropertyDatabaseRecordKey, rhs: PropertyDatabaseRecordKey) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: PropertyDatabaseRecordKey) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class PropertyDatabaseType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : PropertyDatabaseType # 0
    FixedString : PropertyDatabaseType # 1
    String : PropertyDatabaseType # 2
    Bool : PropertyDatabaseType # 3
    Byte : PropertyDatabaseType # 4
    Short : PropertyDatabaseType # 5
    UnsignedShort : PropertyDatabaseType # 6
    Integer : PropertyDatabaseType # 7
    UnsignedInteger : PropertyDatabaseType # 8
    Long : PropertyDatabaseType # 9
    UnsignedLong : PropertyDatabaseType # 10
    Double : PropertyDatabaseType # 11
    Float : PropertyDatabaseType # 12
    GlobalObjectId : PropertyDatabaseType # 13
    Vector4 : PropertyDatabaseType # 14
    Color : PropertyDatabaseType # 15
    Color32 : PropertyDatabaseType # 16
    InstanceId : PropertyDatabaseType # 17
    GameObjectProperty : PropertyDatabaseType # 18
    Volatile : PropertyDatabaseType # 19


class PropertyTable(TreeView, IDisposable):
    def __init__(self, serializationUID: str, tableView: ITableView) -> None: ...
    @property
    def hasSearch(self) -> bool: ...
    @property
    def multiColumnHeader(self) -> MultiColumnHeader: ...
    @multiColumnHeader.setter
    def multiColumnHeader(self, value: MultiColumnHeader) -> MultiColumnHeader: ...
    @property
    def searchString(self) -> str: ...
    @searchString.setter
    def searchString(self, value: str) -> str: ...
    @property
    def state(self) -> TreeViewState: ...
    @property
    def totalHeight(self) -> float: ...
    @property
    def treeViewControlID(self) -> int: ...
    @treeViewControlID.setter
    def treeViewControlID(self, value: int) -> int: ...
    def Dispose(self) -> None: ...
    def FrameColumn(self, columnIndex: int) -> None: ...
    def OnGUI(self, tableRect: Rect) -> None: ...


class Query_GenericClasses(abc.ABCMeta):
    Generic_Query_GenericClasses_Query_1_T = typing.TypeVar('Generic_Query_GenericClasses_Query_1_T')
    @typing.overload
    def __getitem__(self, types : typing.Type[Generic_Query_GenericClasses_Query_1_T]) -> typing.Type[Query_1[Generic_Query_GenericClasses_Query_1_T]]: ...
    Generic_Query_GenericClasses_Query_2_TData = typing.TypeVar('Generic_Query_GenericClasses_Query_2_TData')
    Generic_Query_GenericClasses_Query_2_TPayload = typing.TypeVar('Generic_Query_GenericClasses_Query_2_TPayload')
    @typing.overload
    def __getitem__(self, types : typing.Tuple[typing.Type[Generic_Query_GenericClasses_Query_2_TData], typing.Type[Generic_Query_GenericClasses_Query_2_TPayload]]) -> typing.Type[Query_2[Generic_Query_GenericClasses_Query_2_TData, Generic_Query_GenericClasses_Query_2_TPayload]]: ...

Query : Query_GenericClasses

Query_1_T = typing.TypeVar('Query_1_T')
class Query_1(typing.Generic[Query_1_T], Query_2[Query_1_T, IEnumerable_1[Query_1_T]]):
    @property
    def errors(self) -> ICollection_1[QueryError]: ...
    @property
    def evaluationGraph(self) -> QueryGraph: ...
    @property
    def queryGraph(self) -> QueryGraph: ...
    @property
    def returnPayloadIfEmpty(self) -> bool: ...
    @returnPayloadIfEmpty.setter
    def returnPayloadIfEmpty(self, value: bool) -> bool: ...
    @property
    def text(self) -> str: ...
    @property
    def tokens(self) -> ICollection_1[str]: ...
    @property
    def valid(self) -> bool: ...
    def Apply(self, data: IEnumerable_1[Query_1_T]) -> IEnumerable_1[Query_1_T]: ...
    def Test(self, element: Query_1_T) -> bool: ...


Query_2_TData = typing.TypeVar('Query_2_TData')
Query_2_TPayload = typing.TypeVar('Query_2_TPayload')
class Query_2(typing.Generic[Query_2_TData, Query_2_TPayload]):
    @property
    def errors(self) -> ICollection_1[QueryError]: ...
    @property
    def evaluationGraph(self) -> QueryGraph: ...
    @property
    def queryGraph(self) -> QueryGraph: ...
    @property
    def text(self) -> str: ...
    @property
    def tokens(self) -> ICollection_1[str]: ...
    @property
    def valid(self) -> bool: ...
    def Apply(self, payload: Query_2_TPayload = ...) -> IEnumerable_1[Query_2_TData]: ...
    def GetNodeAtPosition(self, position: int) -> IQueryNode: ...
    # Skipped Optimize due to it being static, abstract and generic.

    Optimize : Optimize_MethodGroup[Query_2_TData, Query_2_TPayload]
    Optimize_MethodGroup_Query_2_TData = typing.TypeVar('Optimize_MethodGroup_Query_2_TData')
    Optimize_MethodGroup_Query_2_TPayload = typing.TypeVar('Optimize_MethodGroup_Query_2_TPayload')
    class Optimize_MethodGroup(typing.Generic[Optimize_MethodGroup_Query_2_TData, Optimize_MethodGroup_Query_2_TPayload]):
        Optimize_MethodGroup_Query_2_TData = Query_2.Optimize_MethodGroup_Query_2_TData
        Optimize_MethodGroup_Query_2_TPayload = Query_2.Optimize_MethodGroup_Query_2_TPayload
        @typing.overload
        def __call__(self, options: QueryGraphOptimizationOptions) -> None:...
        @typing.overload
        def __call__(self, propagateNotToLeaves: bool, swapNotToRightHandSide: bool) -> None:...



class QueryBlock(abc.ABC):
    @property
    def context(self) -> SearchContext: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def op(self) -> str: ...
    @op.setter
    def op(self, value: str) -> str: ...
    @property
    def source(self) -> IQuerySource: ...
    @source.setter
    def source(self, value: IQuerySource) -> IQuerySource: ...
    @property
    def value(self) -> str: ...
    @value.setter
    def value(self, value: str) -> str: ...
    def Apply(self, searchProposition: clr.Reference[SearchProposition]) -> None: ...
    def ToString(self) -> str: ...


class QueryEngine_GenericClasses(abc.ABCMeta):
    Generic_QueryEngine_GenericClasses_QueryEngine_1_TData = typing.TypeVar('Generic_QueryEngine_GenericClasses_QueryEngine_1_TData')
    def __getitem__(self, types : typing.Type[Generic_QueryEngine_GenericClasses_QueryEngine_1_TData]) -> typing.Type[QueryEngine_1[Generic_QueryEngine_GenericClasses_QueryEngine_1_TData]]: ...

class QueryEngine(QueryEngine_0, metaclass =QueryEngine_GenericClasses): ...

class QueryEngine_0(QueryEngine_1[typing.Any]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, validateFilters: bool) -> None: ...
    @typing.overload
    def __init__(self, validationOptions: QueryValidationOptions) -> None: ...
    @property
    def globalStringComparison(self) -> StringComparison: ...
    @property
    def searchDataCallback(self) -> Func_2[typing.Any, IEnumerable_1[str]]: ...
    @property
    def searchDataOverridesStringComparison(self) -> bool: ...
    @property
    def searchDataStringComparison(self) -> StringComparison: ...
    @property
    def searchWordMatcher(self) -> Func_5[str, bool, StringComparison, str, bool]: ...
    @property
    def skipIncompleteFilters(self) -> bool: ...
    @skipIncompleteFilters.setter
    def skipIncompleteFilters(self, value: bool) -> bool: ...
    @property
    def skipUnknownFilters(self) -> bool: ...
    @skipUnknownFilters.setter
    def skipUnknownFilters(self, value: bool) -> bool: ...
    @property
    def validateFilters(self) -> bool: ...
    @validateFilters.setter
    def validateFilters(self, value: bool) -> bool: ...


QueryEngine_1_TData = typing.TypeVar('QueryEngine_1_TData')
class QueryEngine_1(typing.Generic[QueryEngine_1_TData]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, validateFilters: bool) -> None: ...
    @typing.overload
    def __init__(self, validationOptions: QueryValidationOptions) -> None: ...
    @property
    def globalStringComparison(self) -> StringComparison: ...
    @property
    def searchDataCallback(self) -> Func_2[QueryEngine_1_TData, IEnumerable_1[str]]: ...
    @property
    def searchDataOverridesStringComparison(self) -> bool: ...
    @property
    def searchDataStringComparison(self) -> StringComparison: ...
    @property
    def searchWordMatcher(self) -> Func_5[str, bool, StringComparison, str, bool]: ...
    @property
    def skipIncompleteFilters(self) -> bool: ...
    @skipIncompleteFilters.setter
    def skipIncompleteFilters(self, value: bool) -> bool: ...
    @property
    def skipUnknownFilters(self) -> bool: ...
    @skipUnknownFilters.setter
    def skipUnknownFilters(self, value: bool) -> bool: ...
    @property
    def validateFilters(self) -> bool: ...
    @validateFilters.setter
    def validateFilters(self, value: bool) -> bool: ...
    def AddOperator(self, op: str) -> None: ...
    def ClearFilters(self) -> None: ...
    def GetAllFilters(self) -> IEnumerable_1[IQueryEngineFilter]: ...
    def GetOperator(self, op: str) -> QueryFilterOperator: ...
    def RemoveOperator(self, op: str) -> None: ...
    def SetDefaultFilter(self, handler: Func_5[QueryEngine_1_TData, str, str, str, bool]) -> None: ...
    def SetDefaultParamFilter(self, handler: Func_6[QueryEngine_1_TData, str, str, str, str, bool]) -> None: ...
    def SetGlobalStringComparisonOptions(self, stringComparison: StringComparison) -> None: ...
    def SetSearchWordMatcher(self, wordMatcher: Func_5[str, bool, StringComparison, str, bool]) -> None: ...
    # Skipped AddFilter due to it being static, abstract and generic.

    AddFilter : AddFilter_MethodGroup[QueryEngine_1_TData]
    AddFilter_MethodGroup_QueryEngine_1_TData = typing.TypeVar('AddFilter_MethodGroup_QueryEngine_1_TData')
    class AddFilter_MethodGroup(typing.Generic[AddFilter_MethodGroup_QueryEngine_1_TData]):
        AddFilter_MethodGroup_QueryEngine_1_TData = QueryEngine_1.AddFilter_MethodGroup_QueryEngine_1_TData
        @typing.overload
        def __getitem__(self, t:typing.Type[AddFilter_1_T1]) -> AddFilter_1[AddFilter_MethodGroup_QueryEngine_1_TData, AddFilter_1_T1]: ...

        AddFilter_1_QueryEngine_1_TData = typing.TypeVar('AddFilter_1_QueryEngine_1_TData')
        AddFilter_1_T1 = typing.TypeVar('AddFilter_1_T1')
        class AddFilter_1(typing.Generic[AddFilter_1_QueryEngine_1_TData, AddFilter_1_T1]):
            AddFilter_1_QueryEngine_1_TData = QueryEngine_1.AddFilter_MethodGroup.AddFilter_1_QueryEngine_1_TData
            AddFilter_1_TFilter = QueryEngine_1.AddFilter_MethodGroup.AddFilter_1_T1
            @typing.overload
            def __call__(self, token: str, filterResolver: Func_4[AddFilter_1_QueryEngine_1_TData, str, AddFilter_1_TFilter, bool], supportedOperatorType: Array_1[str] = ...) -> None:...
            @typing.overload
            def __call__(self, token: str, getDataFunc: Func_2[AddFilter_1_QueryEngine_1_TData, AddFilter_1_TFilter], supportedOperatorType: Array_1[str] = ...) -> None:...
            @typing.overload
            def __call__(self, token: Regex, filterResolver: Func_5[AddFilter_1_QueryEngine_1_TData, str, str, AddFilter_1_TFilter, bool], supportedOperatorType: Array_1[str] = ...) -> IQueryEngineFilter:...
            @typing.overload
            def __call__(self, token: Regex, getDataFunc: Func_3[AddFilter_1_QueryEngine_1_TData, str, AddFilter_1_TFilter], supportedOperatorType: Array_1[str] = ...) -> IQueryEngineFilter:...
            @typing.overload
            def __call__(self, token: str, getDataFunc: Func_2[AddFilter_1_QueryEngine_1_TData, AddFilter_1_TFilter], stringComparison: StringComparison, supportedOperatorType: Array_1[str] = ...) -> None:...
            @typing.overload
            def __call__(self, token: Regex, getDataFunc: Func_3[AddFilter_1_QueryEngine_1_TData, str, AddFilter_1_TFilter], stringComparison: StringComparison, supportedOperatorType: Array_1[str] = ...) -> IQueryEngineFilter:...

        @typing.overload
        def __getitem__(self, t:typing.Tuple[typing.Type[AddFilter_2_T1], typing.Type[AddFilter_2_T2]]) -> AddFilter_2[AddFilter_MethodGroup_QueryEngine_1_TData, AddFilter_2_T1, AddFilter_2_T2]: ...

        AddFilter_2_QueryEngine_1_TData = typing.TypeVar('AddFilter_2_QueryEngine_1_TData')
        AddFilter_2_T1 = typing.TypeVar('AddFilter_2_T1')
        AddFilter_2_T2 = typing.TypeVar('AddFilter_2_T2')
        class AddFilter_2(typing.Generic[AddFilter_2_QueryEngine_1_TData, AddFilter_2_T1, AddFilter_2_T2]):
            AddFilter_2_QueryEngine_1_TData = QueryEngine_1.AddFilter_MethodGroup.AddFilter_2_QueryEngine_1_TData
            AddFilter_2_TParam = QueryEngine_1.AddFilter_MethodGroup.AddFilter_2_T1
            AddFilter_2_TFilter = QueryEngine_1.AddFilter_MethodGroup.AddFilter_2_T2
            @typing.overload
            def __call__(self, token: str, filterResolver: Func_5[AddFilter_2_QueryEngine_1_TData, AddFilter_2_TParam, str, AddFilter_2_TFilter, bool], supportedOperatorType: Array_1[str] = ...) -> None:...
            @typing.overload
            def __call__(self, token: str, getDataFunc: Func_3[AddFilter_2_QueryEngine_1_TData, AddFilter_2_TParam, AddFilter_2_TFilter], supportedOperatorType: Array_1[str] = ...) -> None:...
            @typing.overload
            def __call__(self, token: Regex, filterResolver: Func_6[AddFilter_2_QueryEngine_1_TData, str, AddFilter_2_TParam, str, AddFilter_2_TFilter, bool], supportedOperatorType: Array_1[str] = ...) -> IQueryEngineFilter:...
            @typing.overload
            def __call__(self, token: Regex, getDataFunc: Func_4[AddFilter_2_QueryEngine_1_TData, str, AddFilter_2_TParam, AddFilter_2_TFilter], supportedOperatorType: Array_1[str] = ...) -> IQueryEngineFilter:...
            @typing.overload
            def __call__(self, token: str, filterResolver: Func_5[AddFilter_2_QueryEngine_1_TData, AddFilter_2_TParam, str, AddFilter_2_TFilter, bool], parameterTransformer: Func_2[str, AddFilter_2_TParam], supportedOperatorType: Array_1[str] = ...) -> None:...
            @typing.overload
            def __call__(self, token: str, getDataFunc: Func_3[AddFilter_2_QueryEngine_1_TData, AddFilter_2_TParam, AddFilter_2_TFilter], parameterTransformer: Func_2[str, AddFilter_2_TParam], supportedOperatorType: Array_1[str] = ...) -> None:...
            @typing.overload
            def __call__(self, token: str, getDataFunc: Func_3[AddFilter_2_QueryEngine_1_TData, AddFilter_2_TParam, AddFilter_2_TFilter], stringComparison: StringComparison, supportedOperatorType: Array_1[str] = ...) -> None:...
            @typing.overload
            def __call__(self, token: Regex, filterResolver: Func_6[AddFilter_2_QueryEngine_1_TData, str, AddFilter_2_TParam, str, AddFilter_2_TFilter, bool], parameterTransformer: Func_2[str, AddFilter_2_TParam], supportedOperatorType: Array_1[str] = ...) -> IQueryEngineFilter:...
            @typing.overload
            def __call__(self, token: Regex, getDataFunc: Func_4[AddFilter_2_QueryEngine_1_TData, str, AddFilter_2_TParam, AddFilter_2_TFilter], parameterTransformer: Func_2[str, AddFilter_2_TParam], supportedOperatorType: Array_1[str] = ...) -> IQueryEngineFilter:...
            @typing.overload
            def __call__(self, token: Regex, getDataFunc: Func_4[AddFilter_2_QueryEngine_1_TData, str, AddFilter_2_TParam, AddFilter_2_TFilter], stringComparison: StringComparison, supportedOperatorType: Array_1[str] = ...) -> IQueryEngineFilter:...
            @typing.overload
            def __call__(self, token: str, getDataFunc: Func_3[AddFilter_2_QueryEngine_1_TData, AddFilter_2_TParam, AddFilter_2_TFilter], parameterTransformer: Func_2[str, AddFilter_2_TParam], stringComparison: StringComparison, supportedOperatorType: Array_1[str] = ...) -> None:...
            @typing.overload
            def __call__(self, token: Regex, getDataFunc: Func_4[AddFilter_2_QueryEngine_1_TData, str, AddFilter_2_TParam, AddFilter_2_TFilter], parameterTransformer: Func_2[str, AddFilter_2_TParam], stringComparison: StringComparison, supportedOperatorType: Array_1[str] = ...) -> IQueryEngineFilter:...


    # Skipped AddFiltersFromAttribute due to it being static, abstract and generic.

    AddFiltersFromAttribute : AddFiltersFromAttribute_MethodGroup[QueryEngine_1_TData]
    AddFiltersFromAttribute_MethodGroup_QueryEngine_1_TData = typing.TypeVar('AddFiltersFromAttribute_MethodGroup_QueryEngine_1_TData')
    class AddFiltersFromAttribute_MethodGroup(typing.Generic[AddFiltersFromAttribute_MethodGroup_QueryEngine_1_TData]):
        AddFiltersFromAttribute_MethodGroup_QueryEngine_1_TData = QueryEngine_1.AddFiltersFromAttribute_MethodGroup_QueryEngine_1_TData
        def __getitem__(self, t:typing.Tuple[typing.Type[AddFiltersFromAttribute_2_T1], typing.Type[AddFiltersFromAttribute_2_T2]]) -> AddFiltersFromAttribute_2[AddFiltersFromAttribute_MethodGroup_QueryEngine_1_TData, AddFiltersFromAttribute_2_T1, AddFiltersFromAttribute_2_T2]: ...

        AddFiltersFromAttribute_2_QueryEngine_1_TData = typing.TypeVar('AddFiltersFromAttribute_2_QueryEngine_1_TData')
        AddFiltersFromAttribute_2_T1 = typing.TypeVar('AddFiltersFromAttribute_2_T1')
        AddFiltersFromAttribute_2_T2 = typing.TypeVar('AddFiltersFromAttribute_2_T2')
        class AddFiltersFromAttribute_2(typing.Generic[AddFiltersFromAttribute_2_QueryEngine_1_TData, AddFiltersFromAttribute_2_T1, AddFiltersFromAttribute_2_T2]):
            AddFiltersFromAttribute_2_QueryEngine_1_TData = QueryEngine_1.AddFiltersFromAttribute_MethodGroup.AddFiltersFromAttribute_2_QueryEngine_1_TData
            AddFiltersFromAttribute_2_TFilterAttribute = QueryEngine_1.AddFiltersFromAttribute_MethodGroup.AddFiltersFromAttribute_2_T1
            AddFiltersFromAttribute_2_TTransformerAttribute = QueryEngine_1.AddFiltersFromAttribute_MethodGroup.AddFiltersFromAttribute_2_T2
            def __call__(self) -> None:...


    # Skipped AddNestedQueryAggregator due to it being static, abstract and generic.

    AddNestedQueryAggregator : AddNestedQueryAggregator_MethodGroup[QueryEngine_1_TData]
    AddNestedQueryAggregator_MethodGroup_QueryEngine_1_TData = typing.TypeVar('AddNestedQueryAggregator_MethodGroup_QueryEngine_1_TData')
    class AddNestedQueryAggregator_MethodGroup(typing.Generic[AddNestedQueryAggregator_MethodGroup_QueryEngine_1_TData]):
        AddNestedQueryAggregator_MethodGroup_QueryEngine_1_TData = QueryEngine_1.AddNestedQueryAggregator_MethodGroup_QueryEngine_1_TData
        def __getitem__(self, t:typing.Type[AddNestedQueryAggregator_1_T1]) -> AddNestedQueryAggregator_1[AddNestedQueryAggregator_MethodGroup_QueryEngine_1_TData, AddNestedQueryAggregator_1_T1]: ...

        AddNestedQueryAggregator_1_QueryEngine_1_TData = typing.TypeVar('AddNestedQueryAggregator_1_QueryEngine_1_TData')
        AddNestedQueryAggregator_1_T1 = typing.TypeVar('AddNestedQueryAggregator_1_T1')
        class AddNestedQueryAggregator_1(typing.Generic[AddNestedQueryAggregator_1_QueryEngine_1_TData, AddNestedQueryAggregator_1_T1]):
            AddNestedQueryAggregator_1_QueryEngine_1_TData = QueryEngine_1.AddNestedQueryAggregator_MethodGroup.AddNestedQueryAggregator_1_QueryEngine_1_TData
            AddNestedQueryAggregator_1_TNestedQueryData = QueryEngine_1.AddNestedQueryAggregator_MethodGroup.AddNestedQueryAggregator_1_T1
            def __call__(self, token: str, aggregator: Func_2[IEnumerable_1[AddNestedQueryAggregator_1_TNestedQueryData], IEnumerable_1[AddNestedQueryAggregator_1_TNestedQueryData]]) -> None:...


    # Skipped AddOperatorHandler due to it being static, abstract and generic.

    AddOperatorHandler : AddOperatorHandler_MethodGroup[QueryEngine_1_TData]
    AddOperatorHandler_MethodGroup_QueryEngine_1_TData = typing.TypeVar('AddOperatorHandler_MethodGroup_QueryEngine_1_TData')
    class AddOperatorHandler_MethodGroup(typing.Generic[AddOperatorHandler_MethodGroup_QueryEngine_1_TData]):
        AddOperatorHandler_MethodGroup_QueryEngine_1_TData = QueryEngine_1.AddOperatorHandler_MethodGroup_QueryEngine_1_TData
        def __getitem__(self, t:typing.Tuple[typing.Type[AddOperatorHandler_2_T1], typing.Type[AddOperatorHandler_2_T2]]) -> AddOperatorHandler_2[AddOperatorHandler_MethodGroup_QueryEngine_1_TData, AddOperatorHandler_2_T1, AddOperatorHandler_2_T2]: ...

        AddOperatorHandler_2_QueryEngine_1_TData = typing.TypeVar('AddOperatorHandler_2_QueryEngine_1_TData')
        AddOperatorHandler_2_T1 = typing.TypeVar('AddOperatorHandler_2_T1')
        AddOperatorHandler_2_T2 = typing.TypeVar('AddOperatorHandler_2_T2')
        class AddOperatorHandler_2(typing.Generic[AddOperatorHandler_2_QueryEngine_1_TData, AddOperatorHandler_2_T1, AddOperatorHandler_2_T2]):
            AddOperatorHandler_2_QueryEngine_1_TData = QueryEngine_1.AddOperatorHandler_MethodGroup.AddOperatorHandler_2_QueryEngine_1_TData
            AddOperatorHandler_2_TFilterVariable = QueryEngine_1.AddOperatorHandler_MethodGroup.AddOperatorHandler_2_T1
            AddOperatorHandler_2_TFilterConstant = QueryEngine_1.AddOperatorHandler_MethodGroup.AddOperatorHandler_2_T2
            @typing.overload
            def __call__(self, op: str, handler: Func_4[AddOperatorHandler_2_TFilterVariable, AddOperatorHandler_2_TFilterConstant, StringComparison, bool]) -> None:...
            @typing.overload
            def __call__(self, op: str, handler: Func_3[AddOperatorHandler_2_TFilterVariable, AddOperatorHandler_2_TFilterConstant, bool]) -> None:...


    # Skipped AddTypeParser due to it being static, abstract and generic.

    AddTypeParser : AddTypeParser_MethodGroup[QueryEngine_1_TData]
    AddTypeParser_MethodGroup_QueryEngine_1_TData = typing.TypeVar('AddTypeParser_MethodGroup_QueryEngine_1_TData')
    class AddTypeParser_MethodGroup(typing.Generic[AddTypeParser_MethodGroup_QueryEngine_1_TData]):
        AddTypeParser_MethodGroup_QueryEngine_1_TData = QueryEngine_1.AddTypeParser_MethodGroup_QueryEngine_1_TData
        def __getitem__(self, t:typing.Type[AddTypeParser_1_T1]) -> AddTypeParser_1[AddTypeParser_MethodGroup_QueryEngine_1_TData, AddTypeParser_1_T1]: ...

        AddTypeParser_1_QueryEngine_1_TData = typing.TypeVar('AddTypeParser_1_QueryEngine_1_TData')
        AddTypeParser_1_T1 = typing.TypeVar('AddTypeParser_1_T1')
        class AddTypeParser_1(typing.Generic[AddTypeParser_1_QueryEngine_1_TData, AddTypeParser_1_T1]):
            AddTypeParser_1_QueryEngine_1_TData = QueryEngine_1.AddTypeParser_MethodGroup.AddTypeParser_1_QueryEngine_1_TData
            AddTypeParser_1_TFilterConstant = QueryEngine_1.AddTypeParser_MethodGroup.AddTypeParser_1_T1
            def __call__(self, parser: Func_2[str, ParseResult_1[AddTypeParser_1_TFilterConstant]]) -> None:...


    # Skipped Parse due to it being static, abstract and generic.

    Parse : Parse_MethodGroup[QueryEngine_1_TData]
    Parse_MethodGroup_QueryEngine_1_TData = typing.TypeVar('Parse_MethodGroup_QueryEngine_1_TData')
    class Parse_MethodGroup(typing.Generic[Parse_MethodGroup_QueryEngine_1_TData]):
        Parse_MethodGroup_QueryEngine_1_TData = QueryEngine_1.Parse_MethodGroup_QueryEngine_1_TData
        def __getitem__(self, t:typing.Tuple[typing.Type[Parse_2_T1], typing.Type[Parse_2_T2]]) -> Parse_2[Parse_MethodGroup_QueryEngine_1_TData, Parse_2_T1, Parse_2_T2]: ...

        Parse_2_QueryEngine_1_TData = typing.TypeVar('Parse_2_QueryEngine_1_TData')
        Parse_2_T1 = typing.TypeVar('Parse_2_T1')
        Parse_2_T2 = typing.TypeVar('Parse_2_T2')
        class Parse_2(typing.Generic[Parse_2_QueryEngine_1_TData, Parse_2_T1, Parse_2_T2]):
            Parse_2_QueryEngine_1_TData = QueryEngine_1.Parse_MethodGroup.Parse_2_QueryEngine_1_TData
            Parse_2_TQueryHandler = QueryEngine_1.Parse_MethodGroup.Parse_2_T1
            Parse_2_TPayload = QueryEngine_1.Parse_MethodGroup.Parse_2_T2
            def __call__(self, text: str, queryHandlerFactory: IQueryHandlerFactory_3[Parse_2_QueryEngine_1_TData, Parse_2_TQueryHandler, Parse_2_TPayload]) -> Query_2[Parse_2_QueryEngine_1_TData, Parse_2_TPayload]:...

        def __call__(self, text: str, useFastYieldingQueryHandler: bool = ...) -> Query_1[Parse_MethodGroup_QueryEngine_1_TData]:...

    # Skipped ParseQuery due to it being static, abstract and generic.

    ParseQuery : ParseQuery_MethodGroup[QueryEngine_1_TData]
    ParseQuery_MethodGroup_QueryEngine_1_TData = typing.TypeVar('ParseQuery_MethodGroup_QueryEngine_1_TData')
    class ParseQuery_MethodGroup(typing.Generic[ParseQuery_MethodGroup_QueryEngine_1_TData]):
        ParseQuery_MethodGroup_QueryEngine_1_TData = QueryEngine_1.ParseQuery_MethodGroup_QueryEngine_1_TData
        def __getitem__(self, t:typing.Tuple[typing.Type[ParseQuery_2_T1], typing.Type[ParseQuery_2_T2]]) -> ParseQuery_2[ParseQuery_MethodGroup_QueryEngine_1_TData, ParseQuery_2_T1, ParseQuery_2_T2]: ...

        ParseQuery_2_QueryEngine_1_TData = typing.TypeVar('ParseQuery_2_QueryEngine_1_TData')
        ParseQuery_2_T1 = typing.TypeVar('ParseQuery_2_T1')
        ParseQuery_2_T2 = typing.TypeVar('ParseQuery_2_T2')
        class ParseQuery_2(typing.Generic[ParseQuery_2_QueryEngine_1_TData, ParseQuery_2_T1, ParseQuery_2_T2]):
            ParseQuery_2_QueryEngine_1_TData = QueryEngine_1.ParseQuery_MethodGroup.ParseQuery_2_QueryEngine_1_TData
            ParseQuery_2_TQueryHandler = QueryEngine_1.ParseQuery_MethodGroup.ParseQuery_2_T1
            ParseQuery_2_TPayload = QueryEngine_1.ParseQuery_MethodGroup.ParseQuery_2_T2
            def __call__(self, text: str, queryHandlerFactory: IQueryHandlerFactory_3[ParseQuery_2_QueryEngine_1_TData, ParseQuery_2_TQueryHandler, ParseQuery_2_TPayload]) -> ParsedQuery_2[ParseQuery_2_QueryEngine_1_TData, ParseQuery_2_TPayload]:...

        def __call__(self, text: str, useFastYieldingQueryHandler: bool = ...) -> ParsedQuery_1[ParseQuery_MethodGroup_QueryEngine_1_TData]:...

    # Skipped RemoveFilter due to it being static, abstract and generic.

    RemoveFilter : RemoveFilter_MethodGroup[QueryEngine_1_TData]
    RemoveFilter_MethodGroup_QueryEngine_1_TData = typing.TypeVar('RemoveFilter_MethodGroup_QueryEngine_1_TData')
    class RemoveFilter_MethodGroup(typing.Generic[RemoveFilter_MethodGroup_QueryEngine_1_TData]):
        RemoveFilter_MethodGroup_QueryEngine_1_TData = QueryEngine_1.RemoveFilter_MethodGroup_QueryEngine_1_TData
        @typing.overload
        def __call__(self, token: str) -> None:...
        @typing.overload
        def __call__(self, token: Regex) -> None:...
        @typing.overload
        def __call__(self, filter: IQueryEngineFilter) -> None:...

    # Skipped SetFilterNestedQueryTransformer due to it being static, abstract and generic.

    SetFilterNestedQueryTransformer : SetFilterNestedQueryTransformer_MethodGroup[QueryEngine_1_TData]
    SetFilterNestedQueryTransformer_MethodGroup_QueryEngine_1_TData = typing.TypeVar('SetFilterNestedQueryTransformer_MethodGroup_QueryEngine_1_TData')
    class SetFilterNestedQueryTransformer_MethodGroup(typing.Generic[SetFilterNestedQueryTransformer_MethodGroup_QueryEngine_1_TData]):
        SetFilterNestedQueryTransformer_MethodGroup_QueryEngine_1_TData = QueryEngine_1.SetFilterNestedQueryTransformer_MethodGroup_QueryEngine_1_TData
        def __getitem__(self, t:typing.Tuple[typing.Type[SetFilterNestedQueryTransformer_2_T1], typing.Type[SetFilterNestedQueryTransformer_2_T2]]) -> SetFilterNestedQueryTransformer_2[SetFilterNestedQueryTransformer_MethodGroup_QueryEngine_1_TData, SetFilterNestedQueryTransformer_2_T1, SetFilterNestedQueryTransformer_2_T2]: ...

        SetFilterNestedQueryTransformer_2_QueryEngine_1_TData = typing.TypeVar('SetFilterNestedQueryTransformer_2_QueryEngine_1_TData')
        SetFilterNestedQueryTransformer_2_T1 = typing.TypeVar('SetFilterNestedQueryTransformer_2_T1')
        SetFilterNestedQueryTransformer_2_T2 = typing.TypeVar('SetFilterNestedQueryTransformer_2_T2')
        class SetFilterNestedQueryTransformer_2(typing.Generic[SetFilterNestedQueryTransformer_2_QueryEngine_1_TData, SetFilterNestedQueryTransformer_2_T1, SetFilterNestedQueryTransformer_2_T2]):
            SetFilterNestedQueryTransformer_2_QueryEngine_1_TData = QueryEngine_1.SetFilterNestedQueryTransformer_MethodGroup.SetFilterNestedQueryTransformer_2_QueryEngine_1_TData
            SetFilterNestedQueryTransformer_2_TNestedQueryData = QueryEngine_1.SetFilterNestedQueryTransformer_MethodGroup.SetFilterNestedQueryTransformer_2_T1
            SetFilterNestedQueryTransformer_2_TRhs = QueryEngine_1.SetFilterNestedQueryTransformer_MethodGroup.SetFilterNestedQueryTransformer_2_T2
            def __call__(self, filterToken: str, transformer: Func_2[SetFilterNestedQueryTransformer_2_TNestedQueryData, SetFilterNestedQueryTransformer_2_TRhs]) -> None:...


    # Skipped SetNestedQueryHandler due to it being static, abstract and generic.

    SetNestedQueryHandler : SetNestedQueryHandler_MethodGroup[QueryEngine_1_TData]
    SetNestedQueryHandler_MethodGroup_QueryEngine_1_TData = typing.TypeVar('SetNestedQueryHandler_MethodGroup_QueryEngine_1_TData')
    class SetNestedQueryHandler_MethodGroup(typing.Generic[SetNestedQueryHandler_MethodGroup_QueryEngine_1_TData]):
        SetNestedQueryHandler_MethodGroup_QueryEngine_1_TData = QueryEngine_1.SetNestedQueryHandler_MethodGroup_QueryEngine_1_TData
        def __getitem__(self, t:typing.Type[SetNestedQueryHandler_1_T1]) -> SetNestedQueryHandler_1[SetNestedQueryHandler_MethodGroup_QueryEngine_1_TData, SetNestedQueryHandler_1_T1]: ...

        SetNestedQueryHandler_1_QueryEngine_1_TData = typing.TypeVar('SetNestedQueryHandler_1_QueryEngine_1_TData')
        SetNestedQueryHandler_1_T1 = typing.TypeVar('SetNestedQueryHandler_1_T1')
        class SetNestedQueryHandler_1(typing.Generic[SetNestedQueryHandler_1_QueryEngine_1_TData, SetNestedQueryHandler_1_T1]):
            SetNestedQueryHandler_1_QueryEngine_1_TData = QueryEngine_1.SetNestedQueryHandler_MethodGroup.SetNestedQueryHandler_1_QueryEngine_1_TData
            SetNestedQueryHandler_1_TNestedQueryData = QueryEngine_1.SetNestedQueryHandler_MethodGroup.SetNestedQueryHandler_1_T1
            def __call__(self, handler: Func_3[str, str, IEnumerable_1[SetNestedQueryHandler_1_TNestedQueryData]]) -> None:...


    # Skipped SetSearchDataCallback due to it being static, abstract and generic.

    SetSearchDataCallback : SetSearchDataCallback_MethodGroup[QueryEngine_1_TData]
    SetSearchDataCallback_MethodGroup_QueryEngine_1_TData = typing.TypeVar('SetSearchDataCallback_MethodGroup_QueryEngine_1_TData')
    class SetSearchDataCallback_MethodGroup(typing.Generic[SetSearchDataCallback_MethodGroup_QueryEngine_1_TData]):
        SetSearchDataCallback_MethodGroup_QueryEngine_1_TData = QueryEngine_1.SetSearchDataCallback_MethodGroup_QueryEngine_1_TData
        @typing.overload
        def __call__(self, getSearchDataCallback: Func_2[SetSearchDataCallback_MethodGroup_QueryEngine_1_TData, IEnumerable_1[str]]) -> None:...
        @typing.overload
        def __call__(self, getSearchDataCallback: Func_2[SetSearchDataCallback_MethodGroup_QueryEngine_1_TData, IEnumerable_1[str]], stringComparison: StringComparison) -> None:...
        @typing.overload
        def __call__(self, getSearchDataCallback: Func_2[SetSearchDataCallback_MethodGroup_QueryEngine_1_TData, IEnumerable_1[str]], searchWordTransformerCallback: Func_2[str, str], stringComparison: StringComparison) -> None:...

    # Skipped TryGetFilter due to it being static, abstract and generic.

    TryGetFilter : TryGetFilter_MethodGroup[QueryEngine_1_TData]
    TryGetFilter_MethodGroup_QueryEngine_1_TData = typing.TypeVar('TryGetFilter_MethodGroup_QueryEngine_1_TData')
    class TryGetFilter_MethodGroup(typing.Generic[TryGetFilter_MethodGroup_QueryEngine_1_TData]):
        TryGetFilter_MethodGroup_QueryEngine_1_TData = QueryEngine_1.TryGetFilter_MethodGroup_QueryEngine_1_TData
        @typing.overload
        def __call__(self, token: str, filter: clr.Reference[IQueryEngineFilter]) -> bool:...
        @typing.overload
        def __call__(self, token: Regex, filter: clr.Reference[IQueryEngineFilter]) -> bool:...



class QueryEngineFilterAttribute(Attribute):
    @typing.overload
    def __init__(self, token: str, options: StringComparison, supportedOperators: Array_1[str] = ...) -> None: ...
    @typing.overload
    def __init__(self, token: str, paramTransformerFunction: str, options: StringComparison, supportedOperators: Array_1[str] = ...) -> None: ...
    @typing.overload
    def __init__(self, token: str, paramTransformerFunction: str, supportedOperators: Array_1[str] = ...) -> None: ...
    @typing.overload
    def __init__(self, token: str, supportedOperators: Array_1[str] = ...) -> None: ...
    @typing.overload
    def __init__(self, token: str, useRegularExpression: bool, options: StringComparison, supportedOperators: Array_1[str] = ...) -> None: ...
    @typing.overload
    def __init__(self, token: str, useRegularExpression: bool, paramTransformerFunction: str, options: StringComparison, supportedOperators: Array_1[str] = ...) -> None: ...
    @typing.overload
    def __init__(self, token: str, useRegularExpression: bool, paramTransformerFunction: str, supportedOperators: Array_1[str] = ...) -> None: ...
    @typing.overload
    def __init__(self, token: str, useRegularExpression: bool, supportedOperators: Array_1[str] = ...) -> None: ...
    comparisonOptions : StringComparison
    overridesStringComparison : bool
    paramTransformerFunction : str
    supportedOperators : Array_1[str]
    token : str
    useParamTransformer : bool
    useRegularExpressionToken : bool
    @property
    def TypeId(self) -> typing.Any: ...


class QueryEngineParameterTransformerAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class QueryError:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, index: int, length: int, reason: str) -> None: ...
    @typing.overload
    def __init__(self, index: int, reason: str) -> None: ...
    @property
    def index(self) -> int: ...
    @index.setter
    def index(self, value: int) -> int: ...
    @property
    def length(self) -> int: ...
    @length.setter
    def length(self, value: int) -> int: ...
    @property
    def reason(self) -> str: ...
    @reason.setter
    def reason(self, value: str) -> str: ...


class QueryFilterOperator:
    @property
    def token(self) -> str: ...
    @property
    def valid(self) -> bool: ...
    # Skipped AddHandler due to it being static, abstract and generic.

    AddHandler : AddHandler_MethodGroup
    class AddHandler_MethodGroup:
        def __getitem__(self, t:typing.Tuple[typing.Type[AddHandler_2_T1], typing.Type[AddHandler_2_T2]]) -> AddHandler_2[AddHandler_2_T1, AddHandler_2_T2]: ...

        AddHandler_2_T1 = typing.TypeVar('AddHandler_2_T1')
        AddHandler_2_T2 = typing.TypeVar('AddHandler_2_T2')
        class AddHandler_2(typing.Generic[AddHandler_2_T1, AddHandler_2_T2]):
            AddHandler_2_TFilterVariable = QueryFilterOperator.AddHandler_MethodGroup.AddHandler_2_T1
            AddHandler_2_TFilterConstant = QueryFilterOperator.AddHandler_MethodGroup.AddHandler_2_T2
            @typing.overload
            def __call__(self, handler: Func_4[AddHandler_2_TFilterVariable, AddHandler_2_TFilterConstant, StringComparison, bool]) -> QueryFilterOperator:...
            @typing.overload
            def __call__(self, handler: Func_3[AddHandler_2_TFilterVariable, AddHandler_2_TFilterConstant, bool]) -> QueryFilterOperator:...




class QueryGraph:
    def __init__(self, root: IQueryNode) -> None: ...
    @property
    def empty(self) -> bool: ...
    @property
    def root(self) -> IQueryNode: ...
    @root.setter
    def root(self, value: IQueryNode) -> IQueryNode: ...
    # Skipped Optimize due to it being static, abstract and generic.

    Optimize : Optimize_MethodGroup
    class Optimize_MethodGroup:
        @typing.overload
        def __call__(self, options: QueryGraphOptimizationOptions) -> None:...
        @typing.overload
        def __call__(self, propagateNotToLeaves: bool, swapNotToRightHandSide: bool) -> None:...



class QueryGraphOptimizationOptions:
    propagateNotToLeaves : bool
    swapFilterFunctionsToRightHandSide : bool
    swapNotToRightHandSide : bool


class QueryListBlock(QueryBlock):
    category : str
    id : str
    @property
    def context(self) -> SearchContext: ...
    @property
    def icon(self) -> Texture2D: ...
    @icon.setter
    def icon(self, value: Texture2D) -> Texture2D: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def op(self) -> str: ...
    @op.setter
    def op(self, value: str) -> str: ...
    @property
    def source(self) -> IQuerySource: ...
    @property
    def value(self) -> str: ...
    @value.setter
    def value(self, value: str) -> str: ...
    def Apply(self, searchProposition: clr.Reference[SearchProposition]) -> None: ...
    @abc.abstractmethod
    def GetPropositions(self, flags: SearchPropositionFlags = ...) -> IEnumerable_1[SearchProposition]: ...
    def ToString(self) -> str: ...


class QueryListBlockAttribute(Attribute):
    @typing.overload
    def __init__(self, category: str, name: str, id: str, op: str = ...) -> None: ...
    @typing.overload
    def __init__(self, category: str, name: str, ids: Array_1[str], op: str = ...) -> None: ...
    @property
    def category(self) -> str: ...
    @category.setter
    def category(self, value: str) -> str: ...
    @property
    def id(self) -> str: ...
    @property
    def ids(self) -> Array_1[str]: ...
    @ids.setter
    def ids(self, value: Array_1[str]) -> Array_1[str]: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def op(self) -> str: ...
    @op.setter
    def op(self, value: str) -> str: ...
    @property
    def type(self) -> typing.Type[typing.Any]: ...
    @type.setter
    def type(self, value: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    @property
    def TypeId(self) -> typing.Any: ...


class QueryNodeType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    And : QueryNodeType # 0
    Or : QueryNodeType # 1
    Filter : QueryNodeType # 2
    Search : QueryNodeType # 3
    Not : QueryNodeType # 4
    NestedQuery : QueryNodeType # 5
    Where : QueryNodeType # 6
    FilterIn : QueryNodeType # 7
    Union : QueryNodeType # 8
    Intersection : QueryNodeType # 9
    Aggregator : QueryNodeType # 10
    Comment : QueryNodeType # 11
    Toggle : QueryNodeType # 12
    Group : QueryNodeType # 13


class QueryToken:
    @typing.overload
    def __init__(self, text: str, position: int) -> None: ...
    @typing.overload
    def __init__(self, text: str, position: int, length: int) -> None: ...
    @property
    def length(self) -> int: ...
    @property
    def position(self) -> int: ...
    @property
    def text(self) -> str: ...


class QueryValidationOptions:
    skipIncompleteFilters : bool
    skipUnknownFilters : bool
    validateFilters : bool


class RefreshFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : RefreshFlags # 0
    Default : RefreshFlags # 1
    StructureChanged : RefreshFlags # 2
    DisplayModeChanged : RefreshFlags # 4
    ItemsChanged : RefreshFlags # 8
    GroupChanged : RefreshFlags # 16


class SearchAction:
    @typing.overload
    def __init__(self, providerId: str, id: str, content: GUIContent) -> None: ...
    @typing.overload
    def __init__(self, providerId: str, id: str, content: GUIContent, handler: Action_1[Array_1[SearchItem]]) -> None: ...
    @typing.overload
    def __init__(self, providerId: str, id: str, content: GUIContent, handler: Action_1[SearchItem]) -> None: ...
    @typing.overload
    def __init__(self, providerId: str, name: str, icon: Texture2D = ..., tooltip: str = ...) -> None: ...
    @typing.overload
    def __init__(self, providerId: str, name: str, icon: Texture2D, tooltip: str, handler: Action_1[Array_1[SearchItem]]) -> None: ...
    @typing.overload
    def __init__(self, providerId: str, name: str, icon: Texture2D, tooltip: str, handler: Action_1[SearchItem]) -> None: ...
    closeWindowAfterExecution : bool
    content : GUIContent
    enabled : Func_2[IReadOnlyCollection_1[SearchItem], bool]
    execute : Action_1[Array_1[SearchItem]]
    handler : Action_1[SearchItem]
    @property
    def displayName(self) -> str: ...
    @property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> str: ...


class SearchActionsProviderAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class SearchColumn(ISerializationCallbackReceiver, IEquatable_1[SearchColumn]):
    @typing.overload
    def __init__(self, path: str, content: GUIContent = ..., options: SearchColumnFlags = ...) -> None: ...
    @typing.overload
    def __init__(self, path: str, selector: str, content: GUIContent = ..., options: SearchColumnFlags = ...) -> None: ...
    @typing.overload
    def __init__(self, path: str, selector: str, provider: str, content: GUIContent = ..., options: SearchColumnFlags = ...) -> None: ...
    content : GUIContent
    options : SearchColumnFlags
    path : str
    provider : str
    selector : str
    width : float
    @property
    def comparer(self) -> SearchColumn.CompareEntry: ...
    @comparer.setter
    def comparer(self, value: SearchColumn.CompareEntry) -> SearchColumn.CompareEntry: ...
    @property
    def drawer(self) -> SearchColumn.DrawEntry: ...
    @drawer.setter
    def drawer(self, value: SearchColumn.DrawEntry) -> SearchColumn.DrawEntry: ...
    @property
    def getter(self) -> SearchColumn.GetterEntry: ...
    @getter.setter
    def getter(self, value: SearchColumn.GetterEntry) -> SearchColumn.GetterEntry: ...
    @property
    def name(self) -> str: ...
    @property
    def setter(self) -> SearchColumn.SetterEntry: ...
    @setter.setter
    def setter(self, value: SearchColumn.SetterEntry) -> SearchColumn.SetterEntry: ...
    @staticmethod
    def Enumerate(context: SearchContext, items: IEnumerable_1[SearchItem]) -> List_1[SearchColumn]: ...
    def GetHashCode(self) -> int: ...
    def InitFunctors(self) -> None: ...
    def OnAfterDeserialize(self) -> None: ...
    def OnBeforeSerialize(self) -> None: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: SearchColumn) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...


    class CompareEntry(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, args: SearchColumnCompareArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> int: ...
        def Invoke(self, args: SearchColumnCompareArgs) -> int: ...


    class DrawEntry(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, args: SearchColumnEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> typing.Any: ...
        def Invoke(self, args: SearchColumnEventArgs) -> typing.Any: ...


    class GetterEntry(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, args: SearchColumnEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> typing.Any: ...
        def Invoke(self, args: SearchColumnEventArgs) -> typing.Any: ...


    class SetterEntry(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, args: SearchColumnEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, args: SearchColumnEventArgs) -> None: ...



class SearchColumnCompareArgs:
    def __init__(self, lhs: SearchColumnEventArgs, rhs: SearchColumnEventArgs, sortAscending: bool) -> None: ...
    lhs : SearchColumnEventArgs
    rhs : SearchColumnEventArgs
    sortAscending : bool


class SearchColumnEventArgs:
    def __init__(self, item: SearchItem, context: SearchContext, column: SearchColumn) -> None: ...
    column : SearchColumn
    context : SearchContext
    focused : bool
    item : SearchItem
    multiple : bool
    rect : Rect
    selected : bool
    value : typing.Any


class SearchColumnFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : SearchColumnFlags # 0
    Hidden : SearchColumnFlags # 1
    Sorted : SearchColumnFlags # 2
    Volatile : SearchColumnFlags # 4
    IgnoreSettings : SearchColumnFlags # 8
    SortedDescending : SearchColumnFlags # 1024
    TextAlignmentLeft : SearchColumnFlags # 32768
    TextAlignmentCenter : SearchColumnFlags # 65536
    TextAlignmentRight : SearchColumnFlags # 131072
    TextAligmentMask : SearchColumnFlags # 229376
    CanHide : SearchColumnFlags # 1048576
    CanSort : SearchColumnFlags # 2097152
    Default : SearchColumnFlags # 3178496


class SearchColumnProviderAttribute(Attribute):
    def __init__(self, provider: str) -> None: ...
    @property
    def provider(self) -> str: ...
    @provider.setter
    def provider(self, value: str) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...


class SearchContext(ISerializationCallbackReceiver, IDisposable):
    @typing.overload
    def __init__(self, context: SearchContext) -> None: ...
    @typing.overload
    def __init__(self, providers: IEnumerable_1[SearchProvider]) -> None: ...
    @typing.overload
    def __init__(self, providers: IEnumerable_1[SearchProvider], searchText: str) -> None: ...
    @typing.overload
    def __init__(self, providers: IEnumerable_1[SearchProvider], searchText: str, options: SearchFlags) -> None: ...
    @property
    def empty(self) -> bool: ...
    @property
    def filterId(self) -> str: ...
    @filterId.setter
    def filterId(self, value: str) -> str: ...
    @property
    def focusedWindow(self) -> EditorWindow: ...
    @focusedWindow.setter
    def focusedWindow(self, value: EditorWindow) -> EditorWindow: ...
    @property
    def options(self) -> SearchFlags: ...
    @options.setter
    def options(self, value: SearchFlags) -> SearchFlags: ...
    @property
    def progressId(self) -> int: ...
    @progressId.setter
    def progressId(self, value: int) -> int: ...
    @property
    def providers(self) -> IEnumerable_1[SearchProvider]: ...
    @property
    def searchInProgress(self) -> bool: ...
    @property
    def searchPhrase(self) -> str: ...
    @property
    def searchQuery(self) -> str: ...
    @searchQuery.setter
    def searchQuery(self, value: str) -> str: ...
    @property
    def searchQueryOffset(self) -> int: ...
    @searchQueryOffset.setter
    def searchQueryOffset(self, value: int) -> int: ...
    @property
    def searchText(self) -> str: ...
    @searchText.setter
    def searchText(self, value: str) -> str: ...
    @property
    def searchView(self) -> ISearchView: ...
    @searchView.setter
    def searchView(self, value: ISearchView) -> ISearchView: ...
    @property
    def searchWords(self) -> Array_1[str]: ...
    @searchWords.setter
    def searchWords(self, value: Array_1[str]) -> Array_1[str]: ...
    @property
    def selection(self) -> SearchSelection: ...
    @property
    def textFilters(self) -> Array_1[str]: ...
    @textFilters.setter
    def textFilters(self, value: Array_1[str]) -> Array_1[str]: ...
    @property
    def wantsMore(self) -> bool: ...
    @wantsMore.setter
    def wantsMore(self, value: bool) -> bool: ...
    def AddSearchQueryError(self, error: SearchQueryError) -> None: ...
    def AddSearchQueryErrors(self, errors: IEnumerable_1[SearchQueryError]) -> None: ...
    def Dispose(self) -> None: ...
    def GetHashCode(self) -> int: ...
    def IsEnabled(self, providerId: str) -> bool: ...
    def SetFilter(self, providerId: str, isEnabled: bool) -> None: ...
    def ToString(self) -> str: ...


class SearchDocument(IComparable_1[SearchDocument], IEquatable_1[SearchDocument]):
    @typing.overload
    def __init__(self, doc: SearchDocument, path: str) -> None: ...
    @typing.overload
    def __init__(self, doc: SearchDocument, score: int) -> None: ...
    @typing.overload
    def __init__(self, id: str, name: str = ..., source: str = ..., score: int = ...) -> None: ...
    @typing.overload
    def __init__(self, index: int, id: str, path: str = ..., score: int = ...) -> None: ...
    id : str
    score : int
    @property
    def index(self) -> int: ...
    @property
    def name(self) -> str: ...
    @property
    def path(self) -> str: ...
    @property
    def source(self) -> str: ...
    @property
    def valid(self) -> bool: ...
    def CompareTo(self, other: SearchDocument) -> int: ...
    def GetHashCode(self) -> int: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: SearchDocument) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...



class SearchDocumentFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : SearchDocumentFlags # 0
    Asset : SearchDocumentFlags # 1
    Object : SearchDocumentFlags # 2
    Nested : SearchDocumentFlags # 4
    Grouped : SearchDocumentFlags # 8
    Resources : SearchDocumentFlags # 9


class SearchExpression:
    alias : StringView
    innerText : StringView
    outerText : StringView
    parameters : Array_1[SearchExpression]
    types : SearchExpressionType
    @property
    def name(self) -> str: ...
    @staticmethod
    def Check(e: SearchExpression, c: SearchExpressionContext) -> bool: ...
    @staticmethod
    def CreateId() -> str: ...
    @staticmethod
    def FormatItem(ctx: SearchContext, item: SearchItem, formatString: str) -> str: ...
    def GetBooleanValue(self, defaultValue: bool = ...) -> bool: ...
    @staticmethod
    def GetFormatString(expr: SearchExpression, formatStr: clr.Reference[str]) -> bool: ...
    def GetNumberValue(self, defaultValue: float = ...) -> float: ...
    def IsKeyword(self, keyword: SearchExpressionKeyword) -> bool: ...
    @staticmethod
    def IsTrue(item: SearchItem) -> bool: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryConvertToDouble(item: SearchItem, value: clr.Reference[float], selector: str = ...) -> bool: ...
    # Skipped CreateItem due to it being static, abstract and generic.

    CreateItem : CreateItem_MethodGroup
    class CreateItem_MethodGroup:
        @typing.overload
        def __call__(self, value: float, label: str = ...) -> SearchItem:...
        # Method CreateItem(value : Int32, label : String) was skipped since it collides with above method
        @typing.overload
        def __call__(self, value: str, label: str = ...) -> SearchItem:...
        @typing.overload
        def __call__(self, label: str, value: typing.Any, description: str) -> SearchItem:...

    # Skipped Execute due to it being static, abstract and generic.

    Execute : Execute_MethodGroup
    class Execute_MethodGroup:
        @typing.overload
        def __call__(self, c: SearchExpressionContext) -> IEnumerable_1[SearchItem]:...
        @typing.overload
        def __call__(self, searchContext: SearchContext) -> IEnumerable_1[SearchItem]:...

    # Skipped ProcessValues due to it being static, abstract and generic.

    ProcessValues : ProcessValues_MethodGroup
    class ProcessValues_MethodGroup:
        def __getitem__(self, t:typing.Type[ProcessValues_1_T1]) -> ProcessValues_1[ProcessValues_1_T1]: ...

        ProcessValues_1_T1 = typing.TypeVar('ProcessValues_1_T1')
        class ProcessValues_1(typing.Generic[ProcessValues_1_T1]):
            ProcessValues_1_T = SearchExpression.ProcessValues_MethodGroup.ProcessValues_1_T1
            def __call__(self, items: IEnumerable_1[SearchItem], outputValueFieldName: str, processHandler: Func_2[SearchItem, ProcessValues_1_T]) -> IEnumerable_1[SearchItem]:...




class SearchExpressionContext:
    args : Array_1[SearchExpression]
    expression : SearchExpression
    runtime : SearchExpressionRuntime
    @property
    def items(self) -> IReadOnlyCollection_1[SearchItem]: ...
    @property
    def search(self) -> SearchContext: ...
    @property
    def valid(self) -> bool: ...
    def Break(self) -> None: ...
    def Continue(self) -> None: ...
    def IsBreaking(self) -> bool: ...
    def IsContinuing(self) -> bool: ...
    def ResetIterationControl(self) -> None: ...
    def ToString(self) -> str: ...
    # Skipped ResolveAlias due to it being static, abstract and generic.

    ResolveAlias : ResolveAlias_MethodGroup
    class ResolveAlias_MethodGroup:
        @typing.overload
        def __call__(self, defaultLabel: str = ...) -> str:...
        @typing.overload
        def __call__(self, expr: SearchExpression, defaultLabel: str = ...) -> str:...

    # Skipped ThrowError due to it being static, abstract and generic.

    ThrowError : ThrowError_MethodGroup
    class ThrowError_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, message: str, errorPosition: StringView) -> None:...



class SearchExpressionEvaluationHints(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    ThreadSupported : SearchExpressionEvaluationHints # 1
    Default : SearchExpressionEvaluationHints # 1
    ThreadNotSupported : SearchExpressionEvaluationHints # 2
    ExpandSupported : SearchExpressionEvaluationHints # 4
    AlwaysExpand : SearchExpressionEvaluationHints # 8
    DoNotValidateSignature : SearchExpressionEvaluationHints # 16
    DoNotValidateArgsSignature : SearchExpressionEvaluationHints # 32
    ImplicitArgsLiterals : SearchExpressionEvaluationHints # 64


class SearchExpressionEvaluatorAttribute(Attribute):
    @typing.overload
    def __init__(self, hints: SearchExpressionEvaluationHints, signatureArgumentTypes: Array_1[SearchExpressionType]) -> None: ...
    @typing.overload
    def __init__(self, name: str, hints: SearchExpressionEvaluationHints, signatureArgumentTypes: Array_1[SearchExpressionType]) -> None: ...
    @typing.overload
    def __init__(self, name: str, signatureArgumentTypes: Array_1[SearchExpressionType]) -> None: ...
    @typing.overload
    def __init__(self, signatureArgumentTypes: Array_1[SearchExpressionType]) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class SearchExpressionEvaluatorSignatureOverloadAttribute(Attribute):
    def __init__(self, signatureArgumentTypes: Array_1[SearchExpressionType]) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class SearchExpressionKeyword(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : SearchExpressionKeyword # 0
    Asc : SearchExpressionKeyword # 1
    Desc : SearchExpressionKeyword # 2
    Any : SearchExpressionKeyword # 3
    All : SearchExpressionKeyword # 4
    Keep : SearchExpressionKeyword # 5
    Sort : SearchExpressionKeyword # 6


class SearchExpressionRuntime:
    frames : Stack_1[SearchExpressionContext]
    items : Stack_1[SearchItem]
    search : SearchContext
    @property
    def current(self) -> SearchExpressionContext: ...
    @property
    def valid(self) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Push due to it being static, abstract and generic.

    Push : Push_MethodGroup
    class Push_MethodGroup:
        @typing.overload
        def __call__(self, item: SearchItem) -> IDisposable:...
        @typing.overload
        def __call__(self, searchExpression: SearchExpression, args: IEnumerable_1[SearchExpression]) -> IDisposable:...



class SearchExpressionType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Nil : SearchExpressionType # 0
    Optional : SearchExpressionType # 1
    Variadic : SearchExpressionType # 2
    Boolean : SearchExpressionType # 4
    Number : SearchExpressionType # 16
    Text : SearchExpressionType # 32
    Selector : SearchExpressionType # 64
    Keyword : SearchExpressionType # 128
    Literal : SearchExpressionType # 180
    Set : SearchExpressionType # 256
    Function : SearchExpressionType # 1024
    QueryString : SearchExpressionType # 2048
    Iterable : SearchExpressionType # 3328
    AnyValue : SearchExpressionType # 3508
    AnyExpression : SearchExpressionType # 3572
    Expandable : SearchExpressionType # 4096
    Group : SearchExpressionType # 8192


class SearchField(IEquatable_1[SearchField]):
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: str, alias: str, value: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, name: str, value: typing.Any) -> None: ...
    alias : str
    name : str
    value : typing.Any
    @property
    def label(self) -> str: ...
    def GetHashCode(self) -> int: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: SearchField) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...



class SearchFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : SearchFlags # 0
    Synchronous : SearchFlags # 1
    Default : SearchFlags # 2
    Sorted : SearchFlags # 2
    FirstBatchAsync : SearchFlags # 4
    WantsMore : SearchFlags # 8
    Debug : SearchFlags # 16
    NoIndexing : SearchFlags # 32
    Expression : SearchFlags # 64
    QueryString : SearchFlags # 128
    Packages : SearchFlags # 256
    ShowErrorsWithResults : SearchFlags # 16777216
    SaveFilters : SearchFlags # 33554432
    ReuseExistingWindow : SearchFlags # 67108864
    Multiselect : SearchFlags # 134217728
    Dockable : SearchFlags # 268435456
    OpenDefault : SearchFlags # 436207616
    OpenGlobal : SearchFlags # 503316480
    FocusContext : SearchFlags # 536870912
    OpenContextual : SearchFlags # 939524096
    HidePanels : SearchFlags # 1073741824
    OpenPicker : SearchFlags # 1610612736


class SearchIndexer:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @property
    def documentCount(self) -> int: ...
    @property
    def keywordCount(self) -> int: ...
    @property
    def minQueryLength(self) -> int: ...
    @minQueryLength.setter
    def minQueryLength(self, value: int) -> int: ...
    @property
    def minWordIndexationLength(self) -> int: ...
    @minWordIndexationLength.setter
    def minWordIndexationLength(self, value: int) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def resolveDocumentHandler(self) -> Func_2[str, str]: ...
    @resolveDocumentHandler.setter
    def resolveDocumentHandler(self, value: Func_2[str, str]) -> Func_2[str, str]: ...
    @property
    def skipEntryHandler(self) -> Func_2[str, bool]: ...
    @skipEntryHandler.setter
    def skipEntryHandler(self, value: Func_2[str, bool]) -> Func_2[str, bool]: ...
    @property
    def timestamp(self) -> int: ...
    def AddExactWord(self, word: str, score: int, documentIndex: int) -> None: ...
    def AddNumber(self, key: str, value: float, score: int, documentIndex: int) -> None: ...
    def GetDocument(self, index: int) -> SearchDocument: ...
    def GetMetaInfo(self, documentId: str) -> str: ...
    def IndexDocument(self, document: str, checkIfDocumentExists: bool) -> None: ...
    def IsReady(self) -> bool: ...
    def LoadBytes(self, bytes: Array_1[int], finished: Action_1[bool]) -> bool: ...
    def Merge(self, removeDocuments: Array_1[str], other: SearchIndexer, baseScore: int = ..., documentIndexing: Action_3[int, SearchIndexer, int] = ...) -> None: ...
    def Read(self, stream: Stream, checkVersionOnly: bool) -> bool: ...
    def SaveBytes(self) -> Array_1[int]: ...
    def SetMetaInfo(self, documentId: str, metadata: str) -> None: ...
    def SkipEntry(self, document: str, checkRoots: bool = ...) -> bool: ...
    def Start(self, clear: bool = ...) -> None: ...
    def Write(self, stream: Stream) -> None: ...
    # Skipped AddDocument due to it being static, abstract and generic.

    AddDocument : AddDocument_MethodGroup
    class AddDocument_MethodGroup:
        @typing.overload
        def __call__(self, document: str, checkIfExists: bool = ...) -> int:...
        @typing.overload
        def __call__(self, document: str, name: str, source: str, checkIfExists: bool, flags: SearchDocumentFlags) -> int:...

    # Skipped AddProperty due to it being static, abstract and generic.

    AddProperty : AddProperty_MethodGroup
    class AddProperty_MethodGroup:
        @typing.overload
        def __call__(self, key: str, value: str, documentIndex: int, saveKeyword: bool = ..., exact: bool = ...) -> None:...
        @typing.overload
        def __call__(self, key: str, value: str, score: int, documentIndex: int, saveKeyword: bool = ..., exact: bool = ...) -> None:...
        @typing.overload
        def __call__(self, name: str, value: str, minVariations: int, maxVariations: int, score: int, documentIndex: int, saveKeyword: bool = ..., exact: bool = ...) -> None:...

    # Skipped AddWord due to it being static, abstract and generic.

    AddWord : AddWord_MethodGroup
    class AddWord_MethodGroup:
        @typing.overload
        def __call__(self, word: str, score: int, documentIndex: int) -> None:...
        @typing.overload
        def __call__(self, word: str, size: int, score: int, documentIndex: int) -> None:...
        @typing.overload
        def __call__(self, word: str, minVariations: int, maxVariations: int, score: int, documentIndex: int) -> None:...

    # Skipped Finish due to it being static, abstract and generic.

    Finish : Finish_MethodGroup
    class Finish_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, removedDocuments: Array_1[str]) -> None:...
        @typing.overload
        def __call__(self, threadCompletedCallback: Action) -> None:...
        @typing.overload
        def __call__(self, threadCompletedCallback: Action_1[Array_1[int]], removedDocuments: Array_1[str]) -> None:...
        @typing.overload
        def __call__(self, threadCompletedCallback: Action, removedDocuments: Array_1[str]) -> None:...
        @typing.overload
        def __call__(self, threadCompletedCallback: Action_1[Array_1[int]], removedDocuments: Array_1[str], saveBytes: bool) -> None:...

    # Skipped Search due to it being static, abstract and generic.

    Search : Search_MethodGroup
    class Search_MethodGroup:
        @typing.overload
        def __call__(self, query: str, maxScore: int = ..., patternMatchLimit: int = ...) -> IEnumerable_1[SearchResult]:...
        @typing.overload
        def __call__(self, context: SearchContext, provider: SearchProvider, maxScore: int = ..., patternMatchLimit: int = ...) -> IEnumerable_1[SearchResult]:...
        @typing.overload
        def __call__(self, query: str, context: SearchContext, provider: SearchProvider, maxScore: int = ..., patternMatchLimit: int = ...) -> IEnumerable_1[SearchResult]:...



class SearchItem(IComparable, IComparable_1[SearchItem], IEquatable_1[SearchItem]):
    def __init__(self, _id: str) -> None: ...
    context : SearchContext
    data : typing.Any
    description : str
    id : str
    label : str
    none : SearchItem
    options : SearchItemOptions
    preview : Texture2D
    provider : SearchProvider
    score : int
    thumbnail : Texture2D
    @classmethod
    @property
    def clear(cls) -> SearchItem: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def value(self) -> typing.Any: ...
    @value.setter
    def value(self, value: typing.Any) -> typing.Any: ...
    def GetDescription(self, context: SearchContext, stripHTML: bool = ...) -> str: ...
    def GetFieldCount(self) -> int: ...
    def GetFieldNames(self) -> Array_1[str]: ...
    def GetFields(self) -> IEnumerable_1[SearchField]: ...
    def GetHashCode(self) -> int: ...
    def GetLabel(self, context: SearchContext, stripHTML: bool = ...) -> str: ...
    def GetPreview(self, context: SearchContext, size: Vector2, options: FetchPreviewOptions = ..., cacheThumbnail: bool = ...) -> Texture2D: ...
    def GetThumbnail(self, context: SearchContext, cacheThumbnail: bool = ...) -> Texture2D: ...
    def GetValue(self, name: str = ..., context: SearchContext = ...) -> typing.Any: ...
    def RemoveField(self, name: str) -> bool: ...
    def ToGlobalId(self) -> str: ...
    def ToString(self) -> str: ...
    def TryGetField(self, name: str, field: clr.Reference[SearchField]) -> bool: ...
    # Skipped CompareTo due to it being static, abstract and generic.

    CompareTo : CompareTo_MethodGroup
    class CompareTo_MethodGroup:
        @typing.overload
        def __call__(self, other: SearchItem) -> int:...
        @typing.overload
        def __call__(self, other: typing.Any) -> int:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: SearchItem) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped SetField due to it being static, abstract and generic.

    SetField : SetField_MethodGroup
    class SetField_MethodGroup:
        @typing.overload
        def __call__(self, name: str, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, name: str, alias: str, value: typing.Any) -> None:...

    # Skipped ToObject due to it being static, abstract and generic.

    ToObject : ToObject_MethodGroup
    class ToObject_MethodGroup:
        def __getitem__(self, t:typing.Type[ToObject_1_T1]) -> ToObject_1[ToObject_1_T1]: ...

        ToObject_1_T1 = typing.TypeVar('ToObject_1_T1')
        class ToObject_1(typing.Generic[ToObject_1_T1]):
            ToObject_1_T = SearchItem.ToObject_MethodGroup.ToObject_1_T1
            def __call__(self) -> ToObject_1_T:...

        @typing.overload
        def __call__(self) -> Object:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> Object:...

    # Skipped TryGetValue due to it being static, abstract and generic.

    TryGetValue : TryGetValue_MethodGroup
    class TryGetValue_MethodGroup:
        @typing.overload
        def __call__(self, name: str, field: clr.Reference[SearchField]) -> bool:...
        @typing.overload
        def __call__(self, name: str, context: SearchContext, field: clr.Reference[SearchField]) -> bool:...



class SearchItemOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : SearchItemOptions # 0
    Ellipsis : SearchItemOptions # 1
    RightToLeft : SearchItemOptions # 2
    Highlight : SearchItemOptions # 4
    FuzzyHighlight : SearchItemOptions # 8
    Compacted : SearchItemOptions # 16
    AlwaysRefresh : SearchItemOptions # 32
    FullDescription : SearchItemOptions # 64
    CustomAction : SearchItemOptions # 128


class SearchItemProviderAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class SearchMonitor(abc.ABC):
    @classmethod
    @property
    def pending(cls) -> bool: ...
    @staticmethod
    def GetDiff(timestamp: int, deletedAssets: IEnumerable_1[str], predicate: Func_2[str, bool]) -> AssetIndexChangeSet: ...
    @staticmethod
    def GetView(delayedSync: bool = ...) -> SearchMonitorView: ...
    @staticmethod
    def Log(message: str, documentKey: int = ...) -> None: ...
    @staticmethod
    def RaiseContentRefreshed(updated: Array_1[str], removed: Array_1[str], moved: Array_1[str]) -> None: ...
    @staticmethod
    def Reset() -> None: ...


class SearchMonitorView(IDisposable):
    def __init__(self, propertyDatabase: PropertyDatabase, propertyAliases: PropertyDatabase, delayedSync: bool = ...) -> None: ...
    def Dispose(self) -> None: ...
    def Invalidate(self, recordKey: PropertyDatabaseRecordKey) -> None: ...
    def StoreAlias(self, key: PropertyDatabaseRecordKey, alias: str) -> None: ...
    def TryLoadAlias(self, recordKey: PropertyDatabaseRecordKey, alias: clr.Reference[str]) -> bool: ...
    # Skipped InvalidateDocument due to it being static, abstract and generic.

    InvalidateDocument : InvalidateDocument_MethodGroup
    class InvalidateDocument_MethodGroup:
        @typing.overload
        def __call__(self, documentKey: int) -> None:...
        @typing.overload
        def __call__(self, documentKey: str) -> None:...

    # Skipped StoreProperty due to it being static, abstract and generic.

    StoreProperty : StoreProperty_MethodGroup
    class StoreProperty_MethodGroup:
        @typing.overload
        def __call__(self, recordKey: PropertyDatabaseRecordKey, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, recordKey: PropertyDatabaseRecordKey, value: typing.Any, alias: str) -> None:...

    # Skipped TryLoadProperty due to it being static, abstract and generic.

    TryLoadProperty : TryLoadProperty_MethodGroup
    class TryLoadProperty_MethodGroup:
        @typing.overload
        def __call__(self, recordKey: PropertyDatabaseRecordKey, data: clr.Reference[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, documentKey: int, propertyName: str, recordKey: clr.Reference[PropertyDatabaseRecordKey], value: clr.Reference[typing.Any], alias: clr.Reference[str]) -> bool:...



class SearchProposition(IComparable_1[SearchProposition], IEquatable_1[SearchProposition]):
    @typing.overload
    def __init__(self, category: str = ..., label: str = ..., replacement: str = ..., help: str = ..., priority: int = ..., moveCursor: TextCursorPlacement = ..., icon: Texture2D = ..., type: typing.Type[typing.Any] = ..., data: typing.Any = ..., color: Color = ...) -> None: ...
    @typing.overload
    def __init__(self, label: str, replacement: str, help: str, priority: int, icon: Texture2D, data: typing.Any, color: Color = ...) -> None: ...
    @typing.overload
    def __init__(self, label: str, replacement: str = ..., help: str = ..., priority: int = ..., moveCursor: TextCursorPlacement = ..., icon: Texture2D = ..., color: Color = ...) -> None: ...
    data : typing.Any
    def CompareTo(self, other: SearchProposition) -> int: ...
    def GetHashCode(self) -> int: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: SearchProposition) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...



class SearchPropositionFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : SearchPropositionFlags # 0
    FilterOnly : SearchPropositionFlags # 1
    IgnoreRecents : SearchPropositionFlags # 2
    QueryBuilder : SearchPropositionFlags # 4
    NoCategory : SearchPropositionFlags # 8
    ForceAllProviders : SearchPropositionFlags # 16


class SearchPropositionFlagsExtensions(abc.ABC):
    @staticmethod
    def HasAll(flags: SearchPropositionFlags, all: SearchPropositionFlags) -> bool: ...
    @staticmethod
    def HasAny(flags: SearchPropositionFlags, f: SearchPropositionFlags) -> bool: ...


class SearchPropositionOptions:
    @property
    def flags(self) -> SearchPropositionFlags: ...
    @flags.setter
    def flags(self, value: SearchPropositionFlags) -> SearchPropositionFlags: ...


class SearchProvider(ISerializationCallbackReceiver):
    @typing.overload
    def __init__(self, id: str) -> None: ...
    @typing.overload
    def __init__(self, id: str, displayName: str) -> None: ...
    @typing.overload
    def __init__(self, id: str, displayName: str, fetchItemsHandler: Func_3[SearchContext, SearchProvider, typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, id: str, displayName: str, fetchItemsHandler: Func_4[SearchContext, List_1[SearchItem], SearchProvider, typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, id: str, fetchItemsHandler: Func_4[SearchContext, List_1[SearchItem], SearchProvider, typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, id: str, fetchItemsHandler: Func_3[SearchContext, SearchProvider, typing.Any]) -> None: ...
    active : bool
    fetchColumns : Func_3[SearchContext, IEnumerable_1[SearchItem], IEnumerable_1[SearchColumn]]
    fetchDescription : Func_3[SearchItem, SearchContext, str]
    fetchItems : Func_4[SearchContext, List_1[SearchItem], SearchProvider, typing.Any]
    fetchLabel : Func_3[SearchItem, SearchContext, str]
    fetchPreview : Func_5[SearchItem, SearchContext, Vector2, FetchPreviewOptions, Texture2D]
    fetchPropositions : Func_3[SearchContext, SearchPropositionOptions, IEnumerable_1[SearchProposition]]
    fetchThumbnail : Func_3[SearchItem, SearchContext, Texture2D]
    filterId : str
    isEnabledForContextualSearch : Func_1[bool]
    isExplicitProvider : bool
    onDisable : Action
    onEnable : Action
    priority : int
    showDetails : bool
    showDetailsOptions : ShowDetailsOptions
    startDrag : Action_2[SearchItem, SearchContext]
    toObject : Func_3[SearchItem, typing.Type[typing.Any], Object]
    trackSelection : Action_2[SearchItem, SearchContext]
    @property
    def actions(self) -> List_1[SearchAction]: ...
    @actions.setter
    def actions(self, value: List_1[SearchAction]) -> List_1[SearchAction]: ...
    @property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> str: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> str: ...
    @property
    def type(self) -> str: ...
    @type.setter
    def type(self, value: str) -> str: ...
    def ToString(self) -> str: ...
    # Skipped CreateItem due to it being static, abstract and generic.

    CreateItem : CreateItem_MethodGroup
    class CreateItem_MethodGroup:
        @typing.overload
        def __call__(self, id: str) -> SearchItem:...
        @typing.overload
        def __call__(self, id: str, label: str) -> SearchItem:...
        @typing.overload
        def __call__(self, context: SearchContext, id: str) -> SearchItem:...
        @typing.overload
        def __call__(self, id: str, label: str, description: str, thumbnail: Texture2D, data: typing.Any) -> SearchItem:...
        @typing.overload
        def __call__(self, id: str, score: int, label: str, description: str, thumbnail: Texture2D, data: typing.Any) -> SearchItem:...
        @typing.overload
        def __call__(self, context: SearchContext, id: str, label: str, description: str, thumbnail: Texture2D, data: typing.Any) -> SearchItem:...
        @typing.overload
        def __call__(self, context: SearchContext, id: str, score: int, label: str, description: str, thumbnail: Texture2D, data: typing.Any) -> SearchItem:...



class SearchQueryError:
    @typing.overload
    def __init__(self, error: QueryError, context: SearchContext, provider: SearchProvider, fromSearchQuery: bool = ...) -> None: ...
    @typing.overload
    def __init__(self, index: int, length: int, reason: str, context: SearchContext, provider: SearchProvider, fromSearchQuery: bool = ..., type: SearchQueryErrorType = ...) -> None: ...
    @property
    def context(self) -> SearchContext: ...
    @property
    def index(self) -> int: ...
    @property
    def length(self) -> int: ...
    @property
    def provider(self) -> SearchProvider: ...
    @property
    def reason(self) -> str: ...
    @property
    def type(self) -> SearchQueryErrorType: ...
    def GetHashCode(self) -> int: ...


class SearchQueryErrorType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Error : SearchQueryErrorType # 0
    Warning : SearchQueryErrorType # 1


class SearchResult(IComparable_1[SearchResult], IEquatable_1[SearchResult]):
    @typing.overload
    def __init__(self, id: str, index: int, score: int) -> None: ...
    @typing.overload
    def __init__(self, index: int) -> None: ...
    @typing.overload
    def __init__(self, index: int, score: int) -> None: ...
    id : str
    index : int
    nil : SearchResult
    score : int
    @property
    def valid(self) -> bool: ...
    def CompareTo(self, other: SearchResult) -> int: ...
    def GetHashCode(self) -> int: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: SearchResult) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...



class SearchSelection(IReadOnlyCollection_1[SearchItem]):
    @typing.overload
    def __init__(self, items: IEnumerable_1[SearchItem]) -> None: ...
    @typing.overload
    def __init__(self, selection: IList_1[int], filteredItems: ISearchList) -> None: ...
    @property
    def Count(self) -> int: ...
    def Contains(self, item: SearchItem) -> bool: ...
    def First(self) -> SearchItem: ...
    def GetEnumerator(self) -> IEnumerator_1[SearchItem]: ...
    def Last(self) -> SearchItem: ...
    def MaxIndex(self) -> int: ...
    def MinIndex(self) -> int: ...


class SearchSelectorArgs:
    current : SearchItem


class SearchSelectorAttribute(Attribute):
    def __init__(self, pattern: str, priority: int = ..., provider: str = ..., printable: bool = ...) -> None: ...
    @property
    def cacheable(self) -> bool: ...
    @cacheable.setter
    def cacheable(self, value: bool) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...


class SearchService(abc.ABC):
    @classmethod
    @property
    def OrderedProviders(cls) -> IEnumerable_1[SearchProvider]: ...
    @classmethod
    @property
    def Providers(cls) -> List_1[SearchProvider]: ...
    @classmethod
    @Providers.setter
    def Providers(cls, value: List_1[SearchProvider]) -> List_1[SearchProvider]: ...
    @staticmethod
    def CreateIndex(name: clr.Reference[str], options: clr.Reference[IndexingOptions], roots: IEnumerable_1[str], includes: IEnumerable_1[str], excludes: IEnumerable_1[str], onIndexReady: Action_3[str, str, Action]) -> None: ...
    @staticmethod
    def EnumerateDatabases() -> IEnumerable_1[ISearchDatabase]: ...
    @staticmethod
    def GetAction(provider: SearchProvider, actionId: str) -> SearchAction: ...
    @staticmethod
    def GetActiveProviders() -> IEnumerable_1[SearchProvider]: ...
    @staticmethod
    def GetItems(context: SearchContext, options: SearchFlags = ...) -> List_1[SearchItem]: ...
    @staticmethod
    def GetProvider(providerId: str) -> SearchProvider: ...
    @staticmethod
    def IsIndexReady(name: str) -> bool: ...
    @staticmethod
    def Refresh() -> None: ...
    @staticmethod
    def RefreshWindows() -> None: ...
    @staticmethod
    def SetActive(providerId: str, active: bool = ...) -> None: ...
    @staticmethod
    def ShowContextual(providerIds: Array_1[str]) -> ISearchView: ...
    @staticmethod
    def ShowObjectPicker(selectHandler: Action_2[Object, bool], trackingHandler: Action_1[Object], searchText: str, typeName: str, filterType: typing.Type[typing.Any], defaultWidth: float = ..., defaultHeight: float = ..., flags: SearchFlags = ...) -> ISearchView: ...
    # Skipped CreateContext due to it being static, abstract and generic.

    CreateContext : CreateContext_MethodGroup
    class CreateContext_MethodGroup:
        @typing.overload
        def __call__(self, searchText: str) -> SearchContext:...
        @typing.overload
        def __call__(self, searchText: str, flags: SearchFlags) -> SearchContext:...
        @typing.overload
        def __call__(self, provider: SearchProvider, searchText: str = ...) -> SearchContext:...
        @typing.overload
        def __call__(self, providerId: str, searchText: str = ..., flags: SearchFlags = ...) -> SearchContext:...
        @typing.overload
        def __call__(self, providerIds: IEnumerable_1[str], searchText: str = ..., flags: SearchFlags = ...) -> SearchContext:...
        @typing.overload
        def __call__(self, providers: IEnumerable_1[SearchProvider], searchText: str = ..., flags: SearchFlags = ...) -> SearchContext:...

    # Skipped Request due to it being static, abstract and generic.

    Request : Request_MethodGroup
    class Request_MethodGroup:
        @typing.overload
        def __call__(self, searchText: str, options: SearchFlags = ...) -> ISearchList:...
        @typing.overload
        def __call__(self, context: SearchContext, options: SearchFlags = ...) -> ISearchList:...
        @typing.overload
        def __call__(self, searchText: str, onSearchCompleted: Action_2[SearchContext, IList_1[SearchItem]], options: SearchFlags = ...) -> None:...
        @typing.overload
        def __call__(self, context: SearchContext, onSearchCompleted: Action_2[SearchContext, IList_1[SearchItem]], options: SearchFlags = ...) -> None:...
        @typing.overload
        def __call__(self, searchText: str, onIncomingItems: Action_2[SearchContext, IEnumerable_1[SearchItem]], onSearchCompleted: Action_1[SearchContext], options: SearchFlags = ...) -> None:...
        @typing.overload
        def __call__(self, context: SearchContext, onIncomingItems: Action_2[SearchContext, IEnumerable_1[SearchItem]], onSearchCompleted: Action_1[SearchContext], options: SearchFlags = ...) -> None:...

    # Skipped ShowPicker due to it being static, abstract and generic.

    ShowPicker : ShowPicker_MethodGroup
    class ShowPicker_MethodGroup:
        @typing.overload
        def __call__(self, viewState: SearchViewState) -> ISearchView:...
        @typing.overload
        def __call__(self, context: SearchContext, selectHandler: Action_2[SearchItem, bool], trackingHandler: Action_1[SearchItem] = ..., filterHandler: Func_2[SearchItem, bool] = ..., subset: IEnumerable_1[SearchItem] = ..., title: str = ..., itemSize: float = ..., defaultWidth: float = ..., defaultHeight: float = ..., flags: SearchFlags = ...) -> ISearchView:...

    # Skipped ShowWindow due to it being static, abstract and generic.

    ShowWindow : ShowWindow_MethodGroup
    class ShowWindow_MethodGroup:
        @typing.overload
        def __call__(self, viewState: SearchViewState) -> ISearchView:...
        @typing.overload
        def __call__(self, context: SearchContext = ..., topic: str = ..., defaultWidth: float = ..., defaultHeight: float = ..., saveFilters: bool = ..., reuseExisting: bool = ..., multiselect: bool = ..., dockable: bool = ...) -> ISearchView:...



class SearchSettings(abc.ABC):
    searchItemFavorites : HashSet_1[str]
    @staticmethod
    def AddItemFavorite(item: SearchItem) -> None: ...
    @staticmethod
    def RemoveItemFavorite(item: SearchItem) -> None: ...


class SearchTable:
    @typing.overload
    def __init__(self, id: str, name: str, columnModels: IEnumerable_1[SearchColumn]) -> None: ...
    @typing.overload
    def __init__(self, name: str, columnModels: IEnumerable_1[SearchColumn]) -> None: ...
    @typing.overload
    def __init__(self, other: SearchTable, newName: str = ...) -> None: ...
    columns : Array_1[SearchColumn]
    id : str
    name : str
    def Clone(self, newName: str = ...) -> SearchTable: ...
    def InitFunctors(self) -> None: ...
    @staticmethod
    def LoadFromFile(stcPath: str) -> SearchTable: ...


class SearchUtils(abc.ABC):
    entrySeparators : Array_1[str]
    @staticmethod
    def CreateGroupProvider(templateProvider: SearchProvider, groupId: str, groupPriority: int, cacheProvider: bool = ...) -> SearchProvider: ...
    @staticmethod
    def CreateQuery(name: clr.Reference[str], context: SearchContext, tableConfig: SearchTable) -> ISearchQuery: ...
    @staticmethod
    def CreateSceneResult(context: SearchContext, sceneProvider: SearchProvider, go: GameObject) -> SearchItem: ...
    @staticmethod
    def EnumerateAllQueries() -> IEnumerable_1[ISearchQuery]: ...
    @staticmethod
    def FindQuery(guid: str) -> ISearchQuery: ...
    @staticmethod
    def FindShiftLeftVariations(word: str) -> Array_1[str]: ...
    @staticmethod
    def FormatBytes(byteCount: int) -> str: ...
    @staticmethod
    def FormatCount(count: int) -> str: ...
    @staticmethod
    def FrameAssetFromPath(path: str) -> None: ...
    @staticmethod
    def GetAssetPath(item: clr.Reference[SearchItem]) -> str: ...
    @staticmethod
    def GetAssetThumbnailFromPath(path: str) -> Texture2D: ...
    @staticmethod
    def GetHierarchyAssetPath(gameObject: GameObject, prefabOnly: bool = ...) -> str: ...
    @staticmethod
    def GetHierarchyPath(gameObject: GameObject, includeScene: bool = ...) -> str: ...
    @staticmethod
    def GetMainAssetInstanceID(assetPath: str) -> int: ...
    @staticmethod
    def GetMainWindowCenteredPosition(size: Vector2) -> Rect: ...
    @staticmethod
    def GetObjectPath(obj: Object) -> str: ...
    @staticmethod
    def GetSceneObjectPreview(obj: GameObject, size: Vector2, options: FetchPreviewOptions, thumbnail: Texture2D) -> Texture2D: ...
    @staticmethod
    def GetTransformPath(tform: Transform) -> str: ...
    @staticmethod
    def GetTypeIcon(type: clr.Reference[typing.Type[typing.Any]]) -> Texture2D: ...
    @staticmethod
    def MatchSearchGroups(context: SearchContext, content: str, ignoreCase: bool = ...) -> bool: ...
    @staticmethod
    def OpenQuery(sq: ISearchQuery, flags: SearchFlags) -> ISearchView: ...
    @staticmethod
    def PingAsset(assetPath: str) -> None: ...
    @staticmethod
    def SelectMultipleItems(items: IEnumerable_1[SearchItem], focusProjectBrowser: bool = ..., pingSelection: bool = ...) -> None: ...
    @staticmethod
    def ShowColumnEditor(column: MultiColumnHeaderState.Column, editHandler: Action_1[MultiColumnHeaderState.Column]) -> EditorWindow: ...
    @staticmethod
    def ShowColumnSelector(columnsAddedHandler: Action_2[IEnumerable_1[SearchColumn], int], columns: IEnumerable_1[SearchColumn], mousePosition: Vector2, activeColumnIndex: int) -> None: ...
    @staticmethod
    def ShowIconPicker(iconSelectedHandler: Action_2[Texture2D, bool]) -> None: ...
    @staticmethod
    def SplitCamelCase(source: str) -> Array_1[str]: ...
    @staticmethod
    def SplitEntryComponents(entry: str, entrySeparators: Array_1[str]) -> IEnumerable_1[str]: ...
    # Skipped FetchGameObjects due to it being static, abstract and generic.

    FetchGameObjects : FetchGameObjects_MethodGroup
    class FetchGameObjects_MethodGroup:
        @typing.overload
        def __call__(self) -> IEnumerable_1[GameObject]:...
        @typing.overload
        def __call__(self, scene: Scene) -> Array_1[GameObject]:...

    # Skipped GetAssetPreviewFromPath due to it being static, abstract and generic.

    GetAssetPreviewFromPath : GetAssetPreviewFromPath_MethodGroup
    class GetAssetPreviewFromPath_MethodGroup:
        @typing.overload
        def __call__(self, path: str, previewOptions: FetchPreviewOptions) -> Texture2D:...
        @typing.overload
        def __call__(self, path: str, previewSize: Vector2, previewOptions: FetchPreviewOptions) -> Texture2D:...

    # Skipped SplitFileEntryComponents due to it being static, abstract and generic.

    SplitFileEntryComponents : SplitFileEntryComponents_MethodGroup
    class SplitFileEntryComponents_MethodGroup:
        @typing.overload
        def __call__(self, path: str, entrySeparators: clr.Reference[Array_1[str]]) -> IEnumerable_1[str]:...
        @typing.overload
        def __call__(self, path: str, entrySeparators: clr.Reference[Array_1[str]], minTokenLength: int) -> IEnumerable_1[str]:...

    # Skipped StartDrag due to it being static, abstract and generic.

    StartDrag : StartDrag_MethodGroup
    class StartDrag_MethodGroup:
        @typing.overload
        def __call__(self, objects: Array_1[Object], label: str = ...) -> None:...
        @typing.overload
        def __call__(self, objects: Array_1[Object], paths: Array_1[str], label: str = ...) -> None:...

    # Skipped TryParse due to it being static, abstract and generic.

    TryParse : TryParse_MethodGroup
    class TryParse_MethodGroup:
        def __getitem__(self, t:typing.Type[TryParse_1_T1]) -> TryParse_1[TryParse_1_T1]: ...

        TryParse_1_T1 = typing.TypeVar('TryParse_1_T1')
        class TryParse_1(typing.Generic[TryParse_1_T1]):
            TryParse_1_T = SearchUtils.TryParse_MethodGroup.TryParse_1_T1
            def __call__(self, expression: str, result: clr.Reference[TryParse_1_T]) -> bool:...




class SearchValue:
    # Constructor .ctor(number : Double) was skipped since it collides with above method
    # Constructor .ctor(v : Boolean) was skipped since it collides with above method
    @typing.overload
    def __init__(self, color: Color) -> None: ...
    @typing.overload
    def __init__(self, number: float) -> None: ...
    @typing.overload
    def __init__(self, text: str) -> None: ...
    @typing.overload
    def __init__(self, v: typing.Any) -> None: ...
    floatNumber : float
    invalid : SearchValue
    number : float
    text : str
    type : SearchValue.ValueType
    @property
    def boolean(self) -> bool: ...
    @property
    def valid(self) -> bool: ...
    @staticmethod
    def ConvertPropertyValue(sp: clr.Reference[SerializedProperty]) -> SearchValue: ...
    def ToString(self) -> str: ...
    # Skipped SetupEngine due to it being static, abstract and generic.

    SetupEngine : SetupEngine_MethodGroup
    class SetupEngine_MethodGroup:
        def __getitem__(self, t:typing.Type[SetupEngine_1_T1]) -> SetupEngine_1[SetupEngine_1_T1]: ...

        SetupEngine_1_T1 = typing.TypeVar('SetupEngine_1_T1')
        class SetupEngine_1(typing.Generic[SetupEngine_1_T1]):
            SetupEngine_1_T = SearchValue.SetupEngine_MethodGroup.SetupEngine_1_T1
            def __call__(self, queryEngine: QueryEngine_1[SetupEngine_1_T]) -> None:...



    class ValueType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Nil : SearchValue.ValueType # 0
        Bool : SearchValue.ValueType # 1
        Number : SearchValue.ValueType # 2
        Text : SearchValue.ValueType # 3
        Color : SearchValue.ValueType # 4
        Enum : SearchValue.ValueType # 5
        Object : SearchValue.ValueType # 6
        Vector2 : SearchValue.ValueType # 7
        Vector3 : SearchValue.ValueType # 8
        Vector4 : SearchValue.ValueType # 9



class SearchViewState(ISerializationCallbackReceiver):
    @typing.overload
    def __init__(self, context: SearchContext) -> None: ...
    @typing.overload
    def __init__(self, context: SearchContext, flags: SearchViewFlags) -> None: ...
    @typing.overload
    def __init__(self, context: SearchContext, selectHandler: Action_2[SearchItem, bool]) -> None: ...
    @typing.overload
    def __init__(self, context: SearchContext, selectObjectHandler: Action_2[Object, bool], trackingObjectHandler: Action_1[Object], typeName: str, filterType: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, context: SearchContext, tableConfig: SearchTable, flags: SearchViewFlags = ...) -> None: ...
    defaultSize : Vector2
    excludeClearItem : bool
    flags : SearchViewFlags
    group : str
    hideAllGroup : bool
    hideTabs : bool
    ignoreSaveSearches : bool
    itemSize : float
    position : Rect
    queryBuilderEnabled : bool
    sessionId : str
    sessionName : str
    tableConfig : SearchTable
    title : str
    windowTitle : GUIContent
    @property
    def context(self) -> SearchContext: ...
    @context.setter
    def context(self, value: SearchContext) -> SearchContext: ...
    @property
    def groupChanged(self) -> Action_3[SearchContext, str, str]: ...
    @groupChanged.setter
    def groupChanged(self, value: Action_3[SearchContext, str, str]) -> Action_3[SearchContext, str, str]: ...
    @property
    def hasQueryPanel(self) -> bool: ...
    @property
    def hasWindowSize(self) -> bool: ...
    @property
    def isQueryPanelVisible(self) -> bool: ...
    @property
    def selectHandler(self) -> Action_2[SearchItem, bool]: ...
    @selectHandler.setter
    def selectHandler(self, value: Action_2[SearchItem, bool]) -> Action_2[SearchItem, bool]: ...
    @property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> str: ...
    @property
    def trackingHandler(self) -> Action_1[SearchItem]: ...
    @trackingHandler.setter
    def trackingHandler(self, value: Action_1[SearchItem]) -> Action_1[SearchItem]: ...
    @property
    def windowSize(self) -> Vector2: ...
    def GetProviderIds(self) -> IEnumerable_1[str]: ...
    def GetProviderTypes(self) -> IEnumerable_1[str]: ...
    def HasFlag(self, flags: SearchViewFlags) -> bool: ...
    @staticmethod
    def LoadDefaults() -> SearchViewState: ...
    def OnAfterDeserialize(self) -> None: ...
    def OnBeforeSerialize(self) -> None: ...
    def ToString(self) -> str: ...
    # Skipped CreatePickerState due to it being static, abstract and generic.

    CreatePickerState : CreatePickerState_MethodGroup
    class CreatePickerState_MethodGroup:
        @typing.overload
        def __call__(self, title: str, context: SearchContext, selectHandler: Action_2[SearchItem, bool], trackingHandler: Action_1[SearchItem] = ..., filterHandler: Func_2[SearchItem, bool] = ..., flags: SearchViewFlags = ...) -> SearchViewState:...
        @typing.overload
        def __call__(self, title: str, context: SearchContext, selectObjectHandler: Action_2[Object, bool], trackingObjectHandler: Action_1[Object], typeName: str, filterType: typing.Type[typing.Any], flags: SearchViewFlags = ...) -> SearchViewState:...



class ShowDetailsOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : ShowDetailsOptions # 0
    Preview : ShowDetailsOptions # 1
    Inspector : ShowDetailsOptions # 2
    Actions : ShowDetailsOptions # 4
    Description : ShowDetailsOptions # 8
    Default : ShowDetailsOptions # 13
    ListView : ShowDetailsOptions # 16
    DefaultGroup : ShowDetailsOptions # 32


class StringView(IEquatable_1[StringView]):
    @typing.overload
    def __init__(self, baseString: str) -> None: ...
    @typing.overload
    def __init__(self, baseString: str, startIndex: int) -> None: ...
    @typing.overload
    def __init__(self, baseString: str, startIndex: int, endIndex: int) -> None: ...
    empty : StringView
    nil : StringView
    @property
    def baseString(self) -> str: ...
    @property
    def endIndex(self) -> int: ...
    @property
    def Item(self) -> str: ...
    @property
    def length(self) -> int: ...
    @property
    def startIndex(self) -> int: ...
    @property
    def valid(self) -> bool: ...
    def GetEnumerator(self) -> IEnumerator_1[str]: ...
    def GetHashCode(self) -> int: ...
    @typing.overload
    def __eq__(self, lhs: StringView, rhs: StringView) -> bool: ...
    @typing.overload
    def __eq__(self, lhs: StringView, rhs: str) -> bool: ...
    @typing.overload
    def __eq__(self, lhs: str, rhs: StringView) -> bool: ...
    # Operator not supported op_Implicit(sv: StringView)
    @typing.overload
    def __ne__(self, lhs: StringView, rhs: StringView) -> bool: ...
    @typing.overload
    def __ne__(self, lhs: StringView, rhs: str) -> bool: ...
    @typing.overload
    def __ne__(self, lhs: str, rhs: StringView) -> bool: ...
    def ToString(self) -> str: ...
    def Trim(self, chrs: Array_1[str]) -> StringView: ...
    # Skipped Contains due to it being static, abstract and generic.

    Contains : Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, c: str, ordinal: StringComparison = ...) -> bool:...
        @typing.overload
        def __call__(self, s: StringView, ordinal: StringComparison = ...) -> bool:...
        # Method Contains(s : String, ordinal : StringComparison) was skipped since it collides with above method

    # Skipped EndsWith due to it being static, abstract and generic.

    EndsWith : EndsWith_MethodGroup
    class EndsWith_MethodGroup:
        def __call__(self, c: str, sc: StringComparison = ...) -> bool:...
        # Method EndsWith(v : String, sc : StringComparison) was skipped since it collides with above method

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: StringView) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, other: StringView, comparisonOptions: StringComparison) -> bool:...
        @typing.overload
        def __call__(self, other: str, comparisonOptions: StringComparison = ...) -> bool:...

    # Skipped IndexOf due to it being static, abstract and generic.

    IndexOf : IndexOf_MethodGroup
    class IndexOf_MethodGroup:
        @typing.overload
        def __call__(self, other: str, sc: StringComparison = ...) -> int:...
        @typing.overload
        def __call__(self, other: StringView, sc: StringComparison = ...) -> int:...
        # Method IndexOf(other : String, sc : StringComparison) was skipped since it collides with above method

    # Skipped LastIndexOf due to it being static, abstract and generic.

    LastIndexOf : LastIndexOf_MethodGroup
    class LastIndexOf_MethodGroup:
        @typing.overload
        def __call__(self, other: StringView, sc: StringComparison = ...) -> int:...
        @typing.overload
        def __call__(self, other: str, sc: StringComparison = ...) -> int:...
        # Method LastIndexOf(other : Char, sc : StringComparison) was skipped since it collides with above method

    # Skipped StartsWith due to it being static, abstract and generic.

    StartsWith : StartsWith_MethodGroup
    class StartsWith_MethodGroup:
        def __call__(self, c: str, stringComparison: StringComparison = ...) -> bool:...
        # Method StartsWith(v : String, sc : StringComparison) was skipped since it collides with above method

    # Skipped Substring due to it being static, abstract and generic.

    Substring : Substring_MethodGroup
    class Substring_MethodGroup:
        @typing.overload
        def __call__(self, start: int) -> StringView:...
        @typing.overload
        def __call__(self, start: int, length: int) -> StringView:...



class TextCursorPlacement(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : TextCursorPlacement # 0
    MoveLineEnd : TextCursorPlacement # 1
    Default : TextCursorPlacement # 1
    MoveLineStart : TextCursorPlacement # 2
    MoveToEndOfPreviousWord : TextCursorPlacement # 3
    MoveToStartOfNextWord : TextCursorPlacement # 4
    MoveWordLeft : TextCursorPlacement # 5
    MoveWordRight : TextCursorPlacement # 6
    MoveAutoComplete : TextCursorPlacement # 7

