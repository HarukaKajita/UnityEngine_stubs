import typing, abc
from System import Array_1, Action, Action_1, IEquatable_1, IDisposable, Action_2, Func_3, Exception, Attribute
from UnityEngine import LogType, Object
from UnityEditor import PropertyModification

class ChannelClient:
    @property
    def channelName(self) -> str: ...
    @property
    def clientId(self) -> int: ...
    @property
    def isAutoTick(self) -> bool: ...
    @isAutoTick.setter
    def isAutoTick(self, value: bool) -> bool: ...
    @staticmethod
    def GetChannelClientList() -> Array_1[ChannelClientInfo]: ...
    @staticmethod
    def GetOrCreateClient(channelName: str) -> ChannelClient: ...
    def IsConnected(self) -> bool: ...
    @staticmethod
    def Shutdown() -> None: ...
    def Start(self, autoTick: bool) -> None: ...
    def Stop(self) -> None: ...
    def Tick(self) -> None: ...
    # Skipped Close due to it being static, abstract and generic.

    Close : Close_MethodGroup
    class Close_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, channelName: str) -> None:...

    # Skipped GetChannelClientInfo due to it being static, abstract and generic.

    GetChannelClientInfo : GetChannelClientInfo_MethodGroup
    class GetChannelClientInfo_MethodGroup:
        @typing.overload
        def __call__(self) -> ChannelClientInfo:...
        @typing.overload
        def __call__(self, clientId: int) -> ChannelClientInfo:...
        @typing.overload
        def __call__(self, channelName: str) -> ChannelClientInfo:...

    # Skipped NewRequestId due to it being static, abstract and generic.

    NewRequestId : NewRequestId_MethodGroup
    class NewRequestId_MethodGroup:
        @typing.overload
        def __call__(self) -> int:...
        @typing.overload
        def __call__(self, clientId: int) -> int:...

    # Skipped RegisterMessageHandler due to it being static, abstract and generic.

    RegisterMessageHandler : RegisterMessageHandler_MethodGroup
    class RegisterMessageHandler_MethodGroup:
        @typing.overload
        def __call__(self, handler: Action_1[Array_1[int]]) -> Action:...
        @typing.overload
        def __call__(self, handler: Action_1[str]) -> Action:...

    # Skipped Send due to it being static, abstract and generic.

    Send : Send_MethodGroup
    class Send_MethodGroup:
        @typing.overload
        def __call__(self, data: Array_1[int]) -> None:...
        @typing.overload
        def __call__(self, data: str) -> None:...
        @typing.overload
        def __call__(self, connectionId: int, data: Array_1[int]) -> None:...

    # Skipped UnregisterMessageHandler due to it being static, abstract and generic.

    UnregisterMessageHandler : UnregisterMessageHandler_MethodGroup
    class UnregisterMessageHandler_MethodGroup:
        @typing.overload
        def __call__(self, handler: Action_1[Array_1[int]]) -> None:...
        @typing.overload
        def __call__(self, handler: Action_1[str]) -> None:...



class ChannelClientInfo(IEquatable_1[ChannelClientInfo]):
    invalidClient : ChannelClientInfo
    @property
    def clientId(self) -> int: ...
    @property
    def connectionId(self) -> int: ...
    @property
    def name(self) -> str: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, x: ChannelClientInfo, y: ChannelClientInfo) -> bool: ...
    def __ne__(self, x: ChannelClientInfo, y: ChannelClientInfo) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, obj: ChannelClientInfo) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class ChannelClientScope(IDisposable):
    @typing.overload
    def __init__(self, autoTick: bool, channelName: str, handler: Action_1[str], closeClientOnExit: bool = ...) -> None: ...
    @typing.overload
    def __init__(self, autoTick: bool, channelName: str, handler: Action_1[Array_1[int]], closeClientOnExit: bool = ...) -> None: ...
    @property
    def client(self) -> ChannelClient: ...
    @client.setter
    def client(self, value: ChannelClient) -> ChannelClient: ...
    def Dispose(self) -> None: ...


class ChannelInfo(IEquatable_1[ChannelInfo]):
    invalidChannel : ChannelInfo
    @property
    def id(self) -> int: ...
    @property
    def name(self) -> str: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, x: ChannelInfo, y: ChannelInfo) -> bool: ...
    def __ne__(self, x: ChannelInfo, y: ChannelInfo) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, obj: ChannelInfo) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class ChannelScope(IDisposable):
    def __init__(self, channelName: str, handler: Action_2[int, Array_1[int]], closeChannelOnExit: bool = ...) -> None: ...
    def Dispose(self) -> None: ...


class ChannelService(abc.ABC):
    @staticmethod
    def BroadcastBinary(channelId: int, data: Array_1[int]) -> None: ...
    @staticmethod
    def ChannelNameToId(channelName: str) -> int: ...
    @staticmethod
    def CloseChannel(channelName: str) -> None: ...
    @staticmethod
    def GetAddress() -> str: ...
    @staticmethod
    def GetChannelClientList() -> Array_1[ChannelClientInfo]: ...
    @staticmethod
    def GetChannelList() -> Array_1[ChannelInfo]: ...
    @staticmethod
    def GetOrCreateChannel(channelName: str, handler: Action_2[int, Array_1[int]]) -> Action: ...
    @staticmethod
    def GetPort() -> int: ...
    @staticmethod
    def IsRunning() -> bool: ...
    @staticmethod
    def RegisterMessageHandler(channelName: str, handler: Action_2[int, Array_1[int]]) -> Action: ...
    @staticmethod
    def Start() -> None: ...
    @staticmethod
    def Stop() -> None: ...
    @staticmethod
    def UnregisterMessageHandler(channelName: str, handler: Action_2[int, Array_1[int]]) -> None: ...
    # Skipped Broadcast due to it being static, abstract and generic.

    Broadcast : Broadcast_MethodGroup
    class Broadcast_MethodGroup:
        @typing.overload
        def __call__(self, channelId: int, data: Array_1[int]) -> None:...
        @typing.overload
        def __call__(self, channelId: int, data: str) -> None:...

    # Skipped Send due to it being static, abstract and generic.

    Send : Send_MethodGroup
    class Send_MethodGroup:
        @typing.overload
        def __call__(self, connectionId: int, data: Array_1[int]) -> None:...
        @typing.overload
        def __call__(self, connectionId: int, data: str) -> None:...



class EventDataSerialization(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    StandardJson : EventDataSerialization # 0
    JsonUtility : EventDataSerialization # 1


class EventService(abc.ABC):
    @classmethod
    @property
    def isConnected(cls) -> bool: ...
    @staticmethod
    def CancelRequest(eventType: str, message: str = ...) -> bool: ...
    @staticmethod
    def Clear() -> None: ...
    @staticmethod
    def Close() -> None: ...
    @staticmethod
    def IsRequestPending(eventType: str) -> bool: ...
    @staticmethod
    def Start() -> None: ...
    @staticmethod
    def Tick() -> None: ...
    @staticmethod
    def UnregisterEventHandler(eventType: str, handler: Func_3[str, Array_1[typing.Any], typing.Any]) -> None: ...
    # Skipped Emit due to it being static, abstract and generic.

    Emit : Emit_MethodGroup
    class Emit_MethodGroup:
        @typing.overload
        def __call__(self, eventType: str, args: Array_1[typing.Any], targetId: int = ..., eventDataSerialization: EventDataSerialization = ...) -> None:...
        @typing.overload
        def __call__(self, eventType: str, args: typing.Any = ..., targetId: int = ..., eventDataSerialization: EventDataSerialization = ...) -> None:...

    # Skipped Log due to it being static, abstract and generic.

    Log : Log_MethodGroup
    class Log_MethodGroup:
        @typing.overload
        def __call__(self, msg: str) -> None:...
        @typing.overload
        def __call__(self, msg: str, logType: LogType) -> None:...

    # Skipped RegisterEventHandler due to it being static, abstract and generic.

    RegisterEventHandler : RegisterEventHandler_MethodGroup
    class RegisterEventHandler_MethodGroup:
        @typing.overload
        def __call__(self, eventType: str, handler: Action_2[str, Array_1[typing.Any]]) -> Action:...
        @typing.overload
        def __call__(self, eventType: str, handler: Func_3[str, Array_1[typing.Any], typing.Any]) -> Action:...

    # Skipped Request due to it being static, abstract and generic.

    Request : Request_MethodGroup
    class Request_MethodGroup:
        @typing.overload
        def __call__(self, eventType: str, promiseHandler: Action_2[Exception, Array_1[typing.Any]], args: Array_1[typing.Any], timeoutInMs: int = ..., eventDataSerialization: EventDataSerialization = ...) -> None:...
        @typing.overload
        def __call__(self, eventType: str, promiseHandler: Action_2[Exception, Array_1[typing.Any]], args: typing.Any = ..., timeoutInMs: int = ..., eventDataSerialization: EventDataSerialization = ...) -> None:...



class ProcessEvent(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    UMP_EVENT_UNDEFINED : ProcessEvent # 0
    Undefined : ProcessEvent # 0
    UMP_EVENT_CREATE : ProcessEvent # 1
    Create : ProcessEvent # 1
    UMP_EVENT_INITIALIZE : ProcessEvent # 2
    Initialize : ProcessEvent # 2
    UMP_EVENT_AFTER_DOMAIN_RELOAD : ProcessEvent # 3
    AfterDomainReload : ProcessEvent # 3
    UMP_EVENT_SHUTDOWN : ProcessEvent # 4
    Shutdown : ProcessEvent # 4


class ProcessLevel(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    UMP_UNDEFINED : ProcessLevel # 0
    Undefined : ProcessLevel # 0
    UMP_MASTER : ProcessLevel # 1
    Main : ProcessLevel # 1
    UMP_SLAVE : ProcessLevel # 2
    Slave : ProcessLevel # 2
    Secondary : ProcessLevel # 2


class ProcessService:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def level(cls) -> ProcessLevel: ...
    @classmethod
    @property
    def roleName(cls) -> str: ...
    @staticmethod
    def ApplyPropertyModifications(modifications: Array_1[PropertyModification]) -> None: ...
    @staticmethod
    def DeserializeObject(bytes: Array_1[int]) -> Object: ...
    @staticmethod
    def DisableProfileConnection() -> None: ...
    @staticmethod
    def EnableProfileConnection(dataPath: str) -> int: ...
    @staticmethod
    def GetProcessState(pid: int) -> ProcessState: ...
    @staticmethod
    def GetSlaveProcessState(pid: int) -> ProcessState: ...
    @staticmethod
    def HasCapability(capName: str) -> bool: ...
    @staticmethod
    def IsChannelServiceStarted() -> bool: ...
    @staticmethod
    def Launch(roleName: str, keyValuePairs: Array_1[str]) -> int: ...
    @staticmethod
    def LaunchSlave(roleName: str, keyValuePairs: Array_1[str]) -> int: ...
    @staticmethod
    def ReadParameter(paramName: str) -> str: ...
    @staticmethod
    def SerializeObject(instanceId: int) -> Array_1[int]: ...
    @staticmethod
    def Terminate(pid: int) -> None: ...
    @staticmethod
    def TerminateSlave(pid: int) -> None: ...


class ProcessState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    UMP_UNKNOWN_PROCESS : ProcessState # 0
    UnknownProcess : ProcessState # 0
    UMP_FINISHED_SUCCESSFULLY : ProcessState # 1
    FinishedSuccessfully : ProcessState # 1
    UMP_FINISHED_WITH_ERROR : ProcessState # 2
    FinishedWithError : ProcessState # 2
    UMP_RUNNING : ProcessState # 3
    Running : ProcessState # 3


class RoleProviderAttribute(Attribute):
    @typing.overload
    def __init__(self, level: ProcessLevel, eventType: ProcessEvent) -> None: ...
    @typing.overload
    def __init__(self, name: str, eventType: ProcessEvent) -> None: ...
    eventType : ProcessEvent
    level : ProcessLevel
    name : str
    @property
    def TypeId(self) -> typing.Any: ...

