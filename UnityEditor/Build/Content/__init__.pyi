import typing, clr, abc
import System.Runtime.Serialization
import UnityEngine
from System.Collections.Generic import List_1
from UnityEditor import GUID, BuildTargetGroup, BuildTarget, AssetBundleBuild
from System import IDisposable, Array_1, IEquatable_1
from System.Runtime.Serialization import ISerializable, StreamingContext
from UnityEngine import Hash128, Object
from UnityEditor.Build.Player import TypeDB
from System.Collections.ObjectModel import ReadOnlyCollection_1

class AssetBundleInfo:
    def __init__(self) -> None: ...
    @property
    def bundleAssets(self) -> List_1[AssetLoadInfo]: ...
    @bundleAssets.setter
    def bundleAssets(self, value: List_1[AssetLoadInfo]) -> List_1[AssetLoadInfo]: ...
    @property
    def bundleName(self) -> str: ...
    @bundleName.setter
    def bundleName(self, value: str) -> str: ...


class AssetLoadInfo:
    def __init__(self) -> None: ...
    @property
    def address(self) -> str: ...
    @address.setter
    def address(self, value: str) -> str: ...
    @property
    def asset(self) -> GUID: ...
    @asset.setter
    def asset(self, value: GUID) -> GUID: ...
    @property
    def includedObjects(self) -> List_1[ObjectIdentifier]: ...
    @includedObjects.setter
    def includedObjects(self, value: List_1[ObjectIdentifier]) -> List_1[ObjectIdentifier]: ...
    @property
    def referencedObjects(self) -> List_1[ObjectIdentifier]: ...
    @referencedObjects.setter
    def referencedObjects(self, value: List_1[ObjectIdentifier]) -> List_1[ObjectIdentifier]: ...


class BuildCompression:
    DefaultLZ4 : BuildCompression
    DefaultLZMA : BuildCompression
    DefaultUncompressed : BuildCompression


class BuildReferenceMap(IDisposable, ISerializable):
    def __init__(self) -> None: ...
    def AddMapping(self, internalFileName: str, serializationIndex: int, objectID: ObjectIdentifier, overwrite: bool = ...) -> None: ...
    def AddMappings(self, internalFileName: str, objectIDs: Array_1[SerializationInfo], overwrite: bool = ...) -> None: ...
    def Dispose(self) -> None: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def FilterToSubset(self, objectIds: Array_1[ObjectIdentifier]) -> None: ...
    def GetHash128(self) -> Hash128: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: StreamingContext) -> None: ...


class BuildSettings:
    @property
    def buildFlags(self) -> ContentBuildFlags: ...
    @buildFlags.setter
    def buildFlags(self, value: ContentBuildFlags) -> ContentBuildFlags: ...
    @property
    def group(self) -> BuildTargetGroup: ...
    @group.setter
    def group(self, value: BuildTargetGroup) -> BuildTargetGroup: ...
    @property
    def subtarget(self) -> int: ...
    @subtarget.setter
    def subtarget(self, value: int) -> int: ...
    @property
    def target(self) -> BuildTarget: ...
    @target.setter
    def target(self, value: BuildTarget) -> BuildTarget: ...
    @property
    def typeDB(self) -> TypeDB: ...
    @typeDB.setter
    def typeDB(self, value: TypeDB) -> TypeDB: ...


class BuildUsageCache(IDisposable):
    def __init__(self) -> None: ...
    def Dispose(self) -> None: ...


class BuildUsageTagGlobal:
    def __or__(self, x: BuildUsageTagGlobal, y: BuildUsageTagGlobal) -> BuildUsageTagGlobal: ...


class BuildUsageTagSet(IDisposable, ISerializable):
    def __init__(self) -> None: ...
    def Dispose(self) -> None: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def FilterToSubset(self, objectIds: Array_1[ObjectIdentifier]) -> None: ...
    def GetHash128(self) -> Hash128: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: StreamingContext) -> None: ...
    def GetObjectIdentifiers(self) -> Array_1[ObjectIdentifier]: ...
    def UnionWith(self, other: BuildUsageTagSet) -> None: ...


class CompressionLevel(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : CompressionLevel # 0
    Fastest : CompressionLevel # 1
    Fast : CompressionLevel # 2
    Normal : CompressionLevel # 3
    High : CompressionLevel # 4
    Maximum : CompressionLevel # 5


class CompressionType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : CompressionType # 0
    Lzma : CompressionType # 1
    Lz4 : CompressionType # 2
    Lz4HC : CompressionType # 3


class ContentBuildFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : ContentBuildFlags # 0
    DisableWriteTypeTree : ContentBuildFlags # 1
    StripUnityVersion : ContentBuildFlags # 2
    DevelopmentBuild : ContentBuildFlags # 4


class ContentBuildInterface(abc.ABC):
    @staticmethod
    def CalculatePlayerSerializationHashForType(type: typing.Type[typing.Any], typeDB: TypeDB) -> Hash128: ...
    @staticmethod
    def GenerateAssetBundleBuilds() -> Array_1[AssetBundleBuild]: ...
    @staticmethod
    def GetGlobalUsageFromActiveScene(target: BuildTarget) -> BuildUsageTagGlobal: ...
    @staticmethod
    def GetGlobalUsageFromGraphicsSettings() -> BuildUsageTagGlobal: ...
    @staticmethod
    def GetPlayerAssetRepresentations(asset: GUID, target: BuildTarget) -> Array_1[ObjectIdentifier]: ...
    @staticmethod
    def GetPlayerObjectIdentifiersInAsset(asset: GUID, target: BuildTarget) -> Array_1[ObjectIdentifier]: ...
    @staticmethod
    def GetPlayerObjectIdentifiersInSerializedFile(filePath: str, target: BuildTarget) -> Array_1[ObjectIdentifier]: ...
    @staticmethod
    def GetTypeForObject(objectID: ObjectIdentifier) -> typing.Type[typing.Any]: ...
    @staticmethod
    def GetTypeForObjects(objectIDs: Array_1[ObjectIdentifier]) -> Array_1[typing.Type[typing.Any]]: ...
    @staticmethod
    def GetTypesForObject(objectID: ObjectIdentifier) -> Array_1[typing.Type[typing.Any]]: ...
    @staticmethod
    def ObjectIsSupportedInBuild(targetObject: Object) -> bool: ...
    @staticmethod
    def StartProfileCapture(options: ProfileCaptureOptions) -> None: ...
    @staticmethod
    def StopProfileCapture() -> Array_1[ContentBuildProfileEvent]: ...
    @staticmethod
    def WriteGameManagersSerializedFile(outputFolder: str, parameters: WriteManagerParameters) -> WriteResult: ...
    # Skipped ArchiveAndCompress due to it being static, abstract and generic.

    ArchiveAndCompress : ArchiveAndCompress_MethodGroup
    class ArchiveAndCompress_MethodGroup:
        @typing.overload
        def __call__(self, resourceFiles: Array_1[ResourceFile], outputBundlePath: str, compression: UnityEngine.BuildCompression) -> int:...
        @typing.overload
        def __call__(self, resourceFiles: Array_1[ResourceFile], outputBundlePath: str, compression: UnityEngine.BuildCompression, stripUnityVersion: bool) -> int:...

    # Skipped CalculateBuildUsageTags due to it being static, abstract and generic.

    CalculateBuildUsageTags : CalculateBuildUsageTags_MethodGroup
    class CalculateBuildUsageTags_MethodGroup:
        @typing.overload
        def __call__(self, objectIDs: Array_1[ObjectIdentifier], dependentObjectIDs: Array_1[ObjectIdentifier], globalUsage: BuildUsageTagGlobal, usageSet: BuildUsageTagSet) -> None:...
        @typing.overload
        def __call__(self, objectIDs: Array_1[ObjectIdentifier], dependentObjectIDs: Array_1[ObjectIdentifier], globalUsage: BuildUsageTagGlobal, usageSet: BuildUsageTagSet, usageCache: BuildUsageCache) -> None:...

    # Skipped CalculatePlayerDependenciesForGameManagers due to it being static, abstract and generic.

    CalculatePlayerDependenciesForGameManagers : CalculatePlayerDependenciesForGameManagers_MethodGroup
    class CalculatePlayerDependenciesForGameManagers_MethodGroup:
        @typing.overload
        def __call__(self, settings: BuildSettings, globalUsage: BuildUsageTagGlobal, usageSet: BuildUsageTagSet) -> GameManagerDependencyInfo:...
        @typing.overload
        def __call__(self, settings: BuildSettings, globalUsage: BuildUsageTagGlobal, usageSet: BuildUsageTagSet, usageCache: BuildUsageCache) -> GameManagerDependencyInfo:...
        @typing.overload
        def __call__(self, settings: BuildSettings, globalUsage: BuildUsageTagGlobal, usageSet: BuildUsageTagSet, usageCache: BuildUsageCache, mode: DependencyType) -> GameManagerDependencyInfo:...

    # Skipped CalculatePlayerDependenciesForScene due to it being static, abstract and generic.

    CalculatePlayerDependenciesForScene : CalculatePlayerDependenciesForScene_MethodGroup
    class CalculatePlayerDependenciesForScene_MethodGroup:
        @typing.overload
        def __call__(self, scenePath: str, settings: BuildSettings, usageSet: BuildUsageTagSet) -> SceneDependencyInfo:...
        @typing.overload
        def __call__(self, scenePath: str, settings: BuildSettings, usageSet: BuildUsageTagSet, usageCache: BuildUsageCache) -> SceneDependencyInfo:...
        @typing.overload
        def __call__(self, scenePath: str, settings: BuildSettings, usageSet: BuildUsageTagSet, usageCache: BuildUsageCache, mode: DependencyType) -> SceneDependencyInfo:...

    # Skipped GetPlayerDependenciesForObject due to it being static, abstract and generic.

    GetPlayerDependenciesForObject : GetPlayerDependenciesForObject_MethodGroup
    class GetPlayerDependenciesForObject_MethodGroup:
        @typing.overload
        def __call__(self, objectID: ObjectIdentifier, target: BuildTarget, typeDB: TypeDB) -> Array_1[ObjectIdentifier]:...
        @typing.overload
        def __call__(self, targetObject: Object, target: BuildTarget, typeDB: TypeDB) -> Array_1[ObjectIdentifier]:...
        @typing.overload
        def __call__(self, objectID: ObjectIdentifier, target: BuildTarget, typeDB: TypeDB, mode: DependencyType) -> Array_1[ObjectIdentifier]:...
        @typing.overload
        def __call__(self, targetObject: Object, target: BuildTarget, typeDB: TypeDB, mode: DependencyType) -> Array_1[ObjectIdentifier]:...

    # Skipped GetPlayerDependenciesForObjects due to it being static, abstract and generic.

    GetPlayerDependenciesForObjects : GetPlayerDependenciesForObjects_MethodGroup
    class GetPlayerDependenciesForObjects_MethodGroup:
        @typing.overload
        def __call__(self, objectIDs: Array_1[ObjectIdentifier], target: BuildTarget, typeDB: TypeDB) -> Array_1[ObjectIdentifier]:...
        @typing.overload
        def __call__(self, objects: Array_1[Object], target: BuildTarget, typeDB: TypeDB) -> Array_1[ObjectIdentifier]:...
        @typing.overload
        def __call__(self, objectIDs: Array_1[ObjectIdentifier], target: BuildTarget, typeDB: TypeDB, mode: DependencyType) -> Array_1[ObjectIdentifier]:...
        @typing.overload
        def __call__(self, objects: Array_1[Object], target: BuildTarget, typeDB: TypeDB, mode: DependencyType) -> Array_1[ObjectIdentifier]:...

    # Skipped PrepareScene due to it being static, abstract and generic.

    PrepareScene : PrepareScene_MethodGroup
    class PrepareScene_MethodGroup:
        @typing.overload
        def __call__(self, scenePath: str, settings: BuildSettings, usageSet: BuildUsageTagSet, outputFolder: str) -> SceneDependencyInfo:...
        @typing.overload
        def __call__(self, scenePath: str, settings: BuildSettings, usageSet: BuildUsageTagSet, usageCache: BuildUsageCache, outputFolder: str) -> SceneDependencyInfo:...

    # Skipped WriteSceneSerializedFile due to it being static, abstract and generic.

    WriteSceneSerializedFile : WriteSceneSerializedFile_MethodGroup
    class WriteSceneSerializedFile_MethodGroup:
        @typing.overload
        def __call__(self, outputFolder: str, parameters: WriteSceneParameters) -> WriteResult:...
        @typing.overload
        def __call__(self, outputFolder: str, scenePath: str, processedScene: str, writeCommand: WriteCommand, settings: BuildSettings, globalUsage: BuildUsageTagGlobal, usageSet: BuildUsageTagSet, referenceMap: BuildReferenceMap) -> WriteResult:...
        @typing.overload
        def __call__(self, outputFolder: str, scenePath: str, processedScene: str, writeCommand: WriteCommand, settings: BuildSettings, globalUsage: BuildUsageTagGlobal, usageSet: BuildUsageTagSet, referenceMap: BuildReferenceMap, preloadInfo: PreloadInfo) -> WriteResult:...
        @typing.overload
        def __call__(self, outputFolder: str, scenePath: str, processedScene: str, writeCommand: WriteCommand, settings: BuildSettings, globalUsage: BuildUsageTagGlobal, usageSet: BuildUsageTagSet, referenceMap: BuildReferenceMap, preloadInfo: PreloadInfo, sceneBundleInfo: SceneBundleInfo) -> WriteResult:...

    # Skipped WriteSerializedFile due to it being static, abstract and generic.

    WriteSerializedFile : WriteSerializedFile_MethodGroup
    class WriteSerializedFile_MethodGroup:
        @typing.overload
        def __call__(self, outputFolder: str, parameters: WriteParameters) -> WriteResult:...
        @typing.overload
        def __call__(self, outputFolder: str, writeCommand: WriteCommand, settings: BuildSettings, globalUsage: BuildUsageTagGlobal, usageSet: BuildUsageTagSet, referenceMap: BuildReferenceMap) -> WriteResult:...
        @typing.overload
        def __call__(self, outputFolder: str, writeCommand: WriteCommand, settings: BuildSettings, globalUsage: BuildUsageTagGlobal, usageSet: BuildUsageTagSet, referenceMap: BuildReferenceMap, bundleInfo: AssetBundleInfo) -> WriteResult:...



class ContentBuildProfileEvent:
    Metadata : str
    Name : str
    TimeMicroseconds : int
    Type : ProfileEventType


class DependencyType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    RecursiveOperation : DependencyType # 1
    MissingReferences : DependencyType # 2
    ValidReferences : DependencyType # 4
    DefaultDependencies : DependencyType # 5


class ExternalFileReference:
    @property
    def filePath(self) -> str: ...
    @property
    def guid(self) -> GUID: ...
    @property
    def type(self) -> int: ...


class FileType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    NonAssetType : FileType # 0
    DeprecatedCachedAssetType : FileType # 1
    SerializedAssetType : FileType # 2
    MetaAssetType : FileType # 3


class GameManagerDependencyInfo:
    @property
    def includedTypes(self) -> ReadOnlyCollection_1[typing.Type[typing.Any]]: ...
    @property
    def managerObjects(self) -> ReadOnlyCollection_1[ObjectIdentifier]: ...
    @property
    def referencedObjects(self) -> ReadOnlyCollection_1[ObjectIdentifier]: ...


class ObjectIdentifier(IEquatable_1[ObjectIdentifier]):
    @property
    def filePath(self) -> str: ...
    @filePath.setter
    def filePath(self, value: str) -> str: ...
    @property
    def fileType(self) -> FileType: ...
    @fileType.setter
    def fileType(self, value: FileType) -> FileType: ...
    @property
    def guid(self) -> GUID: ...
    @guid.setter
    def guid(self, value: GUID) -> GUID: ...
    @property
    def localIdentifierInFile(self) -> int: ...
    @localIdentifierInFile.setter
    def localIdentifierInFile(self, value: int) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, a: ObjectIdentifier, b: ObjectIdentifier) -> bool: ...
    def __gt__(self, a: ObjectIdentifier, b: ObjectIdentifier) -> bool: ...
    def __ne__(self, a: ObjectIdentifier, b: ObjectIdentifier) -> bool: ...
    def __lt__(self, a: ObjectIdentifier, b: ObjectIdentifier) -> bool: ...
    @staticmethod
    def ToInstanceID(objectId: ObjectIdentifier) -> int: ...
    @staticmethod
    def ToObject(objectId: ObjectIdentifier) -> Object: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: ObjectIdentifier) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped TryGetObjectIdentifier due to it being static, abstract and generic.

    TryGetObjectIdentifier : TryGetObjectIdentifier_MethodGroup
    class TryGetObjectIdentifier_MethodGroup:
        @typing.overload
        def __call__(self, instanceID: int, objectId: clr.Reference[ObjectIdentifier]) -> bool:...
        @typing.overload
        def __call__(self, targetObject: Object, objectId: clr.Reference[ObjectIdentifier]) -> bool:...



class ObjectSerializedInfo:
    @property
    def header(self) -> SerializedLocation: ...
    @property
    def rawData(self) -> SerializedLocation: ...
    @property
    def serializedObject(self) -> ObjectIdentifier: ...


class PreloadInfo:
    def __init__(self) -> None: ...
    @property
    def preloadObjects(self) -> List_1[ObjectIdentifier]: ...
    @preloadObjects.setter
    def preloadObjects(self, value: List_1[ObjectIdentifier]) -> List_1[ObjectIdentifier]: ...


class ProfileCaptureOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : ProfileCaptureOptions # 0
    IgnoreShortEvents : ProfileCaptureOptions # 1


class ProfileEventType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Begin : ProfileEventType # 0
    End : ProfileEventType # 1
    Info : ProfileEventType # 2


class ResourceFile:
    @property
    def fileAlias(self) -> str: ...
    @fileAlias.setter
    def fileAlias(self, value: str) -> str: ...
    @property
    def fileName(self) -> str: ...
    @fileName.setter
    def fileName(self, value: str) -> str: ...
    @property
    def serializedFile(self) -> bool: ...
    @serializedFile.setter
    def serializedFile(self, value: bool) -> bool: ...


class SceneBundleInfo:
    def __init__(self) -> None: ...
    @property
    def bundleName(self) -> str: ...
    @bundleName.setter
    def bundleName(self, value: str) -> str: ...
    @property
    def bundleScenes(self) -> List_1[SceneLoadInfo]: ...
    @bundleScenes.setter
    def bundleScenes(self, value: List_1[SceneLoadInfo]) -> List_1[SceneLoadInfo]: ...


class SceneDependencyInfo:
    @property
    def globalUsage(self) -> BuildUsageTagGlobal: ...
    @property
    def includedTypes(self) -> ReadOnlyCollection_1[typing.Type[typing.Any]]: ...
    @property
    def processedScene(self) -> str: ...
    @property
    def referencedObjects(self) -> ReadOnlyCollection_1[ObjectIdentifier]: ...
    @property
    def scene(self) -> str: ...


class SceneLoadInfo:
    def __init__(self) -> None: ...
    @property
    def address(self) -> str: ...
    @address.setter
    def address(self, value: str) -> str: ...
    @property
    def asset(self) -> GUID: ...
    @asset.setter
    def asset(self, value: GUID) -> GUID: ...
    @property
    def internalName(self) -> str: ...
    @internalName.setter
    def internalName(self, value: str) -> str: ...


class SerializationInfo:
    def __init__(self) -> None: ...
    @property
    def serializationIndex(self) -> int: ...
    @serializationIndex.setter
    def serializationIndex(self, value: int) -> int: ...
    @property
    def serializationObject(self) -> ObjectIdentifier: ...
    @serializationObject.setter
    def serializationObject(self, value: ObjectIdentifier) -> ObjectIdentifier: ...


class SerializedLocation:
    @property
    def fileName(self) -> str: ...
    @property
    def offset(self) -> int: ...
    @property
    def size(self) -> int: ...


class WriteCommand:
    def __init__(self) -> None: ...
    @property
    def fileName(self) -> str: ...
    @fileName.setter
    def fileName(self, value: str) -> str: ...
    @property
    def internalName(self) -> str: ...
    @internalName.setter
    def internalName(self, value: str) -> str: ...
    @property
    def serializeObjects(self) -> List_1[SerializationInfo]: ...
    @serializeObjects.setter
    def serializeObjects(self, value: List_1[SerializationInfo]) -> List_1[SerializationInfo]: ...


class WriteManagerParameters:
    globalUsage : BuildUsageTagGlobal
    referenceMap : BuildReferenceMap
    settings : BuildSettings


class WriteParameters:
    bundleInfo : AssetBundleInfo
    globalUsage : BuildUsageTagGlobal
    preloadInfo : PreloadInfo
    referenceMap : BuildReferenceMap
    settings : BuildSettings
    usageSet : BuildUsageTagSet
    writeCommand : WriteCommand


class WriteResult:
    @property
    def externalFileReferences(self) -> ReadOnlyCollection_1[ExternalFileReference]: ...
    @property
    def includedSerializeReferenceFQN(self) -> ReadOnlyCollection_1[str]: ...
    @property
    def includedTypes(self) -> ReadOnlyCollection_1[typing.Type[typing.Any]]: ...
    @property
    def resourceFiles(self) -> ReadOnlyCollection_1[ResourceFile]: ...
    @property
    def serializedObjects(self) -> ReadOnlyCollection_1[ObjectSerializedInfo]: ...


class WriteSceneParameters:
    globalUsage : BuildUsageTagGlobal
    preloadInfo : PreloadInfo
    referenceMap : BuildReferenceMap
    sceneBundleInfo : SceneBundleInfo
    scenePath : str
    settings : BuildSettings
    usageSet : BuildUsageTagSet
    writeCommand : WriteCommand

